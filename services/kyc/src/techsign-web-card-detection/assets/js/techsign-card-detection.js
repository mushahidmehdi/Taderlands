/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!(function (e, t) {
	"use strict";
	"object" == typeof module && "object" == typeof module.exports
		? (module.exports = e.document
				? t(e, !0)
				: function (e) {
						if (!e.document) throw new Error("jQuery requires a window with a document");
						return t(e);
				  })
		: t(e);
})("undefined" != typeof window ? window : this, function (e, t) {
	"use strict";
	var n = [],
		r = Object.getPrototypeOf,
		i = n.slice,
		o = n.flat
			? function (e) {
					return n.flat.call(e);
			  }
			: function (e) {
					return n.concat.apply([], e);
			  },
		a = n.push,
		s = n.indexOf,
		u = {},
		l = u.toString,
		c = u.hasOwnProperty,
		f = c.toString,
		p = f.call(Object),
		d = {},
		h = function (e) {
			return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item;
		},
		g = function (e) {
			return null != e && e === e.window;
		},
		v = e.document,
		y = { type: !0, src: !0, nonce: !0, noModule: !0 };
	function m(e, t, n) {
		var r,
			i,
			o = (n = n || v).createElement("script");
		if (((o.text = e), t)) for (r in y) (i = t[r] || (t.getAttribute && t.getAttribute(r))) && o.setAttribute(r, i);
		n.head.appendChild(o).parentNode.removeChild(o);
	}
	function x(e) {
		return null == e
			? e + ""
			: "object" == typeof e || "function" == typeof e
			? u[l.call(e)] || "object"
			: typeof e;
	}
	var b = "3.6.0",
		w = function (e, t) {
			return new w.fn.init(e, t);
		};
	function T(e) {
		var t = !!e && "length" in e && e.length,
			n = x(e);
		return !h(e) && !g(e) && ("array" === n || 0 === t || ("number" == typeof t && 0 < t && t - 1 in e));
	}
	(w.fn = w.prototype =
		{
			jquery: b,
			constructor: w,
			length: 0,
			toArray: function () {
				return i.call(this);
			},
			get: function (e) {
				return null == e ? i.call(this) : e < 0 ? this[e + this.length] : this[e];
			},
			pushStack: function (e) {
				var t = w.merge(this.constructor(), e);
				return (t.prevObject = this), t;
			},
			each: function (e) {
				return w.each(this, e);
			},
			map: function (e) {
				return this.pushStack(
					w.map(this, function (t, n) {
						return e.call(t, n, t);
					})
				);
			},
			slice: function () {
				return this.pushStack(i.apply(this, arguments));
			},
			first: function () {
				return this.eq(0);
			},
			last: function () {
				return this.eq(-1);
			},
			even: function () {
				return this.pushStack(
					w.grep(this, function (e, t) {
						return (t + 1) % 2;
					})
				);
			},
			odd: function () {
				return this.pushStack(
					w.grep(this, function (e, t) {
						return t % 2;
					})
				);
			},
			eq: function (e) {
				var t = this.length,
					n = +e + (e < 0 ? t : 0);
				return this.pushStack(0 <= n && n < t ? [this[n]] : []);
			},
			end: function () {
				return this.prevObject || this.constructor();
			},
			push: a,
			sort: n.sort,
			splice: n.splice,
		}),
		(w.extend = w.fn.extend =
			function () {
				var e,
					t,
					n,
					r,
					i,
					o,
					a = arguments[0] || {},
					s = 1,
					u = arguments.length,
					l = !1;
				for (
					"boolean" == typeof a && ((l = a), (a = arguments[s] || {}), s++),
						"object" == typeof a || h(a) || (a = {}),
						s === u && ((a = this), s--);
					s < u;
					s++
				)
					if (null != (e = arguments[s]))
						for (t in e)
							(r = e[t]),
								"__proto__" !== t &&
									a !== r &&
									(l && r && (w.isPlainObject(r) || (i = Array.isArray(r)))
										? ((n = a[t]),
										  (o = i && !Array.isArray(n) ? [] : i || w.isPlainObject(n) ? n : {}),
										  (i = !1),
										  (a[t] = w.extend(l, o, r)))
										: void 0 !== r && (a[t] = r));
				return a;
			}),
		w.extend({
			expando: "jQuery" + (b + Math.random()).replace(/\D/g, ""),
			isReady: !0,
			error: function (e) {
				throw new Error(e);
			},
			noop: function () {},
			isPlainObject: function (e) {
				var t, n;
				return !(
					!e ||
					"[object Object]" !== l.call(e) ||
					((t = r(e)) &&
						("function" != typeof (n = c.call(t, "constructor") && t.constructor) || f.call(n) !== p))
				);
			},
			isEmptyObject: function (e) {
				var t;
				for (t in e) return !1;
				return !0;
			},
			globalEval: function (e, t, n) {
				m(e, { nonce: t && t.nonce }, n);
			},
			each: function (e, t) {
				var n,
					r = 0;
				if (T(e)) for (n = e.length; r < n && !1 !== t.call(e[r], r, e[r]); r++);
				else for (r in e) if (!1 === t.call(e[r], r, e[r])) break;
				return e;
			},
			makeArray: function (e, t) {
				var n = t || [];
				return null != e && (T(Object(e)) ? w.merge(n, "string" == typeof e ? [e] : e) : a.call(n, e)), n;
			},
			inArray: function (e, t, n) {
				return null == t ? -1 : s.call(t, e, n);
			},
			merge: function (e, t) {
				for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];
				return (e.length = i), e;
			},
			grep: function (e, t, n) {
				for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]);
				return r;
			},
			map: function (e, t, n) {
				var r,
					i,
					a = 0,
					s = [];
				if (T(e)) for (r = e.length; a < r; a++) null != (i = t(e[a], a, n)) && s.push(i);
				else for (a in e) null != (i = t(e[a], a, n)) && s.push(i);
				return o(s);
			},
			guid: 1,
			support: d,
		}),
		"function" == typeof Symbol && (w.fn[Symbol.iterator] = n[Symbol.iterator]),
		w.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
			u["[object " + t + "]"] = t.toLowerCase();
		});
	var C = (function (e) {
		var t,
			n,
			r,
			i,
			o,
			a,
			s,
			u,
			l,
			c,
			f,
			p,
			d,
			h,
			g,
			v,
			y,
			m,
			x,
			b = "sizzle" + 1 * new Date(),
			w = e.document,
			T = 0,
			C = 0,
			E = ue(),
			S = ue(),
			k = ue(),
			A = ue(),
			N = function (e, t) {
				return e === t && (f = !0), 0;
			},
			j = {}.hasOwnProperty,
			D = [],
			q = D.pop,
			L = D.push,
			H = D.push,
			O = D.slice,
			P = function (e, t) {
				for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
				return -1;
			},
			R =
				"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
			M = "[\\x20\\t\\r\\n\\f]",
			I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
			W =
				"\\[" +
				M +
				"*(" +
				I +
				")(?:" +
				M +
				"*([*^$|!~]?=)" +
				M +
				"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
				I +
				"))|)" +
				M +
				"*\\]",
			F =
				":(" +
				I +
				")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" +
				W +
				")*)|.*)\\)|)",
			B = new RegExp(M + "+", "g"),
			$ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
			_ = new RegExp("^" + M + "*," + M + "*"),
			z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
			U = new RegExp(M + "|>"),
			X = new RegExp(F),
			V = new RegExp("^" + I + "$"),
			G = {
				ID: new RegExp("^#(" + I + ")"),
				CLASS: new RegExp("^\\.(" + I + ")"),
				TAG: new RegExp("^(" + I + "|[*])"),
				ATTR: new RegExp("^" + W),
				PSEUDO: new RegExp("^" + F),
				CHILD: new RegExp(
					"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
						M +
						"*(even|odd|(([+-]|)(\\d*)n|)" +
						M +
						"*(?:([+-]|)" +
						M +
						"*(\\d+)|))" +
						M +
						"*\\)|)",
					"i"
				),
				bool: new RegExp("^(?:" + R + ")$", "i"),
				needsContext: new RegExp(
					"^" +
						M +
						"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
						M +
						"*((?:-\\d)?\\d*)" +
						M +
						"*\\)|)(?=[^-]|$)",
					"i"
				),
			},
			Y = /HTML$/i,
			Q = /^(?:input|select|textarea|button)$/i,
			J = /^h\d$/i,
			K = /^[^{]+\{\s*\[native \w/,
			Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
			ee = /[+~]/,
			te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"),
			ne = function (e, t) {
				var n = "0x" + e.slice(1) - 65536;
				return (
					t ||
					(n < 0
						? String.fromCharCode(n + 65536)
						: String.fromCharCode((n >> 10) | 55296, (1023 & n) | 56320))
				);
			},
			re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
			ie = function (e, t) {
				return t
					? "\0" === e
						? "ï¿½"
						: e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " "
					: "\\" + e;
			},
			oe = function () {
				p();
			},
			ae = be(
				function (e) {
					return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase();
				},
				{ dir: "parentNode", next: "legend" }
			);
		try {
			H.apply((D = O.call(w.childNodes)), w.childNodes), D[w.childNodes.length].nodeType;
		} catch (t) {
			H = {
				apply: D.length
					? function (e, t) {
							L.apply(e, O.call(t));
					  }
					: function (e, t) {
							for (var n = e.length, r = 0; (e[n++] = t[r++]); );
							e.length = n - 1;
					  },
			};
		}
		function se(e, t, r, i) {
			var o,
				s,
				l,
				c,
				f,
				h,
				y,
				m = t && t.ownerDocument,
				w = t ? t.nodeType : 9;
			if (((r = r || []), "string" != typeof e || !e || (1 !== w && 9 !== w && 11 !== w))) return r;
			if (!i && (p(t), (t = t || d), g)) {
				if (11 !== w && (f = Z.exec(e)))
					if ((o = f[1])) {
						if (9 === w) {
							if (!(l = t.getElementById(o))) return r;
							if (l.id === o) return r.push(l), r;
						} else if (m && (l = m.getElementById(o)) && x(t, l) && l.id === o) return r.push(l), r;
					} else {
						if (f[2]) return H.apply(r, t.getElementsByTagName(e)), r;
						if ((o = f[3]) && n.getElementsByClassName && t.getElementsByClassName)
							return H.apply(r, t.getElementsByClassName(o)), r;
					}
				if (n.qsa && !A[e + " "] && (!v || !v.test(e)) && (1 !== w || "object" !== t.nodeName.toLowerCase())) {
					if (((y = e), (m = t), 1 === w && (U.test(e) || z.test(e)))) {
						for (
							((m = (ee.test(e) && ye(t.parentNode)) || t) === t && n.scope) ||
								((c = t.getAttribute("id")) ? (c = c.replace(re, ie)) : t.setAttribute("id", (c = b))),
								s = (h = a(e)).length;
							s--;

						)
							h[s] = (c ? "#" + c : ":scope") + " " + xe(h[s]);
						y = h.join(",");
					}
					try {
						return H.apply(r, m.querySelectorAll(y)), r;
					} catch (t) {
						A(e, !0);
					} finally {
						c === b && t.removeAttribute("id");
					}
				}
			}
			return u(e.replace($, "$1"), t, r, i);
		}
		function ue() {
			var e = [];
			return function t(n, i) {
				return e.push(n + " ") > r.cacheLength && delete t[e.shift()], (t[n + " "] = i);
			};
		}
		function le(e) {
			return (e[b] = !0), e;
		}
		function ce(e) {
			var t = d.createElement("fieldset");
			try {
				return !!e(t);
			} catch (e) {
				return !1;
			} finally {
				t.parentNode && t.parentNode.removeChild(t), (t = null);
			}
		}
		function fe(e, t) {
			for (var n = e.split("|"), i = n.length; i--; ) r.attrHandle[n[i]] = t;
		}
		function pe(e, t) {
			var n = t && e,
				r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
			if (r) return r;
			if (n) for (; (n = n.nextSibling); ) if (n === t) return -1;
			return e ? 1 : -1;
		}
		function de(e) {
			return function (t) {
				return "input" === t.nodeName.toLowerCase() && t.type === e;
			};
		}
		function he(e) {
			return function (t) {
				var n = t.nodeName.toLowerCase();
				return ("input" === n || "button" === n) && t.type === e;
			};
		}
		function ge(e) {
			return function (t) {
				return "form" in t
					? t.parentNode && !1 === t.disabled
						? "label" in t
							? "label" in t.parentNode
								? t.parentNode.disabled === e
								: t.disabled === e
							: t.isDisabled === e || (t.isDisabled !== !e && ae(t) === e)
						: t.disabled === e
					: "label" in t && t.disabled === e;
			};
		}
		function ve(e) {
			return le(function (t) {
				return (
					(t = +t),
					le(function (n, r) {
						for (var i, o = e([], n.length, t), a = o.length; a--; )
							n[(i = o[a])] && (n[i] = !(r[i] = n[i]));
					})
				);
			});
		}
		function ye(e) {
			return e && void 0 !== e.getElementsByTagName && e;
		}
		for (t in ((n = se.support = {}),
		(o = se.isXML =
			function (e) {
				var t = e && e.namespaceURI,
					n = e && (e.ownerDocument || e).documentElement;
				return !Y.test(t || (n && n.nodeName) || "HTML");
			}),
		(p = se.setDocument =
			function (e) {
				var t,
					i,
					a = e ? e.ownerDocument || e : w;
				return (
					a != d &&
						9 === a.nodeType &&
						a.documentElement &&
						((h = (d = a).documentElement),
						(g = !o(d)),
						w != d &&
							(i = d.defaultView) &&
							i.top !== i &&
							(i.addEventListener
								? i.addEventListener("unload", oe, !1)
								: i.attachEvent && i.attachEvent("onunload", oe)),
						(n.scope = ce(function (e) {
							return (
								h.appendChild(e).appendChild(d.createElement("div")),
								void 0 !== e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length
							);
						})),
						(n.attributes = ce(function (e) {
							return (e.className = "i"), !e.getAttribute("className");
						})),
						(n.getElementsByTagName = ce(function (e) {
							return e.appendChild(d.createComment("")), !e.getElementsByTagName("*").length;
						})),
						(n.getElementsByClassName = K.test(d.getElementsByClassName)),
						(n.getById = ce(function (e) {
							return (h.appendChild(e).id = b), !d.getElementsByName || !d.getElementsByName(b).length;
						})),
						n.getById
							? ((r.filter.ID = function (e) {
									var t = e.replace(te, ne);
									return function (e) {
										return e.getAttribute("id") === t;
									};
							  }),
							  (r.find.ID = function (e, t) {
									if (void 0 !== t.getElementById && g) {
										var n = t.getElementById(e);
										return n ? [n] : [];
									}
							  }))
							: ((r.filter.ID = function (e) {
									var t = e.replace(te, ne);
									return function (e) {
										var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
										return n && n.value === t;
									};
							  }),
							  (r.find.ID = function (e, t) {
									if (void 0 !== t.getElementById && g) {
										var n,
											r,
											i,
											o = t.getElementById(e);
										if (o) {
											if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
											for (i = t.getElementsByName(e), r = 0; (o = i[r++]); )
												if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
										}
										return [];
									}
							  })),
						(r.find.TAG = n.getElementsByTagName
							? function (e, t) {
									return void 0 !== t.getElementsByTagName
										? t.getElementsByTagName(e)
										: n.qsa
										? t.querySelectorAll(e)
										: void 0;
							  }
							: function (e, t) {
									var n,
										r = [],
										i = 0,
										o = t.getElementsByTagName(e);
									if ("*" === e) {
										for (; (n = o[i++]); ) 1 === n.nodeType && r.push(n);
										return r;
									}
									return o;
							  }),
						(r.find.CLASS =
							n.getElementsByClassName &&
							function (e, t) {
								if (void 0 !== t.getElementsByClassName && g) return t.getElementsByClassName(e);
							}),
						(y = []),
						(v = []),
						(n.qsa = K.test(d.querySelectorAll)) &&
							(ce(function (e) {
								var t;
								(h.appendChild(e).innerHTML =
									"<a id='" +
									b +
									"'></a><select id='" +
									b +
									"-\r\\' msallowcapture=''><option selected=''></option></select>"),
									e.querySelectorAll("[msallowcapture^='']").length &&
										v.push("[*^$]=" + M + "*(?:''|\"\")"),
									e.querySelectorAll("[selected]").length ||
										v.push("\\[" + M + "*(?:value|" + R + ")"),
									e.querySelectorAll("[id~=" + b + "-]").length || v.push("~="),
									(t = d.createElement("input")).setAttribute("name", ""),
									e.appendChild(t),
									e.querySelectorAll("[name='']").length ||
										v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"),
									e.querySelectorAll(":checked").length || v.push(":checked"),
									e.querySelectorAll("a#" + b + "+*").length || v.push(".#.+[+~]"),
									e.querySelectorAll("\\\f"),
									v.push("[\\r\\n\\f]");
							}),
							ce(function (e) {
								e.innerHTML =
									"<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
								var t = d.createElement("input");
								t.setAttribute("type", "hidden"),
									e.appendChild(t).setAttribute("name", "D"),
									e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="),
									2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"),
									(h.appendChild(e).disabled = !0),
									2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"),
									e.querySelectorAll("*,:x"),
									v.push(",.*:");
							})),
						(n.matchesSelector = K.test(
							(m =
								h.matches ||
								h.webkitMatchesSelector ||
								h.mozMatchesSelector ||
								h.oMatchesSelector ||
								h.msMatchesSelector)
						)) &&
							ce(function (e) {
								(n.disconnectedMatch = m.call(e, "*")), m.call(e, "[s!='']:x"), y.push("!=", F);
							}),
						(v = v.length && new RegExp(v.join("|"))),
						(y = y.length && new RegExp(y.join("|"))),
						(t = K.test(h.compareDocumentPosition)),
						(x =
							t || K.test(h.contains)
								? function (e, t) {
										var n = 9 === e.nodeType ? e.documentElement : e,
											r = t && t.parentNode;
										return (
											e === r ||
											!(
												!r ||
												1 !== r.nodeType ||
												!(n.contains
													? n.contains(r)
													: e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))
											)
										);
								  }
								: function (e, t) {
										if (t) for (; (t = t.parentNode); ) if (t === e) return !0;
										return !1;
								  }),
						(N = t
							? function (e, t) {
									if (e === t) return (f = !0), 0;
									var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
									return (
										r ||
										(1 &
											(r =
												(e.ownerDocument || e) == (t.ownerDocument || t)
													? e.compareDocumentPosition(t)
													: 1) ||
										(!n.sortDetached && t.compareDocumentPosition(e) === r)
											? e == d || (e.ownerDocument == w && x(w, e))
												? -1
												: t == d || (t.ownerDocument == w && x(w, t))
												? 1
												: c
												? P(c, e) - P(c, t)
												: 0
											: 4 & r
											? -1
											: 1)
									);
							  }
							: function (e, t) {
									if (e === t) return (f = !0), 0;
									var n,
										r = 0,
										i = e.parentNode,
										o = t.parentNode,
										a = [e],
										s = [t];
									if (!i || !o)
										return e == d ? -1 : t == d ? 1 : i ? -1 : o ? 1 : c ? P(c, e) - P(c, t) : 0;
									if (i === o) return pe(e, t);
									for (n = e; (n = n.parentNode); ) a.unshift(n);
									for (n = t; (n = n.parentNode); ) s.unshift(n);
									for (; a[r] === s[r]; ) r++;
									return r ? pe(a[r], s[r]) : a[r] == w ? -1 : s[r] == w ? 1 : 0;
							  })),
					d
				);
			}),
		(se.matches = function (e, t) {
			return se(e, null, null, t);
		}),
		(se.matchesSelector = function (e, t) {
			if ((p(e), n.matchesSelector && g && !A[t + " "] && (!y || !y.test(t)) && (!v || !v.test(t))))
				try {
					var r = m.call(e, t);
					if (r || n.disconnectedMatch || (e.document && 11 !== e.document.nodeType)) return r;
				} catch (e) {
					A(t, !0);
				}
			return 0 < se(t, d, null, [e]).length;
		}),
		(se.contains = function (e, t) {
			return (e.ownerDocument || e) != d && p(e), x(e, t);
		}),
		(se.attr = function (e, t) {
			(e.ownerDocument || e) != d && p(e);
			var i = r.attrHandle[t.toLowerCase()],
				o = i && j.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !g) : void 0;
			return void 0 !== o
				? o
				: n.attributes || !g
				? e.getAttribute(t)
				: (o = e.getAttributeNode(t)) && o.specified
				? o.value
				: null;
		}),
		(se.escape = function (e) {
			return (e + "").replace(re, ie);
		}),
		(se.error = function (e) {
			throw new Error("Syntax error, unrecognized expression: " + e);
		}),
		(se.uniqueSort = function (e) {
			var t,
				r = [],
				i = 0,
				o = 0;
			if (((f = !n.detectDuplicates), (c = !n.sortStable && e.slice(0)), e.sort(N), f)) {
				for (; (t = e[o++]); ) t === e[o] && (i = r.push(o));
				for (; i--; ) e.splice(r[i], 1);
			}
			return (c = null), e;
		}),
		(i = se.getText =
			function (e) {
				var t,
					n = "",
					r = 0,
					o = e.nodeType;
				if (o) {
					if (1 === o || 9 === o || 11 === o) {
						if ("string" == typeof e.textContent) return e.textContent;
						for (e = e.firstChild; e; e = e.nextSibling) n += i(e);
					} else if (3 === o || 4 === o) return e.nodeValue;
				} else for (; (t = e[r++]); ) n += i(t);
				return n;
			}),
		((r = se.selectors =
			{
				cacheLength: 50,
				createPseudo: le,
				match: G,
				attrHandle: {},
				find: {},
				relative: {
					">": { dir: "parentNode", first: !0 },
					" ": { dir: "parentNode" },
					"+": { dir: "previousSibling", first: !0 },
					"~": { dir: "previousSibling" },
				},
				preFilter: {
					ATTR: function (e) {
						return (
							(e[1] = e[1].replace(te, ne)),
							(e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne)),
							"~=" === e[2] && (e[3] = " " + e[3] + " "),
							e.slice(0, 4)
						);
					},
					CHILD: function (e) {
						return (
							(e[1] = e[1].toLowerCase()),
							"nth" === e[1].slice(0, 3)
								? (e[3] || se.error(e[0]),
								  (e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3]))),
								  (e[5] = +(e[7] + e[8] || "odd" === e[3])))
								: e[3] && se.error(e[0]),
							e
						);
					},
					PSEUDO: function (e) {
						var t,
							n = !e[6] && e[2];
						return G.CHILD.test(e[0])
							? null
							: (e[3]
									? (e[2] = e[4] || e[5] || "")
									: n &&
									  X.test(n) &&
									  (t = a(n, !0)) &&
									  (t = n.indexOf(")", n.length - t) - n.length) &&
									  ((e[0] = e[0].slice(0, t)), (e[2] = n.slice(0, t))),
							  e.slice(0, 3));
					},
				},
				filter: {
					TAG: function (e) {
						var t = e.replace(te, ne).toLowerCase();
						return "*" === e
							? function () {
									return !0;
							  }
							: function (e) {
									return e.nodeName && e.nodeName.toLowerCase() === t;
							  };
					},
					CLASS: function (e) {
						var t = E[e + " "];
						return (
							t ||
							((t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) &&
								E(e, function (e) {
									return t.test(
										("string" == typeof e.className && e.className) ||
											(void 0 !== e.getAttribute && e.getAttribute("class")) ||
											""
									);
								}))
						);
					},
					ATTR: function (e, t, n) {
						return function (r) {
							var i = se.attr(r, e);
							return null == i
								? "!=" === t
								: !t ||
										((i += ""),
										"=" === t
											? i === n
											: "!=" === t
											? i !== n
											: "^=" === t
											? n && 0 === i.indexOf(n)
											: "*=" === t
											? n && -1 < i.indexOf(n)
											: "$=" === t
											? n && i.slice(-n.length) === n
											: "~=" === t
											? -1 < (" " + i.replace(B, " ") + " ").indexOf(n)
											: "|=" === t && (i === n || i.slice(0, n.length + 1) === n + "-"));
						};
					},
					CHILD: function (e, t, n, r, i) {
						var o = "nth" !== e.slice(0, 3),
							a = "last" !== e.slice(-4),
							s = "of-type" === t;
						return 1 === r && 0 === i
							? function (e) {
									return !!e.parentNode;
							  }
							: function (t, n, u) {
									var l,
										c,
										f,
										p,
										d,
										h,
										g = o !== a ? "nextSibling" : "previousSibling",
										v = t.parentNode,
										y = s && t.nodeName.toLowerCase(),
										m = !u && !s,
										x = !1;
									if (v) {
										if (o) {
											for (; g; ) {
												for (p = t; (p = p[g]); )
													if (s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType)
														return !1;
												h = g = "only" === e && !h && "nextSibling";
											}
											return !0;
										}
										if (((h = [a ? v.firstChild : v.lastChild]), a && m)) {
											for (
												x =
													(d =
														(l =
															(c =
																(f = (p = v)[b] || (p[b] = {}))[p.uniqueID] ||
																(f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]) &&
													l[2],
													p = d && v.childNodes[d];
												(p = (++d && p && p[g]) || (x = d = 0) || h.pop());

											)
												if (1 === p.nodeType && ++x && p === t) {
													c[e] = [T, d, x];
													break;
												}
										} else if (
											(m &&
												(x = d =
													(l =
														(c =
															(f = (p = t)[b] || (p[b] = {}))[p.uniqueID] ||
															(f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]),
											!1 === x)
										)
											for (
												;
												(p = (++d && p && p[g]) || (x = d = 0) || h.pop()) &&
												((s ? p.nodeName.toLowerCase() !== y : 1 !== p.nodeType) ||
													!++x ||
													(m &&
														((c =
															(f = p[b] || (p[b] = {}))[p.uniqueID] ||
															(f[p.uniqueID] = {}))[e] = [T, x]),
													p !== t));

											);
										return (x -= i) === r || (x % r == 0 && 0 <= x / r);
									}
							  };
					},
					PSEUDO: function (e, t) {
						var n,
							i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
						return i[b]
							? i(t)
							: 1 < i.length
							? ((n = [e, e, "", t]),
							  r.setFilters.hasOwnProperty(e.toLowerCase())
									? le(function (e, n) {
											for (var r, o = i(e, t), a = o.length; a--; )
												e[(r = P(e, o[a]))] = !(n[r] = o[a]);
									  })
									: function (e) {
											return i(e, 0, n);
									  })
							: i;
					},
				},
				pseudos: {
					not: le(function (e) {
						var t = [],
							n = [],
							r = s(e.replace($, "$1"));
						return r[b]
							? le(function (e, t, n, i) {
									for (var o, a = r(e, null, i, []), s = e.length; s--; )
										(o = a[s]) && (e[s] = !(t[s] = o));
							  })
							: function (e, i, o) {
									return (t[0] = e), r(t, null, o, n), (t[0] = null), !n.pop();
							  };
					}),
					has: le(function (e) {
						return function (t) {
							return 0 < se(e, t).length;
						};
					}),
					contains: le(function (e) {
						return (
							(e = e.replace(te, ne)),
							function (t) {
								return -1 < (t.textContent || i(t)).indexOf(e);
							}
						);
					}),
					lang: le(function (e) {
						return (
							V.test(e || "") || se.error("unsupported lang: " + e),
							(e = e.replace(te, ne).toLowerCase()),
							function (t) {
								var n;
								do {
									if ((n = g ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")))
										return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-");
								} while ((t = t.parentNode) && 1 === t.nodeType);
								return !1;
							}
						);
					}),
					target: function (t) {
						var n = e.location && e.location.hash;
						return n && n.slice(1) === t.id;
					},
					root: function (e) {
						return e === h;
					},
					focus: function (e) {
						return (
							e === d.activeElement &&
							(!d.hasFocus || d.hasFocus()) &&
							!!(e.type || e.href || ~e.tabIndex)
						);
					},
					enabled: ge(!1),
					disabled: ge(!0),
					checked: function (e) {
						var t = e.nodeName.toLowerCase();
						return ("input" === t && !!e.checked) || ("option" === t && !!e.selected);
					},
					selected: function (e) {
						return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
					},
					empty: function (e) {
						for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
						return !0;
					},
					parent: function (e) {
						return !r.pseudos.empty(e);
					},
					header: function (e) {
						return J.test(e.nodeName);
					},
					input: function (e) {
						return Q.test(e.nodeName);
					},
					button: function (e) {
						var t = e.nodeName.toLowerCase();
						return ("input" === t && "button" === e.type) || "button" === t;
					},
					text: function (e) {
						var t;
						return (
							"input" === e.nodeName.toLowerCase() &&
							"text" === e.type &&
							(null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
						);
					},
					first: ve(function () {
						return [0];
					}),
					last: ve(function (e, t) {
						return [t - 1];
					}),
					eq: ve(function (e, t, n) {
						return [n < 0 ? n + t : n];
					}),
					even: ve(function (e, t) {
						for (var n = 0; n < t; n += 2) e.push(n);
						return e;
					}),
					odd: ve(function (e, t) {
						for (var n = 1; n < t; n += 2) e.push(n);
						return e;
					}),
					lt: ve(function (e, t, n) {
						for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r; ) e.push(r);
						return e;
					}),
					gt: ve(function (e, t, n) {
						for (var r = n < 0 ? n + t : n; ++r < t; ) e.push(r);
						return e;
					}),
				},
			}).pseudos.nth = r.pseudos.eq),
		{ radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }))
			r.pseudos[t] = de(t);
		for (t in { submit: !0, reset: !0 }) r.pseudos[t] = he(t);
		function me() {}
		function xe(e) {
			for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
			return r;
		}
		function be(e, t, n) {
			var r = t.dir,
				i = t.next,
				o = i || r,
				a = n && "parentNode" === o,
				s = C++;
			return t.first
				? function (t, n, i) {
						for (; (t = t[r]); ) if (1 === t.nodeType || a) return e(t, n, i);
						return !1;
				  }
				: function (t, n, u) {
						var l,
							c,
							f,
							p = [T, s];
						if (u) {
							for (; (t = t[r]); ) if ((1 === t.nodeType || a) && e(t, n, u)) return !0;
						} else
							for (; (t = t[r]); )
								if (1 === t.nodeType || a)
									if (
										((c = (f = t[b] || (t[b] = {}))[t.uniqueID] || (f[t.uniqueID] = {})),
										i && i === t.nodeName.toLowerCase())
									)
										t = t[r] || t;
									else {
										if ((l = c[o]) && l[0] === T && l[1] === s) return (p[2] = l[2]);
										if (((c[o] = p)[2] = e(t, n, u))) return !0;
									}
						return !1;
				  };
		}
		function we(e) {
			return 1 < e.length
				? function (t, n, r) {
						for (var i = e.length; i--; ) if (!e[i](t, n, r)) return !1;
						return !0;
				  }
				: e[0];
		}
		function Te(e, t, n, r, i) {
			for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)
				(o = e[s]) && ((n && !n(o, r, i)) || (a.push(o), l && t.push(s)));
			return a;
		}
		function Ce(e, t, n, r, i, o) {
			return (
				r && !r[b] && (r = Ce(r)),
				i && !i[b] && (i = Ce(i, o)),
				le(function (o, a, s, u) {
					var l,
						c,
						f,
						p = [],
						d = [],
						h = a.length,
						g =
							o ||
							(function (e, t, n) {
								for (var r = 0, i = t.length; r < i; r++) se(e, t[r], n);
								return n;
							})(t || "*", s.nodeType ? [s] : s, []),
						v = !e || (!o && t) ? g : Te(g, p, e, s, u),
						y = n ? (i || (o ? e : h || r) ? [] : a) : v;
					if ((n && n(v, y, s, u), r))
						for (l = Te(y, d), r(l, [], s, u), c = l.length; c--; )
							(f = l[c]) && (y[d[c]] = !(v[d[c]] = f));
					if (o) {
						if (i || e) {
							if (i) {
								for (l = [], c = y.length; c--; ) (f = y[c]) && l.push((v[c] = f));
								i(null, (y = []), l, u);
							}
							for (c = y.length; c--; )
								(f = y[c]) && -1 < (l = i ? P(o, f) : p[c]) && (o[l] = !(a[l] = f));
						}
					} else (y = Te(y === a ? y.splice(h, y.length) : y)), i ? i(null, a, y, u) : H.apply(a, y);
				})
			);
		}
		function Ee(e) {
			for (
				var t,
					n,
					i,
					o = e.length,
					a = r.relative[e[0].type],
					s = a || r.relative[" "],
					u = a ? 1 : 0,
					c = be(
						function (e) {
							return e === t;
						},
						s,
						!0
					),
					f = be(
						function (e) {
							return -1 < P(t, e);
						},
						s,
						!0
					),
					p = [
						function (e, n, r) {
							var i = (!a && (r || n !== l)) || ((t = n).nodeType ? c(e, n, r) : f(e, n, r));
							return (t = null), i;
						},
					];
				u < o;
				u++
			)
				if ((n = r.relative[e[u].type])) p = [be(we(p), n)];
				else {
					if ((n = r.filter[e[u].type].apply(null, e[u].matches))[b]) {
						for (i = ++u; i < o && !r.relative[e[i].type]; i++);
						return Ce(
							1 < u && we(p),
							1 < u &&
								xe(e.slice(0, u - 1).concat({ value: " " === e[u - 2].type ? "*" : "" })).replace(
									$,
									"$1"
								),
							n,
							u < i && Ee(e.slice(u, i)),
							i < o && Ee((e = e.slice(i))),
							i < o && xe(e)
						);
					}
					p.push(n);
				}
			return we(p);
		}
		return (
			(me.prototype = r.filters = r.pseudos),
			(r.setFilters = new me()),
			(a = se.tokenize =
				function (e, t) {
					var n,
						i,
						o,
						a,
						s,
						u,
						l,
						c = S[e + " "];
					if (c) return t ? 0 : c.slice(0);
					for (s = e, u = [], l = r.preFilter; s; ) {
						for (a in ((n && !(i = _.exec(s))) || (i && (s = s.slice(i[0].length) || s), u.push((o = []))),
						(n = !1),
						(i = z.exec(s)) &&
							((n = i.shift()),
							o.push({ value: n, type: i[0].replace($, " ") }),
							(s = s.slice(n.length))),
						r.filter))
							!(i = G[a].exec(s)) ||
								(l[a] && !(i = l[a](i))) ||
								((n = i.shift()), o.push({ value: n, type: a, matches: i }), (s = s.slice(n.length)));
						if (!n) break;
					}
					return t ? s.length : s ? se.error(e) : S(e, u).slice(0);
				}),
			(s = se.compile =
				function (e, t) {
					var n,
						i,
						o,
						s,
						u,
						c,
						f = [],
						h = [],
						v = k[e + " "];
					if (!v) {
						for (t || (t = a(e)), n = t.length; n--; ) (v = Ee(t[n]))[b] ? f.push(v) : h.push(v);
						(v = k(
							e,
							((i = h),
							(s = 0 < (o = f).length),
							(u = 0 < i.length),
							(c = function (e, t, n, a, c) {
								var f,
									h,
									v,
									y = 0,
									m = "0",
									x = e && [],
									b = [],
									w = l,
									C = e || (u && r.find.TAG("*", c)),
									E = (T += null == w ? 1 : Math.random() || 0.1),
									S = C.length;
								for (c && (l = t == d || t || c); m !== S && null != (f = C[m]); m++) {
									if (u && f) {
										for (h = 0, t || f.ownerDocument == d || (p(f), (n = !g)); (v = i[h++]); )
											if (v(f, t || d, n)) {
												a.push(f);
												break;
											}
										c && (T = E);
									}
									s && ((f = !v && f) && y--, e && x.push(f));
								}
								if (((y += m), s && m !== y)) {
									for (h = 0; (v = o[h++]); ) v(x, b, t, n);
									if (e) {
										if (0 < y) for (; m--; ) x[m] || b[m] || (b[m] = q.call(a));
										b = Te(b);
									}
									H.apply(a, b), c && !e && 0 < b.length && 1 < y + o.length && se.uniqueSort(a);
								}
								return c && ((T = E), (l = w)), x;
							}),
							s ? le(c) : c)
						)).selector = e;
					}
					return v;
				}),
			(u = se.select =
				function (e, t, n, i) {
					var o,
						u,
						l,
						c,
						f,
						p = "function" == typeof e && e,
						d = !i && a((e = p.selector || e));
					if (((n = n || []), 1 === d.length)) {
						if (
							2 < (u = d[0] = d[0].slice(0)).length &&
							"ID" === (l = u[0]).type &&
							9 === t.nodeType &&
							g &&
							r.relative[u[1].type]
						) {
							if (!(t = (r.find.ID(l.matches[0].replace(te, ne), t) || [])[0])) return n;
							p && (t = t.parentNode), (e = e.slice(u.shift().value.length));
						}
						for (
							o = G.needsContext.test(e) ? 0 : u.length;
							o-- && ((l = u[o]), !r.relative[(c = l.type)]);

						)
							if (
								(f = r.find[c]) &&
								(i = f(l.matches[0].replace(te, ne), (ee.test(u[0].type) && ye(t.parentNode)) || t))
							) {
								if ((u.splice(o, 1), !(e = i.length && xe(u)))) return H.apply(n, i), n;
								break;
							}
					}
					return (p || s(e, d))(i, t, !g, n, !t || (ee.test(e) && ye(t.parentNode)) || t), n;
				}),
			(n.sortStable = b.split("").sort(N).join("") === b),
			(n.detectDuplicates = !!f),
			p(),
			(n.sortDetached = ce(function (e) {
				return 1 & e.compareDocumentPosition(d.createElement("fieldset"));
			})),
			ce(function (e) {
				return (e.innerHTML = "<a href='#'></a>"), "#" === e.firstChild.getAttribute("href");
			}) ||
				fe("type|href|height|width", function (e, t, n) {
					if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
				}),
			(n.attributes &&
				ce(function (e) {
					return (
						(e.innerHTML = "<input/>"),
						e.firstChild.setAttribute("value", ""),
						"" === e.firstChild.getAttribute("value")
					);
				})) ||
				fe("value", function (e, t, n) {
					if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
				}),
			ce(function (e) {
				return null == e.getAttribute("disabled");
			}) ||
				fe(R, function (e, t, n) {
					var r;
					if (!n)
						return !0 === e[t]
							? t.toLowerCase()
							: (r = e.getAttributeNode(t)) && r.specified
							? r.value
							: null;
				}),
			se
		);
	})(e);
	(w.find = C),
		(w.expr = C.selectors),
		(w.expr[":"] = w.expr.pseudos),
		(w.uniqueSort = w.unique = C.uniqueSort),
		(w.text = C.getText),
		(w.isXMLDoc = C.isXML),
		(w.contains = C.contains),
		(w.escapeSelector = C.escape);
	var E = function (e, t, n) {
			for (var r = [], i = void 0 !== n; (e = e[t]) && 9 !== e.nodeType; )
				if (1 === e.nodeType) {
					if (i && w(e).is(n)) break;
					r.push(e);
				}
			return r;
		},
		S = function (e, t) {
			for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
			return n;
		},
		k = w.expr.match.needsContext;
	function A(e, t) {
		return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
	}
	var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
	function j(e, t, n) {
		return h(t)
			? w.grep(e, function (e, r) {
					return !!t.call(e, r, e) !== n;
			  })
			: t.nodeType
			? w.grep(e, function (e) {
					return (e === t) !== n;
			  })
			: "string" != typeof t
			? w.grep(e, function (e) {
					return -1 < s.call(t, e) !== n;
			  })
			: w.filter(t, e, n);
	}
	(w.filter = function (e, t, n) {
		var r = t[0];
		return (
			n && (e = ":not(" + e + ")"),
			1 === t.length && 1 === r.nodeType
				? w.find.matchesSelector(r, e)
					? [r]
					: []
				: w.find.matches(
						e,
						w.grep(t, function (e) {
							return 1 === e.nodeType;
						})
				  )
		);
	}),
		w.fn.extend({
			find: function (e) {
				var t,
					n,
					r = this.length,
					i = this;
				if ("string" != typeof e)
					return this.pushStack(
						w(e).filter(function () {
							for (t = 0; t < r; t++) if (w.contains(i[t], this)) return !0;
						})
					);
				for (n = this.pushStack([]), t = 0; t < r; t++) w.find(e, i[t], n);
				return 1 < r ? w.uniqueSort(n) : n;
			},
			filter: function (e) {
				return this.pushStack(j(this, e || [], !1));
			},
			not: function (e) {
				return this.pushStack(j(this, e || [], !0));
			},
			is: function (e) {
				return !!j(this, "string" == typeof e && k.test(e) ? w(e) : e || [], !1).length;
			},
		});
	var D,
		q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
	((w.fn.init = function (e, t, n) {
		var r, i;
		if (!e) return this;
		if (((n = n || D), "string" == typeof e)) {
			if (
				!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) ||
				(!r[1] && t)
			)
				return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
			if (r[1]) {
				if (
					((t = t instanceof w ? t[0] : t),
					w.merge(this, w.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : v, !0)),
					N.test(r[1]) && w.isPlainObject(t))
				)
					for (r in t) h(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
				return this;
			}
			return (i = v.getElementById(r[2])) && ((this[0] = i), (this.length = 1)), this;
		}
		return e.nodeType
			? ((this[0] = e), (this.length = 1), this)
			: h(e)
			? void 0 !== n.ready
				? n.ready(e)
				: e(w)
			: w.makeArray(e, this);
	}).prototype = w.fn),
		(D = w(v));
	var L = /^(?:parents|prev(?:Until|All))/,
		H = { children: !0, contents: !0, next: !0, prev: !0 };
	function O(e, t) {
		for (; (e = e[t]) && 1 !== e.nodeType; );
		return e;
	}
	w.fn.extend({
		has: function (e) {
			var t = w(e, this),
				n = t.length;
			return this.filter(function () {
				for (var e = 0; e < n; e++) if (w.contains(this, t[e])) return !0;
			});
		},
		closest: function (e, t) {
			var n,
				r = 0,
				i = this.length,
				o = [],
				a = "string" != typeof e && w(e);
			if (!k.test(e))
				for (; r < i; r++)
					for (n = this[r]; n && n !== t; n = n.parentNode)
						if (
							n.nodeType < 11 &&
							(a ? -1 < a.index(n) : 1 === n.nodeType && w.find.matchesSelector(n, e))
						) {
							o.push(n);
							break;
						}
			return this.pushStack(1 < o.length ? w.uniqueSort(o) : o);
		},
		index: function (e) {
			return e
				? "string" == typeof e
					? s.call(w(e), this[0])
					: s.call(this, e.jquery ? e[0] : e)
				: this[0] && this[0].parentNode
				? this.first().prevAll().length
				: -1;
		},
		add: function (e, t) {
			return this.pushStack(w.uniqueSort(w.merge(this.get(), w(e, t))));
		},
		addBack: function (e) {
			return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
		},
	}),
		w.each(
			{
				parent: function (e) {
					var t = e.parentNode;
					return t && 11 !== t.nodeType ? t : null;
				},
				parents: function (e) {
					return E(e, "parentNode");
				},
				parentsUntil: function (e, t, n) {
					return E(e, "parentNode", n);
				},
				next: function (e) {
					return O(e, "nextSibling");
				},
				prev: function (e) {
					return O(e, "previousSibling");
				},
				nextAll: function (e) {
					return E(e, "nextSibling");
				},
				prevAll: function (e) {
					return E(e, "previousSibling");
				},
				nextUntil: function (e, t, n) {
					return E(e, "nextSibling", n);
				},
				prevUntil: function (e, t, n) {
					return E(e, "previousSibling", n);
				},
				siblings: function (e) {
					return S((e.parentNode || {}).firstChild, e);
				},
				children: function (e) {
					return S(e.firstChild);
				},
				contents: function (e) {
					return null != e.contentDocument && r(e.contentDocument)
						? e.contentDocument
						: (A(e, "template") && (e = e.content || e), w.merge([], e.childNodes));
				},
			},
			function (e, t) {
				w.fn[e] = function (n, r) {
					var i = w.map(this, t, n);
					return (
						"Until" !== e.slice(-5) && (r = n),
						r && "string" == typeof r && (i = w.filter(r, i)),
						1 < this.length && (H[e] || w.uniqueSort(i), L.test(e) && i.reverse()),
						this.pushStack(i)
					);
				};
			}
		);
	var P = /[^\x20\t\r\n\f]+/g;
	function R(e) {
		return e;
	}
	function M(e) {
		throw e;
	}
	function I(e, t, n, r) {
		var i;
		try {
			e && h((i = e.promise))
				? i.call(e).done(t).fail(n)
				: e && h((i = e.then))
				? i.call(e, t, n)
				: t.apply(void 0, [e].slice(r));
		} catch (e) {
			n.apply(void 0, [e]);
		}
	}
	(w.Callbacks = function (e) {
		var t, n;
		e =
			"string" == typeof e
				? ((t = e),
				  (n = {}),
				  w.each(t.match(P) || [], function (e, t) {
						n[t] = !0;
				  }),
				  n)
				: w.extend({}, e);
		var r,
			i,
			o,
			a,
			s = [],
			u = [],
			l = -1,
			c = function () {
				for (a = a || e.once, o = r = !0; u.length; l = -1)
					for (i = u.shift(); ++l < s.length; )
						!1 === s[l].apply(i[0], i[1]) && e.stopOnFalse && ((l = s.length), (i = !1));
				e.memory || (i = !1), (r = !1), a && (s = i ? [] : "");
			},
			f = {
				add: function () {
					return (
						s &&
							(i && !r && ((l = s.length - 1), u.push(i)),
							(function t(n) {
								w.each(n, function (n, r) {
									h(r)
										? (e.unique && f.has(r)) || s.push(r)
										: r && r.length && "string" !== x(r) && t(r);
								});
							})(arguments),
							i && !r && c()),
						this
					);
				},
				remove: function () {
					return (
						w.each(arguments, function (e, t) {
							for (var n; -1 < (n = w.inArray(t, s, n)); ) s.splice(n, 1), n <= l && l--;
						}),
						this
					);
				},
				has: function (e) {
					return e ? -1 < w.inArray(e, s) : 0 < s.length;
				},
				empty: function () {
					return s && (s = []), this;
				},
				disable: function () {
					return (a = u = []), (s = i = ""), this;
				},
				disabled: function () {
					return !s;
				},
				lock: function () {
					return (a = u = []), i || r || (s = i = ""), this;
				},
				locked: function () {
					return !!a;
				},
				fireWith: function (e, t) {
					return a || ((t = [e, (t = t || []).slice ? t.slice() : t]), u.push(t), r || c()), this;
				},
				fire: function () {
					return f.fireWith(this, arguments), this;
				},
				fired: function () {
					return !!o;
				},
			};
		return f;
	}),
		w.extend({
			Deferred: function (t) {
				var n = [
						["notify", "progress", w.Callbacks("memory"), w.Callbacks("memory"), 2],
						["resolve", "done", w.Callbacks("once memory"), w.Callbacks("once memory"), 0, "resolved"],
						["reject", "fail", w.Callbacks("once memory"), w.Callbacks("once memory"), 1, "rejected"],
					],
					r = "pending",
					i = {
						state: function () {
							return r;
						},
						always: function () {
							return o.done(arguments).fail(arguments), this;
						},
						catch: function (e) {
							return i.then(null, e);
						},
						pipe: function () {
							var e = arguments;
							return w
								.Deferred(function (t) {
									w.each(n, function (n, r) {
										var i = h(e[r[4]]) && e[r[4]];
										o[r[1]](function () {
											var e = i && i.apply(this, arguments);
											e && h(e.promise)
												? e.promise().progress(t.notify).done(t.resolve).fail(t.reject)
												: t[r[0] + "With"](this, i ? [e] : arguments);
										});
									}),
										(e = null);
								})
								.promise();
						},
						then: function (t, r, i) {
							var o = 0;
							function a(t, n, r, i) {
								return function () {
									var s = this,
										u = arguments,
										l = function () {
											var e, l;
											if (!(t < o)) {
												if ((e = r.apply(s, u)) === n.promise())
													throw new TypeError("Thenable self-resolution");
												(l = e && ("object" == typeof e || "function" == typeof e) && e.then),
													h(l)
														? i
															? l.call(e, a(o, n, R, i), a(o, n, M, i))
															: (o++,
															  l.call(
																	e,
																	a(o, n, R, i),
																	a(o, n, M, i),
																	a(o, n, R, n.notifyWith)
															  ))
														: (r !== R && ((s = void 0), (u = [e])),
														  (i || n.resolveWith)(s, u));
											}
										},
										c = i
											? l
											: function () {
													try {
														l();
													} catch (e) {
														w.Deferred.exceptionHook &&
															w.Deferred.exceptionHook(e, c.stackTrace),
															o <= t + 1 &&
																(r !== M && ((s = void 0), (u = [e])),
																n.rejectWith(s, u));
													}
											  };
									t
										? c()
										: (w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook()),
										  e.setTimeout(c));
								};
							}
							return w
								.Deferred(function (e) {
									n[0][3].add(a(0, e, h(i) ? i : R, e.notifyWith)),
										n[1][3].add(a(0, e, h(t) ? t : R)),
										n[2][3].add(a(0, e, h(r) ? r : M));
								})
								.promise();
						},
						promise: function (e) {
							return null != e ? w.extend(e, i) : i;
						},
					},
					o = {};
				return (
					w.each(n, function (e, t) {
						var a = t[2],
							s = t[5];
						(i[t[1]] = a.add),
							s &&
								a.add(
									function () {
										r = s;
									},
									n[3 - e][2].disable,
									n[3 - e][3].disable,
									n[0][2].lock,
									n[0][3].lock
								),
							a.add(t[3].fire),
							(o[t[0]] = function () {
								return o[t[0] + "With"](this === o ? void 0 : this, arguments), this;
							}),
							(o[t[0] + "With"] = a.fireWith);
					}),
					i.promise(o),
					t && t.call(o, o),
					o
				);
			},
			when: function (e) {
				var t = arguments.length,
					n = t,
					r = Array(n),
					o = i.call(arguments),
					a = w.Deferred(),
					s = function (e) {
						return function (n) {
							(r[e] = this),
								(o[e] = 1 < arguments.length ? i.call(arguments) : n),
								--t || a.resolveWith(r, o);
						};
					};
				if (
					t <= 1 &&
					(I(e, a.done(s(n)).resolve, a.reject, !t), "pending" === a.state() || h(o[n] && o[n].then))
				)
					return a.then();
				for (; n--; ) I(o[n], s(n), a.reject);
				return a.promise();
			},
		});
	var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	(w.Deferred.exceptionHook = function (t, n) {
		e.console &&
			e.console.warn &&
			t &&
			W.test(t.name) &&
			e.console.warn("jQuery.Deferred exception: " + t.message, t.stack, n);
	}),
		(w.readyException = function (t) {
			e.setTimeout(function () {
				throw t;
			});
		});
	var F = w.Deferred();
	function B() {
		v.removeEventListener("DOMContentLoaded", B), e.removeEventListener("load", B), w.ready();
	}
	(w.fn.ready = function (e) {
		return (
			F.then(e).catch(function (e) {
				w.readyException(e);
			}),
			this
		);
	}),
		w.extend({
			isReady: !1,
			readyWait: 1,
			ready: function (e) {
				(!0 === e ? --w.readyWait : w.isReady) ||
					((w.isReady = !0) !== e && 0 < --w.readyWait) ||
					F.resolveWith(v, [w]);
			},
		}),
		(w.ready.then = F.then),
		"complete" === v.readyState || ("loading" !== v.readyState && !v.documentElement.doScroll)
			? e.setTimeout(w.ready)
			: (v.addEventListener("DOMContentLoaded", B), e.addEventListener("load", B));
	var $ = function (e, t, n, r, i, o, a) {
			var s = 0,
				u = e.length,
				l = null == n;
			if ("object" === x(n)) for (s in ((i = !0), n)) $(e, t, s, n[s], !0, o, a);
			else if (
				void 0 !== r &&
				((i = !0),
				h(r) || (a = !0),
				l &&
					(a
						? (t.call(e, r), (t = null))
						: ((l = t),
						  (t = function (e, t, n) {
								return l.call(w(e), n);
						  }))),
				t)
			)
				for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
			return i ? e : l ? t.call(e) : u ? t(e[0], n) : o;
		},
		_ = /^-ms-/,
		z = /-([a-z])/g;
	function U(e, t) {
		return t.toUpperCase();
	}
	function X(e) {
		return e.replace(_, "ms-").replace(z, U);
	}
	var V = function (e) {
		return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
	};
	function G() {
		this.expando = w.expando + G.uid++;
	}
	(G.uid = 1),
		(G.prototype = {
			cache: function (e) {
				var t = e[this.expando];
				return (
					t ||
						((t = {}),
						V(e) &&
							(e.nodeType
								? (e[this.expando] = t)
								: Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))),
					t
				);
			},
			set: function (e, t, n) {
				var r,
					i = this.cache(e);
				if ("string" == typeof t) i[X(t)] = n;
				else for (r in t) i[X(r)] = t[r];
				return i;
			},
			get: function (e, t) {
				return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)];
			},
			access: function (e, t, n) {
				return void 0 === t || (t && "string" == typeof t && void 0 === n)
					? this.get(e, t)
					: (this.set(e, t, n), void 0 !== n ? n : t);
			},
			remove: function (e, t) {
				var n,
					r = e[this.expando];
				if (void 0 !== r) {
					if (void 0 !== t) {
						n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length;
						for (; n--; ) delete r[t[n]];
					}
					(void 0 === t || w.isEmptyObject(r)) &&
						(e.nodeType ? (e[this.expando] = void 0) : delete e[this.expando]);
				}
			},
			hasData: function (e) {
				var t = e[this.expando];
				return void 0 !== t && !w.isEmptyObject(t);
			},
		});
	var Y = new G(),
		Q = new G(),
		J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		K = /[A-Z]/g;
	function Z(e, t, n) {
		var r, i;
		if (void 0 === n && 1 === e.nodeType)
			if (((r = "data-" + t.replace(K, "-$&").toLowerCase()), "string" == typeof (n = e.getAttribute(r)))) {
				try {
					n =
						"true" === (i = n) ||
						("false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i));
				} catch (e) {}
				Q.set(e, t, n);
			} else n = void 0;
		return n;
	}
	w.extend({
		hasData: function (e) {
			return Q.hasData(e) || Y.hasData(e);
		},
		data: function (e, t, n) {
			return Q.access(e, t, n);
		},
		removeData: function (e, t) {
			Q.remove(e, t);
		},
		_data: function (e, t, n) {
			return Y.access(e, t, n);
		},
		_removeData: function (e, t) {
			Y.remove(e, t);
		},
	}),
		w.fn.extend({
			data: function (e, t) {
				var n,
					r,
					i,
					o = this[0],
					a = o && o.attributes;
				if (void 0 === e) {
					if (this.length && ((i = Q.get(o)), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) {
						for (n = a.length; n--; )
							a[n] && 0 === (r = a[n].name).indexOf("data-") && ((r = X(r.slice(5))), Z(o, r, i[r]));
						Y.set(o, "hasDataAttrs", !0);
					}
					return i;
				}
				return "object" == typeof e
					? this.each(function () {
							Q.set(this, e);
					  })
					: $(
							this,
							function (t) {
								var n;
								if (o && void 0 === t)
									return void 0 !== (n = Q.get(o, e)) || void 0 !== (n = Z(o, e)) ? n : void 0;
								this.each(function () {
									Q.set(this, e, t);
								});
							},
							null,
							t,
							1 < arguments.length,
							null,
							!0
					  );
			},
			removeData: function (e) {
				return this.each(function () {
					Q.remove(this, e);
				});
			},
		}),
		w.extend({
			queue: function (e, t, n) {
				var r;
				if (e)
					return (
						(t = (t || "fx") + "queue"),
						(r = Y.get(e, t)),
						n && (!r || Array.isArray(n) ? (r = Y.access(e, t, w.makeArray(n))) : r.push(n)),
						r || []
					);
			},
			dequeue: function (e, t) {
				t = t || "fx";
				var n = w.queue(e, t),
					r = n.length,
					i = n.shift(),
					o = w._queueHooks(e, t);
				"inprogress" === i && ((i = n.shift()), r--),
					i &&
						("fx" === t && n.unshift("inprogress"),
						delete o.stop,
						i.call(
							e,
							function () {
								w.dequeue(e, t);
							},
							o
						)),
					!r && o && o.empty.fire();
			},
			_queueHooks: function (e, t) {
				var n = t + "queueHooks";
				return (
					Y.get(e, n) ||
					Y.access(e, n, {
						empty: w.Callbacks("once memory").add(function () {
							Y.remove(e, [t + "queue", n]);
						}),
					})
				);
			},
		}),
		w.fn.extend({
			queue: function (e, t) {
				var n = 2;
				return (
					"string" != typeof e && ((t = e), (e = "fx"), n--),
					arguments.length < n
						? w.queue(this[0], e)
						: void 0 === t
						? this
						: this.each(function () {
								var n = w.queue(this, e, t);
								w._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && w.dequeue(this, e);
						  })
				);
			},
			dequeue: function (e) {
				return this.each(function () {
					w.dequeue(this, e);
				});
			},
			clearQueue: function (e) {
				return this.queue(e || "fx", []);
			},
			promise: function (e, t) {
				var n,
					r = 1,
					i = w.Deferred(),
					o = this,
					a = this.length,
					s = function () {
						--r || i.resolveWith(o, [o]);
					};
				for ("string" != typeof e && ((t = e), (e = void 0)), e = e || "fx"; a--; )
					(n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
				return s(), i.promise(t);
			},
		});
	var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
		te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"),
		ne = ["Top", "Right", "Bottom", "Left"],
		re = v.documentElement,
		ie = function (e) {
			return w.contains(e.ownerDocument, e);
		},
		oe = { composed: !0 };
	re.getRootNode &&
		(ie = function (e) {
			return w.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument;
		});
	var ae = function (e, t) {
		return (
			"none" === (e = t || e).style.display || ("" === e.style.display && ie(e) && "none" === w.css(e, "display"))
		);
	};
	function se(e, t, n, r) {
		var i,
			o,
			a = 20,
			s = r
				? function () {
						return r.cur();
				  }
				: function () {
						return w.css(e, t, "");
				  },
			u = s(),
			l = (n && n[3]) || (w.cssNumber[t] ? "" : "px"),
			c = e.nodeType && (w.cssNumber[t] || ("px" !== l && +u)) && te.exec(w.css(e, t));
		if (c && c[3] !== l) {
			for (u /= 2, l = l || c[3], c = +u || 1; a--; )
				w.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || 0.5)) <= 0 && (a = 0), (c /= o);
			(c *= 2), w.style(e, t, c + l), (n = n || []);
		}
		return (
			n &&
				((c = +c || +u || 0),
				(i = n[1] ? c + (n[1] + 1) * n[2] : +n[2]),
				r && ((r.unit = l), (r.start = c), (r.end = i))),
			i
		);
	}
	var ue = {};
	function le(e, t) {
		for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)
			(r = e[c]).style &&
				((n = r.style.display),
				t
					? ("none" === n && ((l[c] = Y.get(r, "display") || null), l[c] || (r.style.display = "")),
					  "" === r.style.display &&
							ae(r) &&
							(l[c] =
								((u = a = o = void 0),
								(a = (i = r).ownerDocument),
								(s = i.nodeName),
								(u = ue[s]) ||
									((o = a.body.appendChild(a.createElement(s))),
									(u = w.css(o, "display")),
									o.parentNode.removeChild(o),
									"none" === u && (u = "block"),
									(ue[s] = u)))))
					: "none" !== n && ((l[c] = "none"), Y.set(r, "display", n)));
		for (c = 0; c < f; c++) null != l[c] && (e[c].style.display = l[c]);
		return e;
	}
	w.fn.extend({
		show: function () {
			return le(this, !0);
		},
		hide: function () {
			return le(this);
		},
		toggle: function (e) {
			return "boolean" == typeof e
				? e
					? this.show()
					: this.hide()
				: this.each(function () {
						ae(this) ? w(this).show() : w(this).hide();
				  });
		},
	});
	var ce,
		fe,
		pe = /^(?:checkbox|radio)$/i,
		de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
		he = /^$|^module$|\/(?:java|ecma)script/i;
	(ce = v.createDocumentFragment().appendChild(v.createElement("div"))),
		(fe = v.createElement("input")).setAttribute("type", "radio"),
		fe.setAttribute("checked", "checked"),
		fe.setAttribute("name", "t"),
		ce.appendChild(fe),
		(d.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked),
		(ce.innerHTML = "<textarea>x</textarea>"),
		(d.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue),
		(ce.innerHTML = "<option></option>"),
		(d.option = !!ce.lastChild);
	var ge = {
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
		_default: [0, "", ""],
	};
	function ve(e, t) {
		var n;
		return (
			(n =
				void 0 !== e.getElementsByTagName
					? e.getElementsByTagName(t || "*")
					: void 0 !== e.querySelectorAll
					? e.querySelectorAll(t || "*")
					: []),
			void 0 === t || (t && A(e, t)) ? w.merge([e], n) : n
		);
	}
	function ye(e, t) {
		for (var n = 0, r = e.length; n < r; n++) Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval"));
	}
	(ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead),
		(ge.th = ge.td),
		d.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]);
	var me = /<|&#?\w+;/;
	function xe(e, t, n, r, i) {
		for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)
			if ((o = e[d]) || 0 === o)
				if ("object" === x(o)) w.merge(p, o.nodeType ? [o] : o);
				else if (me.test(o)) {
					for (
						a = a || f.appendChild(t.createElement("div")),
							s = (de.exec(o) || ["", ""])[1].toLowerCase(),
							u = ge[s] || ge._default,
							a.innerHTML = u[1] + w.htmlPrefilter(o) + u[2],
							c = u[0];
						c--;

					)
						a = a.lastChild;
					w.merge(p, a.childNodes), ((a = f.firstChild).textContent = "");
				} else p.push(t.createTextNode(o));
		for (f.textContent = "", d = 0; (o = p[d++]); )
			if (r && -1 < w.inArray(o, r)) i && i.push(o);
			else if (((l = ie(o)), (a = ve(f.appendChild(o), "script")), l && ye(a), n))
				for (c = 0; (o = a[c++]); ) he.test(o.type || "") && n.push(o);
		return f;
	}
	var be = /^([^.]*)(?:\.(.+)|)/;
	function we() {
		return !0;
	}
	function Te() {
		return !1;
	}
	function Ce(e, t) {
		return (
			(e ===
				(function () {
					try {
						return v.activeElement;
					} catch (e) {}
				})()) ==
			("focus" === t)
		);
	}
	function Ee(e, t, n, r, i, o) {
		var a, s;
		if ("object" == typeof t) {
			for (s in ("string" != typeof n && ((r = r || n), (n = void 0)), t)) Ee(e, s, n, r, t[s], o);
			return e;
		}
		if (
			(null == r && null == i
				? ((i = n), (r = n = void 0))
				: null == i && ("string" == typeof n ? ((i = r), (r = void 0)) : ((i = r), (r = n), (n = void 0))),
			!1 === i)
		)
			i = Te;
		else if (!i) return e;
		return (
			1 === o &&
				((a = i),
				((i = function (e) {
					return w().off(e), a.apply(this, arguments);
				}).guid = a.guid || (a.guid = w.guid++))),
			e.each(function () {
				w.event.add(this, t, i, r, n);
			})
		);
	}
	function Se(e, t, n) {
		n
			? (Y.set(e, t, !1),
			  w.event.add(e, t, {
					namespace: !1,
					handler: function (e) {
						var r,
							o,
							a = Y.get(this, t);
						if (1 & e.isTrigger && this[t]) {
							if (a.length) (w.event.special[t] || {}).delegateType && e.stopPropagation();
							else if (
								((a = i.call(arguments)),
								Y.set(this, t, a),
								(r = n(this, t)),
								this[t](),
								a !== (o = Y.get(this, t)) || r ? Y.set(this, t, !1) : (o = {}),
								a !== o)
							)
								return e.stopImmediatePropagation(), e.preventDefault(), o && o.value;
						} else
							a.length &&
								(Y.set(this, t, {
									value: w.event.trigger(w.extend(a[0], w.Event.prototype), a.slice(1), this),
								}),
								e.stopImmediatePropagation());
					},
			  }))
			: void 0 === Y.get(e, t) && w.event.add(e, t, we);
	}
	(w.event = {
		global: {},
		add: function (e, t, n, r, i) {
			var o,
				a,
				s,
				u,
				l,
				c,
				f,
				p,
				d,
				h,
				g,
				v = Y.get(e);
			if (V(e))
				for (
					n.handler && ((n = (o = n).handler), (i = o.selector)),
						i && w.find.matchesSelector(re, i),
						n.guid || (n.guid = w.guid++),
						(u = v.events) || (u = v.events = Object.create(null)),
						(a = v.handle) ||
							(a = v.handle =
								function (t) {
									return void 0 !== w && w.event.triggered !== t.type
										? w.event.dispatch.apply(e, arguments)
										: void 0;
								}),
						l = (t = (t || "").match(P) || [""]).length;
					l--;

				)
					(d = g = (s = be.exec(t[l]) || [])[1]),
						(h = (s[2] || "").split(".").sort()),
						d &&
							((f = w.event.special[d] || {}),
							(d = (i ? f.delegateType : f.bindType) || d),
							(f = w.event.special[d] || {}),
							(c = w.extend(
								{
									type: d,
									origType: g,
									data: r,
									handler: n,
									guid: n.guid,
									selector: i,
									needsContext: i && w.expr.match.needsContext.test(i),
									namespace: h.join("."),
								},
								o
							)),
							(p = u[d]) ||
								(((p = u[d] = []).delegateCount = 0),
								(f.setup && !1 !== f.setup.call(e, r, h, a)) ||
									(e.addEventListener && e.addEventListener(d, a))),
							f.add && (f.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)),
							i ? p.splice(p.delegateCount++, 0, c) : p.push(c),
							(w.event.global[d] = !0));
		},
		remove: function (e, t, n, r, i) {
			var o,
				a,
				s,
				u,
				l,
				c,
				f,
				p,
				d,
				h,
				g,
				v = Y.hasData(e) && Y.get(e);
			if (v && (u = v.events)) {
				for (l = (t = (t || "").match(P) || [""]).length; l--; )
					if (((d = g = (s = be.exec(t[l]) || [])[1]), (h = (s[2] || "").split(".").sort()), d)) {
						for (
							f = w.event.special[d] || {},
								p = u[(d = (r ? f.delegateType : f.bindType) || d)] || [],
								s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"),
								a = o = p.length;
							o--;

						)
							(c = p[o]),
								(!i && g !== c.origType) ||
									(n && n.guid !== c.guid) ||
									(s && !s.test(c.namespace)) ||
									(r && r !== c.selector && ("**" !== r || !c.selector)) ||
									(p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
						a &&
							!p.length &&
							((f.teardown && !1 !== f.teardown.call(e, h, v.handle)) || w.removeEvent(e, d, v.handle),
							delete u[d]);
					} else for (d in u) w.event.remove(e, d + t[l], n, r, !0);
				w.isEmptyObject(u) && Y.remove(e, "handle events");
			}
		},
		dispatch: function (e) {
			var t,
				n,
				r,
				i,
				o,
				a,
				s = new Array(arguments.length),
				u = w.event.fix(e),
				l = (Y.get(this, "events") || Object.create(null))[u.type] || [],
				c = w.event.special[u.type] || {};
			for (s[0] = u, t = 1; t < arguments.length; t++) s[t] = arguments[t];
			if (((u.delegateTarget = this), !c.preDispatch || !1 !== c.preDispatch.call(this, u))) {
				for (a = w.event.handlers.call(this, u, l), t = 0; (i = a[t++]) && !u.isPropagationStopped(); )
					for (u.currentTarget = i.elem, n = 0; (o = i.handlers[n++]) && !u.isImmediatePropagationStopped(); )
						(u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace)) ||
							((u.handleObj = o),
							(u.data = o.data),
							void 0 !==
								(r = ((w.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) &&
								!1 === (u.result = r) &&
								(u.preventDefault(), u.stopPropagation()));
				return c.postDispatch && c.postDispatch.call(this, u), u.result;
			}
		},
		handlers: function (e, t) {
			var n,
				r,
				i,
				o,
				a,
				s = [],
				u = t.delegateCount,
				l = e.target;
			if (u && l.nodeType && !("click" === e.type && 1 <= e.button))
				for (; l !== this; l = l.parentNode || this)
					if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
						for (o = [], a = {}, n = 0; n < u; n++)
							void 0 === a[(i = (r = t[n]).selector + " ")] &&
								(a[i] = r.needsContext ? -1 < w(i, this).index(l) : w.find(i, this, null, [l]).length),
								a[i] && o.push(r);
						o.length && s.push({ elem: l, handlers: o });
					}
			return (l = this), u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s;
		},
		addProp: function (e, t) {
			Object.defineProperty(w.Event.prototype, e, {
				enumerable: !0,
				configurable: !0,
				get: h(t)
					? function () {
							if (this.originalEvent) return t(this.originalEvent);
					  }
					: function () {
							if (this.originalEvent) return this.originalEvent[e];
					  },
				set: function (t) {
					Object.defineProperty(this, e, { enumerable: !0, configurable: !0, writable: !0, value: t });
				},
			});
		},
		fix: function (e) {
			return e[w.expando] ? e : new w.Event(e);
		},
		special: {
			load: { noBubble: !0 },
			click: {
				setup: function (e) {
					var t = this || e;
					return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we), !1;
				},
				trigger: function (e) {
					var t = this || e;
					return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"), !0;
				},
				_default: function (e) {
					var t = e.target;
					return (pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click")) || A(t, "a");
				},
			},
			beforeunload: {
				postDispatch: function (e) {
					void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);
				},
			},
		},
	}),
		(w.removeEvent = function (e, t, n) {
			e.removeEventListener && e.removeEventListener(t, n);
		}),
		(w.Event = function (e, t) {
			if (!(this instanceof w.Event)) return new w.Event(e, t);
			e && e.type
				? ((this.originalEvent = e),
				  (this.type = e.type),
				  (this.isDefaultPrevented =
						e.defaultPrevented || (void 0 === e.defaultPrevented && !1 === e.returnValue) ? we : Te),
				  (this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target),
				  (this.currentTarget = e.currentTarget),
				  (this.relatedTarget = e.relatedTarget))
				: (this.type = e),
				t && w.extend(this, t),
				(this.timeStamp = (e && e.timeStamp) || Date.now()),
				(this[w.expando] = !0);
		}),
		(w.Event.prototype = {
			constructor: w.Event,
			isDefaultPrevented: Te,
			isPropagationStopped: Te,
			isImmediatePropagationStopped: Te,
			isSimulated: !1,
			preventDefault: function () {
				var e = this.originalEvent;
				(this.isDefaultPrevented = we), e && !this.isSimulated && e.preventDefault();
			},
			stopPropagation: function () {
				var e = this.originalEvent;
				(this.isPropagationStopped = we), e && !this.isSimulated && e.stopPropagation();
			},
			stopImmediatePropagation: function () {
				var e = this.originalEvent;
				(this.isImmediatePropagationStopped = we),
					e && !this.isSimulated && e.stopImmediatePropagation(),
					this.stopPropagation();
			},
		}),
		w.each(
			{
				altKey: !0,
				bubbles: !0,
				cancelable: !0,
				changedTouches: !0,
				ctrlKey: !0,
				detail: !0,
				eventPhase: !0,
				metaKey: !0,
				pageX: !0,
				pageY: !0,
				shiftKey: !0,
				view: !0,
				char: !0,
				code: !0,
				charCode: !0,
				key: !0,
				keyCode: !0,
				button: !0,
				buttons: !0,
				clientX: !0,
				clientY: !0,
				offsetX: !0,
				offsetY: !0,
				pointerId: !0,
				pointerType: !0,
				screenX: !0,
				screenY: !0,
				targetTouches: !0,
				toElement: !0,
				touches: !0,
				which: !0,
			},
			w.event.addProp
		),
		w.each({ focus: "focusin", blur: "focusout" }, function (e, t) {
			w.event.special[e] = {
				setup: function () {
					return Se(this, e, Ce), !1;
				},
				trigger: function () {
					return Se(this, e), !0;
				},
				_default: function () {
					return !0;
				},
				delegateType: t,
			};
		}),
		w.each(
			{
				mouseenter: "mouseover",
				mouseleave: "mouseout",
				pointerenter: "pointerover",
				pointerleave: "pointerout",
			},
			function (e, t) {
				w.event.special[e] = {
					delegateType: t,
					bindType: t,
					handle: function (e) {
						var n,
							r = e.relatedTarget,
							i = e.handleObj;
						return (
							(r && (r === this || w.contains(this, r))) ||
								((e.type = i.origType), (n = i.handler.apply(this, arguments)), (e.type = t)),
							n
						);
					},
				};
			}
		),
		w.fn.extend({
			on: function (e, t, n, r) {
				return Ee(this, e, t, n, r);
			},
			one: function (e, t, n, r) {
				return Ee(this, e, t, n, r, 1);
			},
			off: function (e, t, n) {
				var r, i;
				if (e && e.preventDefault && e.handleObj)
					return (
						(r = e.handleObj),
						w(e.delegateTarget).off(
							r.namespace ? r.origType + "." + r.namespace : r.origType,
							r.selector,
							r.handler
						),
						this
					);
				if ("object" == typeof e) {
					for (i in e) this.off(i, t, e[i]);
					return this;
				}
				return (
					(!1 !== t && "function" != typeof t) || ((n = t), (t = void 0)),
					!1 === n && (n = Te),
					this.each(function () {
						w.event.remove(this, e, n, t);
					})
				);
			},
		});
	var ke = /<script|<style|<link/i,
		Ae = /checked\s*(?:[^=]|=\s*.checked.)/i,
		Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	function je(e, t) {
		return (A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && w(e).children("tbody")[0]) || e;
	}
	function De(e) {
		return (e.type = (null !== e.getAttribute("type")) + "/" + e.type), e;
	}
	function qe(e) {
		return "true/" === (e.type || "").slice(0, 5) ? (e.type = e.type.slice(5)) : e.removeAttribute("type"), e;
	}
	function Le(e, t) {
		var n, r, i, o, a, s;
		if (1 === t.nodeType) {
			if (Y.hasData(e) && (s = Y.get(e).events))
				for (i in (Y.remove(t, "handle events"), s))
					for (n = 0, r = s[i].length; n < r; n++) w.event.add(t, i, s[i][n]);
			Q.hasData(e) && ((o = Q.access(e)), (a = w.extend({}, o)), Q.set(t, a));
		}
	}
	function He(e, t, n, r) {
		t = o(t);
		var i,
			a,
			s,
			u,
			l,
			c,
			f = 0,
			p = e.length,
			g = p - 1,
			v = t[0],
			y = h(v);
		if (y || (1 < p && "string" == typeof v && !d.checkClone && Ae.test(v)))
			return e.each(function (i) {
				var o = e.eq(i);
				y && (t[0] = v.call(this, i, o.html())), He(o, t, n, r);
			});
		if (
			p &&
			((a = (i = xe(t, e[0].ownerDocument, !1, e, r)).firstChild), 1 === i.childNodes.length && (i = a), a || r)
		) {
			for (u = (s = w.map(ve(i, "script"), De)).length; f < p; f++)
				(l = i), f !== g && ((l = w.clone(l, !0, !0)), u && w.merge(s, ve(l, "script"))), n.call(e[f], l, f);
			if (u)
				for (c = s[s.length - 1].ownerDocument, w.map(s, qe), f = 0; f < u; f++)
					(l = s[f]),
						he.test(l.type || "") &&
							!Y.access(l, "globalEval") &&
							w.contains(c, l) &&
							(l.src && "module" !== (l.type || "").toLowerCase()
								? w._evalUrl &&
								  !l.noModule &&
								  w._evalUrl(l.src, { nonce: l.nonce || l.getAttribute("nonce") }, c)
								: m(l.textContent.replace(Ne, ""), l, c));
		}
		return e;
	}
	function Oe(e, t, n) {
		for (var r, i = t ? w.filter(t, e) : e, o = 0; null != (r = i[o]); o++)
			n || 1 !== r.nodeType || w.cleanData(ve(r)),
				r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r));
		return e;
	}
	w.extend({
		htmlPrefilter: function (e) {
			return e;
		},
		clone: function (e, t, n) {
			var r,
				i,
				o,
				a,
				s,
				u,
				l,
				c = e.cloneNode(!0),
				f = ie(e);
			if (!(d.noCloneChecked || (1 !== e.nodeType && 11 !== e.nodeType) || w.isXMLDoc(e)))
				for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++)
					(s = o[r]),
						"input" === (l = (u = a[r]).nodeName.toLowerCase()) && pe.test(s.type)
							? (u.checked = s.checked)
							: ("input" !== l && "textarea" !== l) || (u.defaultValue = s.defaultValue);
			if (t)
				if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++) Le(o[r], a[r]);
				else Le(e, c);
			return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c;
		},
		cleanData: function (e) {
			for (var t, n, r, i = w.event.special, o = 0; void 0 !== (n = e[o]); o++)
				if (V(n)) {
					if ((t = n[Y.expando])) {
						if (t.events) for (r in t.events) i[r] ? w.event.remove(n, r) : w.removeEvent(n, r, t.handle);
						n[Y.expando] = void 0;
					}
					n[Q.expando] && (n[Q.expando] = void 0);
				}
		},
	}),
		w.fn.extend({
			detach: function (e) {
				return Oe(this, e, !0);
			},
			remove: function (e) {
				return Oe(this, e);
			},
			text: function (e) {
				return $(
					this,
					function (e) {
						return void 0 === e
							? w.text(this)
							: this.empty().each(function () {
									(1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType) ||
										(this.textContent = e);
							  });
					},
					null,
					e,
					arguments.length
				);
			},
			append: function () {
				return He(this, arguments, function (e) {
					(1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType) || je(this, e).appendChild(e);
				});
			},
			prepend: function () {
				return He(this, arguments, function (e) {
					if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
						var t = je(this, e);
						t.insertBefore(e, t.firstChild);
					}
				});
			},
			before: function () {
				return He(this, arguments, function (e) {
					this.parentNode && this.parentNode.insertBefore(e, this);
				});
			},
			after: function () {
				return He(this, arguments, function (e) {
					this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
				});
			},
			empty: function () {
				for (var e, t = 0; null != (e = this[t]); t++)
					1 === e.nodeType && (w.cleanData(ve(e, !1)), (e.textContent = ""));
				return this;
			},
			clone: function (e, t) {
				return (
					(e = null != e && e),
					(t = null == t ? e : t),
					this.map(function () {
						return w.clone(this, e, t);
					})
				);
			},
			html: function (e) {
				return $(
					this,
					function (e) {
						var t = this[0] || {},
							n = 0,
							r = this.length;
						if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
						if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) {
							e = w.htmlPrefilter(e);
							try {
								for (; n < r; n++)
									1 === (t = this[n] || {}).nodeType && (w.cleanData(ve(t, !1)), (t.innerHTML = e));
								t = 0;
							} catch (e) {}
						}
						t && this.empty().append(e);
					},
					null,
					e,
					arguments.length
				);
			},
			replaceWith: function () {
				var e = [];
				return He(
					this,
					arguments,
					function (t) {
						var n = this.parentNode;
						w.inArray(this, e) < 0 && (w.cleanData(ve(this)), n && n.replaceChild(t, this));
					},
					e
				);
			},
		}),
		w.each(
			{
				appendTo: "append",
				prependTo: "prepend",
				insertBefore: "before",
				insertAfter: "after",
				replaceAll: "replaceWith",
			},
			function (e, t) {
				w.fn[e] = function (e) {
					for (var n, r = [], i = w(e), o = i.length - 1, s = 0; s <= o; s++)
						(n = s === o ? this : this.clone(!0)), w(i[s])[t](n), a.apply(r, n.get());
					return this.pushStack(r);
				};
			}
		);
	var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"),
		Re = function (t) {
			var n = t.ownerDocument.defaultView;
			return (n && n.opener) || (n = e), n.getComputedStyle(t);
		},
		Me = function (e, t, n) {
			var r,
				i,
				o = {};
			for (i in t) (o[i] = e.style[i]), (e.style[i] = t[i]);
			for (i in ((r = n.call(e)), t)) e.style[i] = o[i];
			return r;
		},
		Ie = new RegExp(ne.join("|"), "i");
	function We(e, t, n) {
		var r,
			i,
			o,
			a,
			s = e.style;
		return (
			(n = n || Re(e)) &&
				("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = w.style(e, t)),
				!d.pixelBoxStyles() &&
					Pe.test(a) &&
					Ie.test(t) &&
					((r = s.width),
					(i = s.minWidth),
					(o = s.maxWidth),
					(s.minWidth = s.maxWidth = s.width = a),
					(a = n.width),
					(s.width = r),
					(s.minWidth = i),
					(s.maxWidth = o))),
			void 0 !== a ? a + "" : a
		);
	}
	function Fe(e, t) {
		return {
			get: function () {
				if (!e()) return (this.get = t).apply(this, arguments);
				delete this.get;
			},
		};
	}
	!(function () {
		function t() {
			if (c) {
				(l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0"),
					(c.style.cssText =
						"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%"),
					re.appendChild(l).appendChild(c);
				var t = e.getComputedStyle(c);
				(r = "1%" !== t.top),
					(u = 12 === n(t.marginLeft)),
					(c.style.right = "60%"),
					(a = 36 === n(t.right)),
					(i = 36 === n(t.width)),
					(c.style.position = "absolute"),
					(o = 12 === n(c.offsetWidth / 3)),
					re.removeChild(l),
					(c = null);
			}
		}
		function n(e) {
			return Math.round(parseFloat(e));
		}
		var r,
			i,
			o,
			a,
			s,
			u,
			l = v.createElement("div"),
			c = v.createElement("div");
		c.style &&
			((c.style.backgroundClip = "content-box"),
			(c.cloneNode(!0).style.backgroundClip = ""),
			(d.clearCloneStyle = "content-box" === c.style.backgroundClip),
			w.extend(d, {
				boxSizingReliable: function () {
					return t(), i;
				},
				pixelBoxStyles: function () {
					return t(), a;
				},
				pixelPosition: function () {
					return t(), r;
				},
				reliableMarginLeft: function () {
					return t(), u;
				},
				scrollboxSize: function () {
					return t(), o;
				},
				reliableTrDimensions: function () {
					var t, n, r, i;
					return (
						null == s &&
							((t = v.createElement("table")),
							(n = v.createElement("tr")),
							(r = v.createElement("div")),
							(t.style.cssText = "position:absolute;left:-11111px;border-collapse:separate"),
							(n.style.cssText = "border:1px solid"),
							(n.style.height = "1px"),
							(r.style.height = "9px"),
							(r.style.display = "block"),
							re.appendChild(t).appendChild(n).appendChild(r),
							(i = e.getComputedStyle(n)),
							(s =
								parseInt(i.height, 10) +
									parseInt(i.borderTopWidth, 10) +
									parseInt(i.borderBottomWidth, 10) ===
								n.offsetHeight),
							re.removeChild(t)),
						s
					);
				},
			}));
	})();
	var Be = ["Webkit", "Moz", "ms"],
		$e = v.createElement("div").style,
		_e = {};
	function ze(e) {
		return (
			w.cssProps[e] ||
			_e[e] ||
			(e in $e
				? e
				: (_e[e] =
						(function (e) {
							for (var t = e[0].toUpperCase() + e.slice(1), n = Be.length; n--; )
								if ((e = Be[n] + t) in $e) return e;
						})(e) || e))
		);
	}
	var Ue = /^(none|table(?!-c[ea]).+)/,
		Xe = /^--/,
		Ve = { position: "absolute", visibility: "hidden", display: "block" },
		Ge = { letterSpacing: "0", fontWeight: "400" };
	function Ye(e, t, n) {
		var r = te.exec(t);
		return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t;
	}
	function Qe(e, t, n, r, i, o) {
		var a = "width" === t ? 1 : 0,
			s = 0,
			u = 0;
		if (n === (r ? "border" : "content")) return 0;
		for (; a < 4; a += 2)
			"margin" === n && (u += w.css(e, n + ne[a], !0, i)),
				r
					? ("content" === n && (u -= w.css(e, "padding" + ne[a], !0, i)),
					  "margin" !== n && (u -= w.css(e, "border" + ne[a] + "Width", !0, i)))
					: ((u += w.css(e, "padding" + ne[a], !0, i)),
					  "padding" !== n
							? (u += w.css(e, "border" + ne[a] + "Width", !0, i))
							: (s += w.css(e, "border" + ne[a] + "Width", !0, i)));
		return (
			!r &&
				0 <= o &&
				(u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - 0.5)) || 0),
			u
		);
	}
	function Je(e, t, n) {
		var r = Re(e),
			i = (!d.boxSizingReliable() || n) && "border-box" === w.css(e, "boxSizing", !1, r),
			o = i,
			a = We(e, t, r),
			s = "offset" + t[0].toUpperCase() + t.slice(1);
		if (Pe.test(a)) {
			if (!n) return a;
			a = "auto";
		}
		return (
			((!d.boxSizingReliable() && i) ||
				(!d.reliableTrDimensions() && A(e, "tr")) ||
				"auto" === a ||
				(!parseFloat(a) && "inline" === w.css(e, "display", !1, r))) &&
				e.getClientRects().length &&
				((i = "border-box" === w.css(e, "boxSizing", !1, r)), (o = s in e) && (a = e[s])),
			(a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px"
		);
	}
	function Ke(e, t, n, r, i) {
		return new Ke.prototype.init(e, t, n, r, i);
	}
	w.extend({
		cssHooks: {
			opacity: {
				get: function (e, t) {
					if (t) {
						var n = We(e, "opacity");
						return "" === n ? "1" : n;
					}
				},
			},
		},
		cssNumber: {
			animationIterationCount: !0,
			columnCount: !0,
			fillOpacity: !0,
			flexGrow: !0,
			flexShrink: !0,
			fontWeight: !0,
			gridArea: !0,
			gridColumn: !0,
			gridColumnEnd: !0,
			gridColumnStart: !0,
			gridRow: !0,
			gridRowEnd: !0,
			gridRowStart: !0,
			lineHeight: !0,
			opacity: !0,
			order: !0,
			orphans: !0,
			widows: !0,
			zIndex: !0,
			zoom: !0,
		},
		cssProps: {},
		style: function (e, t, n, r) {
			if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
				var i,
					o,
					a,
					s = X(t),
					u = Xe.test(t),
					l = e.style;
				if ((u || (t = ze(s)), (a = w.cssHooks[t] || w.cssHooks[s]), void 0 === n))
					return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
				"string" == (o = typeof n) && (i = te.exec(n)) && i[1] && ((n = se(e, t, i)), (o = "number")),
					null != n &&
						n == n &&
						("number" !== o || u || (n += (i && i[3]) || (w.cssNumber[s] ? "" : "px")),
						d.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"),
						(a && "set" in a && void 0 === (n = a.set(e, n, r))) || (u ? l.setProperty(t, n) : (l[t] = n)));
			}
		},
		css: function (e, t, n, r) {
			var i,
				o,
				a,
				s = X(t);
			return (
				Xe.test(t) || (t = ze(s)),
				(a = w.cssHooks[t] || w.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)),
				void 0 === i && (i = We(e, t, r)),
				"normal" === i && t in Ge && (i = Ge[t]),
				"" === n || n ? ((o = parseFloat(i)), !0 === n || isFinite(o) ? o || 0 : i) : i
			);
		},
	}),
		w.each(["height", "width"], function (e, t) {
			w.cssHooks[t] = {
				get: function (e, n, r) {
					if (n)
						return !Ue.test(w.css(e, "display")) ||
							(e.getClientRects().length && e.getBoundingClientRect().width)
							? Je(e, t, r)
							: Me(e, Ve, function () {
									return Je(e, t, r);
							  });
				},
				set: function (e, n, r) {
					var i,
						o = Re(e),
						a = !d.scrollboxSize() && "absolute" === o.position,
						s = (a || r) && "border-box" === w.css(e, "boxSizing", !1, o),
						u = r ? Qe(e, t, r, s, o) : 0;
					return (
						s &&
							a &&
							(u -= Math.ceil(
								e["offset" + t[0].toUpperCase() + t.slice(1)] -
									parseFloat(o[t]) -
									Qe(e, t, "border", !1, o) -
									0.5
							)),
						u && (i = te.exec(n)) && "px" !== (i[3] || "px") && ((e.style[t] = n), (n = w.css(e, t))),
						Ye(0, n, u)
					);
				},
			};
		}),
		(w.cssHooks.marginLeft = Fe(d.reliableMarginLeft, function (e, t) {
			if (t)
				return (
					(parseFloat(We(e, "marginLeft")) ||
						e.getBoundingClientRect().left -
							Me(e, { marginLeft: 0 }, function () {
								return e.getBoundingClientRect().left;
							})) + "px"
				);
		})),
		w.each({ margin: "", padding: "", border: "Width" }, function (e, t) {
			(w.cssHooks[e + t] = {
				expand: function (n) {
					for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++)
						i[e + ne[r] + t] = o[r] || o[r - 2] || o[0];
					return i;
				},
			}),
				"margin" !== e && (w.cssHooks[e + t].set = Ye);
		}),
		w.fn.extend({
			css: function (e, t) {
				return $(
					this,
					function (e, t, n) {
						var r,
							i,
							o = {},
							a = 0;
						if (Array.isArray(t)) {
							for (r = Re(e), i = t.length; a < i; a++) o[t[a]] = w.css(e, t[a], !1, r);
							return o;
						}
						return void 0 !== n ? w.style(e, t, n) : w.css(e, t);
					},
					e,
					t,
					1 < arguments.length
				);
			},
		}),
		(((w.Tween = Ke).prototype = {
			constructor: Ke,
			init: function (e, t, n, r, i, o) {
				(this.elem = e),
					(this.prop = n),
					(this.easing = i || w.easing._default),
					(this.options = t),
					(this.start = this.now = this.cur()),
					(this.end = r),
					(this.unit = o || (w.cssNumber[n] ? "" : "px"));
			},
			cur: function () {
				var e = Ke.propHooks[this.prop];
				return e && e.get ? e.get(this) : Ke.propHooks._default.get(this);
			},
			run: function (e) {
				var t,
					n = Ke.propHooks[this.prop];
				return (
					this.options.duration
						? (this.pos = t =
								w.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration))
						: (this.pos = t = e),
					(this.now = (this.end - this.start) * t + this.start),
					this.options.step && this.options.step.call(this.elem, this.now, this),
					n && n.set ? n.set(this) : Ke.propHooks._default.set(this),
					this
				);
			},
		}).init.prototype = Ke.prototype),
		((Ke.propHooks = {
			_default: {
				get: function (e) {
					var t;
					return 1 !== e.elem.nodeType || (null != e.elem[e.prop] && null == e.elem.style[e.prop])
						? e.elem[e.prop]
						: (t = w.css(e.elem, e.prop, "")) && "auto" !== t
						? t
						: 0;
				},
				set: function (e) {
					w.fx.step[e.prop]
						? w.fx.step[e.prop](e)
						: 1 !== e.elem.nodeType || (!w.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)])
						? (e.elem[e.prop] = e.now)
						: w.style(e.elem, e.prop, e.now + e.unit);
				},
			},
		}).scrollTop = Ke.propHooks.scrollLeft =
			{
				set: function (e) {
					e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
				},
			}),
		(w.easing = {
			linear: function (e) {
				return e;
			},
			swing: function (e) {
				return 0.5 - Math.cos(e * Math.PI) / 2;
			},
			_default: "swing",
		}),
		(w.fx = Ke.prototype.init),
		(w.fx.step = {});
	var Ze,
		et,
		tt,
		nt,
		rt = /^(?:toggle|show|hide)$/,
		it = /queueHooks$/;
	function ot() {
		et &&
			(!1 === v.hidden && e.requestAnimationFrame ? e.requestAnimationFrame(ot) : e.setTimeout(ot, w.fx.interval),
			w.fx.tick());
	}
	function at() {
		return (
			e.setTimeout(function () {
				Ze = void 0;
			}),
			(Ze = Date.now())
		);
	}
	function st(e, t) {
		var n,
			r = 0,
			i = { height: e };
		for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = ne[r])] = i["padding" + n] = e;
		return t && (i.opacity = i.width = e), i;
	}
	function ut(e, t, n) {
		for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++)
			if ((r = i[o].call(n, t, e))) return r;
	}
	function lt(e, t, n) {
		var r,
			i,
			o = 0,
			a = lt.prefilters.length,
			s = w.Deferred().always(function () {
				delete u.elem;
			}),
			u = function () {
				if (i) return !1;
				for (
					var t = Ze || at(),
						n = Math.max(0, l.startTime + l.duration - t),
						r = 1 - (n / l.duration || 0),
						o = 0,
						a = l.tweens.length;
					o < a;
					o++
				)
					l.tweens[o].run(r);
				return (
					s.notifyWith(e, [l, r, n]),
					r < 1 && a ? n : (a || s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l]), !1)
				);
			},
			l = s.promise({
				elem: e,
				props: w.extend({}, t),
				opts: w.extend(!0, { specialEasing: {}, easing: w.easing._default }, n),
				originalProperties: t,
				originalOptions: n,
				startTime: Ze || at(),
				duration: n.duration,
				tweens: [],
				createTween: function (t, n) {
					var r = w.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing);
					return l.tweens.push(r), r;
				},
				stop: function (t) {
					var n = 0,
						r = t ? l.tweens.length : 0;
					if (i) return this;
					for (i = !0; n < r; n++) l.tweens[n].run(1);
					return t ? (s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l, t])) : s.rejectWith(e, [l, t]), this;
				},
			}),
			c = l.props;
		for (
			(function (e, t) {
				var n, r, i, o, a;
				for (n in e)
					if (
						((i = t[(r = X(n))]),
						(o = e[n]),
						Array.isArray(o) && ((i = o[1]), (o = e[n] = o[0])),
						n !== r && ((e[r] = o), delete e[n]),
						(a = w.cssHooks[r]) && ("expand" in a))
					)
						for (n in ((o = a.expand(o)), delete e[r], o)) (n in e) || ((e[n] = o[n]), (t[n] = i));
					else t[r] = i;
			})(c, l.opts.specialEasing);
			o < a;
			o++
		)
			if ((r = lt.prefilters[o].call(l, e, c, l.opts)))
				return h(r.stop) && (w._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)), r;
		return (
			w.map(c, ut, l),
			h(l.opts.start) && l.opts.start.call(e, l),
			l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always),
			w.fx.timer(w.extend(u, { elem: e, anim: l, queue: l.opts.queue })),
			l
		);
	}
	(w.Animation = w.extend(lt, {
		tweeners: {
			"*": [
				function (e, t) {
					var n = this.createTween(e, t);
					return se(n.elem, e, te.exec(t), n), n;
				},
			],
		},
		tweener: function (e, t) {
			h(e) ? ((t = e), (e = ["*"])) : (e = e.match(P));
			for (var n, r = 0, i = e.length; r < i; r++)
				(n = e[r]), (lt.tweeners[n] = lt.tweeners[n] || []), lt.tweeners[n].unshift(t);
		},
		prefilters: [
			function (e, t, n) {
				var r,
					i,
					o,
					a,
					s,
					u,
					l,
					c,
					f = "width" in t || "height" in t,
					p = this,
					d = {},
					h = e.style,
					g = e.nodeType && ae(e),
					v = Y.get(e, "fxshow");
				for (r in (n.queue ||
					(null == (a = w._queueHooks(e, "fx")).unqueued &&
						((a.unqueued = 0),
						(s = a.empty.fire),
						(a.empty.fire = function () {
							a.unqueued || s();
						})),
					a.unqueued++,
					p.always(function () {
						p.always(function () {
							a.unqueued--, w.queue(e, "fx").length || a.empty.fire();
						});
					})),
				t))
					if (((i = t[r]), rt.test(i))) {
						if ((delete t[r], (o = o || "toggle" === i), i === (g ? "hide" : "show"))) {
							if ("show" !== i || !v || void 0 === v[r]) continue;
							g = !0;
						}
						d[r] = (v && v[r]) || w.style(e, r);
					}
				if ((u = !w.isEmptyObject(t)) || !w.isEmptyObject(d))
					for (r in (f &&
						1 === e.nodeType &&
						((n.overflow = [h.overflow, h.overflowX, h.overflowY]),
						null == (l = v && v.display) && (l = Y.get(e, "display")),
						"none" === (c = w.css(e, "display")) &&
							(l
								? (c = l)
								: (le([e], !0), (l = e.style.display || l), (c = w.css(e, "display")), le([e]))),
						("inline" === c || ("inline-block" === c && null != l)) &&
							"none" === w.css(e, "float") &&
							(u ||
								(p.done(function () {
									h.display = l;
								}),
								null == l && ((c = h.display), (l = "none" === c ? "" : c))),
							(h.display = "inline-block"))),
					n.overflow &&
						((h.overflow = "hidden"),
						p.always(function () {
							(h.overflow = n.overflow[0]), (h.overflowX = n.overflow[1]), (h.overflowY = n.overflow[2]);
						})),
					(u = !1),
					d))
						u ||
							(v ? "hidden" in v && (g = v.hidden) : (v = Y.access(e, "fxshow", { display: l })),
							o && (v.hidden = !g),
							g && le([e], !0),
							p.done(function () {
								for (r in (g || le([e]), Y.remove(e, "fxshow"), d)) w.style(e, r, d[r]);
							})),
							(u = ut(g ? v[r] : 0, r, p)),
							r in v || ((v[r] = u.start), g && ((u.end = u.start), (u.start = 0)));
			},
		],
		prefilter: function (e, t) {
			t ? lt.prefilters.unshift(e) : lt.prefilters.push(e);
		},
	})),
		(w.speed = function (e, t, n) {
			var r =
				e && "object" == typeof e
					? w.extend({}, e)
					: { complete: n || (!n && t) || (h(e) && e), duration: e, easing: (n && t) || (t && !h(t) && t) };
			return (
				w.fx.off
					? (r.duration = 0)
					: "number" != typeof r.duration &&
					  (r.duration in w.fx.speeds
							? (r.duration = w.fx.speeds[r.duration])
							: (r.duration = w.fx.speeds._default)),
				(null != r.queue && !0 !== r.queue) || (r.queue = "fx"),
				(r.old = r.complete),
				(r.complete = function () {
					h(r.old) && r.old.call(this), r.queue && w.dequeue(this, r.queue);
				}),
				r
			);
		}),
		w.fn.extend({
			fadeTo: function (e, t, n, r) {
				return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r);
			},
			animate: function (e, t, n, r) {
				var i = w.isEmptyObject(e),
					o = w.speed(t, n, r),
					a = function () {
						var t = lt(this, w.extend({}, e), o);
						(i || Y.get(this, "finish")) && t.stop(!0);
					};
				return (a.finish = a), i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a);
			},
			stop: function (e, t, n) {
				var r = function (e) {
					var t = e.stop;
					delete e.stop, t(n);
				};
				return (
					"string" != typeof e && ((n = t), (t = e), (e = void 0)),
					t && this.queue(e || "fx", []),
					this.each(function () {
						var t = !0,
							i = null != e && e + "queueHooks",
							o = w.timers,
							a = Y.get(this);
						if (i) a[i] && a[i].stop && r(a[i]);
						else for (i in a) a[i] && a[i].stop && it.test(i) && r(a[i]);
						for (i = o.length; i--; )
							o[i].elem !== this ||
								(null != e && o[i].queue !== e) ||
								(o[i].anim.stop(n), (t = !1), o.splice(i, 1));
						(!t && n) || w.dequeue(this, e);
					})
				);
			},
			finish: function (e) {
				return (
					!1 !== e && (e = e || "fx"),
					this.each(function () {
						var t,
							n = Y.get(this),
							r = n[e + "queue"],
							i = n[e + "queueHooks"],
							o = w.timers,
							a = r ? r.length : 0;
						for (
							n.finish = !0, w.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length;
							t--;

						)
							o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
						for (t = 0; t < a; t++) r[t] && r[t].finish && r[t].finish.call(this);
						delete n.finish;
					})
				);
			},
		}),
		w.each(["toggle", "show", "hide"], function (e, t) {
			var n = w.fn[t];
			w.fn[t] = function (e, r, i) {
				return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(st(t, !0), e, r, i);
			};
		}),
		w.each(
			{
				slideDown: st("show"),
				slideUp: st("hide"),
				slideToggle: st("toggle"),
				fadeIn: { opacity: "show" },
				fadeOut: { opacity: "hide" },
				fadeToggle: { opacity: "toggle" },
			},
			function (e, t) {
				w.fn[e] = function (e, n, r) {
					return this.animate(t, e, n, r);
				};
			}
		),
		(w.timers = []),
		(w.fx.tick = function () {
			var e,
				t = 0,
				n = w.timers;
			for (Ze = Date.now(); t < n.length; t++) (e = n[t])() || n[t] !== e || n.splice(t--, 1);
			n.length || w.fx.stop(), (Ze = void 0);
		}),
		(w.fx.timer = function (e) {
			w.timers.push(e), w.fx.start();
		}),
		(w.fx.interval = 13),
		(w.fx.start = function () {
			et || ((et = !0), ot());
		}),
		(w.fx.stop = function () {
			et = null;
		}),
		(w.fx.speeds = { slow: 600, fast: 200, _default: 400 }),
		(w.fn.delay = function (t, n) {
			return (
				(t = (w.fx && w.fx.speeds[t]) || t),
				(n = n || "fx"),
				this.queue(n, function (n, r) {
					var i = e.setTimeout(n, t);
					r.stop = function () {
						e.clearTimeout(i);
					};
				})
			);
		}),
		(tt = v.createElement("input")),
		(nt = v.createElement("select").appendChild(v.createElement("option"))),
		(tt.type = "checkbox"),
		(d.checkOn = "" !== tt.value),
		(d.optSelected = nt.selected),
		((tt = v.createElement("input")).value = "t"),
		(tt.type = "radio"),
		(d.radioValue = "t" === tt.value);
	var ct,
		ft = w.expr.attrHandle;
	w.fn.extend({
		attr: function (e, t) {
			return $(this, w.attr, e, t, 1 < arguments.length);
		},
		removeAttr: function (e) {
			return this.each(function () {
				w.removeAttr(this, e);
			});
		},
	}),
		w.extend({
			attr: function (e, t, n) {
				var r,
					i,
					o = e.nodeType;
				if (3 !== o && 8 !== o && 2 !== o)
					return void 0 === e.getAttribute
						? w.prop(e, t, n)
						: ((1 === o && w.isXMLDoc(e)) ||
								(i = w.attrHooks[t.toLowerCase()] || (w.expr.match.bool.test(t) ? ct : void 0)),
						  void 0 !== n
								? null === n
									? void w.removeAttr(e, t)
									: i && "set" in i && void 0 !== (r = i.set(e, n, t))
									? r
									: (e.setAttribute(t, n + ""), n)
								: i && "get" in i && null !== (r = i.get(e, t))
								? r
								: null == (r = w.find.attr(e, t))
								? void 0
								: r);
			},
			attrHooks: {
				type: {
					set: function (e, t) {
						if (!d.radioValue && "radio" === t && A(e, "input")) {
							var n = e.value;
							return e.setAttribute("type", t), n && (e.value = n), t;
						}
					},
				},
			},
			removeAttr: function (e, t) {
				var n,
					r = 0,
					i = t && t.match(P);
				if (i && 1 === e.nodeType) for (; (n = i[r++]); ) e.removeAttribute(n);
			},
		}),
		(ct = {
			set: function (e, t, n) {
				return !1 === t ? w.removeAttr(e, n) : e.setAttribute(n, n), n;
			},
		}),
		w.each(w.expr.match.bool.source.match(/\w+/g), function (e, t) {
			var n = ft[t] || w.find.attr;
			ft[t] = function (e, t, r) {
				var i,
					o,
					a = t.toLowerCase();
				return r || ((o = ft[a]), (ft[a] = i), (i = null != n(e, t, r) ? a : null), (ft[a] = o)), i;
			};
		});
	var pt = /^(?:input|select|textarea|button)$/i,
		dt = /^(?:a|area)$/i;
	function ht(e) {
		return (e.match(P) || []).join(" ");
	}
	function gt(e) {
		return (e.getAttribute && e.getAttribute("class")) || "";
	}
	function vt(e) {
		return Array.isArray(e) ? e : ("string" == typeof e && e.match(P)) || [];
	}
	w.fn.extend({
		prop: function (e, t) {
			return $(this, w.prop, e, t, 1 < arguments.length);
		},
		removeProp: function (e) {
			return this.each(function () {
				delete this[w.propFix[e] || e];
			});
		},
	}),
		w.extend({
			prop: function (e, t, n) {
				var r,
					i,
					o = e.nodeType;
				if (3 !== o && 8 !== o && 2 !== o)
					return (
						(1 === o && w.isXMLDoc(e)) || ((t = w.propFix[t] || t), (i = w.propHooks[t])),
						void 0 !== n
							? i && "set" in i && void 0 !== (r = i.set(e, n, t))
								? r
								: (e[t] = n)
							: i && "get" in i && null !== (r = i.get(e, t))
							? r
							: e[t]
					);
			},
			propHooks: {
				tabIndex: {
					get: function (e) {
						var t = w.find.attr(e, "tabindex");
						return t ? parseInt(t, 10) : pt.test(e.nodeName) || (dt.test(e.nodeName) && e.href) ? 0 : -1;
					},
				},
			},
			propFix: { for: "htmlFor", class: "className" },
		}),
		d.optSelected ||
			(w.propHooks.selected = {
				get: function (e) {
					var t = e.parentNode;
					return t && t.parentNode && t.parentNode.selectedIndex, null;
				},
				set: function (e) {
					var t = e.parentNode;
					t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
				},
			}),
		w.each(
			[
				"tabIndex",
				"readOnly",
				"maxLength",
				"cellSpacing",
				"cellPadding",
				"rowSpan",
				"colSpan",
				"useMap",
				"frameBorder",
				"contentEditable",
			],
			function () {
				w.propFix[this.toLowerCase()] = this;
			}
		),
		w.fn.extend({
			addClass: function (e) {
				var t,
					n,
					r,
					i,
					o,
					a,
					s,
					u = 0;
				if (h(e))
					return this.each(function (t) {
						w(this).addClass(e.call(this, t, gt(this)));
					});
				if ((t = vt(e)).length)
					for (; (n = this[u++]); )
						if (((i = gt(n)), (r = 1 === n.nodeType && " " + ht(i) + " "))) {
							for (a = 0; (o = t[a++]); ) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
							i !== (s = ht(r)) && n.setAttribute("class", s);
						}
				return this;
			},
			removeClass: function (e) {
				var t,
					n,
					r,
					i,
					o,
					a,
					s,
					u = 0;
				if (h(e))
					return this.each(function (t) {
						w(this).removeClass(e.call(this, t, gt(this)));
					});
				if (!arguments.length) return this.attr("class", "");
				if ((t = vt(e)).length)
					for (; (n = this[u++]); )
						if (((i = gt(n)), (r = 1 === n.nodeType && " " + ht(i) + " "))) {
							for (a = 0; (o = t[a++]); )
								for (; -1 < r.indexOf(" " + o + " "); ) r = r.replace(" " + o + " ", " ");
							i !== (s = ht(r)) && n.setAttribute("class", s);
						}
				return this;
			},
			toggleClass: function (e, t) {
				var n = typeof e,
					r = "string" === n || Array.isArray(e);
				return "boolean" == typeof t && r
					? t
						? this.addClass(e)
						: this.removeClass(e)
					: h(e)
					? this.each(function (n) {
							w(this).toggleClass(e.call(this, n, gt(this), t), t);
					  })
					: this.each(function () {
							var t, i, o, a;
							if (r)
								for (i = 0, o = w(this), a = vt(e); (t = a[i++]); )
									o.hasClass(t) ? o.removeClass(t) : o.addClass(t);
							else
								(void 0 !== e && "boolean" !== n) ||
									((t = gt(this)) && Y.set(this, "__className__", t),
									this.setAttribute &&
										this.setAttribute(
											"class",
											t || !1 === e ? "" : Y.get(this, "__className__") || ""
										));
					  });
			},
			hasClass: function (e) {
				var t,
					n,
					r = 0;
				for (t = " " + e + " "; (n = this[r++]); )
					if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t)) return !0;
				return !1;
			},
		});
	var yt = /\r/g;
	w.fn.extend({
		val: function (e) {
			var t,
				n,
				r,
				i = this[0];
			return arguments.length
				? ((r = h(e)),
				  this.each(function (n) {
						var i;
						1 === this.nodeType &&
							(null == (i = r ? e.call(this, n, w(this).val()) : e)
								? (i = "")
								: "number" == typeof i
								? (i += "")
								: Array.isArray(i) &&
								  (i = w.map(i, function (e) {
										return null == e ? "" : e + "";
								  })),
							((t = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()]) &&
								"set" in t &&
								void 0 !== t.set(this, i, "value")) ||
								(this.value = i));
				  }))
				: i
				? (t = w.valHooks[i.type] || w.valHooks[i.nodeName.toLowerCase()]) &&
				  "get" in t &&
				  void 0 !== (n = t.get(i, "value"))
					? n
					: "string" == typeof (n = i.value)
					? n.replace(yt, "")
					: null == n
					? ""
					: n
				: void 0;
		},
	}),
		w.extend({
			valHooks: {
				option: {
					get: function (e) {
						var t = w.find.attr(e, "value");
						return null != t ? t : ht(w.text(e));
					},
				},
				select: {
					get: function (e) {
						var t,
							n,
							r,
							i = e.options,
							o = e.selectedIndex,
							a = "select-one" === e.type,
							s = a ? null : [],
							u = a ? o + 1 : i.length;
						for (r = o < 0 ? u : a ? o : 0; r < u; r++)
							if (
								((n = i[r]).selected || r === o) &&
								!n.disabled &&
								(!n.parentNode.disabled || !A(n.parentNode, "optgroup"))
							) {
								if (((t = w(n).val()), a)) return t;
								s.push(t);
							}
						return s;
					},
					set: function (e, t) {
						for (var n, r, i = e.options, o = w.makeArray(t), a = i.length; a--; )
							((r = i[a]).selected = -1 < w.inArray(w.valHooks.option.get(r), o)) && (n = !0);
						return n || (e.selectedIndex = -1), o;
					},
				},
			},
		}),
		w.each(["radio", "checkbox"], function () {
			(w.valHooks[this] = {
				set: function (e, t) {
					if (Array.isArray(t)) return (e.checked = -1 < w.inArray(w(e).val(), t));
				},
			}),
				d.checkOn ||
					(w.valHooks[this].get = function (e) {
						return null === e.getAttribute("value") ? "on" : e.value;
					});
		}),
		(d.focusin = "onfocusin" in e);
	var mt = /^(?:focusinfocus|focusoutblur)$/,
		xt = function (e) {
			e.stopPropagation();
		};
	w.extend(w.event, {
		trigger: function (t, n, r, i) {
			var o,
				a,
				s,
				u,
				l,
				f,
				p,
				d,
				y = [r || v],
				m = c.call(t, "type") ? t.type : t,
				x = c.call(t, "namespace") ? t.namespace.split(".") : [];
			if (
				((a = d = s = r = r || v),
				3 !== r.nodeType &&
					8 !== r.nodeType &&
					!mt.test(m + w.event.triggered) &&
					(-1 < m.indexOf(".") && ((m = (x = m.split(".")).shift()), x.sort()),
					(l = m.indexOf(":") < 0 && "on" + m),
					((t = t[w.expando] ? t : new w.Event(m, "object" == typeof t && t)).isTrigger = i ? 2 : 3),
					(t.namespace = x.join(".")),
					(t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + x.join("\\.(?:.*\\.|)") + "(\\.|$)") : null),
					(t.result = void 0),
					t.target || (t.target = r),
					(n = null == n ? [t] : w.makeArray(n, [t])),
					(p = w.event.special[m] || {}),
					i || !p.trigger || !1 !== p.trigger.apply(r, n)))
			) {
				if (!i && !p.noBubble && !g(r)) {
					for (u = p.delegateType || m, mt.test(u + m) || (a = a.parentNode); a; a = a.parentNode)
						y.push(a), (s = a);
					s === (r.ownerDocument || v) && y.push(s.defaultView || s.parentWindow || e);
				}
				for (o = 0; (a = y[o++]) && !t.isPropagationStopped(); )
					(d = a),
						(t.type = 1 < o ? u : p.bindType || m),
						(f = (Y.get(a, "events") || Object.create(null))[t.type] && Y.get(a, "handle")) &&
							f.apply(a, n),
						(f = l && a[l]) &&
							f.apply &&
							V(a) &&
							((t.result = f.apply(a, n)), !1 === t.result && t.preventDefault());
				return (
					(t.type = m),
					i ||
						t.isDefaultPrevented() ||
						(p._default && !1 !== p._default.apply(y.pop(), n)) ||
						!V(r) ||
						(l &&
							h(r[m]) &&
							!g(r) &&
							((s = r[l]) && (r[l] = null),
							(w.event.triggered = m),
							t.isPropagationStopped() && d.addEventListener(m, xt),
							r[m](),
							t.isPropagationStopped() && d.removeEventListener(m, xt),
							(w.event.triggered = void 0),
							s && (r[l] = s))),
					t.result
				);
			}
		},
		simulate: function (e, t, n) {
			var r = w.extend(new w.Event(), n, { type: e, isSimulated: !0 });
			w.event.trigger(r, null, t);
		},
	}),
		w.fn.extend({
			trigger: function (e, t) {
				return this.each(function () {
					w.event.trigger(e, t, this);
				});
			},
			triggerHandler: function (e, t) {
				var n = this[0];
				if (n) return w.event.trigger(e, t, n, !0);
			},
		}),
		d.focusin ||
			w.each({ focus: "focusin", blur: "focusout" }, function (e, t) {
				var n = function (e) {
					w.event.simulate(t, e.target, w.event.fix(e));
				};
				w.event.special[t] = {
					setup: function () {
						var r = this.ownerDocument || this.document || this,
							i = Y.access(r, t);
						i || r.addEventListener(e, n, !0), Y.access(r, t, (i || 0) + 1);
					},
					teardown: function () {
						var r = this.ownerDocument || this.document || this,
							i = Y.access(r, t) - 1;
						i ? Y.access(r, t, i) : (r.removeEventListener(e, n, !0), Y.remove(r, t));
					},
				};
			});
	var bt = e.location,
		wt = { guid: Date.now() },
		Tt = /\?/;
	w.parseXML = function (t) {
		var n, r;
		if (!t || "string" != typeof t) return null;
		try {
			n = new e.DOMParser().parseFromString(t, "text/xml");
		} catch (t) {}
		return (
			(r = n && n.getElementsByTagName("parsererror")[0]),
			(n && !r) ||
				w.error(
					"Invalid XML: " +
						(r
							? w
									.map(r.childNodes, function (e) {
										return e.textContent;
									})
									.join("\n")
							: t)
				),
			n
		);
	};
	var Ct = /\[\]$/,
		Et = /\r?\n/g,
		St = /^(?:submit|button|image|reset|file)$/i,
		kt = /^(?:input|select|textarea|keygen)/i;
	function At(e, t, n, r) {
		var i;
		if (Array.isArray(t))
			w.each(t, function (t, i) {
				n || Ct.test(e) ? r(e, i) : At(e + "[" + ("object" == typeof i && null != i ? t : "") + "]", i, n, r);
			});
		else if (n || "object" !== x(t)) r(e, t);
		else for (i in t) At(e + "[" + i + "]", t[i], n, r);
	}
	(w.param = function (e, t) {
		var n,
			r = [],
			i = function (e, t) {
				var n = h(t) ? t() : t;
				r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
			};
		if (null == e) return "";
		if (Array.isArray(e) || (e.jquery && !w.isPlainObject(e)))
			w.each(e, function () {
				i(this.name, this.value);
			});
		else for (n in e) At(n, e[n], t, i);
		return r.join("&");
	}),
		w.fn.extend({
			serialize: function () {
				return w.param(this.serializeArray());
			},
			serializeArray: function () {
				return this.map(function () {
					var e = w.prop(this, "elements");
					return e ? w.makeArray(e) : this;
				})
					.filter(function () {
						var e = this.type;
						return (
							this.name &&
							!w(this).is(":disabled") &&
							kt.test(this.nodeName) &&
							!St.test(e) &&
							(this.checked || !pe.test(e))
						);
					})
					.map(function (e, t) {
						var n = w(this).val();
						return null == n
							? null
							: Array.isArray(n)
							? w.map(n, function (e) {
									return { name: t.name, value: e.replace(Et, "\r\n") };
							  })
							: { name: t.name, value: n.replace(Et, "\r\n") };
					})
					.get();
			},
		});
	var Nt = /%20/g,
		jt = /#.*$/,
		Dt = /([?&])_=[^&]*/,
		qt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
		Lt = /^(?:GET|HEAD)$/,
		Ht = /^\/\//,
		Ot = {},
		Pt = {},
		Rt = "*/".concat("*"),
		Mt = v.createElement("a");
	function It(e) {
		return function (t, n) {
			"string" != typeof t && ((n = t), (t = "*"));
			var r,
				i = 0,
				o = t.toLowerCase().match(P) || [];
			if (h(n))
				for (; (r = o[i++]); )
					"+" === r[0]
						? ((r = r.slice(1) || "*"), (e[r] = e[r] || []).unshift(n))
						: (e[r] = e[r] || []).push(n);
		};
	}
	function Wt(e, t, n, r) {
		var i = {},
			o = e === Pt;
		function a(s) {
			var u;
			return (
				(i[s] = !0),
				w.each(e[s] || [], function (e, s) {
					var l = s(t, n, r);
					return "string" != typeof l || o || i[l]
						? o
							? !(u = l)
							: void 0
						: (t.dataTypes.unshift(l), a(l), !1);
				}),
				u
			);
		}
		return a(t.dataTypes[0]) || (!i["*"] && a("*"));
	}
	function Ft(e, t) {
		var n,
			r,
			i = w.ajaxSettings.flatOptions || {};
		for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
		return r && w.extend(!0, e, r), e;
	}
	(Mt.href = bt.href),
		w.extend({
			active: 0,
			lastModified: {},
			etag: {},
			ajaxSettings: {
				url: bt.href,
				type: "GET",
				isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),
				global: !0,
				processData: !0,
				async: !0,
				contentType: "application/x-www-form-urlencoded; charset=UTF-8",
				accepts: {
					"*": Rt,
					text: "text/plain",
					html: "text/html",
					xml: "application/xml, text/xml",
					json: "application/json, text/javascript",
				},
				contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ },
				responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" },
				converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": w.parseXML },
				flatOptions: { url: !0, context: !0 },
			},
			ajaxSetup: function (e, t) {
				return t ? Ft(Ft(e, w.ajaxSettings), t) : Ft(w.ajaxSettings, e);
			},
			ajaxPrefilter: It(Ot),
			ajaxTransport: It(Pt),
			ajax: function (t, n) {
				"object" == typeof t && ((n = t), (t = void 0)), (n = n || {});
				var r,
					i,
					o,
					a,
					s,
					u,
					l,
					c,
					f,
					p,
					d = w.ajaxSetup({}, n),
					h = d.context || d,
					g = d.context && (h.nodeType || h.jquery) ? w(h) : w.event,
					y = w.Deferred(),
					m = w.Callbacks("once memory"),
					x = d.statusCode || {},
					b = {},
					T = {},
					C = "canceled",
					E = {
						readyState: 0,
						getResponseHeader: function (e) {
							var t;
							if (l) {
								if (!a)
									for (a = {}; (t = qt.exec(o)); )
										a[t[1].toLowerCase() + " "] = (a[t[1].toLowerCase() + " "] || []).concat(t[2]);
								t = a[e.toLowerCase() + " "];
							}
							return null == t ? null : t.join(", ");
						},
						getAllResponseHeaders: function () {
							return l ? o : null;
						},
						setRequestHeader: function (e, t) {
							return null == l && ((e = T[e.toLowerCase()] = T[e.toLowerCase()] || e), (b[e] = t)), this;
						},
						overrideMimeType: function (e) {
							return null == l && (d.mimeType = e), this;
						},
						statusCode: function (e) {
							var t;
							if (e)
								if (l) E.always(e[E.status]);
								else for (t in e) x[t] = [x[t], e[t]];
							return this;
						},
						abort: function (e) {
							var t = e || C;
							return r && r.abort(t), S(0, t), this;
						},
					};
				if (
					(y.promise(E),
					(d.url = ((t || d.url || bt.href) + "").replace(Ht, bt.protocol + "//")),
					(d.type = n.method || n.type || d.method || d.type),
					(d.dataTypes = (d.dataType || "*").toLowerCase().match(P) || [""]),
					null == d.crossDomain)
				) {
					u = v.createElement("a");
					try {
						(u.href = d.url),
							(u.href = u.href),
							(d.crossDomain = Mt.protocol + "//" + Mt.host != u.protocol + "//" + u.host);
					} catch (t) {
						d.crossDomain = !0;
					}
				}
				if (
					(d.data && d.processData && "string" != typeof d.data && (d.data = w.param(d.data, d.traditional)),
					Wt(Ot, d, n, E),
					l)
				)
					return E;
				for (f in ((c = w.event && d.global) && 0 == w.active++ && w.event.trigger("ajaxStart"),
				(d.type = d.type.toUpperCase()),
				(d.hasContent = !Lt.test(d.type)),
				(i = d.url.replace(jt, "")),
				d.hasContent
					? d.data &&
					  d.processData &&
					  0 === (d.contentType || "").indexOf("application/x-www-form-urlencoded") &&
					  (d.data = d.data.replace(Nt, "+"))
					: ((p = d.url.slice(i.length)),
					  d.data &&
							(d.processData || "string" == typeof d.data) &&
							((i += (Tt.test(i) ? "&" : "?") + d.data), delete d.data),
					  !1 === d.cache &&
							((i = i.replace(Dt, "$1")), (p = (Tt.test(i) ? "&" : "?") + "_=" + wt.guid++ + p)),
					  (d.url = i + p)),
				d.ifModified &&
					(w.lastModified[i] && E.setRequestHeader("If-Modified-Since", w.lastModified[i]),
					w.etag[i] && E.setRequestHeader("If-None-Match", w.etag[i])),
				((d.data && d.hasContent && !1 !== d.contentType) || n.contentType) &&
					E.setRequestHeader("Content-Type", d.contentType),
				E.setRequestHeader(
					"Accept",
					d.dataTypes[0] && d.accepts[d.dataTypes[0]]
						? d.accepts[d.dataTypes[0]] + ("*" !== d.dataTypes[0] ? ", " + Rt + "; q=0.01" : "")
						: d.accepts["*"]
				),
				d.headers))
					E.setRequestHeader(f, d.headers[f]);
				if (d.beforeSend && (!1 === d.beforeSend.call(h, E, d) || l)) return E.abort();
				if (((C = "abort"), m.add(d.complete), E.done(d.success), E.fail(d.error), (r = Wt(Pt, d, n, E)))) {
					if (((E.readyState = 1), c && g.trigger("ajaxSend", [E, d]), l)) return E;
					d.async &&
						0 < d.timeout &&
						(s = e.setTimeout(function () {
							E.abort("timeout");
						}, d.timeout));
					try {
						(l = !1), r.send(b, S);
					} catch (t) {
						if (l) throw t;
						S(-1, t);
					}
				} else S(-1, "No Transport");
				function S(t, n, a, u) {
					var f,
						p,
						v,
						b,
						T,
						C = n;
					l ||
						((l = !0),
						s && e.clearTimeout(s),
						(r = void 0),
						(o = u || ""),
						(E.readyState = 0 < t ? 4 : 0),
						(f = (200 <= t && t < 300) || 304 === t),
						a &&
							(b = (function (e, t, n) {
								for (var r, i, o, a, s = e.contents, u = e.dataTypes; "*" === u[0]; )
									u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
								if (r)
									for (i in s)
										if (s[i] && s[i].test(r)) {
											u.unshift(i);
											break;
										}
								if (u[0] in n) o = u[0];
								else {
									for (i in n) {
										if (!u[0] || e.converters[i + " " + u[0]]) {
											o = i;
											break;
										}
										a || (a = i);
									}
									o = o || a;
								}
								if (o) return o !== u[0] && u.unshift(o), n[o];
							})(d, E, a)),
						!f &&
							-1 < w.inArray("script", d.dataTypes) &&
							w.inArray("json", d.dataTypes) < 0 &&
							(d.converters["text script"] = function () {}),
						(b = (function (e, t, n, r) {
							var i,
								o,
								a,
								s,
								u,
								l = {},
								c = e.dataTypes.slice();
							if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
							for (o = c.shift(); o; )
								if (
									(e.responseFields[o] && (n[e.responseFields[o]] = t),
									!u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)),
									(u = o),
									(o = c.shift()))
								)
									if ("*" === o) o = u;
									else if ("*" !== u && u !== o) {
										if (!(a = l[u + " " + o] || l["* " + o]))
											for (i in l)
												if (
													(s = i.split(" "))[1] === o &&
													(a = l[u + " " + s[0]] || l["* " + s[0]])
												) {
													!0 === a
														? (a = l[i])
														: !0 !== l[i] && ((o = s[0]), c.unshift(s[1]));
													break;
												}
										if (!0 !== a)
											if (a && e.throws) t = a(t);
											else
												try {
													t = a(t);
												} catch (e) {
													return {
														state: "parsererror",
														error: a ? e : "No conversion from " + u + " to " + o,
													};
												}
									}
							return { state: "success", data: t };
						})(d, b, E, f)),
						f
							? (d.ifModified &&
									((T = E.getResponseHeader("Last-Modified")) && (w.lastModified[i] = T),
									(T = E.getResponseHeader("etag")) && (w.etag[i] = T)),
							  204 === t || "HEAD" === d.type
									? (C = "nocontent")
									: 304 === t
									? (C = "notmodified")
									: ((C = b.state), (p = b.data), (f = !(v = b.error))))
							: ((v = C), (!t && C) || ((C = "error"), t < 0 && (t = 0))),
						(E.status = t),
						(E.statusText = (n || C) + ""),
						f ? y.resolveWith(h, [p, C, E]) : y.rejectWith(h, [E, C, v]),
						E.statusCode(x),
						(x = void 0),
						c && g.trigger(f ? "ajaxSuccess" : "ajaxError", [E, d, f ? p : v]),
						m.fireWith(h, [E, C]),
						c && (g.trigger("ajaxComplete", [E, d]), --w.active || w.event.trigger("ajaxStop")));
				}
				return E;
			},
			getJSON: function (e, t, n) {
				return w.get(e, t, n, "json");
			},
			getScript: function (e, t) {
				return w.get(e, void 0, t, "script");
			},
		}),
		w.each(["get", "post"], function (e, t) {
			w[t] = function (e, n, r, i) {
				return (
					h(n) && ((i = i || r), (r = n), (n = void 0)),
					w.ajax(w.extend({ url: e, type: t, dataType: i, data: n, success: r }, w.isPlainObject(e) && e))
				);
			};
		}),
		w.ajaxPrefilter(function (e) {
			var t;
			for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "");
		}),
		(w._evalUrl = function (e, t, n) {
			return w.ajax({
				url: e,
				type: "GET",
				dataType: "script",
				cache: !0,
				async: !1,
				global: !1,
				converters: { "text script": function () {} },
				dataFilter: function (e) {
					w.globalEval(e, t, n);
				},
			});
		}),
		w.fn.extend({
			wrapAll: function (e) {
				var t;
				return (
					this[0] &&
						(h(e) && (e = e.call(this[0])),
						(t = w(e, this[0].ownerDocument).eq(0).clone(!0)),
						this[0].parentNode && t.insertBefore(this[0]),
						t
							.map(function () {
								for (var e = this; e.firstElementChild; ) e = e.firstElementChild;
								return e;
							})
							.append(this)),
					this
				);
			},
			wrapInner: function (e) {
				return h(e)
					? this.each(function (t) {
							w(this).wrapInner(e.call(this, t));
					  })
					: this.each(function () {
							var t = w(this),
								n = t.contents();
							n.length ? n.wrapAll(e) : t.append(e);
					  });
			},
			wrap: function (e) {
				var t = h(e);
				return this.each(function (n) {
					w(this).wrapAll(t ? e.call(this, n) : e);
				});
			},
			unwrap: function (e) {
				return (
					this.parent(e)
						.not("body")
						.each(function () {
							w(this).replaceWith(this.childNodes);
						}),
					this
				);
			},
		}),
		(w.expr.pseudos.hidden = function (e) {
			return !w.expr.pseudos.visible(e);
		}),
		(w.expr.pseudos.visible = function (e) {
			return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
		}),
		(w.ajaxSettings.xhr = function () {
			try {
				return new e.XMLHttpRequest();
			} catch (e) {}
		});
	var Bt = { 0: 200, 1223: 204 },
		$t = w.ajaxSettings.xhr();
	(d.cors = !!$t && "withCredentials" in $t),
		(d.ajax = $t = !!$t),
		w.ajaxTransport(function (t) {
			var n, r;
			if (d.cors || ($t && !t.crossDomain))
				return {
					send: function (i, o) {
						var a,
							s = t.xhr();
						if ((s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields))
							for (a in t.xhrFields) s[a] = t.xhrFields[a];
						for (a in (t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType),
						t.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"),
						i))
							s.setRequestHeader(a, i[a]);
						(n = function (e) {
							return function () {
								n &&
									((n =
										r =
										s.onload =
										s.onerror =
										s.onabort =
										s.ontimeout =
										s.onreadystatechange =
											null),
									"abort" === e
										? s.abort()
										: "error" === e
										? "number" != typeof s.status
											? o(0, "error")
											: o(s.status, s.statusText)
										: o(
												Bt[s.status] || s.status,
												s.statusText,
												"text" !== (s.responseType || "text") ||
													"string" != typeof s.responseText
													? { binary: s.response }
													: { text: s.responseText },
												s.getAllResponseHeaders()
										  ));
							};
						}),
							(s.onload = n()),
							(r = s.onerror = s.ontimeout = n("error")),
							void 0 !== s.onabort
								? (s.onabort = r)
								: (s.onreadystatechange = function () {
										4 === s.readyState &&
											e.setTimeout(function () {
												n && r();
											});
								  }),
							(n = n("abort"));
						try {
							s.send((t.hasContent && t.data) || null);
						} catch (i) {
							if (n) throw i;
						}
					},
					abort: function () {
						n && n();
					},
				};
		}),
		w.ajaxPrefilter(function (e) {
			e.crossDomain && (e.contents.script = !1);
		}),
		w.ajaxSetup({
			accepts: {
				script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript",
			},
			contents: { script: /\b(?:java|ecma)script\b/ },
			converters: {
				"text script": function (e) {
					return w.globalEval(e), e;
				},
			},
		}),
		w.ajaxPrefilter("script", function (e) {
			void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");
		}),
		w.ajaxTransport("script", function (e) {
			var t, n;
			if (e.crossDomain || e.scriptAttrs)
				return {
					send: function (r, i) {
						(t = w("<script>")
							.attr(e.scriptAttrs || {})
							.prop({ charset: e.scriptCharset, src: e.url })
							.on(
								"load error",
								(n = function (e) {
									t.remove(), (n = null), e && i("error" === e.type ? 404 : 200, e.type);
								})
							)),
							v.head.appendChild(t[0]);
					},
					abort: function () {
						n && n();
					},
				};
		});
	var _t,
		zt = [],
		Ut = /(=)\?(?=&|$)|\?\?/;
	w.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function () {
			var e = zt.pop() || w.expando + "_" + wt.guid++;
			return (this[e] = !0), e;
		},
	}),
		w.ajaxPrefilter("json jsonp", function (t, n, r) {
			var i,
				o,
				a,
				s =
					!1 !== t.jsonp &&
					(Ut.test(t.url)
						? "url"
						: "string" == typeof t.data &&
						  0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") &&
						  Ut.test(t.data) &&
						  "data");
			if (s || "jsonp" === t.dataTypes[0])
				return (
					(i = t.jsonpCallback = h(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback),
					s
						? (t[s] = t[s].replace(Ut, "$1" + i))
						: !1 !== t.jsonp && (t.url += (Tt.test(t.url) ? "&" : "?") + t.jsonp + "=" + i),
					(t.converters["script json"] = function () {
						return a || w.error(i + " was not called"), a[0];
					}),
					(t.dataTypes[0] = "json"),
					(o = e[i]),
					(e[i] = function () {
						a = arguments;
					}),
					r.always(function () {
						void 0 === o ? w(e).removeProp(i) : (e[i] = o),
							t[i] && ((t.jsonpCallback = n.jsonpCallback), zt.push(i)),
							a && h(o) && o(a[0]),
							(a = o = void 0);
					}),
					"script"
				);
		}),
		(d.createHTMLDocument =
			(((_t = v.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>"),
			2 === _t.childNodes.length)),
		(w.parseHTML = function (e, t, n) {
			return "string" != typeof e
				? []
				: ("boolean" == typeof t && ((n = t), (t = !1)),
				  t ||
						(d.createHTMLDocument
							? (((r = (t = v.implementation.createHTMLDocument("")).createElement("base")).href =
									v.location.href),
							  t.head.appendChild(r))
							: (t = v)),
				  (o = !n && []),
				  (i = N.exec(e))
						? [t.createElement(i[1])]
						: ((i = xe([e], t, o)), o && o.length && w(o).remove(), w.merge([], i.childNodes)));
			var r, i, o;
		}),
		(w.fn.load = function (e, t, n) {
			var r,
				i,
				o,
				a = this,
				s = e.indexOf(" ");
			return (
				-1 < s && ((r = ht(e.slice(s))), (e = e.slice(0, s))),
				h(t) ? ((n = t), (t = void 0)) : t && "object" == typeof t && (i = "POST"),
				0 < a.length &&
					w
						.ajax({ url: e, type: i || "GET", dataType: "html", data: t })
						.done(function (e) {
							(o = arguments), a.html(r ? w("<div>").append(w.parseHTML(e)).find(r) : e);
						})
						.always(
							n &&
								function (e, t) {
									a.each(function () {
										n.apply(this, o || [e.responseText, t, e]);
									});
								}
						),
				this
			);
		}),
		(w.expr.pseudos.animated = function (e) {
			return w.grep(w.timers, function (t) {
				return e === t.elem;
			}).length;
		}),
		(w.offset = {
			setOffset: function (e, t, n) {
				var r,
					i,
					o,
					a,
					s,
					u,
					l = w.css(e, "position"),
					c = w(e),
					f = {};
				"static" === l && (e.style.position = "relative"),
					(s = c.offset()),
					(o = w.css(e, "top")),
					(u = w.css(e, "left")),
					("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto")
						? ((a = (r = c.position()).top), (i = r.left))
						: ((a = parseFloat(o) || 0), (i = parseFloat(u) || 0)),
					h(t) && (t = t.call(e, n, w.extend({}, s))),
					null != t.top && (f.top = t.top - s.top + a),
					null != t.left && (f.left = t.left - s.left + i),
					"using" in t ? t.using.call(e, f) : c.css(f);
			},
		}),
		w.fn.extend({
			offset: function (e) {
				if (arguments.length)
					return void 0 === e
						? this
						: this.each(function (t) {
								w.offset.setOffset(this, e, t);
						  });
				var t,
					n,
					r = this[0];
				return r
					? r.getClientRects().length
						? ((t = r.getBoundingClientRect()),
						  (n = r.ownerDocument.defaultView),
						  { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset })
						: { top: 0, left: 0 }
					: void 0;
			},
			position: function () {
				if (this[0]) {
					var e,
						t,
						n,
						r = this[0],
						i = { top: 0, left: 0 };
					if ("fixed" === w.css(r, "position")) t = r.getBoundingClientRect();
					else {
						for (
							t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;
							e && (e === n.body || e === n.documentElement) && "static" === w.css(e, "position");

						)
							e = e.parentNode;
						e &&
							e !== r &&
							1 === e.nodeType &&
							(((i = w(e).offset()).top += w.css(e, "borderTopWidth", !0)),
							(i.left += w.css(e, "borderLeftWidth", !0)));
					}
					return {
						top: t.top - i.top - w.css(r, "marginTop", !0),
						left: t.left - i.left - w.css(r, "marginLeft", !0),
					};
				}
			},
			offsetParent: function () {
				return this.map(function () {
					for (var e = this.offsetParent; e && "static" === w.css(e, "position"); ) e = e.offsetParent;
					return e || re;
				});
			},
		}),
		w.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (e, t) {
			var n = "pageYOffset" === t;
			w.fn[e] = function (r) {
				return $(
					this,
					function (e, r, i) {
						var o;
						if ((g(e) ? (o = e) : 9 === e.nodeType && (o = e.defaultView), void 0 === i))
							return o ? o[t] : e[r];
						o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : (e[r] = i);
					},
					e,
					r,
					arguments.length
				);
			};
		}),
		w.each(["top", "left"], function (e, t) {
			w.cssHooks[t] = Fe(d.pixelPosition, function (e, n) {
				if (n) return (n = We(e, t)), Pe.test(n) ? w(e).position()[t] + "px" : n;
			});
		}),
		w.each({ Height: "height", Width: "width" }, function (e, t) {
			w.each({ padding: "inner" + e, content: t, "": "outer" + e }, function (n, r) {
				w.fn[r] = function (i, o) {
					var a = arguments.length && (n || "boolean" != typeof i),
						s = n || (!0 === i || !0 === o ? "margin" : "border");
					return $(
						this,
						function (t, n, i) {
							var o;
							return g(t)
								? 0 === r.indexOf("outer")
									? t["inner" + e]
									: t.document.documentElement["client" + e]
								: 9 === t.nodeType
								? ((o = t.documentElement),
								  Math.max(
										t.body["scroll" + e],
										o["scroll" + e],
										t.body["offset" + e],
										o["offset" + e],
										o["client" + e]
								  ))
								: void 0 === i
								? w.css(t, n, s)
								: w.style(t, n, i, s);
						},
						t,
						a ? i : void 0,
						a
					);
				};
			});
		}),
		w.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
			w.fn[t] = function (e) {
				return this.on(t, e);
			};
		}),
		w.fn.extend({
			bind: function (e, t, n) {
				return this.on(e, null, t, n);
			},
			unbind: function (e, t) {
				return this.off(e, null, t);
			},
			delegate: function (e, t, n, r) {
				return this.on(t, e, n, r);
			},
			undelegate: function (e, t, n) {
				return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
			},
			hover: function (e, t) {
				return this.mouseenter(e).mouseleave(t || e);
			},
		}),
		w.each(
			"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(
				" "
			),
			function (e, t) {
				w.fn[t] = function (e, n) {
					return 0 < arguments.length ? this.on(t, null, e, n) : this.trigger(t);
				};
			}
		);
	var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
	(w.proxy = function (e, t) {
		var n, r, o;
		if (("string" == typeof t && ((n = e[t]), (t = e), (e = n)), h(e)))
			return (
				(r = i.call(arguments, 2)),
				((o = function () {
					return e.apply(t || this, r.concat(i.call(arguments)));
				}).guid = e.guid =
					e.guid || w.guid++),
				o
			);
	}),
		(w.holdReady = function (e) {
			e ? w.readyWait++ : w.ready(!0);
		}),
		(w.isArray = Array.isArray),
		(w.parseJSON = JSON.parse),
		(w.nodeName = A),
		(w.isFunction = h),
		(w.isWindow = g),
		(w.camelCase = X),
		(w.type = x),
		(w.now = Date.now),
		(w.isNumeric = function (e) {
			var t = w.type(e);
			return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
		}),
		(w.trim = function (e) {
			return null == e ? "" : (e + "").replace(Xt, "");
		}),
		"function" == typeof define &&
			define.amd &&
			define("jquery", [], function () {
				return w;
			});
	var Vt = e.jQuery,
		Gt = e.$;
	return (
		(w.noConflict = function (t) {
			return e.$ === w && (e.$ = Gt), t && e.jQuery === w && (e.jQuery = Vt), w;
		}),
		void 0 === t && (e.jQuery = e.$ = w),
		w
	);
});
("use strict");
function MediaStreamRecorder(e, t) {
	if (!e) throw "MediaStream is mandatory.";
	var i;
	(t = t || { video: { width: 360, height: 240 } }).frameInterval || (t.frameInterval = 10),
		t.video || (t.video = {}),
		t.video.width || (t.video.width = 360),
		t.video.height || (t.video.height = 240),
		(this.start = function (t) {
			var a;
			"undefined" != typeof MediaRecorder
				? (a = MediaRecorderWrapper)
				: (IsChrome || IsOpera || IsEdge) &&
				  (-1 !== this.mimeType.indexOf("video")
						? (a = WhammyRecorder)
						: -1 !== this.mimeType.indexOf("audio") && (a = StereoAudioRecorder)),
				"image/gif" === this.mimeType && (a = GifRecorder),
				("audio/wav" !== this.mimeType && "audio/pcm" !== this.mimeType) || (a = StereoAudioRecorder),
				this.recorderType && (a = this.recorderType),
				((i = new a(e)).blobs = []);
			var o = this;
			(i.ondataavailable = function (e) {
				i.blobs.push(e), o.ondataavailable(e);
			}),
				(i.onstop = this.onstop),
				(i.onStartedDrawingNonBlankFrames = this.onStartedDrawingNonBlankFrames),
				(i = mergeProps(i, this)).start(t);
		}),
		(this.onStartedDrawingNonBlankFrames = function () {}),
		(this.clearOldRecordedFrames = function () {
			i && i.clearOldRecordedFrames();
		}),
		(this.stop = function () {
			i && i.stop();
		}),
		(this.ondataavailable = function (e) {
			this.disableLogs || console.log("ondataavailable..", e);
		}),
		(this.onstop = function (e) {
			console.warn("stopped..", e);
		}),
		(this.save = function (e, t) {
			if (e) invokeSaveAsDialog(e, t);
			else {
				if (!i) return;
				ConcatenateBlobs(i.blobs, i.blobs[0].type, function (e) {
					invokeSaveAsDialog(e);
				});
			}
		}),
		(this.pause = function () {
			i && (i.pause(), this.disableLogs || console.log("Paused recording.", this.mimeType || i.mimeType));
		}),
		(this.resume = function () {
			i && (i.resume(), this.disableLogs || console.log("Resumed recording.", this.mimeType || i.mimeType));
		}),
		(this.recorderType = null),
		(this.mimeType = "video/webm"),
		(this.disableLogs = !1);
}
function MultiStreamRecorder(e, t) {
	(e = e || []) instanceof MediaStream && (e = [e]);
	var i,
		a,
		o = this;
	(t = t || { mimeType: "video/webm", video: { width: 360, height: 240 } }).frameInterval || (t.frameInterval = 10),
		t.video || (t.video = {}),
		t.video.width || (t.video.width = 360),
		t.video.height || (t.video.height = 240),
		(this.start = function (r) {
			var n;
			for (var d in ((i = new MultiStreamsMixer(e)),
			((n = []),
			e.forEach(function (e) {
				e.getVideoTracks().forEach(function (e) {
					n.push(e);
				});
			}),
			n).length &&
				((i.frameInterval = t.frameInterval || 10),
				(i.width = t.video.width || 360),
				(i.height = t.video.height || 240),
				i.startDrawingFrames()),
			"function" == typeof o.previewStream && o.previewStream(i.getMixedStream()),
			(a = new MediaStreamRecorder(i.getMixedStream())),
			o))
				"function" != typeof o[d] && (a[d] = o[d]);
			(a.ondataavailable = function (e) {
				o.ondataavailable(e);
			}),
				(a.onstop = o.onstop),
				a.start(r);
		}),
		(this.stop = function (e) {
			a &&
				a.stop(function (t) {
					e(t);
				});
		}),
		(this.pause = function () {
			a && a.pause();
		}),
		(this.resume = function () {
			a && a.resume();
		}),
		(this.clearRecordedData = function () {
			a && (a.clearRecordedData(), (a = null)), i && (i.releaseStreams(), (i = null));
		}),
		(this.addStreams = this.addStream =
			function (t) {
				if (!t) throw "First parameter is required.";
				t instanceof Array || (t = [t]), e.concat(t), a && i && i.appendStreams(t);
			}),
		(this.resetVideoStreams = function (e) {
			i && (!e || e instanceof Array || (e = [e]), i.resetVideoStreams(e));
		}),
		(this.ondataavailable = function (e) {
			o.disableLogs || console.log("ondataavailable", e);
		}),
		(this.onstop = function () {}),
		(this.name = "MultiStreamRecorder"),
		(this.toString = function () {
			return this.name;
		});
}
function MultiStreamsMixer(e) {
	var t = [],
		i = !1,
		a = document.createElement("canvas"),
		o = a.getContext("2d");
	(a.style =
		"opacity:0;position:absolute;z-index:-1;top: -100000000;left:-1000000000; margin-top:-1000000000;margin-left:-1000000000;"),
		(document.body || document.documentElement).appendChild(a),
		(this.disableLogs = !1),
		(this.frameInterval = 10),
		(this.width = 360),
		(this.height = 240),
		(this.useGainNode = !0);
	var r = this,
		n = window.AudioContext;
	void 0 === n &&
		("undefined" != typeof webkitAudioContext && (n = webkitAudioContext),
		"undefined" != typeof mozAudioContext && (n = mozAudioContext));
	var d = window.URL;
	void 0 === d && "undefined" != typeof webkitURL && (d = webkitURL),
		"undefined" != typeof navigator &&
			void 0 === navigator.getUserMedia &&
			(void 0 !== navigator.webkitGetUserMedia && (navigator.getUserMedia = navigator.webkitGetUserMedia),
			void 0 !== navigator.mozGetUserMedia && (navigator.getUserMedia = navigator.mozGetUserMedia));
	var s = window.MediaStream;
	void 0 === s && "undefined" != typeof webkitMediaStream && (s = webkitMediaStream),
		void 0 !== s &&
			("getVideoTracks" in s.prototype ||
				((s.prototype.getVideoTracks = function () {
					if (!this.getTracks) return [];
					var e = [];
					return (
						this.getTracks.forEach(function (t) {
							-1 !== t.kind.toString().indexOf("video") && e.push(t);
						}),
						e
					);
				}),
				(s.prototype.getAudioTracks = function () {
					if (!this.getTracks) return [];
					var e = [];
					return (
						this.getTracks.forEach(function (t) {
							-1 !== t.kind.toString().indexOf("audio") && e.push(t);
						}),
						e
					);
				})),
			void 0 === s.prototype.stop &&
				(s.prototype.stop = function () {
					this.getTracks().forEach(function (e) {
						e.stop();
					});
				}));
	var c = {};
	function u() {
		if (!i) {
			var e = t.length,
				o = !1,
				n = [];
			t.forEach(function (e) {
				e.stream || (e.stream = {}), e.stream.fullcanvas ? (o = e) : n.push(e);
			}),
				o
					? ((a.width = o.stream.width), (a.height = o.stream.height))
					: n.length
					? ((a.width = e > 1 ? 2 * n[0].width : n[0].width),
					  (a.height = e > 2 ? 2 * n[0].height : n[0].height))
					: ((a.width = r.width || 360), (a.height = r.height || 240)),
				o && o instanceof HTMLVideoElement && h(o),
				n.forEach(function (e, t) {
					h(e, t);
				}),
				setTimeout(u, r.frameInterval);
		}
	}
	function h(e, t) {
		if (!i) {
			var a = 0,
				r = 0,
				n = e.width,
				d = e.height;
			1 === t && (a = e.width),
				2 === t && (r = e.height),
				3 === t && ((a = e.width), (r = e.height)),
				void 0 !== e.stream.left && (a = e.stream.left),
				void 0 !== e.stream.top && (r = e.stream.top),
				void 0 !== e.stream.width && (n = e.stream.width),
				void 0 !== e.stream.height && (d = e.stream.height),
				o.drawImage(e, a, r, n, d),
				"function" == typeof e.stream.onRender && e.stream.onRender(o, a, r, n, d, t);
		}
	}
	function f(e) {
		var t = document.createElement("video");
		return (
			"srcObject" in t ? (t.srcObject = e) : (t.src = d.createObjectURL(e)),
			(t.muted = !0),
			(t.volume = 0),
			(t.width = e.width || r.width || 360),
			(t.height = e.height || r.height || 240),
			t.play(),
			t
		);
	}
	function m(i) {
		(t = []),
			(i = i || e).forEach(function (e) {
				if (e.getVideoTracks().length) {
					var i = f(e);
					(i.stream = e), t.push(i);
				}
			});
	}
	void 0 !== n
		? (c.AudioContext = n)
		: "undefined" != typeof webkitAudioContext && (c.AudioContext = webkitAudioContext),
		(this.startDrawingFrames = function () {
			u();
		}),
		(this.appendStreams = function (i) {
			if (!i) throw "First parameter is required.";
			i instanceof Array || (i = [i]),
				e.concat(i),
				i.forEach(function (e) {
					if (e.getVideoTracks().length) {
						var i = f(e);
						(i.stream = e), t.push(i);
					}
					if (e.getAudioTracks().length && r.audioContext) {
						var a = r.audioContext.createMediaStreamSource(e);
						a.connect(r.audioDestination), r.audioSources.push(a);
					}
				});
		}),
		(this.releaseStreams = function () {
			(t = []),
				(i = !0),
				r.gainNode && (r.gainNode.disconnect(), (r.gainNode = null)),
				r.audioSources.length &&
					(r.audioSources.forEach(function (e) {
						e.disconnect();
					}),
					(r.audioSources = [])),
				r.audioDestination && (r.audioDestination.disconnect(), (r.audioDestination = null)),
				(r.audioContext = null),
				o.clearRect(0, 0, a.width, a.height),
				a.stream && (a.stream.stop(), (a.stream = null));
		}),
		(this.resetVideoStreams = function (e) {
			!e || e instanceof Array || (e = [e]), m(e);
		}),
		(this.name = "MultiStreamsMixer"),
		(this.toString = function () {
			return this.name;
		}),
		(this.getMixedStream = function () {
			i = !1;
			var t = (function () {
					var e;
					m(),
						"captureStream" in a
							? (e = a.captureStream())
							: "mozCaptureStream" in a
							? (e = a.mozCaptureStream())
							: r.disableLogs ||
							  console.error(
									"Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features"
							  );
					var t = new s();
					return (
						e.getVideoTracks().forEach(function (e) {
							t.addTrack(e);
						}),
						(a.stream = t),
						t
					);
				})(),
				o = (function () {
					c.AudioContextConstructor || (c.AudioContextConstructor = new c.AudioContext());
					(r.audioContext = c.AudioContextConstructor),
						(r.audioSources = []),
						!0 === r.useGainNode &&
							((r.gainNode = r.audioContext.createGain()),
							r.gainNode.connect(r.audioContext.destination),
							(r.gainNode.gain.value = 0));
					var t = 0;
					if (
						(e.forEach(function (e) {
							if (e.getAudioTracks().length) {
								t++;
								var i = r.audioContext.createMediaStreamSource(e);
								!0 === r.useGainNode && i.connect(r.gainNode), r.audioSources.push(i);
							}
						}),
						!t)
					)
						return;
					return (
						(r.audioDestination = r.audioContext.createMediaStreamDestination()),
						r.audioSources.forEach(function (e) {
							e.connect(r.audioDestination);
						}),
						r.audioDestination.stream
					);
				})();
			return (
				o &&
					o.getAudioTracks().forEach(function (e) {
						t.addTrack(e);
					}),
				e.forEach(function (e) {
					e.fullcanvas && !0;
				}),
				t
			);
		});
}
void 0 !== MediaStreamRecorder && (MediaStreamRecorder.MultiStreamRecorder = MultiStreamRecorder);
var AudioContext,
	browserFakeUserAgent = "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45";
!(function (e) {
	"undefined" == typeof window &&
		("undefined" == typeof window &&
			"undefined" != typeof global &&
			((global.navigator = { userAgent: browserFakeUserAgent, getUserMedia: function () {} }),
			(e.window = global)),
		"undefined" == typeof document &&
			((e.document = {}),
			(document.createElement =
				document.captureStream =
				document.mozCaptureStream =
					function () {
						return {};
					})),
		"undefined" == typeof location && (e.location = { protocol: "file:", href: "", hash: "" }),
		"undefined" == typeof screen && (e.screen = { width: 0, height: 0 }));
})("undefined" != typeof global ? global : window),
	void 0 === (AudioContext = window.AudioContext) &&
		("undefined" != typeof webkitAudioContext && (AudioContext = webkitAudioContext),
		"undefined" != typeof mozAudioContext && (AudioContext = mozAudioContext)),
	"undefined" == typeof window && (window = {}),
	void 0 === (AudioContext = window.AudioContext) &&
		("undefined" != typeof webkitAudioContext && (AudioContext = webkitAudioContext),
		"undefined" != typeof mozAudioContext && (AudioContext = mozAudioContext));
var URL = window.URL;
void 0 === URL && "undefined" != typeof webkitURL && (URL = webkitURL),
	"undefined" != typeof navigator
		? (void 0 !== navigator.webkitGetUserMedia && (navigator.getUserMedia = navigator.webkitGetUserMedia),
		  void 0 !== navigator.mozGetUserMedia && (navigator.getUserMedia = navigator.mozGetUserMedia))
		: (navigator = { getUserMedia: function () {}, userAgent: browserFakeUserAgent });
var IsEdge = !(-1 === navigator.userAgent.indexOf("Edge") || (!navigator.msSaveBlob && !navigator.msSaveOrOpenBlob)),
	IsOpera = !1;
"undefined" != typeof opera && navigator.userAgent && -1 !== navigator.userAgent.indexOf("OPR/") && (IsOpera = !0);
var IsChrome = !IsEdge && !IsEdge && !!navigator.webkitGetUserMedia,
	MediaStream = window.MediaStream;
function mergeProps(e, t) {
	for (var i in t) "function" != typeof t[i] && (e[i] = t[i]);
	return e;
}
function dropFirstFrame(e) {
	return e.shift(), e;
}
function invokeSaveAsDialog(e, t) {
	if (!e) throw "Blob object is required.";
	if (!e.type)
		try {
			e.type = "video/webm";
		} catch (e) {}
	var i = (e.type || "video/webm").split("/")[1];
	if (t && -1 !== t.indexOf(".")) {
		var a = t.split(".");
		(t = a[0]), (i = a[1]);
	}
	var o = (t || Math.round(9999999999 * Math.random()) + 888888888) + "." + i;
	if (void 0 !== navigator.msSaveOrOpenBlob) return navigator.msSaveOrOpenBlob(e, o);
	if (void 0 !== navigator.msSaveBlob) return navigator.msSaveBlob(e, o);
	var r = document.createElement("a");
	(r.href = URL.createObjectURL(e)),
		(r.target = "_blank"),
		(r.download = o),
		navigator.mozGetUserMedia &&
			((r.onclick = function () {
				(document.body || document.documentElement).removeChild(r);
			}),
			(document.body || document.documentElement).appendChild(r));
	var n = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !0 });
	r.dispatchEvent(n), navigator.mozGetUserMedia || URL.revokeObjectURL(r.href);
}
function bytesToSize(e) {
	if (0 === e) return "0 Bytes";
	var t = parseInt(Math.floor(Math.log(e) / Math.log(1e3)), 10);
	return (e / Math.pow(1e3, t)).toPrecision(3) + " " + ["Bytes", "KB", "MB", "GB", "TB"][t];
}
void 0 === MediaStream && "undefined" != typeof webkitMediaStream && (MediaStream = webkitMediaStream),
	void 0 !== MediaStream &&
		("getVideoTracks" in MediaStream.prototype ||
			((MediaStream.prototype.getVideoTracks = function () {
				if (!this.getTracks) return [];
				var e = [];
				return (
					this.getTracks.forEach(function (t) {
						-1 !== t.kind.toString().indexOf("video") && e.push(t);
					}),
					e
				);
			}),
			(MediaStream.prototype.getAudioTracks = function () {
				if (!this.getTracks) return [];
				var e = [];
				return (
					this.getTracks.forEach(function (t) {
						-1 !== t.kind.toString().indexOf("audio") && e.push(t);
					}),
					e
				);
			})),
		"stop" in MediaStream.prototype ||
			(MediaStream.prototype.stop = function () {
				this.getAudioTracks().forEach(function (e) {
					e.stop && e.stop();
				}),
					this.getVideoTracks().forEach(function (e) {
						e.stop && e.stop();
					});
			})),
	"undefined" != typeof location &&
		0 === location.href.indexOf("file:") &&
		console.error("Please load this HTML file on HTTP or HTTPS.");
var ObjectStore = { AudioContext: AudioContext };
function isMediaRecorderCompatible() {
	var e = !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0,
		t = !!window.chrome && !e;
	if (void 0 !== window.InstallTrigger) return !0;
	if (!t) return !1;
	navigator.appVersion;
	var i,
		a,
		o = navigator.userAgent,
		r = "" + parseFloat(navigator.appVersion),
		n = parseInt(navigator.appVersion, 10);
	return (
		t && ((i = o.indexOf("Chrome")), (r = o.substring(i + 7))),
		-1 !== (a = r.indexOf(";")) && (r = r.substring(0, a)),
		-1 !== (a = r.indexOf(" ")) && (r = r.substring(0, a)),
		(n = parseInt("" + r, 10)),
		isNaN(n) && ((r = "" + parseFloat(navigator.appVersion)), (n = parseInt(navigator.appVersion, 10))),
		n >= 49
	);
}
function MediaRecorderWrapper(e) {
	var t,
		i = this;
	(this.start = function (a, o) {
		var r;
		((this.timeSlice = a || 5e3), i.mimeType || (i.mimeType = "video/webm"), -1 !== i.mimeType.indexOf("audio")) &&
			e.getVideoTracks().length &&
			e.getAudioTracks().length &&
			(navigator.mozGetUserMedia
				? (r = new MediaStream()).addTrack(e.getAudioTracks()[0])
				: (r = new MediaStream(e.getAudioTracks())),
			(e = r));
		-1 !== i.mimeType.indexOf("audio") && (i.mimeType = IsChrome ? "audio/webm" : "audio/ogg"),
			(i.dontFireOnDataAvailableEvent = !1);
		var n = { mimeType: i.mimeType };
		i.disableLogs || o || console.log("Passing following params over MediaRecorder API.", n),
			t && (t = null),
			IsChrome && !isMediaRecorderCompatible() && (n = "video/vp8");
		try {
			t = new MediaRecorder(e, n);
		} catch (i) {
			t = new MediaRecorder(e);
		}
		"canRecordMimeType" in t &&
			!1 === t.canRecordMimeType(i.mimeType) &&
			(i.disableLogs || console.warn("MediaRecorder API seems unable to record mimeType:", i.mimeType)),
			!0 === i.ignoreMutedMedia && (t.ignoreMutedMedia = !0);
		var d = !1;
		(t.ondataavailable = function (e) {
			if (e.data && e.data.size && !(e.data.size < 26800) && !d) {
				d = !0;
				var o = i.getNativeBlob ? e.data : new Blob([e.data], { type: i.mimeType || "video/webm" });
				i.ondataavailable(o),
					t && "recording" === t.state && t.stop(),
					(t = null),
					i.dontFireOnDataAvailableEvent || i.start(a, "__disableLogs");
			}
		}),
			(t.onerror = function (e) {
				i.disableLogs ||
					("InvalidState" === e.name
						? console.error(
								"The MediaRecorder is not in a state in which the proposed operation is allowed to be executed."
						  )
						: "OutOfMemory" === e.name
						? console.error(
								"The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute."
						  )
						: "IllegalStreamModification" === e.name
						? console.error(
								"A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute."
						  )
						: "OtherRecordingError" === e.name
						? console.error(
								"Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute."
						  )
						: "GenericError" === e.name
						? console.error(
								"The UA cannot provide the codec or recording option that has been requested.",
								e
						  )
						: console.error("MediaRecorder Error", e)),
					t && "inactive" !== t.state && "stopped" !== t.state && t.stop();
			});
		try {
			t.start(36e5);
		} catch (e) {
			t = null;
		}
		setTimeout(function () {
			t && "recording" === t.state && t.requestData();
		}, a);
	}),
		(this.stop = function (e) {
			t &&
				"recording" === t.state &&
				(t.requestData(),
				setTimeout(function () {
					(i.dontFireOnDataAvailableEvent = !0),
						t && "recording" === t.state && t.stop(),
						(t = null),
						i.onstop();
				}, 2e3));
		}),
		(this.pause = function () {
			t && ("recording" === t.state && t.pause(), (this.dontFireOnDataAvailableEvent = !0));
		}),
		(this.ondataavailable = function (e) {
			console.log("recorded-blob", e);
		}),
		(this.resume = function () {
			if (this.dontFireOnDataAvailableEvent) {
				this.dontFireOnDataAvailableEvent = !1;
				var e = i.disableLogs;
				return (i.disableLogs = !0), this.start(this.timeslice || 5e3), void (i.disableLogs = e);
			}
			t && "paused" === t.state && t.resume();
		}),
		(this.clearRecordedData = function () {
			t && (this.pause(), (this.dontFireOnDataAvailableEvent = !0), this.stop());
		}),
		(this.onstop = function () {}),
		(function a() {
			t &&
				(!1 !==
				(function () {
					if ("active" in e) {
						if (!e.active) return !1;
					} else if ("ended" in e && e.ended) return !1;
					return !0;
				})()
					? setTimeout(a, 1e3)
					: i.stop());
		})();
}
function StereoAudioRecorder(e) {
	var t, i;
	(this.start = function (a) {
		(a = a || 1e3),
			(t = new StereoAudioRecorderHelper(e, this)).record(),
			(i = setInterval(function () {
				t.requestData();
			}, a));
	}),
		(this.stop = function () {
			t && (t.stop(), clearTimeout(i), this.onstop());
		}),
		(this.pause = function () {
			t && t.pause();
		}),
		(this.resume = function () {
			t && t.resume();
		}),
		(this.ondataavailable = function () {}),
		(this.onstop = function () {});
}
function StereoAudioRecorderHelper(e, t) {
	var i;
	ObjectStore.AudioContextConstructor || (ObjectStore.AudioContextConstructor = new ObjectStore.AudioContext()),
		(i = ObjectStore.AudioContextConstructor.sampleRate);
	var a,
		o = [],
		r = [],
		n = !1,
		d = 0,
		s = t.sampleRate || i,
		c = (t.mimeType || "audio/wav").indexOf("audio/pcm") > -1,
		u = t.audioChannels || 2;
	function h(e, t) {
		for (var i = new Float32Array(t), a = 0, o = e.length, r = 0; r < o; r++) {
			var n = e[r];
			i.set(n, a), (a += n.length);
		}
		return i;
	}
	function f(e, t, i) {
		for (var a = i.length, o = 0; o < a; o++) e.setUint8(t + o, i.charCodeAt(o));
	}
	function m(e) {
		for (var t = e.length, i = new Int16Array(t); t--; ) i[t] = 65535 * e[t];
		return i.buffer;
	}
	(this.record = function () {
		(n = !0), (o.length = r.length = 0), (d = 0);
	}),
		(this.requestData = function () {
			if (!b)
				if (0 !== d) {
					w = !0;
					var e = o.slice(0),
						i = r.slice(0),
						a = d;
					(o.length = r.length = []), (d = 0), (w = !1);
					var n = h(e, a),
						l = n;
					if (2 === u)
						l = (function (e, t) {
							for (var i = e.length + t.length, a = new Float32Array(i), o = 0, r = 0; r < i; )
								(a[r++] = e[o]), (a[r++] = t[o]), o++;
							return a;
						})(n, h(i, a));
					if (c) {
						var g = new Blob([m(l)], { type: "audio/pcm" });
						return (
							console.debug("audio recorded blob size:", bytesToSize(g.size)), void t.ondataavailable(g)
						);
					}
					var p = new ArrayBuffer(44 + 2 * l.length),
						v = new DataView(p);
					f(v, 0, "RIFF"),
						v.setUint32(4, 44 + 2 * l.length - 8, !0),
						f(v, 8, "WAVE"),
						f(v, 12, "fmt "),
						v.setUint32(16, 16, !0),
						v.setUint16(20, 1, !0),
						v.setUint16(22, u, !0),
						v.setUint32(24, s, !0),
						v.setUint32(28, s * u * 2, !0),
						v.setUint16(32, 2 * u, !0),
						v.setUint16(34, 16, !0),
						f(v, 36, "data"),
						v.setUint32(40, 2 * l.length, !0);
					for (var y = l.length, S = 44, M = 0; M < y; M++) v.setInt16(S, 32767 * l[M], !0), (S += 2);
					g = new Blob([v], { type: "audio/wav" });
					console.debug("audio recorded blob size:", bytesToSize(g.size)), t.ondataavailable(g);
				} else w = !1;
		}),
		(this.stop = function () {
			(n = !1), this.requestData(), g.disconnect(), this.onstop();
		});
	var l = ObjectStore.AudioContextConstructor;
	ObjectStore.VolumeGainNode = l.createGain();
	var g,
		p = ObjectStore.VolumeGainNode;
	(ObjectStore.AudioInput = l.createMediaStreamSource(e)), (g = ObjectStore.AudioInput).connect(p);
	var v = t.bufferSize || 2048;
	if ((0 === t.bufferSize && (v = 0), l.createJavaScriptNode)) a = l.createJavaScriptNode(v, u, u);
	else {
		if (!l.createScriptProcessor) throw "WebAudio API has no support on this browser.";
		a = l.createScriptProcessor(v, u, u);
	}
	(v = a.bufferSize), console.debug("using audio buffer-size:", v);
	var w = !1;
	(window.scriptprocessornode = a), 1 === u && console.debug("All right-channels are skipped.");
	var b = !1;
	(this.pause = function () {
		b = !0;
	}),
		(this.resume = function () {
			b = !1;
		}),
		(this.onstop = function () {}),
		(a.onaudioprocess = function (e) {
			if (n && !w && !b) {
				var t = e.inputBuffer.getChannelData(0);
				if ((o.push(new Float32Array(t)), 2 === u)) {
					var i = e.inputBuffer.getChannelData(1);
					r.push(new Float32Array(i));
				}
				d += v;
			}
		}),
		p.connect(a),
		a.connect(l.destination);
}
function WhammyRecorder(e) {
	var t, i;
	(this.start = function (a) {
		for (var o in ((a = a || 1e3), (t = new WhammyRecorderHelper(e, this)), this))
			"function" != typeof this[o] && (t[o] = this[o]);
		t.record(),
			(i = setInterval(function () {
				t.requestData();
			}, a));
	}),
		(this.stop = function () {
			t && (t.stop(), clearTimeout(i), this.onstop());
		}),
		(this.onstop = function () {}),
		(this.clearOldRecordedFrames = function () {
			t && t.clearOldRecordedFrames();
		}),
		(this.pause = function () {
			t && t.pause();
		}),
		(this.resume = function () {
			t && t.resume();
		}),
		(this.ondataavailable = function () {});
}
function WhammyRecorderHelper(e, t) {
	(this.record = function (i) {
		this.width || (this.width = 320),
			this.height || (this.height = 240),
			this.video &&
				this.video instanceof HTMLVideoElement &&
				(this.width || (this.width = n.videoWidth || n.clientWidth || 320),
				this.height || (this.height = n.videoHeight || n.clientHeight || 240)),
			this.video || (this.video = { width: this.width, height: this.height }),
			(this.canvas && this.canvas.width && this.canvas.height) ||
				(this.canvas = { width: this.width, height: this.height }),
			(c.width = this.canvas.width),
			(c.height = this.canvas.height),
			this.video && this.video instanceof HTMLVideoElement
				? ((this.isHTMLObject = !0), (n = this.video.cloneNode()))
				: (((n = document.createElement("video")).src = URL.createObjectURL(e)),
				  (n.width = this.video.width),
				  (n.height = this.video.height)),
			(n.muted = !0),
			n.play(),
			(d = new Date().getTime()),
			(s = new Whammy.Video(t.speed, t.quality)),
			console.log("canvas resolutions", c.width, "*", c.height),
			console.log("video width/height", n.width || c.width, "*", n.height || c.height),
			o();
	}),
		(this.clearOldRecordedFrames = function () {
			s.frames = [];
		});
	var i = !1;
	this.requestData = function () {
		if (!f)
			if (s.frames.length) {
				i = !0;
				var e = s.frames.slice(0);
				(s.frames = (function (e, t, i, a) {
					var o = document.createElement("canvas");
					(o.width = c.width), (o.height = c.height);
					for (
						var r = o.getContext("2d"),
							n = [],
							d = -1 === t,
							s = t && t > 0 && t <= e.length ? t : e.length,
							u = { r: 0, g: 0, b: 0 },
							h = Math.sqrt(Math.pow(255, 2) + Math.pow(255, 2) + Math.pow(255, 2)),
							f = i && i >= 0 && i <= 1 ? i : 0,
							m = a && a >= 0 && a <= 1 ? a : 0,
							l = !1,
							g = 0;
						g < s;
						g++
					) {
						var p, v, w;
						if (!l) {
							var b = new Image();
							(b.src = e[g].image), r.drawImage(b, 0, 0, c.width, c.height);
							var y = r.getImageData(0, 0, c.width, c.height);
							(p = 0), (v = y.data.length), (w = y.data.length / 4);
							for (var S = 0; S < v; S += 4) {
								var M = { r: y.data[S], g: y.data[S + 1], b: y.data[S + 2] };
								Math.sqrt(Math.pow(M.r - u.r, 2) + Math.pow(M.g - u.g, 2) + Math.pow(M.b - u.b, 2)) <=
									h * f && p++;
							}
						}
						(!l && w - p <= w * m) || (d && (l = !0), n.push(e[g]));
					}
					(n = n.concat(e.slice(s))).length <= 0 && n.push(e[e.length - 1]);
					return n;
				})(e, -1)),
					s.compile(function (e) {
						t.ondataavailable(e), console.debug("video recorded blob size:", bytesToSize(e.size));
					}),
					(s.frames = []),
					(i = !1);
			} else i = !1;
	};
	var a = !1;
	function o() {
		if (f) return (d = new Date().getTime()), void setTimeout(o, 500);
		if (!r) {
			if (i) return setTimeout(o, 100);
			var e = new Date().getTime() - d;
			if (!e) return o();
			(d = new Date().getTime()),
				!h.isHTMLObject && n.paused && n.play(),
				u.drawImage(n, 0, 0, c.width, c.height),
				r || s.frames.push({ duration: e, image: c.toDataURL("image/webp") }),
				a ||
					(function (e, t, i) {
						var a = document.createElement("canvas");
						(a.width = c.width), (a.height = c.height);
						var o,
							r,
							n,
							d = a.getContext("2d"),
							s = { r: 0, g: 0, b: 0 },
							u = Math.sqrt(Math.pow(255, 2) + Math.pow(255, 2) + Math.pow(255, 2)),
							h = t && t >= 0 && t <= 1 ? t : 0,
							f = i && i >= 0 && i <= 1 ? i : 0,
							m = new Image();
						(m.src = e.image), d.drawImage(m, 0, 0, c.width, c.height);
						var l = d.getImageData(0, 0, c.width, c.height);
						(o = 0), (r = l.data.length), (n = l.data.length / 4);
						for (var g = 0; g < r; g += 4) {
							var p = { r: l.data[g], g: l.data[g + 1], b: l.data[g + 2] };
							Math.sqrt(Math.pow(p.r - s.r, 2) + Math.pow(p.g - s.g, 2) + Math.pow(p.b - s.b, 2)) <=
								u * h && o++;
						}
						return !(n - o <= n * f);
					})(s.frames[s.frames.length - 1]) ||
					((a = !0), t.onStartedDrawingNonBlankFrames()),
				setTimeout(o, 10);
		}
	}
	var r = !1;
	this.stop = function () {
		(r = !0), this.requestData(), this.onstop();
	};
	var n,
		d,
		s,
		c = document.createElement("canvas"),
		u = c.getContext("2d"),
		h = this;
	var f = !1;
	(this.pause = function () {
		f = !0;
	}),
		(this.resume = function () {
			f = !1;
		}),
		(this.onstop = function () {});
}
function GifRecorder(e) {
	if ("undefined" == typeof GIFEncoder) throw "Please link: https://cdn.webrtc-experiment.com/gif-recorder.js";
	function t() {
		Date.now();
		var e = new Blob([new Uint8Array(s.stream().bin)], { type: "image/gif" });
		a.ondataavailable(e), (s.stream().bin = []);
	}
	(this.start = function (e) {
		e = e || 1e3;
		var a = this.videoWidth || 320,
			h = this.videoHeight || 240;
		(o.width = n.width = a),
			(o.height = n.height = h),
			(s = new GIFEncoder()).setRepeat(0),
			s.setDelay(this.frameRate || this.speed || 200),
			s.setQuality(this.quality || 1),
			s.start(),
			Date.now(),
			(u = requestAnimationFrame(function e(t) {
				i
					? setTimeout(e, 500, t)
					: ((u = requestAnimationFrame(e)),
					  void 0 === typeof d && (d = t),
					  t - d < 90 || (n.paused && n.play(), r.drawImage(n, 0, 0, a, h), s.addFrame(r), (d = t)));
			})),
			(c = setTimeout(t, e));
	}),
		(this.stop = function () {
			u && (cancelAnimationFrame(u), clearTimeout(c), t(), this.onstop());
		}),
		(this.onstop = function () {});
	var i = !1;
	(this.pause = function () {
		i = !0;
	}),
		(this.resume = function () {
			i = !1;
		}),
		(this.ondataavailable = function () {}),
		(this.onstop = function () {});
	var a = this,
		o = document.createElement("canvas"),
		r = o.getContext("2d"),
		n = document.createElement("video");
	(n.muted = !0), (n.autoplay = !0), (n.src = URL.createObjectURL(e)), n.play();
	var d,
		s,
		c,
		u = null;
}
void 0 !== MediaStreamRecorder && (MediaStreamRecorder.MediaRecorderWrapper = MediaRecorderWrapper),
	void 0 !== MediaStreamRecorder && (MediaStreamRecorder.StereoAudioRecorder = StereoAudioRecorder),
	void 0 !== MediaStreamRecorder && (MediaStreamRecorder.StereoAudioRecorderHelper = StereoAudioRecorderHelper),
	void 0 !== MediaStreamRecorder && (MediaStreamRecorder.WhammyRecorder = WhammyRecorder),
	void 0 !== MediaStreamRecorder && (MediaStreamRecorder.WhammyRecorderHelper = WhammyRecorderHelper),
	void 0 !== MediaStreamRecorder && (MediaStreamRecorder.GifRecorder = GifRecorder);
var Whammy = (function () {
	function e(e, t) {
		(this.frames = []), e || (e = 1), (this.duration = 1e3 / e), (this.quality = t || 0.8);
	}
	function t(e) {
		function t(e, t, i) {
			return [{ data: e, id: 231 }].concat(
				i.map(function (e) {
					var i = (function (e) {
						var t = 0;
						e.keyframe && (t |= 128);
						e.invisible && (t |= 8);
						e.lacing && (t |= e.lacing << 1);
						e.discardable && (t |= 1);
						if (e.trackNum > 127) throw "TrackNumber > 127 not supported";
						return (
							[128 | e.trackNum, e.timecode >> 8, 255 & e.timecode, t]
								.map(function (e) {
									return String.fromCharCode(e);
								})
								.join("") + e.frame
						);
					})({
						discardable: 0,
						frame: e.data.slice(4),
						invisible: 0,
						keyframe: 1,
						lacing: 0,
						trackNum: 1,
						timecode: Math.round(t),
					});
					return (t += e.duration), { data: i, id: 163 };
				})
			);
		}
		function i(e) {
			for (var t = []; e > 0; ) t.push(255 & e), (e >>= 8);
			return new Uint8Array(t.reverse());
		}
		function a(e) {
			var t = [];
			e = (e.length % 8 ? new Array(9 - (e.length % 8)).join("0") : "") + e;
			for (var i = 0; i < e.length; i += 8) t.push(parseInt(e.substr(i, 8), 2));
			return new Uint8Array(t);
		}
		function o(e) {
			for (var t = [], r = 0; r < e.length; r++) {
				var n = e[r].data;
				"object" == typeof n && (n = o(n)),
					"number" == typeof n && (n = a(n.toString(2))),
					"string" == typeof n &&
						(n = new Uint8Array(
							n.split("").map(function (e) {
								return e.charCodeAt(0);
							})
						));
				var d = n.size || n.byteLength || n.length,
					s = Math.ceil(Math.ceil(Math.log(d) / Math.log(2)) / 8),
					c = d.toString(2),
					u = new Array(7 * s + 7 + 1 - c.length).join("0") + c,
					h = new Array(s).join("0") + "1" + u;
				t.push(i(e[r].id)), t.push(a(h)), t.push(n);
			}
			return new Blob(t, { type: "video/webm" });
		}
		function r(e, t) {
			return parseInt(
				e
					.substr(t + 4, 4)
					.split("")
					.map(function (e) {
						var t = e.charCodeAt(0).toString(2);
						return new Array(8 - t.length + 1).join("0") + t;
					})
					.join(""),
				2
			);
		}
		function n(e) {
			for (var t = 0, i = {}; t < e.length; ) {
				var a = e.substr(t, 4),
					o = r(e, t),
					d = e.substr(t + 4 + 4, o);
				(t += 8 + o), (i[a] = i[a] || []), "RIFF" === a || "LIST" === a ? i[a].push(n(d)) : i[a].push(d);
			}
			return i;
		}
		var d = new (function (e) {
			var i = (function (e) {
				if (!e[0])
					return void postMessage({
						error: "Something went wrong. Maybe WebP format is not supported in the current browser.",
					});
				for (var t = e[0].width, i = e[0].height, a = e[0].duration, o = 1; o < e.length; o++)
					a += e[o].duration;
				return { duration: a, width: t, height: i };
			})(e);
			if (!i) return [];
			for (
				var a,
					r = [
						{
							id: 440786851,
							data: [
								{ data: 1, id: 17030 },
								{ data: 1, id: 17143 },
								{ data: 4, id: 17138 },
								{ data: 8, id: 17139 },
								{ data: "webm", id: 17026 },
								{ data: 2, id: 17031 },
								{ data: 2, id: 17029 },
							],
						},
						{
							id: 408125543,
							data: [
								{
									id: 357149030,
									data: [
										{ data: 1e6, id: 2807729 },
										{ data: "whammy", id: 19840 },
										{ data: "whammy", id: 22337 },
										{
											data:
												((a = i.duration),
												[].slice
													.call(new Uint8Array(new Float64Array([a]).buffer), 0)
													.map(function (e) {
														return String.fromCharCode(e);
													})
													.reverse()
													.join("")),
											id: 17545,
										},
									],
								},
								{
									id: 374648427,
									data: [
										{
											id: 174,
											data: [
												{ data: 1, id: 215 },
												{ data: 1, id: 29637 },
												{ data: 0, id: 156 },
												{ data: "und", id: 2274716 },
												{ data: "V_VP8", id: 134 },
												{ data: "VP8", id: 2459272 },
												{ data: 1, id: 131 },
												{
													id: 224,
													data: [
														{ data: i.width, id: 176 },
														{ data: i.height, id: 186 },
													],
												},
											],
										},
									],
								},
							],
						},
					],
					n = 0,
					d = 0;
				n < e.length;

			) {
				var s = [],
					c = 0;
				do {
					s.push(e[n]), (c += e[n].duration), n++;
				} while (n < e.length && c < 3e4);
				var u = { id: 524531317, data: t(d, 0, s) };
				r[1].data.push(u), (d += c);
			}
			return o(r);
		})(
			e.map(function (e) {
				var t = (function (e) {
					for (var t = e.RIFF[0].WEBP[0], i = t.indexOf("Â*"), a = 0, o = []; a < 4; a++)
						o[a] = t.charCodeAt(i + 3 + a);
					return {
						width: 16383 & ((o[1] << 8) | o[0]),
						height: 16383 & ((o[3] << 8) | o[2]),
						data: t,
						riff: e,
					};
				})(n(atob(e.image.slice(23))));
				return (t.duration = e.duration), t;
			})
		);
		postMessage(d);
	}
	return (
		(e.prototype.add = function (e, t) {
			if (
				("canvas" in e && (e = e.canvas),
				"toDataURL" in e && (e = e.toDataURL("image/webp", this.quality)),
				!/^data:image\/webp;base64,/gi.test(e))
			)
				throw "Input must be formatted properly as a base64 encoded DataURI of type image/webp";
			this.frames.push({ image: e, duration: t || this.duration });
		}),
		(e.prototype.compile = function (e) {
			var i,
				a,
				o,
				r =
					((i = t),
					(a = URL.createObjectURL(
						new Blob([i.toString(), "this.onmessage =  function (e) {" + i.name + "(e.data);}"], {
							type: "application/javascript",
						})
					)),
					(o = new Worker(a)),
					URL.revokeObjectURL(a),
					o);
			(r.onmessage = function (t) {
				t.data.error ? console.error(t.data.error) : e(t.data);
			}),
				r.postMessage(this.frames);
		}),
		{ Video: e }
	);
})();
void 0 !== MediaStreamRecorder && (MediaStreamRecorder.Whammy = Whammy),
	(window.ConcatenateBlobs = function (e, t, i) {
		var a = [],
			o = 0;
		!(function r() {
			if (!e[o])
				return (function () {
					var e = 0;
					a.forEach(function (t) {
						e += t.byteLength;
					});
					var o = new Uint16Array(e),
						r = 0;
					a.forEach(function (e) {
						var t = e.byteLength;
						t % 2 != 0 && (e = e.slice(0, t - 1)), o.set(new Uint16Array(e), r), (r += t);
					});
					var n = new Blob([o.buffer], { type: t });
					i(n);
				})();
			var n = new FileReader();
			(n.onload = function (e) {
				a.push(e.target.result), o++, r();
			}),
				n.readAsArrayBuffer(e[o]);
		})();
	}),
	"undefined" != typeof module && (module.exports = MediaStreamRecorder),
	"function" == typeof define &&
		define.amd &&
		define("MediaStreamRecorder", [], function () {
			return MediaStreamRecorder;
		});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!(function (e, t) {
	"object" == typeof exports && "undefined" != typeof module
		? t(exports)
		: "function" == typeof define && define.amd
		? define(["exports"], t)
		: t(((e = e || self).tf = e.tf || {}));
})(this, function (e) {
	"use strict";
	var t =
		"undefined" != typeof globalThis
			? globalThis
			: "undefined" != typeof window
			? window
			: "undefined" != typeof global
			? global
			: "undefined" != typeof self
			? self
			: {};
	function n(e, t) {
		return e((t = { exports: {} }), t.exports), t.exports;
	}
	var r = function (e) {
			return e && e.Math == Math && e;
		},
		a =
			r("object" == typeof globalThis && globalThis) ||
			r("object" == typeof window && window) ||
			r("object" == typeof self && self) ||
			r("object" == typeof t && t) ||
			(function () {
				return this;
			})() ||
			Function("return this")(),
		i = function (e) {
			try {
				return !!e();
			} catch (e) {
				return !0;
			}
		},
		o = !i(function () {
			return (
				7 !=
				Object.defineProperty({}, 1, {
					get: function () {
						return 7;
					},
				})[1]
			);
		}),
		s = {}.propertyIsEnumerable,
		u = Object.getOwnPropertyDescriptor,
		l = {
			f:
				u && !s.call({ 1: 2 }, 1)
					? function (e) {
							var t = u(this, e);
							return !!t && t.enumerable;
					  }
					: s,
		},
		c = function (e, t) {
			return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t };
		},
		p = {}.toString,
		h = function (e) {
			return p.call(e).slice(8, -1);
		},
		f = "".split,
		d = i(function () {
			return !Object("z").propertyIsEnumerable(0);
		})
			? function (e) {
					return "String" == h(e) ? f.call(e, "") : Object(e);
			  }
			: Object,
		m = function (e) {
			if (null == e) throw TypeError("Can't call method on " + e);
			return e;
		},
		g = function (e) {
			return d(m(e));
		},
		v = function (e) {
			return "object" == typeof e ? null !== e : "function" == typeof e;
		},
		y = function (e, t) {
			if (!v(e)) return e;
			var n, r;
			if (t && "function" == typeof (n = e.toString) && !v((r = n.call(e)))) return r;
			if ("function" == typeof (n = e.valueOf) && !v((r = n.call(e)))) return r;
			if (!t && "function" == typeof (n = e.toString) && !v((r = n.call(e)))) return r;
			throw TypeError("Can't convert object to primitive value");
		},
		b = {}.hasOwnProperty,
		x = function (e, t) {
			return b.call(e, t);
		},
		w = a.document,
		k = v(w) && v(w.createElement),
		N = function (e) {
			return k ? w.createElement(e) : {};
		},
		I =
			!o &&
			!i(function () {
				return (
					7 !=
					Object.defineProperty(N("div"), "a", {
						get: function () {
							return 7;
						},
					}).a
				);
			}),
		S = Object.getOwnPropertyDescriptor,
		T = {
			f: o
				? S
				: function (e, t) {
						if (((e = g(e)), (t = y(t, !0)), I))
							try {
								return S(e, t);
							} catch (e) {}
						if (x(e, t)) return c(!l.f.call(e, t), e[t]);
				  },
		},
		C = function (e) {
			if (!v(e)) throw TypeError(String(e) + " is not an object");
			return e;
		},
		E = Object.defineProperty,
		R = {
			f: o
				? E
				: function (e, t, n) {
						if ((C(e), (t = y(t, !0)), C(n), I))
							try {
								return E(e, t, n);
							} catch (e) {}
						if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
						return "value" in n && (e[t] = n.value), e;
				  },
		},
		A = o
			? function (e, t, n) {
					return R.f(e, t, c(1, n));
			  }
			: function (e, t, n) {
					return (e[t] = n), e;
			  },
		_ = function (e, t) {
			try {
				A(a, e, t);
			} catch (n) {
				a[e] = t;
			}
			return t;
		},
		F = "__core-js_shared__",
		D = a[F] || _(F, {}),
		O = Function.toString;
	"function" != typeof D.inspectSource &&
		(D.inspectSource = function (e) {
			return O.call(e);
		});
	var M,
		L,
		z,
		P = D.inspectSource,
		B = a.WeakMap,
		W = "function" == typeof B && /native code/.test(P(B)),
		U = n(function (e) {
			(e.exports = function (e, t) {
				return D[e] || (D[e] = void 0 !== t ? t : {});
			})("versions", []).push({
				version: "3.9.1",
				mode: "global",
				copyright: "Â© 2021 Denis Pushkarev (zloirock.ru)",
			});
		}),
		V = 0,
		G = Math.random(),
		j = function (e) {
			return "Symbol(" + String(void 0 === e ? "" : e) + ")_" + (++V + G).toString(36);
		},
		H = U("keys"),
		q = function (e) {
			return H[e] || (H[e] = j(e));
		},
		K = {},
		X = a.WeakMap;
	if (W) {
		var Y = D.state || (D.state = new X()),
			J = Y.get,
			Z = Y.has,
			Q = Y.set;
		(M = function (e, t) {
			return (t.facade = e), Q.call(Y, e, t), t;
		}),
			(L = function (e) {
				return J.call(Y, e) || {};
			}),
			(z = function (e) {
				return Z.call(Y, e);
			});
	} else {
		var $ = q("state");
		(K[$] = !0),
			(M = function (e, t) {
				return (t.facade = e), A(e, $, t), t;
			}),
			(L = function (e) {
				return x(e, $) ? e[$] : {};
			}),
			(z = function (e) {
				return x(e, $);
			});
	}
	var ee,
		te,
		ne = {
			set: M,
			get: L,
			has: z,
			enforce: function (e) {
				return z(e) ? L(e) : M(e, {});
			},
			getterFor: function (e) {
				return function (t) {
					var n;
					if (!v(t) || (n = L(t)).type !== e) throw TypeError("Incompatible receiver, " + e + " required");
					return n;
				};
			},
		},
		re = n(function (e) {
			var t = ne.get,
				n = ne.enforce,
				r = String(String).split("String");
			(e.exports = function (e, t, i, o) {
				var s,
					u = !!o && !!o.unsafe,
					l = !!o && !!o.enumerable,
					c = !!o && !!o.noTargetGet;
				"function" == typeof i &&
					("string" != typeof t || x(i, "name") || A(i, "name", t),
					(s = n(i)).source || (s.source = r.join("string" == typeof t ? t : ""))),
					e !== a
						? (u ? !c && e[t] && (l = !0) : delete e[t], l ? (e[t] = i) : A(e, t, i))
						: l
						? (e[t] = i)
						: _(t, i);
			})(Function.prototype, "toString", function () {
				return ("function" == typeof this && t(this).source) || P(this);
			});
		}),
		ae = a,
		ie = function (e) {
			return "function" == typeof e ? e : void 0;
		},
		oe = function (e, t) {
			return arguments.length < 2 ? ie(ae[e]) || ie(a[e]) : (ae[e] && ae[e][t]) || (a[e] && a[e][t]);
		},
		se = Math.ceil,
		ue = Math.floor,
		le = function (e) {
			return isNaN((e = +e)) ? 0 : (e > 0 ? ue : se)(e);
		},
		ce = Math.min,
		pe = function (e) {
			return e > 0 ? ce(le(e), 9007199254740991) : 0;
		},
		he = Math.max,
		fe = Math.min,
		de = function (e, t) {
			var n = le(e);
			return n < 0 ? he(n + t, 0) : fe(n, t);
		},
		me = function (e) {
			return function (t, n, r) {
				var a,
					i = g(t),
					o = pe(i.length),
					s = de(r, o);
				if (e && n != n) {
					for (; o > s; ) if ((a = i[s++]) != a) return !0;
				} else for (; o > s; s++) if ((e || s in i) && i[s] === n) return e || s || 0;
				return !e && -1;
			};
		},
		ge = { includes: me(!0), indexOf: me(!1) },
		ve = ge.indexOf,
		ye = function (e, t) {
			var n,
				r = g(e),
				a = 0,
				i = [];
			for (n in r) !x(K, n) && x(r, n) && i.push(n);
			for (; t.length > a; ) x(r, (n = t[a++])) && (~ve(i, n) || i.push(n));
			return i;
		},
		be = [
			"constructor",
			"hasOwnProperty",
			"isPrototypeOf",
			"propertyIsEnumerable",
			"toLocaleString",
			"toString",
			"valueOf",
		],
		xe = be.concat("length", "prototype"),
		we = {
			f:
				Object.getOwnPropertyNames ||
				function (e) {
					return ye(e, xe);
				},
		},
		ke = { f: Object.getOwnPropertySymbols },
		Ne =
			oe("Reflect", "ownKeys") ||
			function (e) {
				var t = we.f(C(e)),
					n = ke.f;
				return n ? t.concat(n(e)) : t;
			},
		Ie = function (e, t) {
			for (var n = Ne(t), r = R.f, a = T.f, i = 0; i < n.length; i++) {
				var o = n[i];
				x(e, o) || r(e, o, a(t, o));
			}
		},
		Se = /#|\.prototype\./,
		Te = function (e, t) {
			var n = Ee[Ce(e)];
			return n == Ae || (n != Re && ("function" == typeof t ? i(t) : !!t));
		},
		Ce = (Te.normalize = function (e) {
			return String(e).replace(Se, ".").toLowerCase();
		}),
		Ee = (Te.data = {}),
		Re = (Te.NATIVE = "N"),
		Ae = (Te.POLYFILL = "P"),
		_e = Te,
		Fe = T.f,
		De = function (e, t) {
			var n,
				r,
				i,
				o,
				s,
				u = e.target,
				l = e.global,
				c = e.stat;
			if ((n = l ? a : c ? a[u] || _(u, {}) : (a[u] || {}).prototype))
				for (r in t) {
					if (
						((o = t[r]),
						(i = e.noTargetGet ? (s = Fe(n, r)) && s.value : n[r]),
						!_e(l ? r : u + (c ? "." : "#") + r, e.forced) && void 0 !== i)
					) {
						if (typeof o == typeof i) continue;
						Ie(o, i);
					}
					(e.sham || (i && i.sham)) && A(o, "sham", !0), re(n, r, o, e);
				}
		},
		Oe = "process" == h(a.process),
		Me = oe("navigator", "userAgent") || "",
		Le = a.process,
		ze = Le && Le.versions,
		Pe = ze && ze.v8;
	Pe
		? (te = (ee = Pe.split("."))[0] + ee[1])
		: Me && (!(ee = Me.match(/Edge\/(\d+)/)) || ee[1] >= 74) && (ee = Me.match(/Chrome\/(\d+)/)) && (te = ee[1]);
	var Be,
		We = te && +te,
		Ue =
			!!Object.getOwnPropertySymbols &&
			!i(function () {
				return !Symbol.sham && (Oe ? 38 === We : We > 37 && We < 41);
			}),
		Ve = Ue && !Symbol.sham && "symbol" == typeof Symbol.iterator,
		Ge =
			Array.isArray ||
			function (e) {
				return "Array" == h(e);
			},
		je = function (e) {
			return Object(m(e));
		},
		He =
			Object.keys ||
			function (e) {
				return ye(e, be);
			},
		qe = o
			? Object.defineProperties
			: function (e, t) {
					C(e);
					for (var n, r = He(t), a = r.length, i = 0; a > i; ) R.f(e, (n = r[i++]), t[n]);
					return e;
			  },
		Ke = oe("document", "documentElement"),
		Xe = q("IE_PROTO"),
		Ye = function () {},
		Je = function (e) {
			return "<script>" + e + "</script>";
		},
		Ze = function () {
			try {
				Be = document.domain && new ActiveXObject("htmlfile");
			} catch (e) {}
			var e, t;
			Ze = Be
				? (function (e) {
						e.write(Je("")), e.close();
						var t = e.parentWindow.Object;
						return (e = null), t;
				  })(Be)
				: (((t = N("iframe")).style.display = "none"),
				  Ke.appendChild(t),
				  (t.src = String("javascript:")),
				  (e = t.contentWindow.document).open(),
				  e.write(Je("document.F=Object")),
				  e.close(),
				  e.F);
			for (var n = be.length; n--; ) delete Ze.prototype[be[n]];
			return Ze();
		};
	K[Xe] = !0;
	var Qe =
			Object.create ||
			function (e, t) {
				var n;
				return (
					null !== e
						? ((Ye.prototype = C(e)), (n = new Ye()), (Ye.prototype = null), (n[Xe] = e))
						: (n = Ze()),
					void 0 === t ? n : qe(n, t)
				);
			},
		$e = we.f,
		et = {}.toString,
		tt =
			"object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
		nt = {
			f: function (e) {
				return tt && "[object Window]" == et.call(e)
					? (function (e) {
							try {
								return $e(e);
							} catch (e) {
								return tt.slice();
							}
					  })(e)
					: $e(g(e));
			},
		},
		rt = U("wks"),
		at = a.Symbol,
		it = Ve ? at : (at && at.withoutSetter) || j,
		ot = function (e) {
			return (
				(x(rt, e) && (Ue || "string" == typeof rt[e])) ||
					(Ue && x(at, e) ? (rt[e] = at[e]) : (rt[e] = it("Symbol." + e))),
				rt[e]
			);
		},
		st = { f: ot },
		ut = R.f,
		lt = function (e) {
			var t = ae.Symbol || (ae.Symbol = {});
			x(t, e) || ut(t, e, { value: st.f(e) });
		},
		ct = R.f,
		pt = ot("toStringTag"),
		ht = function (e, t, n) {
			e && !x((e = n ? e : e.prototype), pt) && ct(e, pt, { configurable: !0, value: t });
		},
		ft = function (e) {
			if ("function" != typeof e) throw TypeError(String(e) + " is not a function");
			return e;
		},
		dt = function (e, t, n) {
			if ((ft(e), void 0 === t)) return e;
			switch (n) {
				case 0:
					return function () {
						return e.call(t);
					};
				case 1:
					return function (n) {
						return e.call(t, n);
					};
				case 2:
					return function (n, r) {
						return e.call(t, n, r);
					};
				case 3:
					return function (n, r, a) {
						return e.call(t, n, r, a);
					};
			}
			return function () {
				return e.apply(t, arguments);
			};
		},
		mt = ot("species"),
		gt = function (e, t) {
			var n;
			return (
				Ge(e) &&
					("function" != typeof (n = e.constructor) || (n !== Array && !Ge(n.prototype))
						? v(n) && null === (n = n[mt]) && (n = void 0)
						: (n = void 0)),
				new (void 0 === n ? Array : n)(0 === t ? 0 : t)
			);
		},
		vt = [].push,
		yt = function (e) {
			var t = 1 == e,
				n = 2 == e,
				r = 3 == e,
				a = 4 == e,
				i = 6 == e,
				o = 7 == e,
				s = 5 == e || i;
			return function (u, l, c, p) {
				for (
					var h,
						f,
						m = je(u),
						g = d(m),
						v = dt(l, c, 3),
						y = pe(g.length),
						b = 0,
						x = p || gt,
						w = t ? x(u, y) : n || o ? x(u, 0) : void 0;
					y > b;
					b++
				)
					if ((s || b in g) && ((f = v((h = g[b]), b, m)), e))
						if (t) w[b] = f;
						else if (f)
							switch (e) {
								case 3:
									return !0;
								case 5:
									return h;
								case 6:
									return b;
								case 2:
									vt.call(w, h);
							}
						else
							switch (e) {
								case 4:
									return !1;
								case 7:
									vt.call(w, h);
							}
				return i ? -1 : r || a ? a : w;
			};
		},
		bt = {
			forEach: yt(0),
			map: yt(1),
			filter: yt(2),
			some: yt(3),
			every: yt(4),
			find: yt(5),
			findIndex: yt(6),
			filterOut: yt(7),
		},
		xt = bt.forEach,
		wt = q("hidden"),
		kt = "Symbol",
		Nt = ot("toPrimitive"),
		It = ne.set,
		St = ne.getterFor(kt),
		Tt = Object.prototype,
		Ct = a.Symbol,
		Et = oe("JSON", "stringify"),
		Rt = T.f,
		At = R.f,
		_t = nt.f,
		Ft = l.f,
		Dt = U("symbols"),
		Ot = U("op-symbols"),
		Mt = U("string-to-symbol-registry"),
		Lt = U("symbol-to-string-registry"),
		zt = U("wks"),
		Pt = a.QObject,
		Bt = !Pt || !Pt.prototype || !Pt.prototype.findChild,
		Wt =
			o &&
			i(function () {
				return (
					7 !=
					Qe(
						At({}, "a", {
							get: function () {
								return At(this, "a", { value: 7 }).a;
							},
						})
					).a
				);
			})
				? function (e, t, n) {
						var r = Rt(Tt, t);
						r && delete Tt[t], At(e, t, n), r && e !== Tt && At(Tt, t, r);
				  }
				: At,
		Ut = function (e, t) {
			var n = (Dt[e] = Qe(Ct.prototype));
			return It(n, { type: kt, tag: e, description: t }), o || (n.description = t), n;
		},
		Vt = Ve
			? function (e) {
					return "symbol" == typeof e;
			  }
			: function (e) {
					return Object(e) instanceof Ct;
			  },
		Gt = function (e, t, n) {
			e === Tt && Gt(Ot, t, n), C(e);
			var r = y(t, !0);
			return (
				C(n),
				x(Dt, r)
					? (n.enumerable
							? (x(e, wt) && e[wt][r] && (e[wt][r] = !1), (n = Qe(n, { enumerable: c(0, !1) })))
							: (x(e, wt) || At(e, wt, c(1, {})), (e[wt][r] = !0)),
					  Wt(e, r, n))
					: At(e, r, n)
			);
		},
		jt = function (e, t) {
			C(e);
			var n = g(t),
				r = He(n).concat(Xt(n));
			return (
				xt(r, function (t) {
					(o && !Ht.call(n, t)) || Gt(e, t, n[t]);
				}),
				e
			);
		},
		Ht = function (e) {
			var t = y(e, !0),
				n = Ft.call(this, t);
			return (
				!(this === Tt && x(Dt, t) && !x(Ot, t)) &&
				(!(n || !x(this, t) || !x(Dt, t) || (x(this, wt) && this[wt][t])) || n)
			);
		},
		qt = function (e, t) {
			var n = g(e),
				r = y(t, !0);
			if (n !== Tt || !x(Dt, r) || x(Ot, r)) {
				var a = Rt(n, r);
				return !a || !x(Dt, r) || (x(n, wt) && n[wt][r]) || (a.enumerable = !0), a;
			}
		},
		Kt = function (e) {
			var t = _t(g(e)),
				n = [];
			return (
				xt(t, function (e) {
					x(Dt, e) || x(K, e) || n.push(e);
				}),
				n
			);
		},
		Xt = function (e) {
			var t = e === Tt,
				n = _t(t ? Ot : g(e)),
				r = [];
			return (
				xt(n, function (e) {
					!x(Dt, e) || (t && !x(Tt, e)) || r.push(Dt[e]);
				}),
				r
			);
		};
	if (
		(Ue ||
			(re(
				(Ct = function () {
					if (this instanceof Ct) throw TypeError("Symbol is not a constructor");
					var e = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0,
						t = j(e),
						n = function e(n) {
							this === Tt && e.call(Ot, n),
								x(this, wt) && x(this[wt], t) && (this[wt][t] = !1),
								Wt(this, t, c(1, n));
						};
					return o && Bt && Wt(Tt, t, { configurable: !0, set: n }), Ut(t, e);
				}).prototype,
				"toString",
				function () {
					return St(this).tag;
				}
			),
			re(Ct, "withoutSetter", function (e) {
				return Ut(j(e), e);
			}),
			(l.f = Ht),
			(R.f = Gt),
			(T.f = qt),
			(we.f = nt.f = Kt),
			(ke.f = Xt),
			(st.f = function (e) {
				return Ut(ot(e), e);
			}),
			o &&
				(At(Ct.prototype, "description", {
					configurable: !0,
					get: function () {
						return St(this).description;
					},
				}),
				re(Tt, "propertyIsEnumerable", Ht, { unsafe: !0 }))),
		De({ global: !0, wrap: !0, forced: !Ue, sham: !Ue }, { Symbol: Ct }),
		xt(He(zt), function (e) {
			lt(e);
		}),
		De(
			{ target: kt, stat: !0, forced: !Ue },
			{
				for: function (e) {
					var t = String(e);
					if (x(Mt, t)) return Mt[t];
					var n = Ct(t);
					return (Mt[t] = n), (Lt[n] = t), n;
				},
				keyFor: function (e) {
					if (!Vt(e)) throw TypeError(e + " is not a symbol");
					if (x(Lt, e)) return Lt[e];
				},
				useSetter: function () {
					Bt = !0;
				},
				useSimple: function () {
					Bt = !1;
				},
			}
		),
		De(
			{ target: "Object", stat: !0, forced: !Ue, sham: !o },
			{
				create: function (e, t) {
					return void 0 === t ? Qe(e) : jt(Qe(e), t);
				},
				defineProperty: Gt,
				defineProperties: jt,
				getOwnPropertyDescriptor: qt,
			}
		),
		De({ target: "Object", stat: !0, forced: !Ue }, { getOwnPropertyNames: Kt, getOwnPropertySymbols: Xt }),
		De(
			{
				target: "Object",
				stat: !0,
				forced: i(function () {
					ke.f(1);
				}),
			},
			{
				getOwnPropertySymbols: function (e) {
					return ke.f(je(e));
				},
			}
		),
		Et)
	) {
		var Yt =
			!Ue ||
			i(function () {
				var e = Ct();
				return "[null]" != Et([e]) || "{}" != Et({ a: e }) || "{}" != Et(Object(e));
			});
		De(
			{ target: "JSON", stat: !0, forced: Yt },
			{
				stringify: function (e, t, n) {
					for (var r, a = [e], i = 1; arguments.length > i; ) a.push(arguments[i++]);
					if (((r = t), (v(t) || void 0 !== e) && !Vt(e)))
						return (
							Ge(t) ||
								(t = function (e, t) {
									if (("function" == typeof r && (t = r.call(this, e, t)), !Vt(t))) return t;
								}),
							(a[1] = t),
							Et.apply(null, a)
						);
				},
			}
		);
	}
	Ct.prototype[Nt] || A(Ct.prototype, Nt, Ct.prototype.valueOf), ht(Ct, kt), (K[wt] = !0), lt("asyncIterator");
	var Jt = R.f,
		Zt = a.Symbol;
	if (o && "function" == typeof Zt && (!("description" in Zt.prototype) || void 0 !== Zt().description)) {
		var Qt = {},
			$t = function () {
				var e = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]),
					t = this instanceof $t ? new Zt(e) : void 0 === e ? Zt() : Zt(e);
				return "" === e && (Qt[t] = !0), t;
			};
		Ie($t, Zt);
		var en = ($t.prototype = Zt.prototype);
		en.constructor = $t;
		var tn = en.toString,
			nn = "Symbol(test)" == String(Zt("test")),
			rn = /^Symbol\((.*)\)[^)]+$/;
		Jt(en, "description", {
			configurable: !0,
			get: function () {
				var e = v(this) ? this.valueOf() : this,
					t = tn.call(e);
				if (x(Qt, e)) return "";
				var n = nn ? t.slice(7, -1) : t.replace(rn, "$1");
				return "" === n ? void 0 : n;
			},
		}),
			De({ global: !0, forced: !0 }, { Symbol: $t });
	}
	lt("hasInstance"),
		lt("isConcatSpreadable"),
		lt("iterator"),
		lt("match"),
		lt("matchAll"),
		lt("replace"),
		lt("search"),
		lt("species"),
		lt("split"),
		lt("toPrimitive"),
		lt("toStringTag"),
		lt("unscopables");
	var an = !i(function () {
			function e() {}
			return (e.prototype.constructor = null), Object.getPrototypeOf(new e()) !== e.prototype;
		}),
		on = q("IE_PROTO"),
		sn = Object.prototype,
		un = an
			? Object.getPrototypeOf
			: function (e) {
					return (
						(e = je(e)),
						x(e, on)
							? e[on]
							: "function" == typeof e.constructor && e instanceof e.constructor
							? e.constructor.prototype
							: e instanceof Object
							? sn
							: null
					);
			  },
		ln = function (e) {
			if (!v(e) && null !== e) throw TypeError("Can't set " + String(e) + " as a prototype");
			return e;
		},
		cn =
			Object.setPrototypeOf ||
			("__proto__" in {}
				? (function () {
						var e,
							t = !1,
							n = {};
						try {
							(e = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []),
								(t = n instanceof Array);
						} catch (e) {}
						return function (n, r) {
							return C(n), ln(r), t ? e.call(n, r) : (n.__proto__ = r), n;
						};
				  })()
				: void 0),
		pn = {},
		hn = ot("iterator"),
		fn = Array.prototype,
		dn = function (e) {
			return void 0 !== e && (pn.Array === e || fn[hn] === e);
		},
		mn = {};
	mn[ot("toStringTag")] = "z";
	var gn = "[object z]" === String(mn),
		vn = ot("toStringTag"),
		yn =
			"Arguments" ==
			h(
				(function () {
					return arguments;
				})()
			),
		bn = gn
			? h
			: function (e) {
					var t, n, r;
					return void 0 === e
						? "Undefined"
						: null === e
						? "Null"
						: "string" ==
						  typeof (n = (function (e, t) {
								try {
									return e[t];
								} catch (e) {}
						  })((t = Object(e)), vn))
						? n
						: yn
						? h(t)
						: "Object" == (r = h(t)) && "function" == typeof t.callee
						? "Arguments"
						: r;
			  },
		xn = ot("iterator"),
		wn = function (e) {
			if (null != e) return e[xn] || e["@@iterator"] || pn[bn(e)];
		},
		kn = function (e) {
			var t = e.return;
			if (void 0 !== t) return C(t.call(e)).value;
		},
		Nn = function (e, t) {
			(this.stopped = e), (this.result = t);
		},
		In = function (e, t, n) {
			var r,
				a,
				i,
				o,
				s,
				u,
				l,
				c = n && n.that,
				p = !(!n || !n.AS_ENTRIES),
				h = !(!n || !n.IS_ITERATOR),
				f = !(!n || !n.INTERRUPTED),
				d = dt(t, c, 1 + p + f),
				m = function (e) {
					return r && kn(r), new Nn(!0, e);
				},
				g = function (e) {
					return p ? (C(e), f ? d(e[0], e[1], m) : d(e[0], e[1])) : f ? d(e, m) : d(e);
				};
			if (h) r = e;
			else {
				if ("function" != typeof (a = wn(e))) throw TypeError("Target is not iterable");
				if (dn(a)) {
					for (i = 0, o = pe(e.length); o > i; i++) if ((s = g(e[i])) && s instanceof Nn) return s;
					return new Nn(!1);
				}
				r = a.call(e);
			}
			for (u = r.next; !(l = u.call(r)).done; ) {
				try {
					s = g(l.value);
				} catch (e) {
					throw (kn(r), e);
				}
				if ("object" == typeof s && s && s instanceof Nn) return s;
			}
			return new Nn(!1);
		},
		Sn = function (e, t) {
			var n = this;
			if (!(n instanceof Sn)) return new Sn(e, t);
			cn && (n = cn(new Error(void 0), un(n))), void 0 !== t && A(n, "message", String(t));
			var r = [];
			return In(e, r.push, { that: r }), A(n, "errors", r), n;
		};
	(Sn.prototype = Qe(Error.prototype, { constructor: c(5, Sn), message: c(5, ""), name: c(5, "AggregateError") })),
		De({ global: !0 }, { AggregateError: Sn });
	var Tn = function (e, t, n, r) {
			try {
				return r ? t(C(n)[0], n[1]) : t(n);
			} catch (t) {
				throw (kn(e), t);
			}
		},
		Cn = function (e, t, n) {
			var r = y(t);
			r in e ? R.f(e, r, c(0, n)) : (e[r] = n);
		},
		En = function (e) {
			var t,
				n,
				r,
				a,
				i,
				o,
				s = je(e),
				u = "function" == typeof this ? this : Array,
				l = arguments.length,
				c = l > 1 ? arguments[1] : void 0,
				p = void 0 !== c,
				h = wn(s),
				f = 0;
			if ((p && (c = dt(c, l > 2 ? arguments[2] : void 0, 2)), null == h || (u == Array && dn(h))))
				for (n = new u((t = pe(s.length))); t > f; f++) (o = p ? c(s[f], f) : s[f]), Cn(n, f, o);
			else
				for (i = (a = h.call(s)).next, n = new u(); !(r = i.call(a)).done; f++)
					(o = p ? Tn(a, c, [r.value, f], !0) : r.value), Cn(n, f, o);
			return (n.length = f), n;
		},
		Rn = ot("iterator"),
		An = !1;
	try {
		var _n = 0,
			Fn = {
				next: function () {
					return { done: !!_n++ };
				},
				return: function () {
					An = !0;
				},
			};
		(Fn[Rn] = function () {
			return this;
		}),
			Array.from(Fn, function () {
				throw 2;
			});
	} catch (e) {}
	var Dn = function (e, t) {
			if (!t && !An) return !1;
			var n = !1;
			try {
				var r = {};
				(r[Rn] = function () {
					return {
						next: function () {
							return { done: (n = !0) };
						},
					};
				}),
					e(r);
			} catch (e) {}
			return n;
		},
		On = !Dn(function (e) {
			Array.from(e);
		});
	De({ target: "Array", stat: !0, forced: On }, { from: En }), De({ target: "Array", stat: !0 }, { isArray: Ge });
	var Mn = i(function () {
		function e() {}
		return !(Array.of.call(e) instanceof e);
	});
	De(
		{ target: "Array", stat: !0, forced: Mn },
		{
			of: function () {
				for (var e = 0, t = arguments.length, n = new ("function" == typeof this ? this : Array)(t); t > e; )
					Cn(n, e, arguments[e++]);
				return (n.length = t), n;
			},
		}
	);
	var Ln = ot("species"),
		zn = function (e) {
			return (
				We >= 51 ||
				!i(function () {
					var t = [];
					return (
						((t.constructor = {})[Ln] = function () {
							return { foo: 1 };
						}),
						1 !== t[e](Boolean).foo
					);
				})
			);
		},
		Pn = ot("isConcatSpreadable"),
		Bn = 9007199254740991,
		Wn = "Maximum allowed index exceeded",
		Un =
			We >= 51 ||
			!i(function () {
				var e = [];
				return (e[Pn] = !1), e.concat()[0] !== e;
			}),
		Vn = zn("concat"),
		Gn = function (e) {
			if (!v(e)) return !1;
			var t = e[Pn];
			return void 0 !== t ? !!t : Ge(e);
		};
	De(
		{ target: "Array", proto: !0, forced: !Un || !Vn },
		{
			concat: function (e) {
				var t,
					n,
					r,
					a,
					i,
					o = je(this),
					s = gt(o, 0),
					u = 0;
				for (t = -1, r = arguments.length; t < r; t++)
					if (Gn((i = -1 === t ? o : arguments[t]))) {
						if (u + (a = pe(i.length)) > Bn) throw TypeError(Wn);
						for (n = 0; n < a; n++, u++) n in i && Cn(s, u, i[n]);
					} else {
						if (u >= Bn) throw TypeError(Wn);
						Cn(s, u++, i);
					}
				return (s.length = u), s;
			},
		}
	);
	var jn = Math.min,
		Hn =
			[].copyWithin ||
			function (e, t) {
				var n = je(this),
					r = pe(n.length),
					a = de(e, r),
					i = de(t, r),
					o = arguments.length > 2 ? arguments[2] : void 0,
					s = jn((void 0 === o ? r : de(o, r)) - i, r - a),
					u = 1;
				for (i < a && a < i + s && ((u = -1), (i += s - 1), (a += s - 1)); s-- > 0; )
					i in n ? (n[a] = n[i]) : delete n[a], (a += u), (i += u);
				return n;
			},
		qn = ot("unscopables"),
		Kn = Array.prototype;
	null == Kn[qn] && R.f(Kn, qn, { configurable: !0, value: Qe(null) });
	var Xn = function (e) {
		Kn[qn][e] = !0;
	};
	De({ target: "Array", proto: !0 }, { copyWithin: Hn }), Xn("copyWithin");
	var Yn = function (e, t) {
			var n = [][e];
			return (
				!!n &&
				i(function () {
					n.call(
						null,
						t ||
							function () {
								throw 1;
							},
						1
					);
				})
			);
		},
		Jn = bt.every,
		Zn = Yn("every");
	De(
		{ target: "Array", proto: !0, forced: !Zn },
		{
			every: function (e) {
				return Jn(this, e, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	);
	var Qn = function (e) {
		for (
			var t = je(this),
				n = pe(t.length),
				r = arguments.length,
				a = de(r > 1 ? arguments[1] : void 0, n),
				i = r > 2 ? arguments[2] : void 0,
				o = void 0 === i ? n : de(i, n);
			o > a;

		)
			t[a++] = e;
		return t;
	};
	De({ target: "Array", proto: !0 }, { fill: Qn }), Xn("fill");
	var $n = bt.filter,
		er = zn("filter");
	De(
		{ target: "Array", proto: !0, forced: !er },
		{
			filter: function (e) {
				return $n(this, e, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	);
	var tr = bt.find,
		nr = "find",
		rr = !0;
	nr in [] &&
		Array(1).find(function () {
			rr = !1;
		}),
		De(
			{ target: "Array", proto: !0, forced: rr },
			{
				find: function (e) {
					return tr(this, e, arguments.length > 1 ? arguments[1] : void 0);
				},
			}
		),
		Xn(nr);
	var ar = bt.findIndex,
		ir = "findIndex",
		or = !0;
	ir in [] &&
		Array(1).findIndex(function () {
			or = !1;
		}),
		De(
			{ target: "Array", proto: !0, forced: or },
			{
				findIndex: function (e) {
					return ar(this, e, arguments.length > 1 ? arguments[1] : void 0);
				},
			}
		),
		Xn(ir);
	var sr = function e(t, n, r, a, i, o, s, u) {
		for (var l, c = i, p = 0, h = !!s && dt(s, u, 3); p < a; ) {
			if (p in r) {
				if (((l = h ? h(r[p], p, n) : r[p]), o > 0 && Ge(l))) c = e(t, n, l, pe(l.length), c, o - 1) - 1;
				else {
					if (c >= 9007199254740991) throw TypeError("Exceed the acceptable array length");
					t[c] = l;
				}
				c++;
			}
			p++;
		}
		return c;
	};
	De(
		{ target: "Array", proto: !0 },
		{
			flat: function () {
				var e = arguments.length ? arguments[0] : void 0,
					t = je(this),
					n = pe(t.length),
					r = gt(t, 0);
				return (r.length = sr(r, t, t, n, 0, void 0 === e ? 1 : le(e))), r;
			},
		}
	),
		De(
			{ target: "Array", proto: !0 },
			{
				flatMap: function (e) {
					var t,
						n = je(this),
						r = pe(n.length);
					return (
						ft(e),
						((t = gt(n, 0)).length = sr(t, n, n, r, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0)),
						t
					);
				},
			}
		);
	var ur = bt.forEach,
		lr = Yn("forEach")
			? [].forEach
			: function (e) {
					return ur(this, e, arguments.length > 1 ? arguments[1] : void 0);
			  };
	De({ target: "Array", proto: !0, forced: [].forEach != lr }, { forEach: lr });
	var cr = ge.includes;
	De(
		{ target: "Array", proto: !0 },
		{
			includes: function (e) {
				return cr(this, e, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	),
		Xn("includes");
	var pr = ge.indexOf,
		hr = [].indexOf,
		fr = !!hr && 1 / [1].indexOf(1, -0) < 0,
		dr = Yn("indexOf");
	De(
		{ target: "Array", proto: !0, forced: fr || !dr },
		{
			indexOf: function (e) {
				return fr ? hr.apply(this, arguments) || 0 : pr(this, e, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	);
	var mr = [].join,
		gr = d != Object,
		vr = Yn("join", ",");
	De(
		{ target: "Array", proto: !0, forced: gr || !vr },
		{
			join: function (e) {
				return mr.call(g(this), void 0 === e ? "," : e);
			},
		}
	);
	var yr = Math.min,
		br = [].lastIndexOf,
		xr = !!br && 1 / [1].lastIndexOf(1, -0) < 0,
		wr = Yn("lastIndexOf"),
		kr =
			xr || !wr
				? function (e) {
						if (xr) return br.apply(this, arguments) || 0;
						var t = g(this),
							n = pe(t.length),
							r = n - 1;
						for (arguments.length > 1 && (r = yr(r, le(arguments[1]))), r < 0 && (r = n + r); r >= 0; r--)
							if (r in t && t[r] === e) return r || 0;
						return -1;
				  }
				: br;
	De({ target: "Array", proto: !0, forced: kr !== [].lastIndexOf }, { lastIndexOf: kr });
	var Nr = bt.map,
		Ir = zn("map");
	De(
		{ target: "Array", proto: !0, forced: !Ir },
		{
			map: function (e) {
				return Nr(this, e, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	);
	var Sr = function (e) {
			return function (t, n, r, a) {
				ft(n);
				var i = je(t),
					o = d(i),
					s = pe(i.length),
					u = e ? s - 1 : 0,
					l = e ? -1 : 1;
				if (r < 2)
					for (;;) {
						if (u in o) {
							(a = o[u]), (u += l);
							break;
						}
						if (((u += l), e ? u < 0 : s <= u))
							throw TypeError("Reduce of empty array with no initial value");
					}
				for (; e ? u >= 0 : s > u; u += l) u in o && (a = n(a, o[u], u, i));
				return a;
			};
		},
		Tr = { left: Sr(!1), right: Sr(!0) },
		Cr = Tr.left,
		Er = Yn("reduce");
	De(
		{ target: "Array", proto: !0, forced: !Er || (!Oe && We > 79 && We < 83) },
		{
			reduce: function (e) {
				return Cr(this, e, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	);
	var Rr = Tr.right,
		Ar = Yn("reduceRight");
	De(
		{ target: "Array", proto: !0, forced: !Ar || (!Oe && We > 79 && We < 83) },
		{
			reduceRight: function (e) {
				return Rr(this, e, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	);
	var _r = [].reverse,
		Fr = [1, 2];
	De(
		{ target: "Array", proto: !0, forced: String(Fr) === String(Fr.reverse()) },
		{
			reverse: function () {
				return Ge(this) && (this.length = this.length), _r.call(this);
			},
		}
	);
	var Dr = zn("slice"),
		Or = ot("species"),
		Mr = [].slice,
		Lr = Math.max;
	De(
		{ target: "Array", proto: !0, forced: !Dr },
		{
			slice: function (e, t) {
				var n,
					r,
					a,
					i = g(this),
					o = pe(i.length),
					s = de(e, o),
					u = de(void 0 === t ? o : t, o);
				if (
					Ge(i) &&
					("function" != typeof (n = i.constructor) || (n !== Array && !Ge(n.prototype))
						? v(n) && null === (n = n[Or]) && (n = void 0)
						: (n = void 0),
					n === Array || void 0 === n)
				)
					return Mr.call(i, s, u);
				for (r = new (void 0 === n ? Array : n)(Lr(u - s, 0)), a = 0; s < u; s++, a++) s in i && Cn(r, a, i[s]);
				return (r.length = a), r;
			},
		}
	);
	var zr = bt.some,
		Pr = Yn("some");
	De(
		{ target: "Array", proto: !0, forced: !Pr },
		{
			some: function (e) {
				return zr(this, e, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	);
	var Br = [],
		Wr = Br.sort,
		Ur = i(function () {
			Br.sort(void 0);
		}),
		Vr = i(function () {
			Br.sort(null);
		}),
		Gr = Yn("sort");
	De(
		{ target: "Array", proto: !0, forced: Ur || !Vr || !Gr },
		{
			sort: function (e) {
				return void 0 === e ? Wr.call(je(this)) : Wr.call(je(this), ft(e));
			},
		}
	);
	var jr = zn("splice"),
		Hr = Math.max,
		qr = Math.min,
		Kr = 9007199254740991,
		Xr = "Maximum allowed length exceeded";
	De(
		{ target: "Array", proto: !0, forced: !jr },
		{
			splice: function (e, t) {
				var n,
					r,
					a,
					i,
					o,
					s,
					u = je(this),
					l = pe(u.length),
					c = de(e, l),
					p = arguments.length;
				if (
					(0 === p
						? (n = r = 0)
						: 1 === p
						? ((n = 0), (r = l - c))
						: ((n = p - 2), (r = qr(Hr(le(t), 0), l - c))),
					l + n - r > Kr)
				)
					throw TypeError(Xr);
				for (a = gt(u, r), i = 0; i < r; i++) (o = c + i) in u && Cn(a, i, u[o]);
				if (((a.length = r), n < r)) {
					for (i = c; i < l - r; i++) (s = i + n), (o = i + r) in u ? (u[s] = u[o]) : delete u[s];
					for (i = l; i > l - r + n; i--) delete u[i - 1];
				} else if (n > r)
					for (i = l - r; i > c; i--) (s = i + n - 1), (o = i + r - 1) in u ? (u[s] = u[o]) : delete u[s];
				for (i = 0; i < n; i++) u[i + c] = arguments[i + 2];
				return (u.length = l - r + n), a;
			},
		}
	);
	var Yr = ot("species"),
		Jr = function (e) {
			var t = oe(e),
				n = R.f;
			o &&
				t &&
				!t[Yr] &&
				n(t, Yr, {
					configurable: !0,
					get: function () {
						return this;
					},
				});
		};
	Jr("Array"), Xn("flat"), Xn("flatMap");
	var Zr,
		Qr,
		$r,
		ea = ot("iterator"),
		ta = !1;
	[].keys && ("next" in ($r = [].keys()) ? (Qr = un(un($r))) !== Object.prototype && (Zr = Qr) : (ta = !0));
	var na =
		null == Zr ||
		i(function () {
			var e = {};
			return Zr[ea].call(e) !== e;
		});
	na && (Zr = {}),
		x(Zr, ea) ||
			A(Zr, ea, function () {
				return this;
			});
	var ra = { IteratorPrototype: Zr, BUGGY_SAFARI_ITERATORS: ta },
		aa = ra.IteratorPrototype,
		ia = function () {
			return this;
		},
		oa = function (e, t, n) {
			var r = t + " Iterator";
			return (e.prototype = Qe(aa, { next: c(1, n) })), ht(e, r, !1), (pn[r] = ia), e;
		},
		sa = ra.IteratorPrototype,
		ua = ra.BUGGY_SAFARI_ITERATORS,
		la = ot("iterator"),
		ca = "keys",
		pa = "values",
		ha = "entries",
		fa = function () {
			return this;
		},
		da = function (e, t, n, r, a, i, o) {
			oa(n, t, r);
			var s,
				u,
				l,
				c = function (e) {
					if (e === a && m) return m;
					if (!ua && e in f) return f[e];
					switch (e) {
						case ca:
						case pa:
						case ha:
							return function () {
								return new n(this, e);
							};
					}
					return function () {
						return new n(this);
					};
				},
				p = t + " Iterator",
				h = !1,
				f = e.prototype,
				d = f[la] || f["@@iterator"] || (a && f[a]),
				m = (!ua && d) || c(a),
				g = ("Array" == t && f.entries) || d;
			if (
				(g &&
					((s = un(g.call(new e()))),
					sa !== Object.prototype &&
						s.next &&
						(un(s) !== sa && (cn ? cn(s, sa) : "function" != typeof s[la] && A(s, la, fa)), ht(s, p, !0))),
				a == pa &&
					d &&
					d.name !== pa &&
					((h = !0),
					(m = function () {
						return d.call(this);
					})),
				f[la] !== m && A(f, la, m),
				(pn[t] = m),
				a)
			)
				if (((u = { values: c(pa), keys: i ? m : c(ca), entries: c(ha) }), o))
					for (l in u) (ua || h || !(l in f)) && re(f, l, u[l]);
				else De({ target: t, proto: !0, forced: ua || h }, u);
			return u;
		},
		ma = "Array Iterator",
		ga = ne.set,
		va = ne.getterFor(ma),
		ya = da(
			Array,
			"Array",
			function (e, t) {
				ga(this, { type: ma, target: g(e), index: 0, kind: t });
			},
			function () {
				var e = va(this),
					t = e.target,
					n = e.kind,
					r = e.index++;
				return !t || r >= t.length
					? ((e.target = void 0), { value: void 0, done: !0 })
					: "keys" == n
					? { value: r, done: !1 }
					: "values" == n
					? { value: t[r], done: !1 }
					: { value: [r, t[r]], done: !1 };
			},
			"values"
		);
	(pn.Arguments = pn.Array), Xn("keys"), Xn("values"), Xn("entries");
	var ba = [].slice,
		xa = {},
		wa = function (e, t, n) {
			if (!(t in xa)) {
				for (var r = [], a = 0; a < t; a++) r[a] = "a[" + a + "]";
				xa[t] = Function("C,a", "return new C(" + r.join(",") + ")");
			}
			return xa[t](e, n);
		},
		ka =
			Function.bind ||
			function (e) {
				var t = ft(this),
					n = ba.call(arguments, 1),
					r = function () {
						var a = n.concat(ba.call(arguments));
						return this instanceof r ? wa(t, a.length, a) : t.apply(e, a);
					};
				return v(t.prototype) && (r.prototype = t.prototype), r;
			};
	De({ target: "Function", proto: !0 }, { bind: ka });
	var Na = R.f,
		Ia = Function.prototype,
		Sa = Ia.toString,
		Ta = /^\s*function ([^ (]*)/,
		Ca = "name";
	o &&
		!(Ca in Ia) &&
		Na(Ia, Ca, {
			configurable: !0,
			get: function () {
				try {
					return Sa.call(this).match(Ta)[1];
				} catch (e) {
					return "";
				}
			},
		});
	var Ea = ot("hasInstance"),
		Ra = Function.prototype;
	Ea in Ra ||
		R.f(Ra, Ea, {
			value: function (e) {
				if ("function" != typeof this || !v(e)) return !1;
				if (!v(this.prototype)) return e instanceof this;
				for (; (e = un(e)); ) if (this.prototype === e) return !0;
				return !1;
			},
		}),
		De({ global: !0 }, { globalThis: a });
	var Aa = Object.assign,
		_a = Object.defineProperty,
		Fa =
			!Aa ||
			i(function () {
				if (
					o &&
					1 !==
						Aa(
							{ b: 1 },
							Aa(
								_a({}, "a", {
									enumerable: !0,
									get: function () {
										_a(this, "b", { value: 3, enumerable: !1 });
									},
								}),
								{ b: 2 }
							)
						).b
				)
					return !0;
				var e = {},
					t = {},
					n = Symbol(),
					r = "abcdefghijklmnopqrst";
				return (
					(e[n] = 7),
					r.split("").forEach(function (e) {
						t[e] = e;
					}),
					7 != Aa({}, e)[n] || He(Aa({}, t)).join("") != r
				);
			})
				? function (e, t) {
						for (var n = je(e), r = arguments.length, a = 1, i = ke.f, s = l.f; r > a; )
							for (
								var u, c = d(arguments[a++]), p = i ? He(c).concat(i(c)) : He(c), h = p.length, f = 0;
								h > f;

							)
								(u = p[f++]), (o && !s.call(c, u)) || (n[u] = c[u]);
						return n;
				  }
				: Aa;
	De({ target: "Object", stat: !0, forced: Object.assign !== Fa }, { assign: Fa }),
		De({ target: "Object", stat: !0, sham: !o }, { create: Qe }),
		De({ target: "Object", stat: !0, forced: !o, sham: !o }, { defineProperty: R.f }),
		De({ target: "Object", stat: !0, forced: !o, sham: !o }, { defineProperties: qe });
	var Da = l.f,
		Oa = function (e) {
			return function (t) {
				for (var n, r = g(t), a = He(r), i = a.length, s = 0, u = []; i > s; )
					(n = a[s++]), (o && !Da.call(r, n)) || u.push(e ? [n, r[n]] : r[n]);
				return u;
			};
		},
		Ma = { entries: Oa(!0), values: Oa(!1) },
		La = Ma.entries;
	De(
		{ target: "Object", stat: !0 },
		{
			entries: function (e) {
				return La(e);
			},
		}
	);
	var za = !i(function () {
			return Object.isExtensible(Object.preventExtensions({}));
		}),
		Pa = n(function (e) {
			var t = R.f,
				n = j("meta"),
				r = 0,
				a =
					Object.isExtensible ||
					function () {
						return !0;
					},
				i = function (e) {
					t(e, n, { value: { objectID: "O" + ++r, weakData: {} } });
				},
				o = (e.exports = {
					REQUIRED: !1,
					fastKey: function (e, t) {
						if (!v(e)) return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
						if (!x(e, n)) {
							if (!a(e)) return "F";
							if (!t) return "E";
							i(e);
						}
						return e[n].objectID;
					},
					getWeakData: function (e, t) {
						if (!x(e, n)) {
							if (!a(e)) return !0;
							if (!t) return !1;
							i(e);
						}
						return e[n].weakData;
					},
					onFreeze: function (e) {
						return za && o.REQUIRED && a(e) && !x(e, n) && i(e), e;
					},
				});
			K[n] = !0;
		}),
		Ba = (Pa.REQUIRED, Pa.fastKey, Pa.getWeakData, Pa.onFreeze, Pa.onFreeze),
		Wa = Object.freeze,
		Ua = i(function () {
			Wa(1);
		});
	De(
		{ target: "Object", stat: !0, forced: Ua, sham: !za },
		{
			freeze: function (e) {
				return Wa && v(e) ? Wa(Ba(e)) : e;
			},
		}
	),
		De(
			{ target: "Object", stat: !0 },
			{
				fromEntries: function (e) {
					var t = {};
					return (
						In(
							e,
							function (e, n) {
								Cn(t, e, n);
							},
							{ AS_ENTRIES: !0 }
						),
						t
					);
				},
			}
		);
	var Va = T.f,
		Ga = i(function () {
			Va(1);
		});
	De(
		{ target: "Object", stat: !0, forced: !o || Ga, sham: !o },
		{
			getOwnPropertyDescriptor: function (e, t) {
				return Va(g(e), t);
			},
		}
	),
		De(
			{ target: "Object", stat: !0, sham: !o },
			{
				getOwnPropertyDescriptors: function (e) {
					for (var t, n, r = g(e), a = T.f, i = Ne(r), o = {}, s = 0; i.length > s; )
						void 0 !== (n = a(r, (t = i[s++]))) && Cn(o, t, n);
					return o;
				},
			}
		);
	var ja = nt.f,
		Ha = i(function () {
			return !Object.getOwnPropertyNames(1);
		});
	De({ target: "Object", stat: !0, forced: Ha }, { getOwnPropertyNames: ja });
	var qa = i(function () {
		un(1);
	});
	De(
		{ target: "Object", stat: !0, forced: qa, sham: !an },
		{
			getPrototypeOf: function (e) {
				return un(je(e));
			},
		}
	);
	var Ka =
		Object.is ||
		function (e, t) {
			return e === t ? 0 !== e || 1 / e == 1 / t : e != e && t != t;
		};
	De({ target: "Object", stat: !0 }, { is: Ka });
	var Xa = Object.isExtensible,
		Ya = i(function () {
			Xa(1);
		});
	De(
		{ target: "Object", stat: !0, forced: Ya },
		{
			isExtensible: function (e) {
				return !!v(e) && (!Xa || Xa(e));
			},
		}
	);
	var Ja = Object.isFrozen,
		Za = i(function () {
			Ja(1);
		});
	De(
		{ target: "Object", stat: !0, forced: Za },
		{
			isFrozen: function (e) {
				return !v(e) || (!!Ja && Ja(e));
			},
		}
	);
	var Qa = Object.isSealed,
		$a = i(function () {
			Qa(1);
		});
	De(
		{ target: "Object", stat: !0, forced: $a },
		{
			isSealed: function (e) {
				return !v(e) || (!!Qa && Qa(e));
			},
		}
	);
	var ei = i(function () {
		He(1);
	});
	De(
		{ target: "Object", stat: !0, forced: ei },
		{
			keys: function (e) {
				return He(je(e));
			},
		}
	);
	var ti = Pa.onFreeze,
		ni = Object.preventExtensions,
		ri = i(function () {
			ni(1);
		});
	De(
		{ target: "Object", stat: !0, forced: ri, sham: !za },
		{
			preventExtensions: function (e) {
				return ni && v(e) ? ni(ti(e)) : e;
			},
		}
	);
	var ai = Pa.onFreeze,
		ii = Object.seal,
		oi = i(function () {
			ii(1);
		});
	De(
		{ target: "Object", stat: !0, forced: oi, sham: !za },
		{
			seal: function (e) {
				return ii && v(e) ? ii(ai(e)) : e;
			},
		}
	),
		De({ target: "Object", stat: !0 }, { setPrototypeOf: cn });
	var si = Ma.values;
	De(
		{ target: "Object", stat: !0 },
		{
			values: function (e) {
				return si(e);
			},
		}
	);
	var ui = gn
		? {}.toString
		: function () {
				return "[object " + bn(this) + "]";
		  };
	gn || re(Object.prototype, "toString", ui, { unsafe: !0 });
	var li = !i(function () {
		var e = Math.random();
		__defineSetter__.call(null, e, function () {}), delete a[e];
	});
	o &&
		De(
			{ target: "Object", proto: !0, forced: li },
			{
				__defineGetter__: function (e, t) {
					R.f(je(this), e, { get: ft(t), enumerable: !0, configurable: !0 });
				},
			}
		),
		o &&
			De(
				{ target: "Object", proto: !0, forced: li },
				{
					__defineSetter__: function (e, t) {
						R.f(je(this), e, { set: ft(t), enumerable: !0, configurable: !0 });
					},
				}
			);
	var ci = T.f;
	o &&
		De(
			{ target: "Object", proto: !0, forced: li },
			{
				__lookupGetter__: function (e) {
					var t,
						n = je(this),
						r = y(e, !0);
					do {
						if ((t = ci(n, r))) return t.get;
					} while ((n = un(n)));
				},
			}
		);
	var pi = T.f;
	o &&
		De(
			{ target: "Object", proto: !0, forced: li },
			{
				__lookupSetter__: function (e) {
					var t,
						n = je(this),
						r = y(e, !0);
					do {
						if ((t = pi(n, r))) return t.set;
					} while ((n = un(n)));
				},
			}
		);
	var hi = String.fromCharCode,
		fi = String.fromCodePoint,
		di = !!fi && 1 != fi.length;
	De(
		{ target: "String", stat: !0, forced: di },
		{
			fromCodePoint: function (e) {
				for (var t, n = [], r = arguments.length, a = 0; r > a; ) {
					if (((t = +arguments[a++]), de(t, 1114111) !== t))
						throw RangeError(t + " is not a valid code point");
					n.push(t < 65536 ? hi(t) : hi(55296 + ((t -= 65536) >> 10), (t % 1024) + 56320));
				}
				return n.join("");
			},
		}
	),
		De(
			{ target: "String", stat: !0 },
			{
				raw: function (e) {
					for (var t = g(e.raw), n = pe(t.length), r = arguments.length, a = [], i = 0; n > i; )
						a.push(String(t[i++])), i < r && a.push(String(arguments[i]));
					return a.join("");
				},
			}
		);
	var mi = function (e) {
			return function (t, n) {
				var r,
					a,
					i = String(m(t)),
					o = le(n),
					s = i.length;
				return o < 0 || o >= s
					? e
						? ""
						: void 0
					: (r = i.charCodeAt(o)) < 55296 ||
					  r > 56319 ||
					  o + 1 === s ||
					  (a = i.charCodeAt(o + 1)) < 56320 ||
					  a > 57343
					? e
						? i.charAt(o)
						: r
					: e
					? i.slice(o, o + 2)
					: a - 56320 + ((r - 55296) << 10) + 65536;
			};
		},
		gi = { codeAt: mi(!1), charAt: mi(!0) },
		vi = gi.codeAt;
	De(
		{ target: "String", proto: !0 },
		{
			codePointAt: function (e) {
				return vi(this, e);
			},
		}
	);
	var yi,
		bi = ot("match"),
		xi = function (e) {
			var t;
			return v(e) && (void 0 !== (t = e[bi]) ? !!t : "RegExp" == h(e));
		},
		wi = function (e) {
			if (xi(e)) throw TypeError("The method doesn't accept regular expressions");
			return e;
		},
		ki = ot("match"),
		Ni = function (e) {
			var t = /./;
			try {
				"/./"[e](t);
			} catch (n) {
				try {
					return (t[ki] = !1), "/./"[e](t);
				} catch (e) {}
			}
			return !1;
		},
		Ii = T.f,
		Si = "".endsWith,
		Ti = Math.min,
		Ci = Ni("endsWith"),
		Ei = !(Ci || ((yi = Ii(String.prototype, "endsWith")), !yi || yi.writable));
	De(
		{ target: "String", proto: !0, forced: !Ei && !Ci },
		{
			endsWith: function (e) {
				var t = String(m(this));
				wi(e);
				var n = arguments.length > 1 ? arguments[1] : void 0,
					r = pe(t.length),
					a = void 0 === n ? r : Ti(pe(n), r),
					i = String(e);
				return Si ? Si.call(t, i, a) : t.slice(a - i.length, a) === i;
			},
		}
	),
		De(
			{ target: "String", proto: !0, forced: !Ni("includes") },
			{
				includes: function (e) {
					return !!~String(m(this)).indexOf(wi(e), arguments.length > 1 ? arguments[1] : void 0);
				},
			}
		);
	var Ri = function () {
		var e = C(this),
			t = "";
		return (
			e.global && (t += "g"),
			e.ignoreCase && (t += "i"),
			e.multiline && (t += "m"),
			e.dotAll && (t += "s"),
			e.unicode && (t += "u"),
			e.sticky && (t += "y"),
			t
		);
	};
	function Ai(e, t) {
		return RegExp(e, t);
	}
	var _i = {
			UNSUPPORTED_Y: i(function () {
				var e = Ai("a", "y");
				return (e.lastIndex = 2), null != e.exec("abcd");
			}),
			BROKEN_CARET: i(function () {
				var e = Ai("^r", "gy");
				return (e.lastIndex = 2), null != e.exec("str");
			}),
		},
		Fi = RegExp.prototype.exec,
		Di = String.prototype.replace,
		Oi = Fi,
		Mi = (function () {
			var e = /a/,
				t = /b*/g;
			return Fi.call(e, "a"), Fi.call(t, "a"), 0 !== e.lastIndex || 0 !== t.lastIndex;
		})(),
		Li = _i.UNSUPPORTED_Y || _i.BROKEN_CARET,
		zi = void 0 !== /()??/.exec("")[1];
	(Mi || zi || Li) &&
		(Oi = function (e) {
			var t,
				n,
				r,
				a,
				i = this,
				o = Li && i.sticky,
				s = Ri.call(i),
				u = i.source,
				l = 0,
				c = e;
			return (
				o &&
					(-1 === (s = s.replace("y", "")).indexOf("g") && (s += "g"),
					(c = String(e).slice(i.lastIndex)),
					i.lastIndex > 0 &&
						(!i.multiline || (i.multiline && "\n" !== e[i.lastIndex - 1])) &&
						((u = "(?: " + u + ")"), (c = " " + c), l++),
					(n = new RegExp("^(?:" + u + ")", s))),
				zi && (n = new RegExp("^" + u + "$(?!\\s)", s)),
				Mi && (t = i.lastIndex),
				(r = Fi.call(o ? n : i, c)),
				o
					? r
						? ((r.input = r.input.slice(l)),
						  (r[0] = r[0].slice(l)),
						  (r.index = i.lastIndex),
						  (i.lastIndex += r[0].length))
						: (i.lastIndex = 0)
					: Mi && r && (i.lastIndex = i.global ? r.index + r[0].length : t),
				zi &&
					r &&
					r.length > 1 &&
					Di.call(r[0], n, function () {
						for (a = 1; a < arguments.length - 2; a++) void 0 === arguments[a] && (r[a] = void 0);
					}),
				r
			);
		});
	var Pi = Oi;
	De({ target: "RegExp", proto: !0, forced: /./.exec !== Pi }, { exec: Pi });
	var Bi = ot("species"),
		Wi = !i(function () {
			var e = /./;
			return (
				(e.exec = function () {
					var e = [];
					return (e.groups = { a: "7" }), e;
				}),
				"7" !== "".replace(e, "$<a>")
			);
		}),
		Ui = "$0" === "a".replace(/./, "$0"),
		Vi = ot("replace"),
		Gi = !!/./[Vi] && "" === /./[Vi]("a", "$0"),
		ji = !i(function () {
			var e = /(?:)/,
				t = e.exec;
			e.exec = function () {
				return t.apply(this, arguments);
			};
			var n = "ab".split(e);
			return 2 !== n.length || "a" !== n[0] || "b" !== n[1];
		}),
		Hi = function (e, t, n, r) {
			var a = ot(e),
				o = !i(function () {
					var t = {};
					return (
						(t[a] = function () {
							return 7;
						}),
						7 != ""[e](t)
					);
				}),
				s =
					o &&
					!i(function () {
						var t = !1,
							n = /a/;
						return (
							"split" === e &&
								(((n = {}).constructor = {}),
								(n.constructor[Bi] = function () {
									return n;
								}),
								(n.flags = ""),
								(n[a] = /./[a])),
							(n.exec = function () {
								return (t = !0), null;
							}),
							n[a](""),
							!t
						);
					});
			if (!o || !s || ("replace" === e && (!Wi || !Ui || Gi)) || ("split" === e && !ji)) {
				var u = /./[a],
					l = n(
						a,
						""[e],
						function (e, t, n, r, a) {
							return t.exec === Pi
								? o && !a
									? { done: !0, value: u.call(t, n, r) }
									: { done: !0, value: e.call(n, t, r) }
								: { done: !1 };
						},
						{ REPLACE_KEEPS_$0: Ui, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Gi }
					),
					c = l[0],
					p = l[1];
				re(String.prototype, e, c),
					re(
						RegExp.prototype,
						a,
						2 == t
							? function (e, t) {
									return p.call(e, this, t);
							  }
							: function (e) {
									return p.call(e, this);
							  }
					);
			}
			r && A(RegExp.prototype[a], "sham", !0);
		},
		qi = gi.charAt,
		Ki = function (e, t, n) {
			return t + (n ? qi(e, t).length : 1);
		},
		Xi = function (e, t) {
			var n = e.exec;
			if ("function" == typeof n) {
				var r = n.call(e, t);
				if ("object" != typeof r)
					throw TypeError("RegExp exec method returned something other than an Object or null");
				return r;
			}
			if ("RegExp" !== h(e)) throw TypeError("RegExp#exec called on incompatible receiver");
			return Pi.call(e, t);
		};
	Hi("match", 1, function (e, t, n) {
		return [
			function (t) {
				var n = m(this),
					r = null == t ? void 0 : t[e];
				return void 0 !== r ? r.call(t, n) : new RegExp(t)[e](String(n));
			},
			function (e) {
				var r = n(t, e, this);
				if (r.done) return r.value;
				var a = C(e),
					i = String(this);
				if (!a.global) return Xi(a, i);
				var o = a.unicode;
				a.lastIndex = 0;
				for (var s, u = [], l = 0; null !== (s = Xi(a, i)); ) {
					var c = String(s[0]);
					(u[l] = c), "" === c && (a.lastIndex = Ki(i, pe(a.lastIndex), o)), l++;
				}
				return 0 === l ? null : u;
			},
		];
	});
	var Yi = ot("species"),
		Ji = function (e, t) {
			var n,
				r = C(e).constructor;
			return void 0 === r || null == (n = C(r)[Yi]) ? t : ft(n);
		},
		Zi = ot("matchAll"),
		Qi = "RegExp String Iterator",
		$i = ne.set,
		eo = ne.getterFor(Qi),
		to = RegExp.prototype,
		no = to.exec,
		ro = "".matchAll,
		ao =
			!!ro &&
			!i(function () {
				"a".matchAll(/./);
			}),
		io = oa(
			function (e, t, n, r) {
				$i(this, { type: Qi, regexp: e, string: t, global: n, unicode: r, done: !1 });
			},
			"RegExp String",
			function () {
				var e = eo(this);
				if (e.done) return { value: void 0, done: !0 };
				var t = e.regexp,
					n = e.string,
					r = (function (e, t) {
						var n,
							r = e.exec;
						if ("function" == typeof r) {
							if ("object" != typeof (n = r.call(e, t))) throw TypeError("Incorrect exec result");
							return n;
						}
						return no.call(e, t);
					})(t, n);
				return null === r
					? { value: void 0, done: (e.done = !0) }
					: e.global
					? ("" == String(r[0]) && (t.lastIndex = Ki(n, pe(t.lastIndex), e.unicode)), { value: r, done: !1 })
					: ((e.done = !0), { value: r, done: !1 });
			}
		);
	De(
		{ target: "String", proto: !0, forced: ao },
		{
			matchAll: function (e) {
				var t,
					n,
					r = m(this);
				if (null != e) {
					if (xi(e) && !~String(m("flags" in to ? e.flags : Ri.call(e))).indexOf("g"))
						throw TypeError("`.matchAll` does not allow non-global regexes");
					if (ao) return ro.apply(r, arguments);
					if (null != (n = e[Zi])) return ft(n).call(e, r);
				} else if (ao) return ro.apply(r, arguments);
				return (t = String(r)), new RegExp(e, "g")[Zi](t);
			},
		}
	),
		Zi in to ||
			A(to, Zi, function (e) {
				var t,
					n,
					r,
					a,
					i,
					o,
					s = C(this),
					u = String(e);
				return (
					(t = Ji(s, RegExp)),
					void 0 === (n = s.flags) && s instanceof RegExp && !("flags" in to) && (n = Ri.call(s)),
					(r = void 0 === n ? "" : String(n)),
					(a = new t(t === RegExp ? s.source : s, r)),
					(i = !!~r.indexOf("g")),
					(o = !!~r.indexOf("u")),
					(a.lastIndex = pe(s.lastIndex)),
					new io(a, u, i, o)
				);
			});
	var oo =
			"".repeat ||
			function (e) {
				var t = String(m(this)),
					n = "",
					r = le(e);
				if (r < 0 || r == 1 / 0) throw RangeError("Wrong number of repetitions");
				for (; r > 0; (r >>>= 1) && (t += t)) 1 & r && (n += t);
				return n;
			},
		so = Math.ceil,
		uo = function (e) {
			return function (t, n, r) {
				var a,
					i,
					o = String(m(t)),
					s = o.length,
					u = void 0 === r ? " " : String(r),
					l = pe(n);
				return l <= s || "" == u
					? o
					: ((a = l - s),
					  (i = oo.call(u, so(a / u.length))).length > a && (i = i.slice(0, a)),
					  e ? o + i : i + o);
			};
		},
		lo = { start: uo(!1), end: uo(!0) },
		co = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(Me),
		po = lo.end;
	De(
		{ target: "String", proto: !0, forced: co },
		{
			padEnd: function (e) {
				return po(this, e, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	);
	var ho = lo.start;
	De(
		{ target: "String", proto: !0, forced: co },
		{
			padStart: function (e) {
				return ho(this, e, arguments.length > 1 ? arguments[1] : void 0);
			},
		}
	),
		De({ target: "String", proto: !0 }, { repeat: oo });
	var fo = Math.floor,
		mo = "".replace,
		go = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
		vo = /\$([$&'`]|\d{1,2})/g,
		yo = function (e, t, n, r, a, i) {
			var o = n + e.length,
				s = r.length,
				u = vo;
			return (
				void 0 !== a && ((a = je(a)), (u = go)),
				mo.call(i, u, function (i, u) {
					var l;
					switch (u.charAt(0)) {
						case "$":
							return "$";
						case "&":
							return e;
						case "`":
							return t.slice(0, n);
						case "'":
							return t.slice(o);
						case "<":
							l = a[u.slice(1, -1)];
							break;
						default:
							var c = +u;
							if (0 === c) return i;
							if (c > s) {
								var p = fo(c / 10);
								return 0 === p
									? i
									: p <= s
									? void 0 === r[p - 1]
										? u.charAt(1)
										: r[p - 1] + u.charAt(1)
									: i;
							}
							l = r[c - 1];
					}
					return void 0 === l ? "" : l;
				})
			);
		},
		bo = Math.max,
		xo = Math.min;
	Hi("replace", 2, function (e, t, n, r) {
		var a = r.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,
			i = r.REPLACE_KEEPS_$0,
			o = a ? "$" : "$0";
		return [
			function (n, r) {
				var a = m(this),
					i = null == n ? void 0 : n[e];
				return void 0 !== i ? i.call(n, a, r) : t.call(String(a), n, r);
			},
			function (e, r) {
				if ((!a && i) || ("string" == typeof r && -1 === r.indexOf(o))) {
					var s = n(t, e, this, r);
					if (s.done) return s.value;
				}
				var u = C(e),
					l = String(this),
					c = "function" == typeof r;
				c || (r = String(r));
				var p = u.global;
				if (p) {
					var h = u.unicode;
					u.lastIndex = 0;
				}
				for (var f = []; ; ) {
					var d = Xi(u, l);
					if (null === d) break;
					if ((f.push(d), !p)) break;
					"" === String(d[0]) && (u.lastIndex = Ki(l, pe(u.lastIndex), h));
				}
				for (var m, g = "", v = 0, y = 0; y < f.length; y++) {
					d = f[y];
					for (var b = String(d[0]), x = bo(xo(le(d.index), l.length), 0), w = [], k = 1; k < d.length; k++)
						w.push(void 0 === (m = d[k]) ? m : String(m));
					var N = d.groups;
					if (c) {
						var I = [b].concat(w, x, l);
						void 0 !== N && I.push(N);
						var S = String(r.apply(void 0, I));
					} else S = yo(b, l, x, w, N, r);
					x >= v && ((g += l.slice(v, x) + S), (v = x + b.length));
				}
				return g + l.slice(v);
			},
		];
	}),
		Hi("search", 1, function (e, t, n) {
			return [
				function (t) {
					var n = m(this),
						r = null == t ? void 0 : t[e];
					return void 0 !== r ? r.call(t, n) : new RegExp(t)[e](String(n));
				},
				function (e) {
					var r = n(t, e, this);
					if (r.done) return r.value;
					var a = C(e),
						i = String(this),
						o = a.lastIndex;
					Ka(o, 0) || (a.lastIndex = 0);
					var s = Xi(a, i);
					return Ka(a.lastIndex, o) || (a.lastIndex = o), null === s ? -1 : s.index;
				},
			];
		});
	var wo = [].push,
		ko = Math.min,
		No = 4294967295,
		Io = !i(function () {
			return !RegExp(No, "y");
		});
	Hi(
		"split",
		2,
		function (e, t, n) {
			var r;
			return (
				(r =
					"c" == "abbc".split(/(b)*/)[1] ||
					4 != "test".split(/(?:)/, -1).length ||
					2 != "ab".split(/(?:ab)*/).length ||
					4 != ".".split(/(.?)(.?)/).length ||
					".".split(/()()/).length > 1 ||
					"".split(/.?/).length
						? function (e, n) {
								var r = String(m(this)),
									a = void 0 === n ? No : n >>> 0;
								if (0 === a) return [];
								if (void 0 === e) return [r];
								if (!xi(e)) return t.call(r, e, a);
								for (
									var i,
										o,
										s,
										u = [],
										l =
											(e.ignoreCase ? "i" : "") +
											(e.multiline ? "m" : "") +
											(e.unicode ? "u" : "") +
											(e.sticky ? "y" : ""),
										c = 0,
										p = new RegExp(e.source, l + "g");
									(i = Pi.call(p, r)) &&
									!(
										(o = p.lastIndex) > c &&
										(u.push(r.slice(c, i.index)),
										i.length > 1 && i.index < r.length && wo.apply(u, i.slice(1)),
										(s = i[0].length),
										(c = o),
										u.length >= a)
									);

								)
									p.lastIndex === i.index && p.lastIndex++;
								return (
									c === r.length ? (!s && p.test("")) || u.push("") : u.push(r.slice(c)),
									u.length > a ? u.slice(0, a) : u
								);
						  }
						: "0".split(void 0, 0).length
						? function (e, n) {
								return void 0 === e && 0 === n ? [] : t.call(this, e, n);
						  }
						: t),
				[
					function (t, n) {
						var a = m(this),
							i = null == t ? void 0 : t[e];
						return void 0 !== i ? i.call(t, a, n) : r.call(String(a), t, n);
					},
					function (e, a) {
						var i = n(r, e, this, a, r !== t);
						if (i.done) return i.value;
						var o = C(e),
							s = String(this),
							u = Ji(o, RegExp),
							l = o.unicode,
							c =
								(o.ignoreCase ? "i" : "") +
								(o.multiline ? "m" : "") +
								(o.unicode ? "u" : "") +
								(Io ? "y" : "g"),
							p = new u(Io ? o : "^(?:" + o.source + ")", c),
							h = void 0 === a ? No : a >>> 0;
						if (0 === h) return [];
						if (0 === s.length) return null === Xi(p, s) ? [s] : [];
						for (var f = 0, d = 0, m = []; d < s.length; ) {
							p.lastIndex = Io ? d : 0;
							var g,
								v = Xi(p, Io ? s : s.slice(d));
							if (null === v || (g = ko(pe(p.lastIndex + (Io ? 0 : d)), s.length)) === f) d = Ki(s, d, l);
							else {
								if ((m.push(s.slice(f, d)), m.length === h)) return m;
								for (var y = 1; y <= v.length - 1; y++) if ((m.push(v[y]), m.length === h)) return m;
								d = f = g;
							}
						}
						return m.push(s.slice(f)), m;
					},
				]
			);
		},
		!Io
	);
	var So = T.f,
		To = "".startsWith,
		Co = Math.min,
		Eo = Ni("startsWith"),
		Ro =
			!Eo &&
			!!(function () {
				var e = So(String.prototype, "startsWith");
				return e && !e.writable;
			})();
	De(
		{ target: "String", proto: !0, forced: !Ro && !Eo },
		{
			startsWith: function (e) {
				var t = String(m(this));
				wi(e);
				var n = pe(Co(arguments.length > 1 ? arguments[1] : void 0, t.length)),
					r = String(e);
				return To ? To.call(t, r, n) : t.slice(n, n + r.length) === r;
			},
		}
	);
	var Ao = "\t\n\v\f\r  áââââââââââââ¯âã\u2028\u2029\ufeff",
		_o = "[" + Ao + "]",
		Fo = RegExp("^" + _o + _o + "*"),
		Do = RegExp(_o + _o + "*$"),
		Oo = function (e) {
			return function (t) {
				var n = String(m(t));
				return 1 & e && (n = n.replace(Fo, "")), 2 & e && (n = n.replace(Do, "")), n;
			};
		},
		Mo = { start: Oo(1), end: Oo(2), trim: Oo(3) },
		Lo = function (e) {
			return i(function () {
				return !!Ao[e]() || "âÂá " != "âÂá "[e]() || Ao[e].name !== e;
			});
		},
		zo = Mo.trim;
	De(
		{ target: "String", proto: !0, forced: Lo("trim") },
		{
			trim: function () {
				return zo(this);
			},
		}
	);
	var Po = Mo.start,
		Bo = Lo("trimStart"),
		Wo = Bo
			? function () {
					return Po(this);
			  }
			: "".trimStart;
	De({ target: "String", proto: !0, forced: Bo }, { trimStart: Wo, trimLeft: Wo });
	var Uo = Mo.end,
		Vo = Lo("trimEnd"),
		Go = Vo
			? function () {
					return Uo(this);
			  }
			: "".trimEnd;
	De({ target: "String", proto: !0, forced: Vo }, { trimEnd: Go, trimRight: Go });
	var jo = gi.charAt,
		Ho = "String Iterator",
		qo = ne.set,
		Ko = ne.getterFor(Ho);
	da(
		String,
		"String",
		function (e) {
			qo(this, { type: Ho, string: String(e), index: 0 });
		},
		function () {
			var e,
				t = Ko(this),
				n = t.string,
				r = t.index;
			return r >= n.length
				? { value: void 0, done: !0 }
				: ((e = jo(n, r)), (t.index += e.length), { value: e, done: !1 });
		}
	);
	var Xo = /"/g,
		Yo = function (e, t, n, r) {
			var a = String(m(e)),
				i = "<" + t;
			return (
				"" !== n && (i += " " + n + '="' + String(r).replace(Xo, "&quot;") + '"'), i + ">" + a + "</" + t + ">"
			);
		},
		Jo = function (e) {
			return i(function () {
				var t = ""[e]('"');
				return t !== t.toLowerCase() || t.split('"').length > 3;
			});
		};
	De(
		{ target: "String", proto: !0, forced: Jo("anchor") },
		{
			anchor: function (e) {
				return Yo(this, "a", "name", e);
			},
		}
	),
		De(
			{ target: "String", proto: !0, forced: Jo("big") },
			{
				big: function () {
					return Yo(this, "big", "", "");
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("blink") },
			{
				blink: function () {
					return Yo(this, "blink", "", "");
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("bold") },
			{
				bold: function () {
					return Yo(this, "b", "", "");
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("fixed") },
			{
				fixed: function () {
					return Yo(this, "tt", "", "");
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("fontcolor") },
			{
				fontcolor: function (e) {
					return Yo(this, "font", "color", e);
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("fontsize") },
			{
				fontsize: function (e) {
					return Yo(this, "font", "size", e);
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("italics") },
			{
				italics: function () {
					return Yo(this, "i", "", "");
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("link") },
			{
				link: function (e) {
					return Yo(this, "a", "href", e);
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("small") },
			{
				small: function () {
					return Yo(this, "small", "", "");
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("strike") },
			{
				strike: function () {
					return Yo(this, "strike", "", "");
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("sub") },
			{
				sub: function () {
					return Yo(this, "sub", "", "");
				},
			}
		),
		De(
			{ target: "String", proto: !0, forced: Jo("sup") },
			{
				sup: function () {
					return Yo(this, "sup", "", "");
				},
			}
		);
	var Zo = ot("replace"),
		Qo = RegExp.prototype,
		$o = Math.max,
		es = function (e, t, n) {
			return n > e.length ? -1 : "" === t ? n : e.indexOf(t, n);
		};
	De(
		{ target: "String", proto: !0 },
		{
			replaceAll: function (e, t) {
				var n,
					r,
					a,
					i,
					o,
					s,
					u,
					l = m(this),
					c = 0,
					p = 0,
					h = "";
				if (null != e) {
					if (xi(e) && !~String(m("flags" in Qo ? e.flags : Ri.call(e))).indexOf("g"))
						throw TypeError("`.replaceAll` does not allow non-global regexes");
					if (void 0 !== (n = e[Zo])) return n.call(e, l, t);
				}
				for (
					r = String(l),
						a = String(e),
						(i = "function" == typeof t) || (t = String(t)),
						o = a.length,
						s = $o(1, o),
						c = es(r, a, 0);
					-1 !== c;

				)
					(u = i ? String(t(a, c, r)) : yo(a, r, c, [], void 0, t)),
						(h += r.slice(p, c) + u),
						(p = c + o),
						(c = es(r, a, c + s));
				return p < r.length && (h += r.slice(p)), h;
			},
		}
	);
	var ts = function (e, t, n) {
			var r, a;
			return (
				cn &&
					"function" == typeof (r = t.constructor) &&
					r !== n &&
					v((a = r.prototype)) &&
					a !== n.prototype &&
					cn(e, a),
				e
			);
		},
		ns = R.f,
		rs = we.f,
		as = ne.set,
		is = ot("match"),
		os = a.RegExp,
		ss = os.prototype,
		us = /a/g,
		ls = /a/g,
		cs = new os(us) !== us,
		ps = _i.UNSUPPORTED_Y;
	if (
		o &&
		_e(
			"RegExp",
			!cs ||
				ps ||
				i(function () {
					return (ls[is] = !1), os(us) != us || os(ls) == ls || "/a/i" != os(us, "i");
				})
		)
	) {
		for (
			var hs = function (e, t) {
					var n,
						r = this instanceof hs,
						a = xi(e),
						i = void 0 === t;
					if (!r && a && e.constructor === hs && i) return e;
					cs ? a && !i && (e = e.source) : e instanceof hs && (i && (t = Ri.call(e)), (e = e.source)),
						ps && (n = !!t && t.indexOf("y") > -1) && (t = t.replace(/y/g, ""));
					var o = ts(cs ? new os(e, t) : os(e, t), r ? this : ss, hs);
					return ps && n && as(o, { sticky: n }), o;
				},
				fs = function (e) {
					(e in hs) ||
						ns(hs, e, {
							configurable: !0,
							get: function () {
								return os[e];
							},
							set: function (t) {
								os[e] = t;
							},
						});
				},
				ds = rs(os),
				ms = 0;
			ds.length > ms;

		)
			fs(ds[ms++]);
		(ss.constructor = hs), (hs.prototype = ss), re(a, "RegExp", hs);
	}
	Jr("RegExp"),
		o && ("g" != /./g.flags || _i.UNSUPPORTED_Y) && R.f(RegExp.prototype, "flags", { configurable: !0, get: Ri });
	var gs = _i.UNSUPPORTED_Y,
		vs = R.f,
		ys = ne.get,
		bs = RegExp.prototype;
	o &&
		gs &&
		vs(RegExp.prototype, "sticky", {
			configurable: !0,
			get: function () {
				if (this !== bs) {
					if (this instanceof RegExp) return !!ys(this).sticky;
					throw TypeError("Incompatible receiver, RegExp required");
				}
			},
		});
	var xs = (function () {
			var e = !1,
				t = /[ac]/;
			return (
				(t.exec = function () {
					return (e = !0), /./.exec.apply(this, arguments);
				}),
				!0 === t.test("abc") && e
			);
		})(),
		ws = /./.test;
	De(
		{ target: "RegExp", proto: !0, forced: !xs },
		{
			test: function (e) {
				if ("function" != typeof this.exec) return ws.call(this, e);
				var t = this.exec(e);
				if (null !== t && !v(t))
					throw new Error("RegExp exec method returned something other than an Object or null");
				return !!t;
			},
		}
	);
	var ks = "toString",
		Ns = RegExp.prototype,
		Is = Ns.toString,
		Ss = i(function () {
			return "/a/b" != Is.call({ source: "a", flags: "b" });
		}),
		Ts = Is.name != ks;
	(Ss || Ts) &&
		re(
			RegExp.prototype,
			ks,
			function () {
				var e = C(this),
					t = String(e.source),
					n = e.flags;
				return "/" + t + "/" + String(void 0 === n && e instanceof RegExp && !("flags" in Ns) ? Ri.call(e) : n);
			},
			{ unsafe: !0 }
		);
	var Cs = Mo.trim,
		Es = a.parseInt,
		Rs = /^[+-]?0[Xx]/,
		As =
			8 !== Es(Ao + "08") || 22 !== Es(Ao + "0x16")
				? function (e, t) {
						var n = Cs(String(e));
						return Es(n, t >>> 0 || (Rs.test(n) ? 16 : 10));
				  }
				: Es;
	De({ global: !0, forced: parseInt != As }, { parseInt: As });
	var _s = Mo.trim,
		Fs = a.parseFloat,
		Ds =
			1 / Fs(Ao + "-0") != -1 / 0
				? function (e) {
						var t = _s(String(e)),
							n = Fs(t);
						return 0 === n && "-" == t.charAt(0) ? -0 : n;
				  }
				: Fs;
	De({ global: !0, forced: parseFloat != Ds }, { parseFloat: Ds });
	var Os = we.f,
		Ms = T.f,
		Ls = R.f,
		zs = Mo.trim,
		Ps = "Number",
		Bs = a.Number,
		Ws = Bs.prototype,
		Us = h(Qe(Ws)) == Ps,
		Vs = function (e) {
			var t,
				n,
				r,
				a,
				i,
				o,
				s,
				u,
				l = y(e, !1);
			if ("string" == typeof l && l.length > 2)
				if (43 === (t = (l = zs(l)).charCodeAt(0)) || 45 === t) {
					if (88 === (n = l.charCodeAt(2)) || 120 === n) return NaN;
				} else if (48 === t) {
					switch (l.charCodeAt(1)) {
						case 66:
						case 98:
							(r = 2), (a = 49);
							break;
						case 79:
						case 111:
							(r = 8), (a = 55);
							break;
						default:
							return +l;
					}
					for (o = (i = l.slice(2)).length, s = 0; s < o; s++)
						if ((u = i.charCodeAt(s)) < 48 || u > a) return NaN;
					return parseInt(i, r);
				}
			return +l;
		};
	if (_e(Ps, !Bs(" 0o1") || !Bs("0b1") || Bs("+0x1"))) {
		for (
			var Gs,
				js = function (e) {
					var t = arguments.length < 1 ? 0 : e,
						n = this;
					return n instanceof js &&
						(Us
							? i(function () {
									Ws.valueOf.call(n);
							  })
							: h(n) != Ps)
						? ts(new Bs(Vs(t)), n, js)
						: Vs(t);
				},
				Hs = o
					? Os(Bs)
					: "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(
							","
					  ),
				qs = 0;
			Hs.length > qs;
			qs++
		)
			x(Bs, (Gs = Hs[qs])) && !x(js, Gs) && Ls(js, Gs, Ms(Bs, Gs));
		(js.prototype = Ws), (Ws.constructor = js), re(a, Ps, js);
	}
	De({ target: "Number", stat: !0 }, { EPSILON: Math.pow(2, -52) });
	var Ks = a.isFinite,
		Xs =
			Number.isFinite ||
			function (e) {
				return "number" == typeof e && Ks(e);
			};
	De({ target: "Number", stat: !0 }, { isFinite: Xs });
	var Ys = Math.floor,
		Js = function (e) {
			return !v(e) && isFinite(e) && Ys(e) === e;
		};
	De({ target: "Number", stat: !0 }, { isInteger: Js }),
		De(
			{ target: "Number", stat: !0 },
			{
				isNaN: function (e) {
					return e != e;
				},
			}
		);
	var Zs = Math.abs;
	De(
		{ target: "Number", stat: !0 },
		{
			isSafeInteger: function (e) {
				return Js(e) && Zs(e) <= 9007199254740991;
			},
		}
	),
		De({ target: "Number", stat: !0 }, { MAX_SAFE_INTEGER: 9007199254740991 }),
		De({ target: "Number", stat: !0 }, { MIN_SAFE_INTEGER: -9007199254740991 }),
		De({ target: "Number", stat: !0, forced: Number.parseFloat != Ds }, { parseFloat: Ds }),
		De({ target: "Number", stat: !0, forced: Number.parseInt != As }, { parseInt: As });
	var Qs = function (e) {
			if ("number" != typeof e && "Number" != h(e)) throw TypeError("Incorrect invocation");
			return +e;
		},
		$s = (1).toFixed,
		eu = Math.floor,
		tu = function e(t, n, r) {
			return 0 === n ? r : n % 2 == 1 ? e(t, n - 1, r * t) : e(t * t, n / 2, r);
		},
		nu = function (e, t, n) {
			for (var r = -1, a = n; ++r < 6; ) (a += t * e[r]), (e[r] = a % 1e7), (a = eu(a / 1e7));
		},
		ru = function (e, t) {
			for (var n = 6, r = 0; --n >= 0; ) (r += e[n]), (e[n] = eu(r / t)), (r = (r % t) * 1e7);
		},
		au = function (e) {
			for (var t = 6, n = ""; --t >= 0; )
				if ("" !== n || 0 === t || 0 !== e[t]) {
					var r = String(e[t]);
					n = "" === n ? r : n + oo.call("0", 7 - r.length) + r;
				}
			return n;
		},
		iu =
			($s &&
				("0.000" !== (8e-5).toFixed(3) ||
					"1" !== (0.9).toFixed(0) ||
					"1.25" !== (1.255).toFixed(2) ||
					"1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0))) ||
			!i(function () {
				$s.call({});
			});
	De(
		{ target: "Number", proto: !0, forced: iu },
		{
			toFixed: function (e) {
				var t,
					n,
					r,
					a,
					i = Qs(this),
					o = le(e),
					s = [0, 0, 0, 0, 0, 0],
					u = "",
					l = "0";
				if (o < 0 || o > 20) throw RangeError("Incorrect fraction digits");
				if (i != i) return "NaN";
				if (i <= -1e21 || i >= 1e21) return String(i);
				if ((i < 0 && ((u = "-"), (i = -i)), i > 1e-21))
					if (
						((n =
							(t =
								(function (e) {
									for (var t = 0, n = e; n >= 4096; ) (t += 12), (n /= 4096);
									for (; n >= 2; ) (t += 1), (n /= 2);
									return t;
								})(i * tu(2, 69, 1)) - 69) < 0
								? i * tu(2, -t, 1)
								: i / tu(2, t, 1)),
						(n *= 4503599627370496),
						(t = 52 - t) > 0)
					) {
						for (nu(s, 0, n), r = o; r >= 7; ) nu(s, 1e7, 0), (r -= 7);
						for (nu(s, tu(10, r, 1), 0), r = t - 1; r >= 23; ) ru(s, 1 << 23), (r -= 23);
						ru(s, 1 << r), nu(s, 1, 1), ru(s, 2), (l = au(s));
					} else nu(s, 0, n), nu(s, 1 << -t, 0), (l = au(s) + oo.call("0", o));
				return o > 0
					? u +
							((a = l.length) <= o
								? "0." + oo.call("0", o - a) + l
								: l.slice(0, a - o) + "." + l.slice(a - o))
					: u + l;
			},
		}
	);
	var ou = (1).toPrecision,
		su =
			i(function () {
				return "1" !== ou.call(1, void 0);
			}) ||
			!i(function () {
				ou.call({});
			});
	De(
		{ target: "Number", proto: !0, forced: su },
		{
			toPrecision: function (e) {
				return void 0 === e ? ou.call(Qs(this)) : ou.call(Qs(this), e);
			},
		}
	);
	var uu = Math.log,
		lu =
			Math.log1p ||
			function (e) {
				return (e = +e) > -1e-8 && e < 1e-8 ? e - (e * e) / 2 : uu(1 + e);
			},
		cu = Math.acosh,
		pu = Math.log,
		hu = Math.sqrt,
		fu = Math.LN2,
		du = !cu || 710 != Math.floor(cu(Number.MAX_VALUE)) || cu(1 / 0) != 1 / 0;
	De(
		{ target: "Math", stat: !0, forced: du },
		{
			acosh: function (e) {
				return (e = +e) < 1 ? NaN : e > 94906265.62425156 ? pu(e) + fu : lu(e - 1 + hu(e - 1) * hu(e + 1));
			},
		}
	);
	var mu = Math.asinh,
		gu = Math.log,
		vu = Math.sqrt;
	De(
		{ target: "Math", stat: !0, forced: !(mu && 1 / mu(0) > 0) },
		{
			asinh: function e(t) {
				return isFinite((t = +t)) && 0 != t ? (t < 0 ? -e(-t) : gu(t + vu(t * t + 1))) : t;
			},
		}
	);
	var yu = Math.atanh,
		bu = Math.log;
	De(
		{ target: "Math", stat: !0, forced: !(yu && 1 / yu(-0) < 0) },
		{
			atanh: function (e) {
				return 0 == (e = +e) ? e : bu((1 + e) / (1 - e)) / 2;
			},
		}
	);
	var xu =
			Math.sign ||
			function (e) {
				return 0 == (e = +e) || e != e ? e : e < 0 ? -1 : 1;
			},
		wu = Math.abs,
		ku = Math.pow;
	De(
		{ target: "Math", stat: !0 },
		{
			cbrt: function (e) {
				return xu((e = +e)) * ku(wu(e), 1 / 3);
			},
		}
	);
	var Nu = Math.floor,
		Iu = Math.log,
		Su = Math.LOG2E;
	De(
		{ target: "Math", stat: !0 },
		{
			clz32: function (e) {
				return (e >>>= 0) ? 31 - Nu(Iu(e + 0.5) * Su) : 32;
			},
		}
	);
	var Tu = Math.expm1,
		Cu = Math.exp,
		Eu =
			!Tu || Tu(10) > 22025.465794806718 || Tu(10) < 22025.465794806718 || -2e-17 != Tu(-2e-17)
				? function (e) {
						return 0 == (e = +e) ? e : e > -1e-6 && e < 1e-6 ? e + (e * e) / 2 : Cu(e) - 1;
				  }
				: Tu,
		Ru = Math.cosh,
		Au = Math.abs,
		_u = Math.E;
	De(
		{ target: "Math", stat: !0, forced: !Ru || Ru(710) === 1 / 0 },
		{
			cosh: function (e) {
				var t = Eu(Au(e) - 1) + 1;
				return (t + 1 / (t * _u * _u)) * (_u / 2);
			},
		}
	),
		De({ target: "Math", stat: !0, forced: Eu != Math.expm1 }, { expm1: Eu });
	var Fu = Math.abs,
		Du = Math.pow,
		Ou = Du(2, -52),
		Mu = Du(2, -23),
		Lu = Du(2, 127) * (2 - Mu),
		zu = Du(2, -126),
		Pu =
			Math.fround ||
			function (e) {
				var t,
					n,
					r = Fu(e),
					a = xu(e);
				return r < zu
					? a * (r / zu / Mu + 1 / Ou - 1 / Ou) * zu * Mu
					: (n = (t = (1 + Mu / Ou) * r) - (t - r)) > Lu || n != n
					? a * (1 / 0)
					: a * n;
			};
	De({ target: "Math", stat: !0 }, { fround: Pu });
	var Bu = Math.hypot,
		Wu = Math.abs,
		Uu = Math.sqrt,
		Vu = !!Bu && Bu(1 / 0, NaN) !== 1 / 0;
	De(
		{ target: "Math", stat: !0, forced: Vu },
		{
			hypot: function (e, t) {
				for (var n, r, a = 0, i = 0, o = arguments.length, s = 0; i < o; )
					s < (n = Wu(arguments[i++]))
						? ((a = a * (r = s / n) * r + 1), (s = n))
						: (a += n > 0 ? (r = n / s) * r : n);
				return s === 1 / 0 ? 1 / 0 : s * Uu(a);
			},
		}
	);
	var Gu = Math.imul,
		ju = i(function () {
			return -5 != Gu(4294967295, 5) || 2 != Gu.length;
		});
	De(
		{ target: "Math", stat: !0, forced: ju },
		{
			imul: function (e, t) {
				var n = 65535,
					r = +e,
					a = +t,
					i = n & r,
					o = n & a;
				return 0 | (i * o + ((((n & (r >>> 16)) * o + i * (n & (a >>> 16))) << 16) >>> 0));
			},
		}
	);
	var Hu = Math.log,
		qu = Math.LOG10E;
	De(
		{ target: "Math", stat: !0 },
		{
			log10: function (e) {
				return Hu(e) * qu;
			},
		}
	),
		De({ target: "Math", stat: !0 }, { log1p: lu });
	var Ku = Math.log,
		Xu = Math.LN2;
	De(
		{ target: "Math", stat: !0 },
		{
			log2: function (e) {
				return Ku(e) / Xu;
			},
		}
	),
		De({ target: "Math", stat: !0 }, { sign: xu });
	var Yu = Math.abs,
		Ju = Math.exp,
		Zu = Math.E,
		Qu = i(function () {
			return -2e-17 != Math.sinh(-2e-17);
		});
	De(
		{ target: "Math", stat: !0, forced: Qu },
		{
			sinh: function (e) {
				return Yu((e = +e)) < 1 ? (Eu(e) - Eu(-e)) / 2 : (Ju(e - 1) - Ju(-e - 1)) * (Zu / 2);
			},
		}
	);
	var $u = Math.exp;
	De(
		{ target: "Math", stat: !0 },
		{
			tanh: function (e) {
				var t = Eu((e = +e)),
					n = Eu(-e);
				return t == 1 / 0 ? 1 : n == 1 / 0 ? -1 : (t - n) / ($u(e) + $u(-e));
			},
		}
	),
		ht(Math, "Math", !0);
	var el = Math.ceil,
		tl = Math.floor;
	De(
		{ target: "Math", stat: !0 },
		{
			trunc: function (e) {
				return (e > 0 ? tl : el)(e);
			},
		}
	),
		De(
			{ target: "Date", stat: !0 },
			{
				now: function () {
					return new Date().getTime();
				},
			}
		);
	var nl = i(function () {
		return (
			null !== new Date(NaN).toJSON() ||
			1 !==
				Date.prototype.toJSON.call({
					toISOString: function () {
						return 1;
					},
				})
		);
	});
	De(
		{ target: "Date", proto: !0, forced: nl },
		{
			toJSON: function (e) {
				var t = je(this),
					n = y(t);
				return "number" != typeof n || isFinite(n) ? t.toISOString() : null;
			},
		}
	);
	var rl = lo.start,
		al = Math.abs,
		il = Date.prototype,
		ol = il.getTime,
		sl = il.toISOString,
		ul =
			i(function () {
				return "0385-07-25T07:06:39.999Z" != sl.call(new Date(-50000000000001));
			}) ||
			!i(function () {
				sl.call(new Date(NaN));
			})
				? function () {
						if (!isFinite(ol.call(this))) throw RangeError("Invalid time value");
						var e = this,
							t = e.getUTCFullYear(),
							n = e.getUTCMilliseconds(),
							r = t < 0 ? "-" : t > 9999 ? "+" : "";
						return (
							r +
							rl(al(t), r ? 6 : 4, 0) +
							"-" +
							rl(e.getUTCMonth() + 1, 2, 0) +
							"-" +
							rl(e.getUTCDate(), 2, 0) +
							"T" +
							rl(e.getUTCHours(), 2, 0) +
							":" +
							rl(e.getUTCMinutes(), 2, 0) +
							":" +
							rl(e.getUTCSeconds(), 2, 0) +
							"." +
							rl(n, 3, 0) +
							"Z"
						);
				  }
				: sl;
	De({ target: "Date", proto: !0, forced: Date.prototype.toISOString !== ul }, { toISOString: ul });
	var ll = Date.prototype,
		cl = "Invalid Date",
		pl = ll.toString,
		hl = ll.getTime;
	new Date(NaN) + "" != cl &&
		re(ll, "toString", function () {
			var e = hl.call(this);
			return e == e ? pl.call(this) : cl;
		});
	var fl = ot("toPrimitive"),
		dl = Date.prototype;
	fl in dl ||
		A(dl, fl, function (e) {
			if ("string" !== e && "number" !== e && "default" !== e) throw TypeError("Incorrect hint");
			return y(C(this), "number" !== e);
		});
	var ml = oe("JSON", "stringify"),
		gl = /[\uD800-\uDFFF]/g,
		vl = /^[\uD800-\uDBFF]$/,
		yl = /^[\uDC00-\uDFFF]$/,
		bl = function (e, t, n) {
			var r = n.charAt(t - 1),
				a = n.charAt(t + 1);
			return (vl.test(e) && !yl.test(a)) || (yl.test(e) && !vl.test(r))
				? "\\u" + e.charCodeAt(0).toString(16)
				: e;
		},
		xl = i(function () {
			return '"\\udf06\\ud834"' !== ml("\udf06\ud834") || '"\\udead"' !== ml("\udead");
		});
	ml &&
		De(
			{ target: "JSON", stat: !0, forced: xl },
			{
				stringify: function (e, t, n) {
					var r = ml.apply(null, arguments);
					return "string" == typeof r ? r.replace(gl, bl) : r;
				},
			}
		),
		ht(a.JSON, "JSON", !0);
	var wl,
		kl,
		Nl,
		Il = a.Promise,
		Sl = function (e, t, n) {
			for (var r in t) re(e, r, t[r], n);
			return e;
		},
		Tl = function (e, t, n) {
			if (!(e instanceof t)) throw TypeError("Incorrect " + (n ? n + " " : "") + "invocation");
			return e;
		},
		Cl = /(iphone|ipod|ipad).*applewebkit/i.test(Me),
		El = a.location,
		Rl = a.setImmediate,
		Al = a.clearImmediate,
		_l = a.process,
		Fl = a.MessageChannel,
		Dl = a.Dispatch,
		Ol = 0,
		Ml = {},
		Ll = function (e) {
			if (Ml.hasOwnProperty(e)) {
				var t = Ml[e];
				delete Ml[e], t();
			}
		},
		zl = function (e) {
			return function () {
				Ll(e);
			};
		},
		Pl = function (e) {
			Ll(e.data);
		},
		Bl = function (e) {
			a.postMessage(e + "", El.protocol + "//" + El.host);
		};
	(Rl && Al) ||
		((Rl = function (e) {
			for (var t = [], n = 1; arguments.length > n; ) t.push(arguments[n++]);
			return (
				(Ml[++Ol] = function () {
					("function" == typeof e ? e : Function(e)).apply(void 0, t);
				}),
				wl(Ol),
				Ol
			);
		}),
		(Al = function (e) {
			delete Ml[e];
		}),
		Oe
			? (wl = function (e) {
					_l.nextTick(zl(e));
			  })
			: Dl && Dl.now
			? (wl = function (e) {
					Dl.now(zl(e));
			  })
			: Fl && !Cl
			? ((Nl = (kl = new Fl()).port2), (kl.port1.onmessage = Pl), (wl = dt(Nl.postMessage, Nl, 1)))
			: a.addEventListener &&
			  "function" == typeof postMessage &&
			  !a.importScripts &&
			  El &&
			  "file:" !== El.protocol &&
			  !i(Bl)
			? ((wl = Bl), a.addEventListener("message", Pl, !1))
			: (wl =
					"onreadystatechange" in N("script")
						? function (e) {
								Ke.appendChild(N("script")).onreadystatechange = function () {
									Ke.removeChild(this), Ll(e);
								};
						  }
						: function (e) {
								setTimeout(zl(e), 0);
						  }));
	var Wl,
		Ul,
		Vl,
		Gl,
		jl,
		Hl,
		ql,
		Kl,
		Xl = { set: Rl, clear: Al },
		Yl = /web0s(?!.*chrome)/i.test(Me),
		Jl = T.f,
		Zl = Xl.set,
		Ql = a.MutationObserver || a.WebKitMutationObserver,
		$l = a.document,
		ec = a.process,
		tc = a.Promise,
		nc = Jl(a, "queueMicrotask"),
		rc = nc && nc.value;
	rc ||
		((Wl = function () {
			var e, t;
			for (Oe && (e = ec.domain) && e.exit(); Ul; ) {
				(t = Ul.fn), (Ul = Ul.next);
				try {
					t();
				} catch (e) {
					throw (Ul ? Gl() : (Vl = void 0), e);
				}
			}
			(Vl = void 0), e && e.enter();
		}),
		Cl || Oe || Yl || !Ql || !$l
			? tc && tc.resolve
				? ((ql = tc.resolve(void 0)),
				  (Kl = ql.then),
				  (Gl = function () {
						Kl.call(ql, Wl);
				  }))
				: (Gl = Oe
						? function () {
								ec.nextTick(Wl);
						  }
						: function () {
								Zl.call(a, Wl);
						  })
			: ((jl = !0),
			  (Hl = $l.createTextNode("")),
			  new Ql(Wl).observe(Hl, { characterData: !0 }),
			  (Gl = function () {
					Hl.data = jl = !jl;
			  })));
	var ac,
		ic,
		oc,
		sc,
		uc =
			rc ||
			function (e) {
				var t = { fn: e, next: void 0 };
				Vl && (Vl.next = t), Ul || ((Ul = t), Gl()), (Vl = t);
			},
		lc = function (e) {
			var t, n;
			(this.promise = new e(function (e, r) {
				if (void 0 !== t || void 0 !== n) throw TypeError("Bad Promise constructor");
				(t = e), (n = r);
			})),
				(this.resolve = ft(t)),
				(this.reject = ft(n));
		},
		cc = {
			f: function (e) {
				return new lc(e);
			},
		},
		pc = function (e, t) {
			if ((C(e), v(t) && t.constructor === e)) return t;
			var n = cc.f(e);
			return (0, n.resolve)(t), n.promise;
		},
		hc = function (e) {
			try {
				return { error: !1, value: e() };
			} catch (e) {
				return { error: !0, value: e };
			}
		},
		fc = Xl.set,
		dc = ot("species"),
		mc = "Promise",
		gc = ne.get,
		vc = ne.set,
		yc = ne.getterFor(mc),
		bc = Il,
		xc = a.TypeError,
		wc = a.document,
		kc = a.process,
		Nc = oe("fetch"),
		Ic = cc.f,
		Sc = Ic,
		Tc = !!(wc && wc.createEvent && a.dispatchEvent),
		Cc = "function" == typeof PromiseRejectionEvent,
		Ec = "unhandledrejection",
		Rc = _e(mc, function () {
			if (P(bc) === String(bc)) {
				if (66 === We) return !0;
				if (!Oe && !Cc) return !0;
			}
			if (We >= 51 && /native code/.test(bc)) return !1;
			var e = bc.resolve(1),
				t = function (e) {
					e(
						function () {},
						function () {}
					);
				};
			return ((e.constructor = {})[dc] = t), !(e.then(function () {}) instanceof t);
		}),
		Ac =
			Rc ||
			!Dn(function (e) {
				bc.all(e).catch(function () {});
			}),
		_c = function (e) {
			var t;
			return !(!v(e) || "function" != typeof (t = e.then)) && t;
		},
		Fc = function (e, t) {
			if (!e.notified) {
				e.notified = !0;
				var n = e.reactions;
				uc(function () {
					for (var r = e.value, a = 1 == e.state, i = 0; n.length > i; ) {
						var o,
							s,
							u,
							l = n[i++],
							c = a ? l.ok : l.fail,
							p = l.resolve,
							h = l.reject,
							f = l.domain;
						try {
							c
								? (a || (2 === e.rejection && Lc(e), (e.rejection = 1)),
								  !0 === c ? (o = r) : (f && f.enter(), (o = c(r)), f && (f.exit(), (u = !0))),
								  o === l.promise ? h(xc("Promise-chain cycle")) : (s = _c(o)) ? s.call(o, p, h) : p(o))
								: h(r);
						} catch (e) {
							f && !u && f.exit(), h(e);
						}
					}
					(e.reactions = []), (e.notified = !1), t && !e.rejection && Oc(e);
				});
			}
		},
		Dc = function (e, t, n) {
			var r, i;
			Tc
				? (((r = wc.createEvent("Event")).promise = t),
				  (r.reason = n),
				  r.initEvent(e, !1, !0),
				  a.dispatchEvent(r))
				: (r = { promise: t, reason: n }),
				!Cc && (i = a["on" + e])
					? i(r)
					: e === Ec &&
					  (function (e, t) {
							var n = a.console;
							n && n.error && (1 === arguments.length ? n.error(e) : n.error(e, t));
					  })("Unhandled promise rejection", n);
		},
		Oc = function (e) {
			fc.call(a, function () {
				var t,
					n = e.facade,
					r = e.value;
				if (
					Mc(e) &&
					((t = hc(function () {
						Oe ? kc.emit("unhandledRejection", r, n) : Dc(Ec, n, r);
					})),
					(e.rejection = Oe || Mc(e) ? 2 : 1),
					t.error)
				)
					throw t.value;
			});
		},
		Mc = function (e) {
			return 1 !== e.rejection && !e.parent;
		},
		Lc = function (e) {
			fc.call(a, function () {
				var t = e.facade;
				Oe ? kc.emit("rejectionHandled", t) : Dc("rejectionhandled", t, e.value);
			});
		},
		zc = function (e, t, n) {
			return function (r) {
				e(t, r, n);
			};
		},
		Pc = function (e, t, n) {
			e.done || ((e.done = !0), n && (e = n), (e.value = t), (e.state = 2), Fc(e, !0));
		},
		Bc = function e(t, n, r) {
			if (!t.done) {
				(t.done = !0), r && (t = r);
				try {
					if (t.facade === n) throw xc("Promise can't be resolved itself");
					var a = _c(n);
					a
						? uc(function () {
								var r = { done: !1 };
								try {
									a.call(n, zc(e, r, t), zc(Pc, r, t));
								} catch (e) {
									Pc(r, e, t);
								}
						  })
						: ((t.value = n), (t.state = 1), Fc(t, !1));
				} catch (e) {
					Pc({ done: !1 }, e, t);
				}
			}
		};
	Rc &&
		((bc = function (e) {
			Tl(this, bc, mc), ft(e), ac.call(this);
			var t = gc(this);
			try {
				e(zc(Bc, t), zc(Pc, t));
			} catch (e) {
				Pc(t, e);
			}
		}),
		((ac = function (e) {
			vc(this, {
				type: mc,
				done: !1,
				notified: !1,
				parent: !1,
				reactions: [],
				rejection: !1,
				state: 0,
				value: void 0,
			});
		}).prototype = Sl(bc.prototype, {
			then: function (e, t) {
				var n = yc(this),
					r = Ic(Ji(this, bc));
				return (
					(r.ok = "function" != typeof e || e),
					(r.fail = "function" == typeof t && t),
					(r.domain = Oe ? kc.domain : void 0),
					(n.parent = !0),
					n.reactions.push(r),
					0 != n.state && Fc(n, !1),
					r.promise
				);
			},
			catch: function (e) {
				return this.then(void 0, e);
			},
		})),
		(ic = function () {
			var e = new ac(),
				t = gc(e);
			(this.promise = e), (this.resolve = zc(Bc, t)), (this.reject = zc(Pc, t));
		}),
		(cc.f = Ic =
			function (e) {
				return e === bc || e === oc ? new ic(e) : Sc(e);
			}),
		"function" == typeof Il &&
			((sc = Il.prototype.then),
			re(
				Il.prototype,
				"then",
				function (e, t) {
					var n = this;
					return new bc(function (e, t) {
						sc.call(n, e, t);
					}).then(e, t);
				},
				{ unsafe: !0 }
			),
			"function" == typeof Nc &&
				De(
					{ global: !0, enumerable: !0, forced: !0 },
					{
						fetch: function (e) {
							return pc(bc, Nc.apply(a, arguments));
						},
					}
				))),
		De({ global: !0, wrap: !0, forced: Rc }, { Promise: bc }),
		ht(bc, mc, !1),
		Jr(mc),
		(oc = oe(mc)),
		De(
			{ target: mc, stat: !0, forced: Rc },
			{
				reject: function (e) {
					var t = Ic(this);
					return t.reject.call(void 0, e), t.promise;
				},
			}
		),
		De(
			{ target: mc, stat: !0, forced: Rc },
			{
				resolve: function (e) {
					return pc(this, e);
				},
			}
		),
		De(
			{ target: mc, stat: !0, forced: Ac },
			{
				all: function (e) {
					var t = this,
						n = Ic(t),
						r = n.resolve,
						a = n.reject,
						i = hc(function () {
							var n = ft(t.resolve),
								i = [],
								o = 0,
								s = 1;
							In(e, function (e) {
								var u = o++,
									l = !1;
								i.push(void 0),
									s++,
									n.call(t, e).then(function (e) {
										l || ((l = !0), (i[u] = e), --s || r(i));
									}, a);
							}),
								--s || r(i);
						});
					return i.error && a(i.value), n.promise;
				},
				race: function (e) {
					var t = this,
						n = Ic(t),
						r = n.reject,
						a = hc(function () {
							var a = ft(t.resolve);
							In(e, function (e) {
								a.call(t, e).then(n.resolve, r);
							});
						});
					return a.error && r(a.value), n.promise;
				},
			}
		),
		De(
			{ target: "Promise", stat: !0 },
			{
				allSettled: function (e) {
					var t = this,
						n = cc.f(t),
						r = n.resolve,
						a = n.reject,
						i = hc(function () {
							var n = ft(t.resolve),
								a = [],
								i = 0,
								o = 1;
							In(e, function (e) {
								var s = i++,
									u = !1;
								a.push(void 0),
									o++,
									n.call(t, e).then(
										function (e) {
											u || ((u = !0), (a[s] = { status: "fulfilled", value: e }), --o || r(a));
										},
										function (e) {
											u || ((u = !0), (a[s] = { status: "rejected", reason: e }), --o || r(a));
										}
									);
							}),
								--o || r(a);
						});
					return i.error && a(i.value), n.promise;
				},
			}
		);
	var Wc = "No one promise resolved";
	De(
		{ target: "Promise", stat: !0 },
		{
			any: function (e) {
				var t = this,
					n = cc.f(t),
					r = n.resolve,
					a = n.reject,
					i = hc(function () {
						var n = ft(t.resolve),
							i = [],
							o = 0,
							s = 1,
							u = !1;
						In(e, function (e) {
							var l = o++,
								c = !1;
							i.push(void 0),
								s++,
								n.call(t, e).then(
									function (e) {
										c || u || ((u = !0), r(e));
									},
									function (e) {
										c || u || ((c = !0), (i[l] = e), --s || a(new (oe("AggregateError"))(i, Wc)));
									}
								);
						}),
							--s || a(new (oe("AggregateError"))(i, Wc));
					});
				return i.error && a(i.value), n.promise;
			},
		}
	);
	var Uc =
		!!Il &&
		i(function () {
			Il.prototype.finally.call({ then: function () {} }, function () {});
		});
	De(
		{ target: "Promise", proto: !0, real: !0, forced: Uc },
		{
			finally: function (e) {
				var t = Ji(this, oe("Promise")),
					n = "function" == typeof e;
				return this.then(
					n
						? function (n) {
								return pc(t, e()).then(function () {
									return n;
								});
						  }
						: e,
					n
						? function (n) {
								return pc(t, e()).then(function () {
									throw n;
								});
						  }
						: e
				);
			},
		}
	),
		"function" != typeof Il || Il.prototype.finally || re(Il.prototype, "finally", oe("Promise").prototype.finally);
	var Vc = function (e, t, n) {
			var r = -1 !== e.indexOf("Map"),
				o = -1 !== e.indexOf("Weak"),
				s = r ? "set" : "add",
				u = a[e],
				l = u && u.prototype,
				c = u,
				p = {},
				h = function (e) {
					var t = l[e];
					re(
						l,
						e,
						"add" == e
							? function (e) {
									return t.call(this, 0 === e ? 0 : e), this;
							  }
							: "delete" == e
							? function (e) {
									return !(o && !v(e)) && t.call(this, 0 === e ? 0 : e);
							  }
							: "get" == e
							? function (e) {
									return o && !v(e) ? void 0 : t.call(this, 0 === e ? 0 : e);
							  }
							: "has" == e
							? function (e) {
									return !(o && !v(e)) && t.call(this, 0 === e ? 0 : e);
							  }
							: function (e, n) {
									return t.call(this, 0 === e ? 0 : e, n), this;
							  }
					);
				};
			if (
				_e(
					e,
					"function" != typeof u ||
						!(
							o ||
							(l.forEach &&
								!i(function () {
									new u().entries().next();
								}))
						)
				)
			)
				(c = n.getConstructor(t, e, r, s)), (Pa.REQUIRED = !0);
			else if (_e(e, !0)) {
				var f = new c(),
					d = f[s](o ? {} : -0, 1) != f,
					m = i(function () {
						f.has(1);
					}),
					g = Dn(function (e) {
						new u(e);
					}),
					y =
						!o &&
						i(function () {
							for (var e = new u(), t = 5; t--; ) e[s](t, t);
							return !e.has(-0);
						});
				g ||
					(((c = t(function (t, n) {
						Tl(t, c, e);
						var a = ts(new u(), t, c);
						return null != n && In(n, a[s], { that: a, AS_ENTRIES: r }), a;
					})).prototype = l),
					(l.constructor = c)),
					(m || y) && (h("delete"), h("has"), r && h("get")),
					(y || d) && h(s),
					o && l.clear && delete l.clear;
			}
			return (p[e] = c), De({ global: !0, forced: c != u }, p), ht(c, e), o || n.setStrong(c, e, r), c;
		},
		Gc = R.f,
		jc = Pa.fastKey,
		Hc = ne.set,
		qc = ne.getterFor,
		Kc = {
			getConstructor: function (e, t, n, r) {
				var a = e(function (e, i) {
						Tl(e, a, t),
							Hc(e, { type: t, index: Qe(null), first: void 0, last: void 0, size: 0 }),
							o || (e.size = 0),
							null != i && In(i, e[r], { that: e, AS_ENTRIES: n });
					}),
					i = qc(t),
					s = function (e, t, n) {
						var r,
							a,
							s = i(e),
							l = u(e, t);
						return (
							l
								? (l.value = n)
								: ((s.last = l =
										{
											index: (a = jc(t, !0)),
											key: t,
											value: n,
											previous: (r = s.last),
											next: void 0,
											removed: !1,
										}),
								  s.first || (s.first = l),
								  r && (r.next = l),
								  o ? s.size++ : e.size++,
								  "F" !== a && (s.index[a] = l)),
							e
						);
					},
					u = function (e, t) {
						var n,
							r = i(e),
							a = jc(t);
						if ("F" !== a) return r.index[a];
						for (n = r.first; n; n = n.next) if (n.key == t) return n;
					};
				return (
					Sl(a.prototype, {
						clear: function () {
							for (var e = i(this), t = e.index, n = e.first; n; )
								(n.removed = !0),
									n.previous && (n.previous = n.previous.next = void 0),
									delete t[n.index],
									(n = n.next);
							(e.first = e.last = void 0), o ? (e.size = 0) : (this.size = 0);
						},
						delete: function (e) {
							var t = this,
								n = i(t),
								r = u(t, e);
							if (r) {
								var a = r.next,
									s = r.previous;
								delete n.index[r.index],
									(r.removed = !0),
									s && (s.next = a),
									a && (a.previous = s),
									n.first == r && (n.first = a),
									n.last == r && (n.last = s),
									o ? n.size-- : t.size--;
							}
							return !!r;
						},
						forEach: function (e) {
							for (
								var t, n = i(this), r = dt(e, arguments.length > 1 ? arguments[1] : void 0, 3);
								(t = t ? t.next : n.first);

							)
								for (r(t.value, t.key, this); t && t.removed; ) t = t.previous;
						},
						has: function (e) {
							return !!u(this, e);
						},
					}),
					Sl(
						a.prototype,
						n
							? {
									get: function (e) {
										var t = u(this, e);
										return t && t.value;
									},
									set: function (e, t) {
										return s(this, 0 === e ? 0 : e, t);
									},
							  }
							: {
									add: function (e) {
										return s(this, (e = 0 === e ? 0 : e), e);
									},
							  }
					),
					o &&
						Gc(a.prototype, "size", {
							get: function () {
								return i(this).size;
							},
						}),
					a
				);
			},
			setStrong: function (e, t, n) {
				var r = t + " Iterator",
					a = qc(t),
					i = qc(r);
				da(
					e,
					t,
					function (e, t) {
						Hc(this, { type: r, target: e, state: a(e), kind: t, last: void 0 });
					},
					function () {
						for (var e = i(this), t = e.kind, n = e.last; n && n.removed; ) n = n.previous;
						return e.target && (e.last = n = n ? n.next : e.state.first)
							? "keys" == t
								? { value: n.key, done: !1 }
								: "values" == t
								? { value: n.value, done: !1 }
								: { value: [n.key, n.value], done: !1 }
							: ((e.target = void 0), { value: void 0, done: !0 });
					},
					n ? "entries" : "values",
					!n,
					!0
				),
					Jr(t);
			},
		},
		Xc =
			(Vc(
				"Map",
				function (e) {
					return function () {
						return e(this, arguments.length ? arguments[0] : void 0);
					};
				},
				Kc
			),
			Vc(
				"Set",
				function (e) {
					return function () {
						return e(this, arguments.length ? arguments[0] : void 0);
					};
				},
				Kc
			),
			Pa.getWeakData),
		Yc = ne.set,
		Jc = ne.getterFor,
		Zc = bt.find,
		Qc = bt.findIndex,
		$c = 0,
		ep = function (e) {
			return e.frozen || (e.frozen = new tp());
		},
		tp = function () {
			this.entries = [];
		},
		np = function (e, t) {
			return Zc(e.entries, function (e) {
				return e[0] === t;
			});
		};
	tp.prototype = {
		get: function (e) {
			var t = np(this, e);
			if (t) return t[1];
		},
		has: function (e) {
			return !!np(this, e);
		},
		set: function (e, t) {
			var n = np(this, e);
			n ? (n[1] = t) : this.entries.push([e, t]);
		},
		delete: function (e) {
			var t = Qc(this.entries, function (t) {
				return t[0] === e;
			});
			return ~t && this.entries.splice(t, 1), !!~t;
		},
	};
	var rp = {
		getConstructor: function (e, t, n, r) {
			var a = e(function (e, i) {
					Tl(e, a, t),
						Yc(e, { type: t, id: $c++, frozen: void 0 }),
						null != i && In(i, e[r], { that: e, AS_ENTRIES: n });
				}),
				i = Jc(t),
				o = function (e, t, n) {
					var r = i(e),
						a = Xc(C(t), !0);
					return !0 === a ? ep(r).set(t, n) : (a[r.id] = n), e;
				};
			return (
				Sl(a.prototype, {
					delete: function (e) {
						var t = i(this);
						if (!v(e)) return !1;
						var n = Xc(e);
						return !0 === n ? ep(t).delete(e) : n && x(n, t.id) && delete n[t.id];
					},
					has: function (e) {
						var t = i(this);
						if (!v(e)) return !1;
						var n = Xc(e);
						return !0 === n ? ep(t).has(e) : n && x(n, t.id);
					},
				}),
				Sl(
					a.prototype,
					n
						? {
								get: function (e) {
									var t = i(this);
									if (v(e)) {
										var n = Xc(e);
										return !0 === n ? ep(t).get(e) : n ? n[t.id] : void 0;
									}
								},
								set: function (e, t) {
									return o(this, e, t);
								},
						  }
						: {
								add: function (e) {
									return o(this, e, !0);
								},
						  }
				),
				a
			);
		},
	};
	n(function (e) {
		var t,
			n = ne.enforce,
			r = !a.ActiveXObject && "ActiveXObject" in a,
			i = Object.isExtensible,
			o = function (e) {
				return function () {
					return e(this, arguments.length ? arguments[0] : void 0);
				};
			},
			s = (e.exports = Vc("WeakMap", o, rp));
		if (W && r) {
			(t = rp.getConstructor(o, "WeakMap", !0)), (Pa.REQUIRED = !0);
			var u = s.prototype,
				l = u.delete,
				c = u.has,
				p = u.get,
				h = u.set;
			Sl(u, {
				delete: function (e) {
					if (v(e) && !i(e)) {
						var r = n(this);
						return r.frozen || (r.frozen = new t()), l.call(this, e) || r.frozen.delete(e);
					}
					return l.call(this, e);
				},
				has: function (e) {
					if (v(e) && !i(e)) {
						var r = n(this);
						return r.frozen || (r.frozen = new t()), c.call(this, e) || r.frozen.has(e);
					}
					return c.call(this, e);
				},
				get: function (e) {
					if (v(e) && !i(e)) {
						var r = n(this);
						return r.frozen || (r.frozen = new t()), c.call(this, e) ? p.call(this, e) : r.frozen.get(e);
					}
					return p.call(this, e);
				},
				set: function (e, r) {
					if (v(e) && !i(e)) {
						var a = n(this);
						a.frozen || (a.frozen = new t()), c.call(this, e) ? h.call(this, e, r) : a.frozen.set(e, r);
					} else h.call(this, e, r);
					return this;
				},
			});
		}
	}),
		Vc(
			"WeakSet",
			function (e) {
				return function () {
					return e(this, arguments.length ? arguments[0] : void 0);
				};
			},
			rp
		);
	var ap = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView,
		ip = function (e) {
			if (void 0 === e) return 0;
			var t = le(e),
				n = pe(t);
			if (t !== n) throw RangeError("Wrong length or index");
			return n;
		},
		op = Math.abs,
		sp = Math.pow,
		up = Math.floor,
		lp = Math.log,
		cp = Math.LN2,
		pp = we.f,
		hp = R.f,
		fp = ne.get,
		dp = ne.set,
		mp = "ArrayBuffer",
		gp = "DataView",
		vp = "Wrong index",
		yp = a.ArrayBuffer,
		bp = yp,
		xp = a.DataView,
		wp = xp && xp.prototype,
		kp = Object.prototype,
		Np = a.RangeError,
		Ip = function (e, t, n) {
			var r,
				a,
				i,
				o = new Array(n),
				s = 8 * n - t - 1,
				u = (1 << s) - 1,
				l = u >> 1,
				c = 23 === t ? sp(2, -24) - sp(2, -77) : 0,
				p = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0,
				h = 0;
			for (
				(e = op(e)) != e || e === 1 / 0
					? ((a = e != e ? 1 : 0), (r = u))
					: ((r = up(lp(e) / cp)),
					  e * (i = sp(2, -r)) < 1 && (r--, (i *= 2)),
					  (e += r + l >= 1 ? c / i : c * sp(2, 1 - l)) * i >= 2 && (r++, (i /= 2)),
					  r + l >= u
							? ((a = 0), (r = u))
							: r + l >= 1
							? ((a = (e * i - 1) * sp(2, t)), (r += l))
							: ((a = e * sp(2, l - 1) * sp(2, t)), (r = 0)));
				t >= 8;
				o[h++] = 255 & a, a /= 256, t -= 8
			);
			for (r = (r << t) | a, s += t; s > 0; o[h++] = 255 & r, r /= 256, s -= 8);
			return (o[--h] |= 128 * p), o;
		},
		Sp = function (e, t) {
			var n,
				r = e.length,
				a = 8 * r - t - 1,
				i = (1 << a) - 1,
				o = i >> 1,
				s = a - 7,
				u = r - 1,
				l = e[u--],
				c = 127 & l;
			for (l >>= 7; s > 0; c = 256 * c + e[u], u--, s -= 8);
			for (n = c & ((1 << -s) - 1), c >>= -s, s += t; s > 0; n = 256 * n + e[u], u--, s -= 8);
			if (0 === c) c = 1 - o;
			else {
				if (c === i) return n ? NaN : l ? -1 / 0 : 1 / 0;
				(n += sp(2, t)), (c -= o);
			}
			return (l ? -1 : 1) * n * sp(2, c - t);
		},
		Tp = function (e) {
			return [255 & e];
		},
		Cp = function (e) {
			return [255 & e, (e >> 8) & 255];
		},
		Ep = function (e) {
			return [255 & e, (e >> 8) & 255, (e >> 16) & 255, (e >> 24) & 255];
		},
		Rp = function (e) {
			return (e[3] << 24) | (e[2] << 16) | (e[1] << 8) | e[0];
		},
		Ap = function (e) {
			return Ip(e, 23, 4);
		},
		_p = function (e) {
			return Ip(e, 52, 8);
		},
		Fp = function (e, t) {
			hp(e.prototype, t, {
				get: function () {
					return fp(this)[t];
				},
			});
		},
		Dp = function (e, t, n, r) {
			var a = ip(n),
				i = fp(e);
			if (a + t > i.byteLength) throw Np(vp);
			var o = fp(i.buffer).bytes,
				s = a + i.byteOffset,
				u = o.slice(s, s + t);
			return r ? u : u.reverse();
		},
		Op = function (e, t, n, r, a, i) {
			var o = ip(n),
				s = fp(e);
			if (o + t > s.byteLength) throw Np(vp);
			for (var u = fp(s.buffer).bytes, l = o + s.byteOffset, c = r(+a), p = 0; p < t; p++)
				u[l + p] = c[i ? p : t - p - 1];
		};
	if (ap) {
		if (
			!i(function () {
				yp(1);
			}) ||
			!i(function () {
				new yp(-1);
			}) ||
			i(function () {
				return new yp(), new yp(1.5), new yp(NaN), yp.name != mp;
			})
		) {
			for (
				var Mp,
					Lp = ((bp = function (e) {
						return Tl(this, bp), new yp(ip(e));
					}).prototype = yp.prototype),
					zp = pp(yp),
					Pp = 0;
				zp.length > Pp;

			)
				(Mp = zp[Pp++]) in bp || A(bp, Mp, yp[Mp]);
			Lp.constructor = bp;
		}
		cn && un(wp) !== kp && cn(wp, kp);
		var Bp = new xp(new bp(2)),
			Wp = wp.setInt8;
		Bp.setInt8(0, 2147483648),
			Bp.setInt8(1, 2147483649),
			(!Bp.getInt8(0) && Bp.getInt8(1)) ||
				Sl(
					wp,
					{
						setInt8: function (e, t) {
							Wp.call(this, e, (t << 24) >> 24);
						},
						setUint8: function (e, t) {
							Wp.call(this, e, (t << 24) >> 24);
						},
					},
					{ unsafe: !0 }
				);
	} else
		(bp = function (e) {
			Tl(this, bp, mp);
			var t = ip(e);
			dp(this, { bytes: Qn.call(new Array(t), 0), byteLength: t }), o || (this.byteLength = t);
		}),
			(xp = function (e, t, n) {
				Tl(this, xp, gp), Tl(e, bp, gp);
				var r = fp(e).byteLength,
					a = le(t);
				if (a < 0 || a > r) throw Np("Wrong offset");
				if (a + (n = void 0 === n ? r - a : pe(n)) > r) throw Np("Wrong length");
				dp(this, { buffer: e, byteLength: n, byteOffset: a }),
					o || ((this.buffer = e), (this.byteLength = n), (this.byteOffset = a));
			}),
			o && (Fp(bp, "byteLength"), Fp(xp, "buffer"), Fp(xp, "byteLength"), Fp(xp, "byteOffset")),
			Sl(xp.prototype, {
				getInt8: function (e) {
					return (Dp(this, 1, e)[0] << 24) >> 24;
				},
				getUint8: function (e) {
					return Dp(this, 1, e)[0];
				},
				getInt16: function (e) {
					var t = Dp(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
					return (((t[1] << 8) | t[0]) << 16) >> 16;
				},
				getUint16: function (e) {
					var t = Dp(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
					return (t[1] << 8) | t[0];
				},
				getInt32: function (e) {
					return Rp(Dp(this, 4, e, arguments.length > 1 ? arguments[1] : void 0));
				},
				getUint32: function (e) {
					return Rp(Dp(this, 4, e, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
				},
				getFloat32: function (e) {
					return Sp(Dp(this, 4, e, arguments.length > 1 ? arguments[1] : void 0), 23);
				},
				getFloat64: function (e) {
					return Sp(Dp(this, 8, e, arguments.length > 1 ? arguments[1] : void 0), 52);
				},
				setInt8: function (e, t) {
					Op(this, 1, e, Tp, t);
				},
				setUint8: function (e, t) {
					Op(this, 1, e, Tp, t);
				},
				setInt16: function (e, t) {
					Op(this, 2, e, Cp, t, arguments.length > 2 ? arguments[2] : void 0);
				},
				setUint16: function (e, t) {
					Op(this, 2, e, Cp, t, arguments.length > 2 ? arguments[2] : void 0);
				},
				setInt32: function (e, t) {
					Op(this, 4, e, Ep, t, arguments.length > 2 ? arguments[2] : void 0);
				},
				setUint32: function (e, t) {
					Op(this, 4, e, Ep, t, arguments.length > 2 ? arguments[2] : void 0);
				},
				setFloat32: function (e, t) {
					Op(this, 4, e, Ap, t, arguments.length > 2 ? arguments[2] : void 0);
				},
				setFloat64: function (e, t) {
					Op(this, 8, e, _p, t, arguments.length > 2 ? arguments[2] : void 0);
				},
			});
	ht(bp, mp), ht(xp, gp);
	var Up = { ArrayBuffer: bp, DataView: xp },
		Vp = Up.ArrayBuffer,
		Gp = a.ArrayBuffer;
	De({ global: !0, forced: Gp !== Vp }, { ArrayBuffer: Vp }), Jr("ArrayBuffer");
	var jp,
		Hp = R.f,
		qp = a.Int8Array,
		Kp = qp && qp.prototype,
		Xp = a.Uint8ClampedArray,
		Yp = Xp && Xp.prototype,
		Jp = qp && un(qp),
		Zp = Kp && un(Kp),
		Qp = Object.prototype,
		$p = Qp.isPrototypeOf,
		eh = ot("toStringTag"),
		th = j("TYPED_ARRAY_TAG"),
		nh = ap && !!cn && "Opera" !== bn(a.opera),
		rh = !1,
		ah = {
			Int8Array: 1,
			Uint8Array: 1,
			Uint8ClampedArray: 1,
			Int16Array: 2,
			Uint16Array: 2,
			Int32Array: 4,
			Uint32Array: 4,
			Float32Array: 4,
			Float64Array: 8,
		},
		ih = { BigInt64Array: 8, BigUint64Array: 8 },
		oh = function (e) {
			if (!v(e)) return !1;
			var t = bn(e);
			return x(ah, t) || x(ih, t);
		};
	for (jp in ah) a[jp] || (nh = !1);
	if (
		(!nh || "function" != typeof Jp || Jp === Function.prototype) &&
		((Jp = function () {
			throw TypeError("Incorrect invocation");
		}),
		nh)
	)
		for (jp in ah) a[jp] && cn(a[jp], Jp);
	if ((!nh || !Zp || Zp === Qp) && ((Zp = Jp.prototype), nh)) for (jp in ah) a[jp] && cn(a[jp].prototype, Zp);
	if ((nh && un(Yp) !== Zp && cn(Yp, Zp), o && !x(Zp, eh)))
		for (jp in ((rh = !0),
		Hp(Zp, eh, {
			get: function () {
				return v(this) ? this[th] : void 0;
			},
		}),
		ah))
			a[jp] && A(a[jp], th, jp);
	var sh = {
		NATIVE_ARRAY_BUFFER_VIEWS: nh,
		TYPED_ARRAY_TAG: rh && th,
		aTypedArray: function (e) {
			if (oh(e)) return e;
			throw TypeError("Target is not a typed array");
		},
		aTypedArrayConstructor: function (e) {
			if (cn) {
				if ($p.call(Jp, e)) return e;
			} else
				for (var t in ah)
					if (x(ah, jp)) {
						var n = a[t];
						if (n && (e === n || $p.call(n, e))) return e;
					}
			throw TypeError("Target is not a typed array constructor");
		},
		exportTypedArrayMethod: function (e, t, n) {
			if (o) {
				if (n)
					for (var r in ah) {
						var i = a[r];
						i && x(i.prototype, e) && delete i.prototype[e];
					}
				(Zp[e] && !n) || re(Zp, e, n ? t : (nh && Kp[e]) || t);
			}
		},
		exportTypedArrayStaticMethod: function (e, t, n) {
			var r, i;
			if (o) {
				if (cn) {
					if (n) for (r in ah) (i = a[r]) && x(i, e) && delete i[e];
					if (Jp[e] && !n) return;
					try {
						return re(Jp, e, n ? t : (nh && qp[e]) || t);
					} catch (e) {}
				}
				for (r in ah) !(i = a[r]) || (i[e] && !n) || re(i, e, t);
			}
		},
		isView: function (e) {
			if (!v(e)) return !1;
			var t = bn(e);
			return "DataView" === t || x(ah, t) || x(ih, t);
		},
		isTypedArray: oh,
		TypedArray: Jp,
		TypedArrayPrototype: Zp,
	};
	De({ target: "ArrayBuffer", stat: !0, forced: !sh.NATIVE_ARRAY_BUFFER_VIEWS }, { isView: sh.isView });
	var uh = Up.ArrayBuffer,
		lh = Up.DataView,
		ch = uh.prototype.slice,
		ph = i(function () {
			return !new uh(2).slice(1, void 0).byteLength;
		});
	De(
		{ target: "ArrayBuffer", proto: !0, unsafe: !0, forced: ph },
		{
			slice: function (e, t) {
				if (void 0 !== ch && void 0 === t) return ch.call(C(this), e);
				for (
					var n = C(this).byteLength,
						r = de(e, n),
						a = de(void 0 === t ? n : t, n),
						i = new (Ji(this, uh))(pe(a - r)),
						o = new lh(this),
						s = new lh(i),
						u = 0;
					r < a;

				)
					s.setUint8(u++, o.getUint8(r++));
				return i;
			},
		}
	),
		De({ global: !0, forced: !ap }, { DataView: Up.DataView });
	var hh = sh.NATIVE_ARRAY_BUFFER_VIEWS,
		fh = a.ArrayBuffer,
		dh = a.Int8Array,
		mh =
			!hh ||
			!i(function () {
				dh(1);
			}) ||
			!i(function () {
				new dh(-1);
			}) ||
			!Dn(function (e) {
				new dh(), new dh(null), new dh(1.5), new dh(e);
			}, !0) ||
			i(function () {
				return 1 !== new dh(new fh(2), 1, void 0).length;
			}),
		gh = function (e, t) {
			var n = (function (e) {
				var t = le(e);
				if (t < 0) throw RangeError("The argument can't be less than 0");
				return t;
			})(e);
			if (n % t) throw RangeError("Wrong offset");
			return n;
		},
		vh = sh.aTypedArrayConstructor,
		yh = function (e) {
			var t,
				n,
				r,
				a,
				i,
				o,
				s = je(e),
				u = arguments.length,
				l = u > 1 ? arguments[1] : void 0,
				c = void 0 !== l,
				p = wn(s);
			if (null != p && !dn(p)) for (o = (i = p.call(s)).next, s = []; !(a = o.call(i)).done; ) s.push(a.value);
			for (c && u > 2 && (l = dt(l, arguments[2], 2)), n = pe(s.length), r = new (vh(this))(n), t = 0; n > t; t++)
				r[t] = c ? l(s[t], t) : s[t];
			return r;
		},
		bh = n(function (e) {
			var t = we.f,
				n = bt.forEach,
				r = ne.get,
				i = ne.set,
				s = R.f,
				u = T.f,
				l = Math.round,
				p = a.RangeError,
				h = Up.ArrayBuffer,
				f = Up.DataView,
				d = sh.NATIVE_ARRAY_BUFFER_VIEWS,
				m = sh.TYPED_ARRAY_TAG,
				g = sh.TypedArray,
				b = sh.TypedArrayPrototype,
				w = sh.aTypedArrayConstructor,
				k = sh.isTypedArray,
				N = "BYTES_PER_ELEMENT",
				I = "Wrong length",
				S = function (e, t) {
					for (var n = 0, r = t.length, a = new (w(e))(r); r > n; ) a[n] = t[n++];
					return a;
				},
				C = function (e, t) {
					s(e, t, {
						get: function () {
							return r(this)[t];
						},
					});
				},
				E = function (e) {
					var t;
					return e instanceof h || "ArrayBuffer" == (t = bn(e)) || "SharedArrayBuffer" == t;
				},
				_ = function (e, t) {
					return k(e) && "symbol" != typeof t && t in e && String(+t) == String(t);
				},
				F = function (e, t) {
					return _(e, (t = y(t, !0))) ? c(2, e[t]) : u(e, t);
				},
				D = function (e, t, n) {
					return !(_(e, (t = y(t, !0))) && v(n) && x(n, "value")) ||
						x(n, "get") ||
						x(n, "set") ||
						n.configurable ||
						(x(n, "writable") && !n.writable) ||
						(x(n, "enumerable") && !n.enumerable)
						? s(e, t, n)
						: ((e[t] = n.value), e);
				};
			o
				? (d || ((T.f = F), (R.f = D), C(b, "buffer"), C(b, "byteOffset"), C(b, "byteLength"), C(b, "length")),
				  De({ target: "Object", stat: !0, forced: !d }, { getOwnPropertyDescriptor: F, defineProperty: D }),
				  (e.exports = function (e, o, u) {
						var c = e.match(/\d+$/)[0] / 8,
							y = e + (u ? "Clamped" : "") + "Array",
							x = "get" + e,
							w = "set" + e,
							T = a[y],
							C = T,
							R = C && C.prototype,
							_ = {},
							F = function (e, t) {
								s(e, t, {
									get: function () {
										return (function (e, t) {
											var n = r(e);
											return n.view[x](t * c + n.byteOffset, !0);
										})(this, t);
									},
									set: function (e) {
										return (function (e, t, n) {
											var a = r(e);
											u && (n = (n = l(n)) < 0 ? 0 : n > 255 ? 255 : 255 & n),
												a.view[w](t * c + a.byteOffset, n, !0);
										})(this, t, e);
									},
									enumerable: !0,
								});
							};
						d
							? mh &&
							  ((C = o(function (e, t, n, r) {
									return (
										Tl(e, C, y),
										ts(
											v(t)
												? E(t)
													? void 0 !== r
														? new T(t, gh(n, c), r)
														: void 0 !== n
														? new T(t, gh(n, c))
														: new T(t)
													: k(t)
													? S(C, t)
													: yh.call(C, t)
												: new T(ip(t)),
											e,
											C
										)
									);
							  })),
							  cn && cn(C, g),
							  n(t(T), function (e) {
									e in C || A(C, e, T[e]);
							  }),
							  (C.prototype = R))
							: ((C = o(function (e, t, n, r) {
									Tl(e, C, y);
									var a,
										o,
										s,
										u = 0,
										l = 0;
									if (v(t)) {
										if (!E(t)) return k(t) ? S(C, t) : yh.call(C, t);
										(a = t), (l = gh(n, c));
										var d = t.byteLength;
										if (void 0 === r) {
											if (d % c) throw p(I);
											if ((o = d - l) < 0) throw p(I);
										} else if ((o = pe(r) * c) + l > d) throw p(I);
										s = o / c;
									} else (s = ip(t)), (a = new h((o = s * c)));
									for (
										i(e, { buffer: a, byteOffset: l, byteLength: o, length: s, view: new f(a) });
										u < s;

									)
										F(e, u++);
							  })),
							  cn && cn(C, g),
							  (R = C.prototype = Qe(b))),
							R.constructor !== C && A(R, "constructor", C),
							m && A(R, m, y),
							(_[y] = C),
							De({ global: !0, forced: C != T, sham: !d }, _),
							N in C || A(C, N, c),
							N in R || A(R, N, c),
							Jr(y);
				  }))
				: (e.exports = function () {});
		});
	bh("Int8", function (e) {
		return function (t, n, r) {
			return e(this, t, n, r);
		};
	}),
		bh("Uint8", function (e) {
			return function (t, n, r) {
				return e(this, t, n, r);
			};
		}),
		bh(
			"Uint8",
			function (e) {
				return function (t, n, r) {
					return e(this, t, n, r);
				};
			},
			!0
		),
		bh("Int16", function (e) {
			return function (t, n, r) {
				return e(this, t, n, r);
			};
		}),
		bh("Uint16", function (e) {
			return function (t, n, r) {
				return e(this, t, n, r);
			};
		}),
		bh("Int32", function (e) {
			return function (t, n, r) {
				return e(this, t, n, r);
			};
		}),
		bh("Uint32", function (e) {
			return function (t, n, r) {
				return e(this, t, n, r);
			};
		}),
		bh("Float32", function (e) {
			return function (t, n, r) {
				return e(this, t, n, r);
			};
		}),
		bh("Float64", function (e) {
			return function (t, n, r) {
				return e(this, t, n, r);
			};
		}),
		(0, sh.exportTypedArrayStaticMethod)("from", yh, mh);
	var xh = sh.aTypedArrayConstructor;
	(0, sh.exportTypedArrayStaticMethod)(
		"of",
		function () {
			for (var e = 0, t = arguments.length, n = new (xh(this))(t); t > e; ) n[e] = arguments[e++];
			return n;
		},
		mh
	);
	var wh = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("copyWithin", function (e, t) {
		return Hn.call(wh(this), e, t, arguments.length > 2 ? arguments[2] : void 0);
	});
	var kh = bt.every,
		Nh = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("every", function (e) {
		return kh(Nh(this), e, arguments.length > 1 ? arguments[1] : void 0);
	});
	var Ih = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("fill", function (e) {
		return Qn.apply(Ih(this), arguments);
	});
	var Sh = sh.aTypedArrayConstructor,
		Th = function (e, t) {
			for (var n = Ji(e, e.constructor), r = 0, a = t.length, i = new (Sh(n))(a); a > r; ) i[r] = t[r++];
			return i;
		},
		Ch = bt.filter,
		Eh = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("filter", function (e) {
		var t = Ch(Eh(this), e, arguments.length > 1 ? arguments[1] : void 0);
		return Th(this, t);
	});
	var Rh = bt.find,
		Ah = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("find", function (e) {
		return Rh(Ah(this), e, arguments.length > 1 ? arguments[1] : void 0);
	});
	var _h = bt.findIndex,
		Fh = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("findIndex", function (e) {
		return _h(Fh(this), e, arguments.length > 1 ? arguments[1] : void 0);
	});
	var Dh = bt.forEach,
		Oh = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("forEach", function (e) {
		Dh(Oh(this), e, arguments.length > 1 ? arguments[1] : void 0);
	});
	var Mh = ge.includes,
		Lh = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("includes", function (e) {
		return Mh(Lh(this), e, arguments.length > 1 ? arguments[1] : void 0);
	});
	var zh = ge.indexOf,
		Ph = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("indexOf", function (e) {
		return zh(Ph(this), e, arguments.length > 1 ? arguments[1] : void 0);
	});
	var Bh = ot("iterator"),
		Wh = a.Uint8Array,
		Uh = ya.values,
		Vh = ya.keys,
		Gh = ya.entries,
		jh = sh.aTypedArray,
		Hh = sh.exportTypedArrayMethod,
		qh = Wh && Wh.prototype[Bh],
		Kh = !!qh && ("values" == qh.name || null == qh.name),
		Xh = function () {
			return Uh.call(jh(this));
		};
	Hh("entries", function () {
		return Gh.call(jh(this));
	}),
		Hh("keys", function () {
			return Vh.call(jh(this));
		}),
		Hh("values", Xh, !Kh),
		Hh(Bh, Xh, !Kh);
	var Yh = sh.aTypedArray,
		Jh = [].join;
	(0, sh.exportTypedArrayMethod)("join", function (e) {
		return Jh.apply(Yh(this), arguments);
	});
	var Zh = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("lastIndexOf", function (e) {
		return kr.apply(Zh(this), arguments);
	});
	var Qh = bt.map,
		$h = sh.aTypedArray,
		ef = sh.aTypedArrayConstructor;
	(0, sh.exportTypedArrayMethod)("map", function (e) {
		return Qh($h(this), e, arguments.length > 1 ? arguments[1] : void 0, function (e, t) {
			return new (ef(Ji(e, e.constructor)))(t);
		});
	});
	var tf = Tr.left,
		nf = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("reduce", function (e) {
		return tf(nf(this), e, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
	});
	var rf = Tr.right,
		af = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("reduceRight", function (e) {
		return rf(af(this), e, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
	});
	var of = sh.aTypedArray,
		sf = sh.exportTypedArrayMethod,
		uf = Math.floor;
	sf("reverse", function () {
		for (var e, t = this, n = of(t).length, r = uf(n / 2), a = 0; a < r; )
			(e = t[a]), (t[a++] = t[--n]), (t[n] = e);
		return t;
	});
	var lf = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)(
		"set",
		function (e) {
			lf(this);
			var t = gh(arguments.length > 1 ? arguments[1] : void 0, 1),
				n = this.length,
				r = je(e),
				a = pe(r.length),
				i = 0;
			if (a + t > n) throw RangeError("Wrong length");
			for (; i < a; ) this[t + i] = r[i++];
		},
		i(function () {
			new Int8Array(1).set({});
		})
	);
	var cf = sh.aTypedArray,
		pf = sh.aTypedArrayConstructor,
		hf = [].slice;
	(0, sh.exportTypedArrayMethod)(
		"slice",
		function (e, t) {
			for (
				var n = hf.call(cf(this), e, t),
					r = Ji(this, this.constructor),
					a = 0,
					i = n.length,
					o = new (pf(r))(i);
				i > a;

			)
				o[a] = n[a++];
			return o;
		},
		i(function () {
			new Int8Array(1).slice();
		})
	);
	var ff = bt.some,
		df = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("some", function (e) {
		return ff(df(this), e, arguments.length > 1 ? arguments[1] : void 0);
	});
	var mf = sh.aTypedArray,
		gf = [].sort;
	(0, sh.exportTypedArrayMethod)("sort", function (e) {
		return gf.call(mf(this), e);
	});
	var vf = sh.aTypedArray;
	(0, sh.exportTypedArrayMethod)("subarray", function (e, t) {
		var n = vf(this),
			r = n.length,
			a = de(e, r);
		return new (Ji(n, n.constructor))(
			n.buffer,
			n.byteOffset + a * n.BYTES_PER_ELEMENT,
			pe((void 0 === t ? r : de(t, r)) - a)
		);
	});
	var yf = a.Int8Array,
		bf = sh.aTypedArray,
		xf = sh.exportTypedArrayMethod,
		wf = [].toLocaleString,
		kf = [].slice,
		Nf =
			!!yf &&
			i(function () {
				wf.call(new yf(1));
			});
	xf(
		"toLocaleString",
		function () {
			return wf.apply(Nf ? kf.call(bf(this)) : bf(this), arguments);
		},
		i(function () {
			return [1, 2].toLocaleString() != new yf([1, 2]).toLocaleString();
		}) ||
			!i(function () {
				yf.prototype.toLocaleString.call([1, 2]);
			})
	);
	var If = sh.exportTypedArrayMethod,
		Sf = a.Uint8Array,
		Tf = (Sf && Sf.prototype) || {},
		Cf = [].toString,
		Ef = [].join;
	i(function () {
		Cf.call({});
	}) &&
		(Cf = function () {
			return Ef.call(this);
		});
	var Rf = Tf.toString != Cf;
	If("toString", Cf, Rf);
	var Af = oe("Reflect", "apply"),
		_f = Function.apply,
		Ff = !i(function () {
			Af(function () {});
		});
	De(
		{ target: "Reflect", stat: !0, forced: Ff },
		{
			apply: function (e, t, n) {
				return ft(e), C(n), Af ? Af(e, t, n) : _f.call(e, t, n);
			},
		}
	);
	var Df = oe("Reflect", "construct"),
		Of = i(function () {
			function e() {}
			return !(Df(function () {}, [], e) instanceof e);
		}),
		Mf = !i(function () {
			Df(function () {});
		}),
		Lf = Of || Mf;
	De(
		{ target: "Reflect", stat: !0, forced: Lf, sham: Lf },
		{
			construct: function (e, t) {
				ft(e), C(t);
				var n = arguments.length < 3 ? e : ft(arguments[2]);
				if (Mf && !Of) return Df(e, t, n);
				if (e == n) {
					switch (t.length) {
						case 0:
							return new e();
						case 1:
							return new e(t[0]);
						case 2:
							return new e(t[0], t[1]);
						case 3:
							return new e(t[0], t[1], t[2]);
						case 4:
							return new e(t[0], t[1], t[2], t[3]);
					}
					var r = [null];
					return r.push.apply(r, t), new (ka.apply(e, r))();
				}
				var a = n.prototype,
					i = Qe(v(a) ? a : Object.prototype),
					o = Function.apply.call(e, i, t);
				return v(o) ? o : i;
			},
		}
	);
	var zf = i(function () {
		Reflect.defineProperty(R.f({}, 1, { value: 1 }), 1, { value: 2 });
	});
	De(
		{ target: "Reflect", stat: !0, forced: zf, sham: !o },
		{
			defineProperty: function (e, t, n) {
				C(e);
				var r = y(t, !0);
				C(n);
				try {
					return R.f(e, r, n), !0;
				} catch (e) {
					return !1;
				}
			},
		}
	);
	var Pf = T.f;
	De(
		{ target: "Reflect", stat: !0 },
		{
			deleteProperty: function (e, t) {
				var n = Pf(C(e), t);
				return !(n && !n.configurable) && delete e[t];
			},
		}
	),
		De(
			{ target: "Reflect", stat: !0 },
			{
				get: function e(t, n) {
					var r,
						a,
						i = arguments.length < 3 ? t : arguments[2];
					return C(t) === i
						? t[n]
						: (r = T.f(t, n))
						? x(r, "value")
							? r.value
							: void 0 === r.get
							? void 0
							: r.get.call(i)
						: v((a = un(t)))
						? e(a, n, i)
						: void 0;
				},
			}
		),
		De(
			{ target: "Reflect", stat: !0, sham: !o },
			{
				getOwnPropertyDescriptor: function (e, t) {
					return T.f(C(e), t);
				},
			}
		),
		De(
			{ target: "Reflect", stat: !0, sham: !an },
			{
				getPrototypeOf: function (e) {
					return un(C(e));
				},
			}
		),
		De(
			{ target: "Reflect", stat: !0 },
			{
				has: function (e, t) {
					return t in e;
				},
			}
		);
	var Bf = Object.isExtensible;
	De(
		{ target: "Reflect", stat: !0 },
		{
			isExtensible: function (e) {
				return C(e), !Bf || Bf(e);
			},
		}
	),
		De({ target: "Reflect", stat: !0 }, { ownKeys: Ne }),
		De(
			{ target: "Reflect", stat: !0, sham: !za },
			{
				preventExtensions: function (e) {
					C(e);
					try {
						var t = oe("Object", "preventExtensions");
						return t && t(e), !0;
					} catch (e) {
						return !1;
					}
				},
			}
		);
	var Wf = i(function () {
		var e = function () {},
			t = R.f(new e(), "a", { configurable: !0 });
		return !1 !== Reflect.set(e.prototype, "a", 1, t);
	});
	De(
		{ target: "Reflect", stat: !0, forced: Wf },
		{
			set: function e(t, n, r) {
				var a,
					i,
					o = arguments.length < 4 ? t : arguments[3],
					s = T.f(C(t), n);
				if (!s) {
					if (v((i = un(t)))) return e(i, n, r, o);
					s = c(0);
				}
				if (x(s, "value")) {
					if (!1 === s.writable || !v(o)) return !1;
					if ((a = T.f(o, n))) {
						if (a.get || a.set || !1 === a.writable) return !1;
						(a.value = r), R.f(o, n, a);
					} else R.f(o, n, c(0, r));
					return !0;
				}
				return void 0 !== s.set && (s.set.call(o, r), !0);
			},
		}
	),
		cn &&
			De(
				{ target: "Reflect", stat: !0 },
				{
					setPrototypeOf: function (e, t) {
						C(e), ln(t);
						try {
							return cn(e, t), !0;
						} catch (e) {
							return !1;
						}
					},
				}
			),
		De({ global: !0 }, { Reflect: {} }),
		ht(a.Reflect, "Reflect", !0);
	var Uf = {
		CSSRuleList: 0,
		CSSStyleDeclaration: 0,
		CSSValueList: 0,
		ClientRectList: 0,
		DOMRectList: 0,
		DOMStringList: 0,
		DOMTokenList: 1,
		DataTransferItemList: 0,
		FileList: 0,
		HTMLAllCollection: 0,
		HTMLCollection: 0,
		HTMLFormElement: 0,
		HTMLSelectElement: 0,
		MediaList: 0,
		MimeTypeArray: 0,
		NamedNodeMap: 0,
		NodeList: 1,
		PaintRequestList: 0,
		Plugin: 0,
		PluginArray: 0,
		SVGLengthList: 0,
		SVGNumberList: 0,
		SVGPathSegList: 0,
		SVGPointList: 0,
		SVGStringList: 0,
		SVGTransformList: 0,
		SourceBufferList: 0,
		StyleSheetList: 0,
		TextTrackCueList: 0,
		TextTrackList: 0,
		TouchList: 0,
	};
	for (var Vf in Uf) {
		var Gf = a[Vf],
			jf = Gf && Gf.prototype;
		if (jf && jf.forEach !== lr)
			try {
				A(jf, "forEach", lr);
			} catch (e) {
				jf.forEach = lr;
			}
	}
	var Hf = ot("iterator"),
		qf = ot("toStringTag"),
		Kf = ya.values;
	for (var Xf in Uf) {
		var Yf = a[Xf],
			Jf = Yf && Yf.prototype;
		if (Jf) {
			if (Jf[Hf] !== Kf)
				try {
					A(Jf, Hf, Kf);
				} catch (e) {
					Jf[Hf] = Kf;
				}
			if ((Jf[qf] || A(Jf, qf, Xf), Uf[Xf]))
				for (var Zf in ya)
					if (Jf[Zf] !== ya[Zf])
						try {
							A(Jf, Zf, ya[Zf]);
						} catch (e) {
							Jf[Zf] = ya[Zf];
						}
		}
	}
	var Qf = !a.setImmediate || !a.clearImmediate;
	De({ global: !0, bind: !0, enumerable: !0, forced: Qf }, { setImmediate: Xl.set, clearImmediate: Xl.clear });
	var $f = a.process;
	De(
		{ global: !0, enumerable: !0, noTargetGet: !0 },
		{
			queueMicrotask: function (e) {
				var t = Oe && $f.domain;
				uc(t ? t.bind(e) : e);
			},
		}
	);
	var ed = [].slice,
		td = /MSIE .\./.test(Me),
		nd = function (e) {
			return function (t, n) {
				var r = arguments.length > 2,
					a = r ? ed.call(arguments, 2) : void 0;
				return e(
					r
						? function () {
								("function" == typeof t ? t : Function(t)).apply(this, a);
						  }
						: t,
					n
				);
			};
		};
	De({ global: !0, bind: !0, forced: td }, { setTimeout: nd(a.setTimeout), setInterval: nd(a.setInterval) });
	var rd = ot("iterator"),
		ad = !i(function () {
			var e = new URL("b?a=1&b=2&c=3", "http://a"),
				t = e.searchParams,
				n = "";
			return (
				(e.pathname = "c%20d"),
				t.forEach(function (e, r) {
					t.delete("b"), (n += r + e);
				}),
				!t.sort ||
					"http://a/c%20d?a=1&c=3" !== e.href ||
					"3" !== t.get("c") ||
					"a=1" !== String(new URLSearchParams("?a=1")) ||
					!t[rd] ||
					"a" !== new URL("https://a@b").username ||
					"b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") ||
					"xn--e1aybc" !== new URL("http://ÑÐµÑÑ").host ||
					"#%D0%B1" !== new URL("http://a#Ð±").hash ||
					"a1c3" !== n ||
					"x" !== new URL("http://x", void 0).host
			);
		}),
		id = 2147483647,
		od = /[^\0-\u007E]/,
		sd = /[.\u3002\uFF0E\uFF61]/g,
		ud = "Overflow: input needs wider integers to process",
		ld = Math.floor,
		cd = String.fromCharCode,
		pd = function (e) {
			return e + 22 + 75 * (e < 26);
		},
		hd = function (e, t, n) {
			var r = 0;
			for (e = n ? ld(e / 700) : e >> 1, e += ld(e / t); e > 455; r += 36) e = ld(e / 35);
			return ld(r + (36 * e) / (e + 38));
		},
		fd = function (e) {
			var t,
				n,
				r = [],
				a = (e = (function (e) {
					for (var t = [], n = 0, r = e.length; n < r; ) {
						var a = e.charCodeAt(n++);
						if (a >= 55296 && a <= 56319 && n < r) {
							var i = e.charCodeAt(n++);
							56320 == (64512 & i) ? t.push(((1023 & a) << 10) + (1023 & i) + 65536) : (t.push(a), n--);
						} else t.push(a);
					}
					return t;
				})(e)).length,
				i = 128,
				o = 0,
				s = 72;
			for (t = 0; t < e.length; t++) (n = e[t]) < 128 && r.push(cd(n));
			var u = r.length,
				l = u;
			for (u && r.push("-"); l < a; ) {
				var c = id;
				for (t = 0; t < e.length; t++) (n = e[t]) >= i && n < c && (c = n);
				var p = l + 1;
				if (c - i > ld((id - o) / p)) throw RangeError(ud);
				for (o += (c - i) * p, i = c, t = 0; t < e.length; t++) {
					if ((n = e[t]) < i && ++o > id) throw RangeError(ud);
					if (n == i) {
						for (var h = o, f = 36; ; f += 36) {
							var d = f <= s ? 1 : f >= s + 26 ? 26 : f - s;
							if (h < d) break;
							var m = h - d,
								g = 36 - d;
							r.push(cd(pd(d + (m % g)))), (h = ld(m / g));
						}
						r.push(cd(pd(h))), (s = hd(o, p, l == u)), (o = 0), ++l;
					}
				}
				++o, ++i;
			}
			return r.join("");
		},
		dd = function (e) {
			var t = wn(e);
			if ("function" != typeof t) throw TypeError(String(e) + " is not iterable");
			return C(t.call(e));
		},
		md = oe("fetch"),
		gd = oe("Headers"),
		vd = ot("iterator"),
		yd = "URLSearchParams",
		bd = "URLSearchParamsIterator",
		xd = ne.set,
		wd = ne.getterFor(yd),
		kd = ne.getterFor(bd),
		Nd = /\+/g,
		Id = Array(4),
		Sd = function (e) {
			return Id[e - 1] || (Id[e - 1] = RegExp("((?:%[\\da-f]{2}){" + e + "})", "gi"));
		},
		Td = function (e) {
			try {
				return decodeURIComponent(e);
			} catch (t) {
				return e;
			}
		},
		Cd = function (e) {
			var t = e.replace(Nd, " "),
				n = 4;
			try {
				return decodeURIComponent(t);
			} catch (e) {
				for (; n; ) t = t.replace(Sd(n--), Td);
				return t;
			}
		},
		Ed = /[!'()~]|%20/g,
		Rd = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" },
		Ad = function (e) {
			return Rd[e];
		},
		_d = function (e) {
			return encodeURIComponent(e).replace(Ed, Ad);
		},
		Fd = function (e, t) {
			if (t)
				for (var n, r, a = t.split("&"), i = 0; i < a.length; )
					(n = a[i++]).length && ((r = n.split("=")), e.push({ key: Cd(r.shift()), value: Cd(r.join("=")) }));
		},
		Dd = function (e) {
			(this.entries.length = 0), Fd(this.entries, e);
		},
		Od = function (e, t) {
			if (e < t) throw TypeError("Not enough arguments");
		},
		Md = oa(
			function (e, t) {
				xd(this, { type: bd, iterator: dd(wd(e).entries), kind: t });
			},
			"Iterator",
			function () {
				var e = kd(this),
					t = e.kind,
					n = e.iterator.next(),
					r = n.value;
				return n.done || (n.value = "keys" === t ? r.key : "values" === t ? r.value : [r.key, r.value]), n;
			}
		),
		Ld = function () {
			Tl(this, Ld, yd);
			var e,
				t,
				n,
				r,
				a,
				i,
				o,
				s,
				u,
				l = arguments.length > 0 ? arguments[0] : void 0,
				c = this,
				p = [];
			if ((xd(c, { type: yd, entries: p, updateURL: function () {}, updateSearchParams: Dd }), void 0 !== l))
				if (v(l))
					if ("function" == typeof (e = wn(l)))
						for (n = (t = e.call(l)).next; !(r = n.call(t)).done; ) {
							if (
								(o = (i = (a = dd(C(r.value))).next).call(a)).done ||
								(s = i.call(a)).done ||
								!i.call(a).done
							)
								throw TypeError("Expected sequence with length 2");
							p.push({ key: o.value + "", value: s.value + "" });
						}
					else for (u in l) x(l, u) && p.push({ key: u, value: l[u] + "" });
				else Fd(p, "string" == typeof l ? ("?" === l.charAt(0) ? l.slice(1) : l) : l + "");
		},
		zd = Ld.prototype;
	Sl(
		zd,
		{
			append: function (e, t) {
				Od(arguments.length, 2);
				var n = wd(this);
				n.entries.push({ key: e + "", value: t + "" }), n.updateURL();
			},
			delete: function (e) {
				Od(arguments.length, 1);
				for (var t = wd(this), n = t.entries, r = e + "", a = 0; a < n.length; )
					n[a].key === r ? n.splice(a, 1) : a++;
				t.updateURL();
			},
			get: function (e) {
				Od(arguments.length, 1);
				for (var t = wd(this).entries, n = e + "", r = 0; r < t.length; r++)
					if (t[r].key === n) return t[r].value;
				return null;
			},
			getAll: function (e) {
				Od(arguments.length, 1);
				for (var t = wd(this).entries, n = e + "", r = [], a = 0; a < t.length; a++)
					t[a].key === n && r.push(t[a].value);
				return r;
			},
			has: function (e) {
				Od(arguments.length, 1);
				for (var t = wd(this).entries, n = e + "", r = 0; r < t.length; ) if (t[r++].key === n) return !0;
				return !1;
			},
			set: function (e, t) {
				Od(arguments.length, 1);
				for (var n, r = wd(this), a = r.entries, i = !1, o = e + "", s = t + "", u = 0; u < a.length; u++)
					(n = a[u]).key === o && (i ? a.splice(u--, 1) : ((i = !0), (n.value = s)));
				i || a.push({ key: o, value: s }), r.updateURL();
			},
			sort: function () {
				var e,
					t,
					n,
					r = wd(this),
					a = r.entries,
					i = a.slice();
				for (a.length = 0, n = 0; n < i.length; n++) {
					for (e = i[n], t = 0; t < n; t++)
						if (a[t].key > e.key) {
							a.splice(t, 0, e);
							break;
						}
					t === n && a.push(e);
				}
				r.updateURL();
			},
			forEach: function (e) {
				for (
					var t, n = wd(this).entries, r = dt(e, arguments.length > 1 ? arguments[1] : void 0, 3), a = 0;
					a < n.length;

				)
					r((t = n[a++]).value, t.key, this);
			},
			keys: function () {
				return new Md(this, "keys");
			},
			values: function () {
				return new Md(this, "values");
			},
			entries: function () {
				return new Md(this, "entries");
			},
		},
		{ enumerable: !0 }
	),
		re(zd, vd, zd.entries),
		re(
			zd,
			"toString",
			function () {
				for (var e, t = wd(this).entries, n = [], r = 0; r < t.length; )
					(e = t[r++]), n.push(_d(e.key) + "=" + _d(e.value));
				return n.join("&");
			},
			{ enumerable: !0 }
		),
		ht(Ld, yd),
		De({ global: !0, forced: !ad }, { URLSearchParams: Ld }),
		ad ||
			"function" != typeof md ||
			"function" != typeof gd ||
			De(
				{ global: !0, enumerable: !0, forced: !0 },
				{
					fetch: function (e) {
						var t,
							n,
							r,
							a = [e];
						return (
							arguments.length > 1 &&
								(v((t = arguments[1])) &&
									((n = t.body),
									bn(n) === yd &&
										((r = t.headers ? new gd(t.headers) : new gd()).has("content-type") ||
											r.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"),
										(t = Qe(t, { body: c(0, String(n)), headers: c(0, r) })))),
								a.push(t)),
							md.apply(this, a)
						);
					},
				}
			);
	var Pd,
		Bd = { URLSearchParams: Ld, getState: wd },
		Wd = gi.codeAt,
		Ud = a.URL,
		Vd = Bd.URLSearchParams,
		Gd = Bd.getState,
		jd = ne.set,
		Hd = ne.getterFor("URL"),
		qd = Math.floor,
		Kd = Math.pow,
		Xd = "Invalid scheme",
		Yd = "Invalid host",
		Jd = "Invalid port",
		Zd = /[A-Za-z]/,
		Qd = /[\d+-.A-Za-z]/,
		$d = /\d/,
		em = /^(0x|0X)/,
		tm = /^[0-7]+$/,
		nm = /^\d+$/,
		rm = /^[\dA-Fa-f]+$/,
		am = /[\u0000\t\u000A\u000D #%/:?@[\\]]/,
		im = /[\u0000\t\u000A\u000D #/:?@[\\]]/,
		om = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g,
		sm = /[\t\u000A\u000D]/g,
		um = function (e, t) {
			var n, r, a;
			if ("[" == t.charAt(0)) {
				if ("]" != t.charAt(t.length - 1)) return Yd;
				if (!(n = cm(t.slice(1, -1)))) return Yd;
				e.host = n;
			} else if (ym(e)) {
				if (
					((t = (function (e) {
						var t,
							n,
							r = [],
							a = e.toLowerCase().replace(sd, ".").split(".");
						for (t = 0; t < a.length; t++) (n = a[t]), r.push(od.test(n) ? "xn--" + fd(n) : n);
						return r.join(".");
					})(t)),
					am.test(t))
				)
					return Yd;
				if (null === (n = lm(t))) return Yd;
				e.host = n;
			} else {
				if (im.test(t)) return Yd;
				for (n = "", r = En(t), a = 0; a < r.length; a++) n += gm(r[a], hm);
				e.host = n;
			}
		},
		lm = function (e) {
			var t,
				n,
				r,
				a,
				i,
				o,
				s,
				u = e.split(".");
			if ((u.length && "" == u[u.length - 1] && u.pop(), (t = u.length) > 4)) return e;
			for (n = [], r = 0; r < t; r++) {
				if ("" == (a = u[r])) return e;
				if (
					((i = 10),
					a.length > 1 && "0" == a.charAt(0) && ((i = em.test(a) ? 16 : 8), (a = a.slice(8 == i ? 1 : 2))),
					"" === a)
				)
					o = 0;
				else {
					if (!(10 == i ? nm : 8 == i ? tm : rm).test(a)) return e;
					o = parseInt(a, i);
				}
				n.push(o);
			}
			for (r = 0; r < t; r++)
				if (((o = n[r]), r == t - 1)) {
					if (o >= Kd(256, 5 - t)) return null;
				} else if (o > 255) return null;
			for (s = n.pop(), r = 0; r < n.length; r++) s += n[r] * Kd(256, 3 - r);
			return s;
		},
		cm = function (e) {
			var t,
				n,
				r,
				a,
				i,
				o,
				s,
				u = [0, 0, 0, 0, 0, 0, 0, 0],
				l = 0,
				c = null,
				p = 0,
				h = function () {
					return e.charAt(p);
				};
			if (":" == h()) {
				if (":" != e.charAt(1)) return;
				(p += 2), (c = ++l);
			}
			for (; h(); ) {
				if (8 == l) return;
				if (":" != h()) {
					for (t = n = 0; n < 4 && rm.test(h()); ) (t = 16 * t + parseInt(h(), 16)), p++, n++;
					if ("." == h()) {
						if (0 == n) return;
						if (((p -= n), l > 6)) return;
						for (r = 0; h(); ) {
							if (((a = null), r > 0)) {
								if (!("." == h() && r < 4)) return;
								p++;
							}
							if (!$d.test(h())) return;
							for (; $d.test(h()); ) {
								if (((i = parseInt(h(), 10)), null === a)) a = i;
								else {
									if (0 == a) return;
									a = 10 * a + i;
								}
								if (a > 255) return;
								p++;
							}
							(u[l] = 256 * u[l] + a), (2 != ++r && 4 != r) || l++;
						}
						if (4 != r) return;
						break;
					}
					if (":" == h()) {
						if ((p++, !h())) return;
					} else if (h()) return;
					u[l++] = t;
				} else {
					if (null !== c) return;
					p++, (c = ++l);
				}
			}
			if (null !== c)
				for (o = l - c, l = 7; 0 != l && o > 0; ) (s = u[l]), (u[l--] = u[c + o - 1]), (u[c + --o] = s);
			else if (8 != l) return;
			return u;
		},
		pm = function (e) {
			var t, n, r, a;
			if ("number" == typeof e) {
				for (t = [], n = 0; n < 4; n++) t.unshift(e % 256), (e = qd(e / 256));
				return t.join(".");
			}
			if ("object" == typeof e) {
				for (
					t = "",
						r = (function (e) {
							for (var t = null, n = 1, r = null, a = 0, i = 0; i < 8; i++)
								0 !== e[i]
									? (a > n && ((t = r), (n = a)), (r = null), (a = 0))
									: (null === r && (r = i), ++a);
							return a > n && ((t = r), (n = a)), t;
						})(e),
						n = 0;
					n < 8;
					n++
				)
					(a && 0 === e[n]) ||
						(a && (a = !1),
						r === n ? ((t += n ? ":" : "::"), (a = !0)) : ((t += e[n].toString(16)), n < 7 && (t += ":")));
				return "[" + t + "]";
			}
			return e;
		},
		hm = {},
		fm = Fa({}, hm, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }),
		dm = Fa({}, fm, { "#": 1, "?": 1, "{": 1, "}": 1 }),
		mm = Fa({}, dm, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }),
		gm = function (e, t) {
			var n = Wd(e, 0);
			return n > 32 && n < 127 && !x(t, e) ? e : encodeURIComponent(e);
		},
		vm = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 },
		ym = function (e) {
			return x(vm, e.scheme);
		},
		bm = function (e) {
			return "" != e.username || "" != e.password;
		},
		xm = function (e) {
			return !e.host || e.cannotBeABaseURL || "file" == e.scheme;
		},
		wm = function (e, t) {
			var n;
			return 2 == e.length && Zd.test(e.charAt(0)) && (":" == (n = e.charAt(1)) || (!t && "|" == n));
		},
		km = function (e) {
			var t;
			return (
				e.length > 1 &&
				wm(e.slice(0, 2)) &&
				(2 == e.length || "/" === (t = e.charAt(2)) || "\\" === t || "?" === t || "#" === t)
			);
		},
		Nm = function (e) {
			var t = e.path,
				n = t.length;
			!n || ("file" == e.scheme && 1 == n && wm(t[0], !0)) || t.pop();
		},
		Im = function (e) {
			return "." === e || "%2e" === e.toLowerCase();
		},
		Sm = {},
		Tm = {},
		Cm = {},
		Em = {},
		Rm = {},
		Am = {},
		_m = {},
		Fm = {},
		Dm = {},
		Om = {},
		Mm = {},
		Lm = {},
		zm = {},
		Pm = {},
		Bm = {},
		Wm = {},
		Um = {},
		Vm = {},
		Gm = {},
		jm = {},
		Hm = {},
		qm = function (e, t, n, r) {
			var a,
				i,
				o,
				s,
				u,
				l = n || Sm,
				c = 0,
				p = "",
				h = !1,
				f = !1,
				d = !1;
			for (
				n ||
					((e.scheme = ""),
					(e.username = ""),
					(e.password = ""),
					(e.host = null),
					(e.port = null),
					(e.path = []),
					(e.query = null),
					(e.fragment = null),
					(e.cannotBeABaseURL = !1),
					(t = t.replace(om, ""))),
					t = t.replace(sm, ""),
					a = En(t);
				c <= a.length;

			) {
				switch (((i = a[c]), l)) {
					case Sm:
						if (!i || !Zd.test(i)) {
							if (n) return Xd;
							l = Cm;
							continue;
						}
						(p += i.toLowerCase()), (l = Tm);
						break;
					case Tm:
						if (i && (Qd.test(i) || "+" == i || "-" == i || "." == i)) p += i.toLowerCase();
						else {
							if (":" != i) {
								if (n) return Xd;
								(p = ""), (l = Cm), (c = 0);
								continue;
							}
							if (
								n &&
								(ym(e) != x(vm, p) ||
									("file" == p && (bm(e) || null !== e.port)) ||
									("file" == e.scheme && !e.host))
							)
								return;
							if (((e.scheme = p), n)) return void (ym(e) && vm[e.scheme] == e.port && (e.port = null));
							(p = ""),
								"file" == e.scheme
									? (l = Pm)
									: ym(e) && r && r.scheme == e.scheme
									? (l = Em)
									: ym(e)
									? (l = Fm)
									: "/" == a[c + 1]
									? ((l = Rm), c++)
									: ((e.cannotBeABaseURL = !0), e.path.push(""), (l = Gm));
						}
						break;
					case Cm:
						if (!r || (r.cannotBeABaseURL && "#" != i)) return Xd;
						if (r.cannotBeABaseURL && "#" == i) {
							(e.scheme = r.scheme),
								(e.path = r.path.slice()),
								(e.query = r.query),
								(e.fragment = ""),
								(e.cannotBeABaseURL = !0),
								(l = Hm);
							break;
						}
						l = "file" == r.scheme ? Pm : Am;
						continue;
					case Em:
						if ("/" != i || "/" != a[c + 1]) {
							l = Am;
							continue;
						}
						(l = Dm), c++;
						break;
					case Rm:
						if ("/" == i) {
							l = Om;
							break;
						}
						l = Vm;
						continue;
					case Am:
						if (((e.scheme = r.scheme), i == Pd))
							(e.username = r.username),
								(e.password = r.password),
								(e.host = r.host),
								(e.port = r.port),
								(e.path = r.path.slice()),
								(e.query = r.query);
						else if ("/" == i || ("\\" == i && ym(e))) l = _m;
						else if ("?" == i)
							(e.username = r.username),
								(e.password = r.password),
								(e.host = r.host),
								(e.port = r.port),
								(e.path = r.path.slice()),
								(e.query = ""),
								(l = jm);
						else {
							if ("#" != i) {
								(e.username = r.username),
									(e.password = r.password),
									(e.host = r.host),
									(e.port = r.port),
									(e.path = r.path.slice()),
									e.path.pop(),
									(l = Vm);
								continue;
							}
							(e.username = r.username),
								(e.password = r.password),
								(e.host = r.host),
								(e.port = r.port),
								(e.path = r.path.slice()),
								(e.query = r.query),
								(e.fragment = ""),
								(l = Hm);
						}
						break;
					case _m:
						if (!ym(e) || ("/" != i && "\\" != i)) {
							if ("/" != i) {
								(e.username = r.username),
									(e.password = r.password),
									(e.host = r.host),
									(e.port = r.port),
									(l = Vm);
								continue;
							}
							l = Om;
						} else l = Dm;
						break;
					case Fm:
						if (((l = Dm), "/" != i || "/" != p.charAt(c + 1))) continue;
						c++;
						break;
					case Dm:
						if ("/" != i && "\\" != i) {
							l = Om;
							continue;
						}
						break;
					case Om:
						if ("@" == i) {
							h && (p = "%40" + p), (h = !0), (o = En(p));
							for (var m = 0; m < o.length; m++) {
								var g = o[m];
								if (":" != g || d) {
									var v = gm(g, mm);
									d ? (e.password += v) : (e.username += v);
								} else d = !0;
							}
							p = "";
						} else if (i == Pd || "/" == i || "?" == i || "#" == i || ("\\" == i && ym(e))) {
							if (h && "" == p) return "Invalid authority";
							(c -= En(p).length + 1), (p = ""), (l = Mm);
						} else p += i;
						break;
					case Mm:
					case Lm:
						if (n && "file" == e.scheme) {
							l = Wm;
							continue;
						}
						if (":" != i || f) {
							if (i == Pd || "/" == i || "?" == i || "#" == i || ("\\" == i && ym(e))) {
								if (ym(e) && "" == p) return Yd;
								if (n && "" == p && (bm(e) || null !== e.port)) return;
								if ((s = um(e, p))) return s;
								if (((p = ""), (l = Um), n)) return;
								continue;
							}
							"[" == i ? (f = !0) : "]" == i && (f = !1), (p += i);
						} else {
							if ("" == p) return Yd;
							if ((s = um(e, p))) return s;
							if (((p = ""), (l = zm), n == Lm)) return;
						}
						break;
					case zm:
						if (!$d.test(i)) {
							if (i == Pd || "/" == i || "?" == i || "#" == i || ("\\" == i && ym(e)) || n) {
								if ("" != p) {
									var y = parseInt(p, 10);
									if (y > 65535) return Jd;
									(e.port = ym(e) && y === vm[e.scheme] ? null : y), (p = "");
								}
								if (n) return;
								l = Um;
								continue;
							}
							return Jd;
						}
						p += i;
						break;
					case Pm:
						if (((e.scheme = "file"), "/" == i || "\\" == i)) l = Bm;
						else {
							if (!r || "file" != r.scheme) {
								l = Vm;
								continue;
							}
							if (i == Pd) (e.host = r.host), (e.path = r.path.slice()), (e.query = r.query);
							else if ("?" == i) (e.host = r.host), (e.path = r.path.slice()), (e.query = ""), (l = jm);
							else {
								if ("#" != i) {
									km(a.slice(c).join("")) || ((e.host = r.host), (e.path = r.path.slice()), Nm(e)),
										(l = Vm);
									continue;
								}
								(e.host = r.host),
									(e.path = r.path.slice()),
									(e.query = r.query),
									(e.fragment = ""),
									(l = Hm);
							}
						}
						break;
					case Bm:
						if ("/" == i || "\\" == i) {
							l = Wm;
							break;
						}
						r &&
							"file" == r.scheme &&
							!km(a.slice(c).join("")) &&
							(wm(r.path[0], !0) ? e.path.push(r.path[0]) : (e.host = r.host)),
							(l = Vm);
						continue;
					case Wm:
						if (i == Pd || "/" == i || "\\" == i || "?" == i || "#" == i) {
							if (!n && wm(p)) l = Vm;
							else if ("" == p) {
								if (((e.host = ""), n)) return;
								l = Um;
							} else {
								if ((s = um(e, p))) return s;
								if (("localhost" == e.host && (e.host = ""), n)) return;
								(p = ""), (l = Um);
							}
							continue;
						}
						p += i;
						break;
					case Um:
						if (ym(e)) {
							if (((l = Vm), "/" != i && "\\" != i)) continue;
						} else if (n || "?" != i)
							if (n || "#" != i) {
								if (i != Pd && ((l = Vm), "/" != i)) continue;
							} else (e.fragment = ""), (l = Hm);
						else (e.query = ""), (l = jm);
						break;
					case Vm:
						if (i == Pd || "/" == i || ("\\" == i && ym(e)) || (!n && ("?" == i || "#" == i))) {
							if (
								(".." === (u = (u = p).toLowerCase()) || "%2e." === u || ".%2e" === u || "%2e%2e" === u
									? (Nm(e), "/" == i || ("\\" == i && ym(e)) || e.path.push(""))
									: Im(p)
									? "/" == i || ("\\" == i && ym(e)) || e.path.push("")
									: ("file" == e.scheme &&
											!e.path.length &&
											wm(p) &&
											(e.host && (e.host = ""), (p = p.charAt(0) + ":")),
									  e.path.push(p)),
								(p = ""),
								"file" == e.scheme && (i == Pd || "?" == i || "#" == i))
							)
								for (; e.path.length > 1 && "" === e.path[0]; ) e.path.shift();
							"?" == i ? ((e.query = ""), (l = jm)) : "#" == i && ((e.fragment = ""), (l = Hm));
						} else p += gm(i, dm);
						break;
					case Gm:
						"?" == i
							? ((e.query = ""), (l = jm))
							: "#" == i
							? ((e.fragment = ""), (l = Hm))
							: i != Pd && (e.path[0] += gm(i, hm));
						break;
					case jm:
						n || "#" != i
							? i != Pd &&
							  ("'" == i && ym(e) ? (e.query += "%27") : (e.query += "#" == i ? "%23" : gm(i, hm)))
							: ((e.fragment = ""), (l = Hm));
						break;
					case Hm:
						i != Pd && (e.fragment += gm(i, fm));
				}
				c++;
			}
		},
		Km = function (e) {
			var t,
				n,
				r = Tl(this, Km, "URL"),
				a = arguments.length > 1 ? arguments[1] : void 0,
				i = String(e),
				s = jd(r, { type: "URL" });
			if (void 0 !== a)
				if (a instanceof Km) t = Hd(a);
				else if ((n = qm((t = {}), String(a)))) throw TypeError(n);
			if ((n = qm(s, i, null, t))) throw TypeError(n);
			var u = (s.searchParams = new Vd()),
				l = Gd(u);
			l.updateSearchParams(s.query),
				(l.updateURL = function () {
					s.query = String(u) || null;
				}),
				o ||
					((r.href = Ym.call(r)),
					(r.origin = Jm.call(r)),
					(r.protocol = Zm.call(r)),
					(r.username = Qm.call(r)),
					(r.password = $m.call(r)),
					(r.host = eg.call(r)),
					(r.hostname = tg.call(r)),
					(r.port = ng.call(r)),
					(r.pathname = rg.call(r)),
					(r.search = ag.call(r)),
					(r.searchParams = ig.call(r)),
					(r.hash = og.call(r)));
		},
		Xm = Km.prototype,
		Ym = function () {
			var e = Hd(this),
				t = e.scheme,
				n = e.username,
				r = e.password,
				a = e.host,
				i = e.port,
				o = e.path,
				s = e.query,
				u = e.fragment,
				l = t + ":";
			return (
				null !== a
					? ((l += "//"),
					  bm(e) && (l += n + (r ? ":" + r : "") + "@"),
					  (l += pm(a)),
					  null !== i && (l += ":" + i))
					: "file" == t && (l += "//"),
				(l += e.cannotBeABaseURL ? o[0] : o.length ? "/" + o.join("/") : ""),
				null !== s && (l += "?" + s),
				null !== u && (l += "#" + u),
				l
			);
		},
		Jm = function () {
			var e = Hd(this),
				t = e.scheme,
				n = e.port;
			if ("blob" == t)
				try {
					return new URL(t.path[0]).origin;
				} catch (e) {
					return "null";
				}
			return "file" != t && ym(e) ? t + "://" + pm(e.host) + (null !== n ? ":" + n : "") : "null";
		},
		Zm = function () {
			return Hd(this).scheme + ":";
		},
		Qm = function () {
			return Hd(this).username;
		},
		$m = function () {
			return Hd(this).password;
		},
		eg = function () {
			var e = Hd(this),
				t = e.host,
				n = e.port;
			return null === t ? "" : null === n ? pm(t) : pm(t) + ":" + n;
		},
		tg = function () {
			var e = Hd(this).host;
			return null === e ? "" : pm(e);
		},
		ng = function () {
			var e = Hd(this).port;
			return null === e ? "" : String(e);
		},
		rg = function () {
			var e = Hd(this),
				t = e.path;
			return e.cannotBeABaseURL ? t[0] : t.length ? "/" + t.join("/") : "";
		},
		ag = function () {
			var e = Hd(this).query;
			return e ? "?" + e : "";
		},
		ig = function () {
			return Hd(this).searchParams;
		},
		og = function () {
			var e = Hd(this).fragment;
			return e ? "#" + e : "";
		},
		sg = function (e, t) {
			return { get: e, set: t, configurable: !0, enumerable: !0 };
		};
	if (
		(o &&
			qe(Xm, {
				href: sg(Ym, function (e) {
					var t = Hd(this),
						n = String(e),
						r = qm(t, n);
					if (r) throw TypeError(r);
					Gd(t.searchParams).updateSearchParams(t.query);
				}),
				origin: sg(Jm),
				protocol: sg(Zm, function (e) {
					var t = Hd(this);
					qm(t, String(e) + ":", Sm);
				}),
				username: sg(Qm, function (e) {
					var t = Hd(this),
						n = En(String(e));
					if (!xm(t)) {
						t.username = "";
						for (var r = 0; r < n.length; r++) t.username += gm(n[r], mm);
					}
				}),
				password: sg($m, function (e) {
					var t = Hd(this),
						n = En(String(e));
					if (!xm(t)) {
						t.password = "";
						for (var r = 0; r < n.length; r++) t.password += gm(n[r], mm);
					}
				}),
				host: sg(eg, function (e) {
					var t = Hd(this);
					t.cannotBeABaseURL || qm(t, String(e), Mm);
				}),
				hostname: sg(tg, function (e) {
					var t = Hd(this);
					t.cannotBeABaseURL || qm(t, String(e), Lm);
				}),
				port: sg(ng, function (e) {
					var t = Hd(this);
					xm(t) || ("" == (e = String(e)) ? (t.port = null) : qm(t, e, zm));
				}),
				pathname: sg(rg, function (e) {
					var t = Hd(this);
					t.cannotBeABaseURL || ((t.path = []), qm(t, e + "", Um));
				}),
				search: sg(ag, function (e) {
					var t = Hd(this);
					"" == (e = String(e))
						? (t.query = null)
						: ("?" == e.charAt(0) && (e = e.slice(1)), (t.query = ""), qm(t, e, jm)),
						Gd(t.searchParams).updateSearchParams(t.query);
				}),
				searchParams: sg(ig),
				hash: sg(og, function (e) {
					var t = Hd(this);
					"" != (e = String(e))
						? ("#" == e.charAt(0) && (e = e.slice(1)), (t.fragment = ""), qm(t, e, Hm))
						: (t.fragment = null);
				}),
			}),
		re(
			Xm,
			"toJSON",
			function () {
				return Ym.call(this);
			},
			{ enumerable: !0 }
		),
		re(
			Xm,
			"toString",
			function () {
				return Ym.call(this);
			},
			{ enumerable: !0 }
		),
		Ud)
	) {
		var ug = Ud.createObjectURL,
			lg = Ud.revokeObjectURL;
		ug &&
			re(Km, "createObjectURL", function (e) {
				return ug.apply(Ud, arguments);
			}),
			lg &&
				re(Km, "revokeObjectURL", function (e) {
					return lg.apply(Ud, arguments);
				});
	}
	function cg(e) {
		this.wrapped = e;
	}
	function pg(e) {
		var t, n;
		function r(t, n) {
			try {
				var i = e[t](n),
					o = i.value,
					s = o instanceof cg;
				Promise.resolve(s ? o.wrapped : o).then(
					function (e) {
						s ? r("return" === t ? "return" : "next", e) : a(i.done ? "return" : "normal", e);
					},
					function (e) {
						r("throw", e);
					}
				);
			} catch (e) {
				a("throw", e);
			}
		}
		function a(e, a) {
			switch (e) {
				case "return":
					t.resolve({ value: a, done: !0 });
					break;
				case "throw":
					t.reject(a);
					break;
				default:
					t.resolve({ value: a, done: !1 });
			}
			(t = t.next) ? r(t.key, t.arg) : (n = null);
		}
		(this._invoke = function (e, a) {
			return new Promise(function (i, o) {
				var s = { key: e, arg: a, resolve: i, reject: o, next: null };
				n ? (n = n.next = s) : ((t = n = s), r(e, a));
			});
		}),
			"function" != typeof e.return && (this.return = void 0);
	}
	function hg(e, t, n, r, a, i, o) {
		try {
			var s = e[i](o),
				u = s.value;
		} catch (e) {
			return void n(e);
		}
		s.done ? t(u) : Promise.resolve(u).then(r, a);
	}
	function fg(e) {
		return function () {
			var t = this,
				n = arguments;
			return new Promise(function (r, a) {
				var i = e.apply(t, n);
				function o(e) {
					hg(i, r, a, o, s, "next", e);
				}
				function s(e) {
					hg(i, r, a, o, s, "throw", e);
				}
				o(void 0);
			});
		};
	}
	function dg(e, t) {
		for (var n = 0; n < t.length; n++) {
			var r = t[n];
			(r.enumerable = r.enumerable || !1),
				(r.configurable = !0),
				"value" in r && (r.writable = !0),
				Object.defineProperty(e, r.key, r);
		}
	}
	function mg(e, t, n) {
		return t && dg(e.prototype, t), n && dg(e, n), e;
	}
	function gg(e, t) {
		(e.prototype = Object.create(t.prototype)), (e.prototype.constructor = e), yg(e, t);
	}
	function vg(e) {
		return (vg = Object.setPrototypeOf
			? Object.getPrototypeOf
			: function (e) {
					return e.__proto__ || Object.getPrototypeOf(e);
			  })(e);
	}
	function yg(e, t) {
		return (yg =
			Object.setPrototypeOf ||
			function (e, t) {
				return (e.__proto__ = t), e;
			})(e, t);
	}
	function bg() {
		if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
		if (Reflect.construct.sham) return !1;
		if ("function" == typeof Proxy) return !0;
		try {
			return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
		} catch (e) {
			return !1;
		}
	}
	function xg(e, t, n) {
		return (xg = bg()
			? Reflect.construct
			: function (e, t, n) {
					var r = [null];
					r.push.apply(r, t);
					var a = new (Function.bind.apply(e, r))();
					return n && yg(a, n.prototype), a;
			  }).apply(null, arguments);
	}
	function wg(e) {
		var t = "function" == typeof Map ? new Map() : void 0;
		return (wg = function (e) {
			if (null === e || ((n = e), -1 === Function.toString.call(n).indexOf("[native code]"))) return e;
			var n;
			if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
			if (void 0 !== t) {
				if (t.has(e)) return t.get(e);
				t.set(e, r);
			}
			function r() {
				return xg(e, arguments, vg(this).constructor);
			}
			return (
				(r.prototype = Object.create(e.prototype, {
					constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 },
				})),
				yg(r, e)
			);
		})(e);
	}
	function kg(e) {
		if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e;
	}
	function Ng(e, t) {
		(null == t || t > e.length) && (t = e.length);
		for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
		return r;
	}
	function Ig(e, t) {
		var n;
		if ("undefined" == typeof Symbol || null == e[Symbol.iterator]) {
			if (
				Array.isArray(e) ||
				(n = (function (e, t) {
					if (e) {
						if ("string" == typeof e) return Ng(e, t);
						var n = Object.prototype.toString.call(e).slice(8, -1);
						return (
							"Object" === n && e.constructor && (n = e.constructor.name),
							"Map" === n || "Set" === n
								? Array.from(e)
								: "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
								? Ng(e, t)
								: void 0
						);
					}
				})(e)) ||
				(t && e && "number" == typeof e.length)
			) {
				n && (e = n);
				var r = 0;
				return function () {
					return r >= e.length ? { done: !0 } : { done: !1, value: e[r++] };
				};
			}
			throw new TypeError(
				"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
			);
		}
		return (n = e[Symbol.iterator]()).next.bind(n);
	}
	ht(Km, "URL"),
		De({ global: !0, forced: !ad, sham: !o }, { URL: Km }),
		De(
			{ target: "URL", proto: !0, enumerable: !0 },
			{
				toJSON: function () {
					return URL.prototype.toString.call(this);
				},
			}
		),
		n(function (e) {
			var t = (function (e) {
				var t,
					n = Object.prototype,
					r = n.hasOwnProperty,
					a = "function" == typeof Symbol ? Symbol : {},
					i = a.iterator || "@@iterator",
					o = a.asyncIterator || "@@asyncIterator",
					s = a.toStringTag || "@@toStringTag";
				function u(e, t, n) {
					return (
						Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }), e[t]
					);
				}
				try {
					u({}, "");
				} catch (e) {
					u = function (e, t, n) {
						return (e[t] = n);
					};
				}
				function l(e, t, n, r) {
					var a = t && t.prototype instanceof g ? t : g,
						i = Object.create(a.prototype),
						o = new E(r || []);
					return (
						(i._invoke = (function (e, t, n) {
							var r = p;
							return function (a, i) {
								if (r === f) throw new Error("Generator is already running");
								if (r === d) {
									if ("throw" === a) throw i;
									return A();
								}
								for (n.method = a, n.arg = i; ; ) {
									var o = n.delegate;
									if (o) {
										var s = S(o, n);
										if (s) {
											if (s === m) continue;
											return s;
										}
									}
									if ("next" === n.method) n.sent = n._sent = n.arg;
									else if ("throw" === n.method) {
										if (r === p) throw ((r = d), n.arg);
										n.dispatchException(n.arg);
									} else "return" === n.method && n.abrupt("return", n.arg);
									r = f;
									var u = c(e, t, n);
									if ("normal" === u.type) {
										if (((r = n.done ? d : h), u.arg === m)) continue;
										return { value: u.arg, done: n.done };
									}
									"throw" === u.type && ((r = d), (n.method = "throw"), (n.arg = u.arg));
								}
							};
						})(e, n, o)),
						i
					);
				}
				function c(e, t, n) {
					try {
						return { type: "normal", arg: e.call(t, n) };
					} catch (e) {
						return { type: "throw", arg: e };
					}
				}
				e.wrap = l;
				var p = "suspendedStart",
					h = "suspendedYield",
					f = "executing",
					d = "completed",
					m = {};
				function g() {}
				function v() {}
				function y() {}
				var b = {};
				b[i] = function () {
					return this;
				};
				var x = Object.getPrototypeOf,
					w = x && x(x(R([])));
				w && w !== n && r.call(w, i) && (b = w);
				var k = (y.prototype = g.prototype = Object.create(b));
				function N(e) {
					["next", "throw", "return"].forEach(function (t) {
						u(e, t, function (e) {
							return this._invoke(t, e);
						});
					});
				}
				function I(e, t) {
					function n(a, i, o, s) {
						var u = c(e[a], e, i);
						if ("throw" !== u.type) {
							var l = u.arg,
								p = l.value;
							return p && "object" == typeof p && r.call(p, "__await")
								? t.resolve(p.__await).then(
										function (e) {
											n("next", e, o, s);
										},
										function (e) {
											n("throw", e, o, s);
										}
								  )
								: t.resolve(p).then(
										function (e) {
											(l.value = e), o(l);
										},
										function (e) {
											return n("throw", e, o, s);
										}
								  );
						}
						s(u.arg);
					}
					var a;
					this._invoke = function (e, r) {
						function i() {
							return new t(function (t, a) {
								n(e, r, t, a);
							});
						}
						return (a = a ? a.then(i, i) : i());
					};
				}
				function S(e, n) {
					var r = e.iterator[n.method];
					if (r === t) {
						if (((n.delegate = null), "throw" === n.method)) {
							if (
								e.iterator.return &&
								((n.method = "return"), (n.arg = t), S(e, n), "throw" === n.method)
							)
								return m;
							(n.method = "throw"),
								(n.arg = new TypeError("The iterator does not provide a 'throw' method"));
						}
						return m;
					}
					var a = c(r, e.iterator, n.arg);
					if ("throw" === a.type) return (n.method = "throw"), (n.arg = a.arg), (n.delegate = null), m;
					var i = a.arg;
					return i
						? i.done
							? ((n[e.resultName] = i.value),
							  (n.next = e.nextLoc),
							  "return" !== n.method && ((n.method = "next"), (n.arg = t)),
							  (n.delegate = null),
							  m)
							: i
						: ((n.method = "throw"),
						  (n.arg = new TypeError("iterator result is not an object")),
						  (n.delegate = null),
						  m);
				}
				function T(e) {
					var t = { tryLoc: e[0] };
					1 in e && (t.catchLoc = e[1]),
						2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])),
						this.tryEntries.push(t);
				}
				function C(e) {
					var t = e.completion || {};
					(t.type = "normal"), delete t.arg, (e.completion = t);
				}
				function E(e) {
					(this.tryEntries = [{ tryLoc: "root" }]), e.forEach(T, this), this.reset(!0);
				}
				function R(e) {
					if (e) {
						var n = e[i];
						if (n) return n.call(e);
						if ("function" == typeof e.next) return e;
						if (!isNaN(e.length)) {
							var a = -1,
								o = function n() {
									for (; ++a < e.length; )
										if (r.call(e, a)) return (n.value = e[a]), (n.done = !1), n;
									return (n.value = t), (n.done = !0), n;
								};
							return (o.next = o);
						}
					}
					return { next: A };
				}
				function A() {
					return { value: t, done: !0 };
				}
				return (
					(v.prototype = k.constructor = y),
					(y.constructor = v),
					(v.displayName = u(y, s, "GeneratorFunction")),
					(e.isGeneratorFunction = function (e) {
						var t = "function" == typeof e && e.constructor;
						return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name));
					}),
					(e.mark = function (e) {
						return (
							Object.setPrototypeOf
								? Object.setPrototypeOf(e, y)
								: ((e.__proto__ = y), u(e, s, "GeneratorFunction")),
							(e.prototype = Object.create(k)),
							e
						);
					}),
					(e.awrap = function (e) {
						return { __await: e };
					}),
					N(I.prototype),
					(I.prototype[o] = function () {
						return this;
					}),
					(e.AsyncIterator = I),
					(e.async = function (t, n, r, a, i) {
						void 0 === i && (i = Promise);
						var o = new I(l(t, n, r, a), i);
						return e.isGeneratorFunction(n)
							? o
							: o.next().then(function (e) {
									return e.done ? e.value : o.next();
							  });
					}),
					N(k),
					u(k, s, "Generator"),
					(k[i] = function () {
						return this;
					}),
					(k.toString = function () {
						return "[object Generator]";
					}),
					(e.keys = function (e) {
						var t = [];
						for (var n in e) t.push(n);
						return (
							t.reverse(),
							function n() {
								for (; t.length; ) {
									var r = t.pop();
									if (r in e) return (n.value = r), (n.done = !1), n;
								}
								return (n.done = !0), n;
							}
						);
					}),
					(e.values = R),
					(E.prototype = {
						constructor: E,
						reset: function (e) {
							if (
								((this.prev = 0),
								(this.next = 0),
								(this.sent = this._sent = t),
								(this.done = !1),
								(this.delegate = null),
								(this.method = "next"),
								(this.arg = t),
								this.tryEntries.forEach(C),
								!e)
							)
								for (var n in this)
									"t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t);
						},
						stop: function () {
							this.done = !0;
							var e = this.tryEntries[0].completion;
							if ("throw" === e.type) throw e.arg;
							return this.rval;
						},
						dispatchException: function (e) {
							if (this.done) throw e;
							var n = this;
							function a(r, a) {
								return (
									(s.type = "throw"),
									(s.arg = e),
									(n.next = r),
									a && ((n.method = "next"), (n.arg = t)),
									!!a
								);
							}
							for (var i = this.tryEntries.length - 1; i >= 0; --i) {
								var o = this.tryEntries[i],
									s = o.completion;
								if ("root" === o.tryLoc) return a("end");
								if (o.tryLoc <= this.prev) {
									var u = r.call(o, "catchLoc"),
										l = r.call(o, "finallyLoc");
									if (u && l) {
										if (this.prev < o.catchLoc) return a(o.catchLoc, !0);
										if (this.prev < o.finallyLoc) return a(o.finallyLoc);
									} else if (u) {
										if (this.prev < o.catchLoc) return a(o.catchLoc, !0);
									} else {
										if (!l) throw new Error("try statement without catch or finally");
										if (this.prev < o.finallyLoc) return a(o.finallyLoc);
									}
								}
							}
						},
						abrupt: function (e, t) {
							for (var n = this.tryEntries.length - 1; n >= 0; --n) {
								var a = this.tryEntries[n];
								if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
									var i = a;
									break;
								}
							}
							i &&
								("break" === e || "continue" === e) &&
								i.tryLoc <= t &&
								t <= i.finallyLoc &&
								(i = null);
							var o = i ? i.completion : {};
							return (
								(o.type = e),
								(o.arg = t),
								i ? ((this.method = "next"), (this.next = i.finallyLoc), m) : this.complete(o)
							);
						},
						complete: function (e, t) {
							if ("throw" === e.type) throw e.arg;
							return (
								"break" === e.type || "continue" === e.type
									? (this.next = e.arg)
									: "return" === e.type
									? ((this.rval = this.arg = e.arg), (this.method = "return"), (this.next = "end"))
									: "normal" === e.type && t && (this.next = t),
								m
							);
						},
						finish: function (e) {
							for (var t = this.tryEntries.length - 1; t >= 0; --t) {
								var n = this.tryEntries[t];
								if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), C(n), m;
							}
						},
						catch: function (e) {
							for (var t = this.tryEntries.length - 1; t >= 0; --t) {
								var n = this.tryEntries[t];
								if (n.tryLoc === e) {
									var r = n.completion;
									if ("throw" === r.type) {
										var a = r.arg;
										C(n);
									}
									return a;
								}
							}
							throw new Error("illegal catch attempt");
						},
						delegateYield: function (e, n, r) {
							return (
								(this.delegate = { iterator: R(e), resultName: n, nextLoc: r }),
								"next" === this.method && (this.arg = t),
								m
							);
						},
					}),
					e
				);
			})(e.exports);
			try {
				regeneratorRuntime = t;
			} catch (e) {
				Function("r", "regeneratorRuntime = r")(t);
			}
		}),
		"function" == typeof Symbol &&
			Symbol.asyncIterator &&
			(pg.prototype[Symbol.asyncIterator] = function () {
				return this;
			}),
		(pg.prototype.next = function (e) {
			return this._invoke("next", e);
		}),
		(pg.prototype.throw = function (e) {
			return this._invoke("throw", e);
		}),
		(pg.prototype.return = function (e) {
			return this._invoke("return", e);
		});
	var Sg = (function () {
			function e(e, t) {
				(this.backend = e), (this.dataMover = t), (this.data = new WeakMap()), (this.dataIdsCount = 0);
			}
			var t = e.prototype;
			return (
				(t.get = function (e) {
					return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
				}),
				(t.set = function (e, t) {
					this.dataIdsCount++, this.data.set(e, t);
				}),
				(t.has = function (e) {
					return this.data.has(e);
				}),
				(t.delete = function (e) {
					return this.dataIdsCount--, this.data.delete(e);
				}),
				(t.numDataIds = function () {
					return this.dataIdsCount;
				}),
				e
			);
		})(),
		Tg = (function () {
			function e() {}
			var t = e.prototype;
			return (
				(t.refCount = function (e) {
					return Cg("refCount");
				}),
				(t.incRef = function (e) {
					return Cg("incRef");
				}),
				(t.timerAvailable = function () {
					return !0;
				}),
				(t.time = function (e) {
					return Cg("time");
				}),
				(t.read = function (e) {
					return Cg("read");
				}),
				(t.readSync = function (e) {
					return Cg("readSync");
				}),
				(t.readToGPU = function (e, t) {
					return Cg("readToGPU");
				}),
				(t.numDataIds = function () {
					return Cg("numDataIds");
				}),
				(t.disposeData = function (e, t) {
					return Cg("disposeData");
				}),
				(t.write = function (e, t, n) {
					return Cg("write");
				}),
				(t.move = function (e, t, n, r, a) {
					return Cg("move");
				}),
				(t.memory = function () {
					return Cg("memory");
				}),
				(t.floatPrecision = function () {
					return Cg("floatPrecision");
				}),
				(t.epsilon = function () {
					return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
				}),
				(t.dispose = function () {
					return Cg("dispose");
				}),
				e
			);
		})();
	function Cg(e) {
		throw new Error(
			"'" +
				e +
				"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen"
		);
	}
	function Eg(e) {
		for (var t = e.length, n = 0; t > 0; ) (n = (Math.random() * t) | 0), _g(e, --t, n);
	}
	function Rg(e, t, n) {
		return Math.max(e, Math.min(t, n));
	}
	function Ag(e) {
		return e % 2 == 0 ? e : e + 1;
	}
	function _g(e, t, n) {
		var r = e[t];
		(e[t] = e[n]), (e[n] = r);
	}
	function Fg(e) {
		for (var t = 0, n = 0; n < e.length; n++) t += e[n];
		return t;
	}
	function Dg(e, t) {
		if (!e) throw new Error("string" == typeof t ? t : t());
	}
	function Og(e, t, n) {
		void 0 === n && (n = ""),
			Dg(Pg(e, t), function () {
				return n + " Shapes " + e + " and " + t + " must match";
			});
	}
	function Mg(e) {
		Dg(null != e, function () {
			return "The input to the tensor constructor must be a non-null value.";
		});
	}
	function Lg(e, t, n) {
		if (
			(void 0 === t && (t = []),
			void 0 === n && (n = !1),
			null == t && (t = []),
			Array.isArray(e) || (Zg(e) && !n))
		)
			for (var r = 0; r < e.length; ++r) Lg(e[r], t, n);
		else t.push(e);
		return t;
	}
	function zg(e) {
		if (0 === e.length) return 1;
		for (var t = e[0], n = 1; n < e.length; n++) t *= e[n];
		return t;
	}
	function Pg(e, t) {
		if (e === t) return !0;
		if (null == e || null == t) return !1;
		if (e.length !== t.length) return !1;
		for (var n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
		return !0;
	}
	function Bg(e) {
		return e % 1 == 0;
	}
	function Wg(e) {
		var t = Math.ceil(Math.sqrt(e));
		return [t, Math.ceil(e / t)];
	}
	function Ug(e, t) {
		return t <= e.length ? e : e + " ".repeat(t - e.length);
	}
	function Vg(e, t, n) {
		return (
			void 0 === t &&
				(t = function (e) {
					return 0;
				}),
			new Promise(function (r, a) {
				var i = 0;
				!(function o() {
					if (e()) r();
					else {
						i++;
						var s = t(i);
						null != n && i >= n ? a() : setTimeout(o, s);
					}
				})();
			})
		);
	}
	function Gg(e, t) {
		for (var n = 1, r = -1, a = 0; a < e.length; ++a)
			if (e[a] >= 0) n *= e[a];
			else if (-1 === e[a]) {
				if (-1 !== r)
					throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + a);
				r = a;
			} else if (e[a] < 0) throw Error("Shapes can not be < 0. Found " + e[a] + " at dim " + a);
		if (-1 === r) {
			if (t > 0 && t !== n) throw Error("Size(" + t + ") must match the product of shape " + e);
			return e;
		}
		if (0 === n) throw Error("Cannot infer the missing size in [" + e + "] when there are 0 elements");
		if (t % n != 0) throw Error("The implicit shape can't be a fractional number. Got " + t + " / " + n);
		var i = e.slice();
		return (i[r] = t / n), i;
	}
	function jg(e, t) {
		var n = t.length;
		return (
			Dg(
				(e =
					null == e
						? t.map(function (e, t) {
								return t;
						  })
						: [].concat(e)).every(function (e) {
					return e >= -n && e < n;
				}),
				function () {
					return "All values in axis param must be in range [-" + n + ", " + n + ") but got axis " + e;
				}
			),
			Dg(
				e.every(function (e) {
					return Bg(e);
				}),
				function () {
					return "All values in axis param must be integers but got axis " + e;
				}
			),
			e.map(function (e) {
				return e < 0 ? n + e : e;
			})
		);
	}
	function Hg(e, t) {
		for (
			var n = [],
				r = [],
				a = null != t && Array.isArray(t) && 0 === t.length,
				i = null == t || a ? null : jg(t, e).sort(),
				o = 0,
				s = 0;
			s < e.length;
			++s
		) {
			if (null != i) {
				if (i[o] === s && 1 !== e[s])
					throw new Error("Can't squeeze axis " + s + " since its dim '" + e[s] + "' is not 1");
				(null == i[o] || i[o] > s) && 1 === e[s] && (n.push(e[s]), r.push(s)), i[o] <= s && o++;
			}
			1 !== e[s] && (n.push(e[s]), r.push(s));
		}
		return { newShape: n, keptDims: r };
	}
	function qg(e, t) {
		var n = null;
		if (null == e || "float32" === e) n = new Float32Array(t);
		else if ("int32" === e) n = new Int32Array(t);
		else {
			if ("bool" !== e) throw new Error("Unknown data type " + e);
			n = new Uint8Array(t);
		}
		return n;
	}
	function Kg(e, t) {
		var n = null;
		if (null == e || "float32" === e) n = new Float32Array(t);
		else if ("int32" === e) n = new Int32Array(t);
		else if ("bool" === e) n = new Uint8Array(t);
		else {
			if ("string" !== e) throw new Error("Unknown data type " + e);
			n = new Array(t);
		}
		return n;
	}
	function Xg(e, t) {
		for (var n = 0; n < e.length; n++) {
			var r = e[n];
			if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + t + " being uploaded contains " + r + ".");
		}
	}
	function Yg(e) {
		return "bool" === e || "complex64" === e || "float32" === e || "int32" === e || "string" === e;
	}
	function Jg(e, t) {
		return !(
			"complex64" === t ||
			("float32" === t && "complex64" !== e) ||
			("int32" === t && "float32" !== e && "complex64" !== e) ||
			("bool" === t && "bool" === e)
		);
	}
	function Zg(e) {
		return (
			e instanceof Float32Array ||
			e instanceof Int32Array ||
			e instanceof Uint8Array ||
			e instanceof Uint8ClampedArray
		);
	}
	function Qg(e) {
		if ("float32" === e || "int32" === e) return 4;
		if ("complex64" === e) return 8;
		if ("bool" === e) return 1;
		throw new Error("Unknown dtype " + e);
	}
	function $g(e) {
		if (null == e) return 0;
		var t = 0;
		return (
			e.forEach(function (e) {
				return (t += e.length);
			}),
			t
		);
	}
	function ev(e) {
		return "string" == typeof e || e instanceof String;
	}
	function tv(e) {
		return "boolean" == typeof e;
	}
	function nv(e) {
		return "number" == typeof e;
	}
	function rv(e) {
		return Array.isArray(e)
			? rv(e[0])
			: e instanceof Float32Array
			? "float32"
			: e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray
			? "int32"
			: nv(e)
			? "float32"
			: ev(e)
			? "string"
			: tv(e)
			? "bool"
			: "float32";
	}
	function av(e) {
		return !!(e && e.constructor && e.call && e.apply);
	}
	function iv(e, t) {
		for (var n = t; n < e; ++n) if (e % n == 0) return n;
		return e;
	}
	function ov(e) {
		var t = e.length;
		if (t < 2) return [];
		var n = new Array(t - 1);
		n[t - 2] = e[t - 1];
		for (var r = t - 3; r >= 0; --r) n[r] = n[r + 1] * e[r + 1];
		return n;
	}
	function sv(e, t, n, r) {
		void 0 === r && (r = !1);
		var a = new Array();
		if (1 === t.length) for (var i = t[0] * (r ? 2 : 1), o = 0; o < i; o++) a[o] = n[e + o];
		else
			for (
				var s = t[0],
					u = t.slice(1),
					l =
						u.reduce(function (e, t) {
							return e * t;
						}) * (r ? 2 : 1),
					c = 0;
				c < s;
				c++
			)
				a[c] = sv(e + c * l, u, n, r);
		return a;
	}
	function uv(e, t, n) {
		if ((void 0 === n && (n = !1), 0 === e.length)) return t[0];
		var r =
			e.reduce(function (e, t) {
				return e * t;
			}) * (n ? 2 : 1);
		if (0 === r) return [];
		if (r !== t.length)
			throw new Error(
				"[" + e + "] does not match the input size " + t.length + (n ? " for a complex tensor" : "") + "."
			);
		return sv(0, e, t, n);
	}
	function lv(e, t) {
		for (var n = cv(e, t), r = 0; r < n.length; r++) n[r] = 1;
		return n;
	}
	function cv(e, t) {
		if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
		if ("int32" === t) return new Int32Array(e);
		if ("bool" === t) return new Uint8Array(e);
		throw new Error("Unknown data type " + t);
	}
	function pv(e, t) {
		var n = e.reduce(function (e, t) {
			return e * t;
		}, 1);
		if (null == t || "float32" === t) return uv(e, new Float32Array(n));
		if ("int32" === t) return uv(e, new Int32Array(n));
		if ("bool" === t) return uv(e, new Uint8Array(n));
		throw new Error("Unknown data type " + t);
	}
	function hv(e) {
		e.forEach(function (t) {
			Dg(Number.isInteger(t) && t >= 0, function () {
				return "Tensor must have a shape comprised of positive integers but got shape [" + e + "].";
			});
		});
	}
	function fv(e, t, n) {
		if (0 === t) return 0;
		if (1 === t) return e[0];
		for (var r = e[e.length - 1], a = 0; a < e.length - 1; ++a) r += n[a] * e[a];
		return r;
	}
	function dv(e, t, n) {
		if (0 === t) return [];
		if (1 === t) return [e];
		for (var r = new Array(t), a = 0; a < r.length - 1; ++a) (r[a] = Math.floor(e / n[a])), (e -= r[a] * n[a]);
		return (r[r.length - 1] = e), r;
	}
	function mv(e) {
		return e && e.then && "function" == typeof e.then;
	}
	var gv,
		vv = (function () {
			function e(e) {
				(this.global = e),
					(this.flags = {}),
					(this.flagRegistry = {}),
					(this.urlFlags = {}),
					(this.getQueryParams = yv),
					this.populateURLFlags();
			}
			var t = e.prototype;
			return (
				(t.setPlatform = function (e, t) {
					null != this.platform &&
						(xv().getBool("IS_TEST") ||
							xv().getBool("PROD") ||
							console.warn(
								"Platform " +
									this.platformName +
									" has already been set. Overwriting the platform with " +
									e +
									"."
							)),
						(this.platformName = e),
						(this.platform = t);
				}),
				(t.registerFlag = function (e, t, n) {
					if (((this.flagRegistry[e] = { evaluationFn: t, setHook: n }), null != this.urlFlags[e])) {
						var r = this.urlFlags[e];
						xv().getBool("IS_TEST") ||
							xv().getBool("PROD") ||
							console.warn("Setting feature override from URL " + e + ": " + r + "."),
							this.set(e, r);
					}
				}),
				(t.getAsync = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (!(t in this.flags)) {
													e.next = 2;
													break;
												}
												return e.abrupt("return", this.flags[t]);
											case 2:
												return (e.next = 4), this.evaluateFlag(t);
											case 4:
												return (this.flags[t] = e.sent), e.abrupt("return", this.flags[t]);
											case 6:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.get = function (e) {
					if (e in this.flags) return this.flags[e];
					var t = this.evaluateFlag(e);
					if (mv(t))
						throw new Error(
							"Flag " + e + " cannot be synchronously evaluated. Please use getAsync() instead."
						);
					return (this.flags[e] = t), this.flags[e];
				}),
				(t.getNumber = function (e) {
					return this.get(e);
				}),
				(t.getBool = function (e) {
					return this.get(e);
				}),
				(t.getFlags = function () {
					return this.flags;
				}),
				(t.set = function (e, t) {
					if (null == this.flagRegistry[e])
						throw new Error("Cannot set flag " + e + " as it has not been registered.");
					(this.flags[e] = t), null != this.flagRegistry[e].setHook && this.flagRegistry[e].setHook(t);
				}),
				(t.evaluateFlag = function (e) {
					if (null == this.flagRegistry[e])
						throw new Error("Cannot evaluate flag '" + e + "': no evaluation function found.");
					return this.flagRegistry[e].evaluationFn();
				}),
				(t.setFlags = function (e) {
					this.flags = Object.assign({}, e);
				}),
				(t.reset = function () {
					(this.flags = {}), (this.urlFlags = {}), this.populateURLFlags();
				}),
				(t.populateURLFlags = function () {
					var e = this;
					if (
						void 0 !== this.global &&
						void 0 !== this.global.location &&
						void 0 !== this.global.location.search
					) {
						var t = this.getQueryParams(this.global.location.search);
						"tfjsflags" in t &&
							t.tfjsflags.split(",").forEach(function (t) {
								var n = t.split(":"),
									r = n[0],
									a = n[1];
								e.urlFlags[r] = (function (e, t) {
									if ("true" === (t = t.toLowerCase()) || "false" === t) return "true" === t;
									if ("" + +t === t) return +t;
									throw new Error("Could not parse value flag value " + t + " for flag " + e + ".");
								})(r, a);
							});
					}
				}),
				mg(e, [
					{
						key: "features",
						get: function () {
							return this.flags;
						},
					},
				]),
				e
			);
		})();
	function yv(e) {
		var t = {};
		return (
			e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (e) {
				for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
					r[a - 1] = arguments[a];
				return bv(t, r[0], r[1]), r.join("=");
			}),
			t
		);
	}
	function bv(e, t, n) {
		e[decodeURIComponent(t)] = decodeURIComponent(n || "");
	}
	function xv() {
		return e.ENV;
	}
	function wv() {
		if (null == gv) {
			var e;
			if ("undefined" != typeof window) e = window;
			else if ("undefined" != typeof global) e = global;
			else if ("undefined" != typeof process) e = process;
			else {
				if ("undefined" == typeof self) throw new Error("Could not find a global object");
				e = self;
			}
			gv = e;
		}
		return gv;
	}
	function kv(e, t) {
		var n,
			r = (null == (n = wv())._tfGlobals && (n._tfGlobals = new Map()), n._tfGlobals);
		if (r.has(e)) return r.get(e);
		var a = t();
		return r.set(e, a), r.get(e);
	}
	e.ENV = null;
	var Nv = "Abs",
		Iv = "Acos",
		Sv = "Acosh",
		Tv = "Add",
		Cv = "AddN",
		Ev = "All",
		Rv = "Any",
		Av = "ArgMax",
		_v = "ArgMin",
		Fv = "Asin",
		Dv = "Asinh",
		Ov = "Atan",
		Mv = "Atanh",
		Lv = "Atan2",
		zv = "AvgPool",
		Pv = "AvgPoolGrad",
		Bv = "AvgPool3D",
		Wv = "AvgPool3DGrad",
		Uv = "BatchMatMul",
		Vv = "BatchToSpaceND",
		Gv = "Bincount",
		jv = "BroadcastTo",
		Hv = "BroadcastArgs",
		qv = "Cast",
		Kv = "Ceil",
		Xv = "ClipByValue",
		Yv = "Complex",
		Jv = "ComplexAbs",
		Zv = "Concat",
		Qv = "Conv2D",
		$v = "Conv2DBackpropFilter",
		ey = "Conv2DBackpropInput",
		ty = "Conv3D",
		ny = "Conv3DBackpropFilterV2",
		ry = "Conv3DBackpropInputV2",
		ay = "Cos",
		iy = "Cosh",
		oy = "Cumprod",
		sy = "Cumsum",
		uy = "CropAndResize",
		ly = "DenseBincount",
		cy = "DepthToSpace",
		py = "DepthwiseConv2dNative",
		hy = "DepthwiseConv2dNativeBackpropFilter",
		fy = "DepthwiseConv2dNativeBackpropInput",
		dy = "Diag",
		my = "Dilation2D",
		gy = "Dilation2DBackpropInput",
		vy = "Dilation2DBackpropFilter",
		yy = "RealDiv",
		by = "Einsum",
		xy = "Elu",
		wy = "EluGrad",
		ky = "Erf",
		Ny = "Equal",
		Iy = "Exp",
		Sy = "ExpandDims",
		Ty = "Expm1",
		Cy = "FFT",
		Ey = "Fill",
		Ry = "FlipLeftRight",
		Ay = "Floor",
		_y = "FloorDiv",
		Fy = "FusedBatchNorm",
		Dy = "GatherV2",
		Oy = "GatherNd",
		My = "Greater",
		Ly = "GreaterEqual",
		zy = "Identity",
		Py = "IFFT",
		By = "Imag",
		Wy = "IsFinite",
		Uy = "IsInf",
		Vy = "IsNan",
		Gy = "LeakyRelu",
		jy = "Less",
		Hy = "LessEqual",
		qy = "LinSpace",
		Ky = "Log",
		Xy = "Log1p",
		Yy = "LogicalAnd",
		Jy = "LogicalNot",
		Zy = "LogicalOr",
		Qy = "LogSoftmax",
		$y = "LRN",
		eb = "LRNGrad",
		tb = "Max",
		nb = "Maximum",
		rb = "MaxPool",
		ab = "MaxPoolGrad",
		ib = "MaxPool3D",
		ob = "MaxPool3DGrad",
		sb = "MaxPoolWithArgmax",
		ub = "Mean",
		lb = "Min",
		cb = "Minimum",
		pb = "MirrorPad",
		hb = "Mod",
		fb = "Multinomial",
		db = "Multiply",
		mb = "Neg",
		gb = "NotEqual",
		vb = "NonMaxSuppressionV3",
		yb = "NonMaxSuppressionV4",
		bb = "NonMaxSuppressionV5",
		xb = "OnesLike",
		wb = "OneHot",
		kb = "Pack",
		Nb = "PadV2",
		Ib = "Pow",
		Sb = "Prelu",
		Tb = "Prod",
		Cb = "Range",
		Eb = "Real",
		Rb = "Reciprocal",
		Ab = "Relu",
		_b = "Reshape",
		Fb = "ResizeNearestNeighbor",
		Db = "ResizeNearestNeighborGrad",
		Ob = "ResizeBilinear",
		Mb = "ResizeBilinearGrad",
		Lb = "Relu6",
		zb = "Reverse",
		Pb = "Round",
		Bb = "Rsqrt",
		Wb = "ScatterNd",
		Ub = "Select",
		Vb = "Selu",
		Gb = "Slice",
		jb = "Sin",
		Hb = "Sinh",
		qb = "Sign",
		Kb = "Sigmoid",
		Xb = "Softplus",
		Yb = "Sqrt",
		Jb = "Sum",
		Zb = "SpaceToBatchND",
		Qb = "SplitV",
		$b = "Softmax",
		ex = "SparseFillEmptyRows",
		tx = "SparseReshape",
		nx = "SparseSegmentMean",
		rx = "SparseSegmentSum",
		ax = "SparseToDense",
		ix = "SquaredDifference",
		ox = "Square",
		sx = "StridedSlice",
		ux = "StringNGrams",
		lx = "StringSplit",
		cx = "StringToHashBucketFast",
		px = "Sub",
		hx = "Tan",
		fx = "Tanh",
		dx = "Tile",
		mx = "TopK",
		gx = "Transform",
		vx = "Transpose",
		yx = "Unique",
		bx = "Unpack",
		xx = "UnsortedSegmentSum",
		wx = "ZerosLike",
		kx = "Step",
		Nx = "FromPixels",
		Ix = "RotateWithOffset",
		Sx = "_FusedMatMul",
		Tx = "FusedConv2D",
		Cx = "FusedDepthwiseConv2D";
	function Ex() {
		var e;
		xv().getBool("IS_TEST") || xv().getBool("PROD") || (e = console).warn.apply(e, arguments);
	}
	var Rx = kv("kernelRegistry", function () {
			return new Map();
		}),
		Ax = kv("gradRegistry", function () {
			return new Map();
		});
	function _x(e, t) {
		var n = Lx(e, t);
		return Rx.get(n);
	}
	function Fx(e) {
		return Ax.get(e);
	}
	function Dx(e) {
		for (var t = Rx.entries(), n = []; ; ) {
			var r = t.next(),
				a = r.done,
				i = r.value;
			if (a) break;
			var o = i[0],
				s = i[1];
			o.split("_")[0] === e && n.push(s);
		}
		return n;
	}
	function Ox(e) {
		var t = e.kernelName,
			n = e.backendName,
			r = Lx(t, n);
		Rx.has(r) && Ex("The kernel '" + t + "' for backend '" + n + "' is already registered"), Rx.set(r, e);
	}
	function Mx(e) {
		var t = e.kernelName;
		Ax.has(t) && xv().getBool("DEBUG") && Ex("Overriding the gradient for '" + t + "'"), Ax.set(t, e);
	}
	function Lx(e, t) {
		return t + "_" + e;
	}
	var zx = Bx,
		Px = null;
	try {
		Px = new WebAssembly.Instance(
			new WebAssembly.Module(
				new Uint8Array([
					0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0,
					1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95,
					115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95,
					117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1,
					126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4,
					66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132,
					32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36,
					1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128,
					34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134,
					132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11,
					36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132,
					130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11,
				])
			),
			{}
		).exports;
	} catch (e) {}
	function Bx(e, t, n) {
		(this.low = 0 | e), (this.high = 0 | t), (this.unsigned = !!n);
	}
	function Wx(e) {
		return !0 === (e && e.__isLong__);
	}
	Bx.prototype.__isLong__, Object.defineProperty(Bx.prototype, "__isLong__", { value: !0 }), (Bx.isLong = Wx);
	var Ux = {},
		Vx = {};
	function Gx(e, t) {
		var n, r, a;
		return t
			? (a = 0 <= (e >>>= 0) && e < 256) && (r = Vx[e])
				? r
				: ((n = Hx(e, (0 | e) < 0 ? -1 : 0, !0)), a && (Vx[e] = n), n)
			: (a = -128 <= (e |= 0) && e < 128) && (r = Ux[e])
			? r
			: ((n = Hx(e, e < 0 ? -1 : 0, !1)), a && (Ux[e] = n), n);
	}
	function jx(e, t) {
		if (isNaN(e)) return t ? ew : $x;
		if (t) {
			if (e < 0) return ew;
			if (e >= Jx) return iw;
		} else {
			if (e <= -Zx) return ow;
			if (e + 1 >= Zx) return aw;
		}
		return e < 0 ? jx(-e, t).neg() : Hx(e % Yx | 0, (e / Yx) | 0, t);
	}
	function Hx(e, t, n) {
		return new Bx(e, t, n);
	}
	(Bx.fromInt = Gx), (Bx.fromNumber = jx), (Bx.fromBits = Hx);
	var qx = Math.pow;
	function Kx(e, t, n) {
		if (0 === e.length) throw Error("empty string");
		if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return $x;
		if (("number" == typeof t ? ((n = t), (t = !1)) : (t = !!t), (n = n || 10) < 2 || 36 < n))
			throw RangeError("radix");
		var r;
		if ((r = e.indexOf("-")) > 0) throw Error("interior hyphen");
		if (0 === r) return Kx(e.substring(1), t, n).neg();
		for (var a = jx(qx(n, 8)), i = $x, o = 0; o < e.length; o += 8) {
			var s = Math.min(8, e.length - o),
				u = parseInt(e.substring(o, o + s), n);
			if (s < 8) {
				var l = jx(qx(n, s));
				i = i.mul(l).add(jx(u));
			} else i = (i = i.mul(a)).add(jx(u));
		}
		return (i.unsigned = t), i;
	}
	function Xx(e, t) {
		return "number" == typeof e
			? jx(e, t)
			: "string" == typeof e
			? Kx(e, t)
			: Hx(e.low, e.high, "boolean" == typeof t ? t : e.unsigned);
	}
	(Bx.fromString = Kx), (Bx.fromValue = Xx);
	var Yx = 4294967296,
		Jx = Yx * Yx,
		Zx = Jx / 2,
		Qx = Gx(1 << 24),
		$x = Gx(0);
	Bx.ZERO = $x;
	var ew = Gx(0, !0);
	Bx.UZERO = ew;
	var tw = Gx(1);
	Bx.ONE = tw;
	var nw = Gx(1, !0);
	Bx.UONE = nw;
	var rw = Gx(-1);
	Bx.NEG_ONE = rw;
	var aw = Hx(-1, 2147483647, !1);
	Bx.MAX_VALUE = aw;
	var iw = Hx(-1, -1, !0);
	Bx.MAX_UNSIGNED_VALUE = iw;
	var ow = Hx(0, -2147483648, !1);
	Bx.MIN_VALUE = ow;
	var sw = Bx.prototype;
	(sw.toInt = function () {
		return this.unsigned ? this.low >>> 0 : this.low;
	}),
		(sw.toNumber = function () {
			return this.unsigned ? (this.high >>> 0) * Yx + (this.low >>> 0) : this.high * Yx + (this.low >>> 0);
		}),
		(sw.toString = function (e) {
			if ((e = e || 10) < 2 || 36 < e) throw RangeError("radix");
			if (this.isZero()) return "0";
			if (this.isNegative()) {
				if (this.eq(ow)) {
					var t = jx(e),
						n = this.div(t),
						r = n.mul(t).sub(this);
					return n.toString(e) + r.toInt().toString(e);
				}
				return "-" + this.neg().toString(e);
			}
			for (var a = jx(qx(e, 6), this.unsigned), i = this, o = ""; ; ) {
				var s = i.div(a),
					u = (i.sub(s.mul(a)).toInt() >>> 0).toString(e);
				if ((i = s).isZero()) return u + o;
				for (; u.length < 6; ) u = "0" + u;
				o = "" + u + o;
			}
		}),
		(sw.getHighBits = function () {
			return this.high;
		}),
		(sw.getHighBitsUnsigned = function () {
			return this.high >>> 0;
		}),
		(sw.getLowBits = function () {
			return this.low;
		}),
		(sw.getLowBitsUnsigned = function () {
			return this.low >>> 0;
		}),
		(sw.getNumBitsAbs = function () {
			if (this.isNegative()) return this.eq(ow) ? 64 : this.neg().getNumBitsAbs();
			for (var e = 0 != this.high ? this.high : this.low, t = 31; t > 0 && 0 == (e & (1 << t)); t--);
			return 0 != this.high ? t + 33 : t + 1;
		}),
		(sw.isZero = function () {
			return 0 === this.high && 0 === this.low;
		}),
		(sw.eqz = sw.isZero),
		(sw.isNegative = function () {
			return !this.unsigned && this.high < 0;
		}),
		(sw.isPositive = function () {
			return this.unsigned || this.high >= 0;
		}),
		(sw.isOdd = function () {
			return 1 == (1 & this.low);
		}),
		(sw.isEven = function () {
			return 0 == (1 & this.low);
		}),
		(sw.equals = function (e) {
			return (
				Wx(e) || (e = Xx(e)),
				(this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) &&
					this.high === e.high &&
					this.low === e.low
			);
		}),
		(sw.eq = sw.equals),
		(sw.notEquals = function (e) {
			return !this.eq(e);
		}),
		(sw.neq = sw.notEquals),
		(sw.ne = sw.notEquals),
		(sw.lessThan = function (e) {
			return this.comp(e) < 0;
		}),
		(sw.lt = sw.lessThan),
		(sw.lessThanOrEqual = function (e) {
			return this.comp(e) <= 0;
		}),
		(sw.lte = sw.lessThanOrEqual),
		(sw.le = sw.lessThanOrEqual),
		(sw.greaterThan = function (e) {
			return this.comp(e) > 0;
		}),
		(sw.gt = sw.greaterThan),
		(sw.greaterThanOrEqual = function (e) {
			return this.comp(e) >= 0;
		}),
		(sw.gte = sw.greaterThanOrEqual),
		(sw.ge = sw.greaterThanOrEqual),
		(sw.compare = function (e) {
			if ((Wx(e) || (e = Xx(e)), this.eq(e))) return 0;
			var t = this.isNegative(),
				n = e.isNegative();
			return t && !n
				? -1
				: !t && n
				? 1
				: this.unsigned
				? e.high >>> 0 > this.high >>> 0 || (e.high === this.high && e.low >>> 0 > this.low >>> 0)
					? -1
					: 1
				: this.sub(e).isNegative()
				? -1
				: 1;
		}),
		(sw.comp = sw.compare),
		(sw.negate = function () {
			return !this.unsigned && this.eq(ow) ? ow : this.not().add(tw);
		}),
		(sw.neg = sw.negate),
		(sw.add = function (e) {
			Wx(e) || (e = Xx(e));
			var t = this.high >>> 16,
				n = 65535 & this.high,
				r = this.low >>> 16,
				a = 65535 & this.low,
				i = e.high >>> 16,
				o = 65535 & e.high,
				s = e.low >>> 16,
				u = 0,
				l = 0,
				c = 0,
				p = 0;
			return (
				(c += (p += a + (65535 & e.low)) >>> 16),
				(l += (c += r + s) >>> 16),
				(u += (l += n + o) >>> 16),
				(u += t + i),
				Hx(((c &= 65535) << 16) | (p &= 65535), ((u &= 65535) << 16) | (l &= 65535), this.unsigned)
			);
		}),
		(sw.subtract = function (e) {
			return Wx(e) || (e = Xx(e)), this.add(e.neg());
		}),
		(sw.sub = sw.subtract),
		(sw.multiply = function (e) {
			if (this.isZero()) return $x;
			if ((Wx(e) || (e = Xx(e)), Px))
				return Hx(Px.mul(this.low, this.high, e.low, e.high), Px.get_high(), this.unsigned);
			if (e.isZero()) return $x;
			if (this.eq(ow)) return e.isOdd() ? ow : $x;
			if (e.eq(ow)) return this.isOdd() ? ow : $x;
			if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
			if (e.isNegative()) return this.mul(e.neg()).neg();
			if (this.lt(Qx) && e.lt(Qx)) return jx(this.toNumber() * e.toNumber(), this.unsigned);
			var t = this.high >>> 16,
				n = 65535 & this.high,
				r = this.low >>> 16,
				a = 65535 & this.low,
				i = e.high >>> 16,
				o = 65535 & e.high,
				s = e.low >>> 16,
				u = 65535 & e.low,
				l = 0,
				c = 0,
				p = 0,
				h = 0;
			return (
				(p += (h += a * u) >>> 16),
				(c += (p += r * u) >>> 16),
				(p &= 65535),
				(c += (p += a * s) >>> 16),
				(l += (c += n * u) >>> 16),
				(c &= 65535),
				(l += (c += r * s) >>> 16),
				(c &= 65535),
				(l += (c += a * o) >>> 16),
				(l += t * u + n * s + r * o + a * i),
				Hx(((p &= 65535) << 16) | (h &= 65535), ((l &= 65535) << 16) | (c &= 65535), this.unsigned)
			);
		}),
		(sw.mul = sw.multiply),
		(sw.divide = function (e) {
			if ((Wx(e) || (e = Xx(e)), e.isZero())) throw Error("division by zero");
			var t, n, r;
			if (Px)
				return this.unsigned || -2147483648 !== this.high || -1 !== e.low || -1 !== e.high
					? Hx(
							(this.unsigned ? Px.div_u : Px.div_s)(this.low, this.high, e.low, e.high),
							Px.get_high(),
							this.unsigned
					  )
					: this;
			if (this.isZero()) return this.unsigned ? ew : $x;
			if (this.unsigned) {
				if ((e.unsigned || (e = e.toUnsigned()), e.gt(this))) return ew;
				if (e.gt(this.shru(1))) return nw;
				r = ew;
			} else {
				if (this.eq(ow))
					return e.eq(tw) || e.eq(rw)
						? ow
						: e.eq(ow)
						? tw
						: (t = this.shr(1).div(e).shl(1)).eq($x)
						? e.isNegative()
							? tw
							: rw
						: ((n = this.sub(e.mul(t))), (r = t.add(n.div(e))));
				if (e.eq(ow)) return this.unsigned ? ew : $x;
				if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
				if (e.isNegative()) return this.div(e.neg()).neg();
				r = $x;
			}
			for (n = this; n.gte(e); ) {
				t = Math.max(1, Math.floor(n.toNumber() / e.toNumber()));
				for (
					var a = Math.ceil(Math.log(t) / Math.LN2), i = a <= 48 ? 1 : qx(2, a - 48), o = jx(t), s = o.mul(e);
					s.isNegative() || s.gt(n);

				)
					s = (o = jx((t -= i), this.unsigned)).mul(e);
				o.isZero() && (o = tw), (r = r.add(o)), (n = n.sub(s));
			}
			return r;
		}),
		(sw.div = sw.divide),
		(sw.modulo = function (e) {
			return (
				Wx(e) || (e = Xx(e)),
				Px
					? Hx(
							(this.unsigned ? Px.rem_u : Px.rem_s)(this.low, this.high, e.low, e.high),
							Px.get_high(),
							this.unsigned
					  )
					: this.sub(this.div(e).mul(e))
			);
		}),
		(sw.mod = sw.modulo),
		(sw.rem = sw.modulo),
		(sw.not = function () {
			return Hx(~this.low, ~this.high, this.unsigned);
		}),
		(sw.and = function (e) {
			return Wx(e) || (e = Xx(e)), Hx(this.low & e.low, this.high & e.high, this.unsigned);
		}),
		(sw.or = function (e) {
			return Wx(e) || (e = Xx(e)), Hx(this.low | e.low, this.high | e.high, this.unsigned);
		}),
		(sw.xor = function (e) {
			return Wx(e) || (e = Xx(e)), Hx(this.low ^ e.low, this.high ^ e.high, this.unsigned);
		}),
		(sw.shiftLeft = function (e) {
			return (
				Wx(e) && (e = e.toInt()),
				0 == (e &= 63)
					? this
					: e < 32
					? Hx(this.low << e, (this.high << e) | (this.low >>> (32 - e)), this.unsigned)
					: Hx(0, this.low << (e - 32), this.unsigned)
			);
		}),
		(sw.shl = sw.shiftLeft),
		(sw.shiftRight = function (e) {
			return (
				Wx(e) && (e = e.toInt()),
				0 == (e &= 63)
					? this
					: e < 32
					? Hx((this.low >>> e) | (this.high << (32 - e)), this.high >> e, this.unsigned)
					: Hx(this.high >> (e - 32), this.high >= 0 ? 0 : -1, this.unsigned)
			);
		}),
		(sw.shr = sw.shiftRight),
		(sw.shiftRightUnsigned = function (e) {
			if ((Wx(e) && (e = e.toInt()), 0 == (e &= 63))) return this;
			var t = this.high;
			return e < 32
				? Hx((this.low >>> e) | (t << (32 - e)), t >>> e, this.unsigned)
				: Hx(32 === e ? t : t >>> (e - 32), 0, this.unsigned);
		}),
		(sw.shru = sw.shiftRightUnsigned),
		(sw.shr_u = sw.shiftRightUnsigned),
		(sw.toSigned = function () {
			return this.unsigned ? Hx(this.low, this.high, !1) : this;
		}),
		(sw.toUnsigned = function () {
			return this.unsigned ? this : Hx(this.low, this.high, !0);
		}),
		(sw.toBytes = function (e) {
			return e ? this.toBytesLE() : this.toBytesBE();
		}),
		(sw.toBytesLE = function () {
			var e = this.high,
				t = this.low;
			return [
				255 & t,
				(t >>> 8) & 255,
				(t >>> 16) & 255,
				t >>> 24,
				255 & e,
				(e >>> 8) & 255,
				(e >>> 16) & 255,
				e >>> 24,
			];
		}),
		(sw.toBytesBE = function () {
			var e = this.high,
				t = this.low;
			return [
				e >>> 24,
				(e >>> 16) & 255,
				(e >>> 8) & 255,
				255 & e,
				t >>> 24,
				(t >>> 16) & 255,
				(t >>> 8) & 255,
				255 & t,
			];
		}),
		(Bx.fromBytes = function (e, t, n) {
			return n ? Bx.fromBytesLE(e, t) : Bx.fromBytesBE(e, t);
		}),
		(Bx.fromBytesLE = function (e, t) {
			return new Bx(
				e[0] | (e[1] << 8) | (e[2] << 16) | (e[3] << 24),
				e[4] | (e[5] << 8) | (e[6] << 16) | (e[7] << 24),
				t
			);
		}),
		(Bx.fromBytesBE = function (e, t) {
			return new Bx(
				(e[4] << 24) | (e[5] << 16) | (e[6] << 8) | e[7],
				(e[0] << 24) | (e[1] << 16) | (e[2] << 8) | e[3],
				t
			);
		});
	var uw = zx || { __proto__: null, default: zx, __moduleExports: zx };
	function lw(e) {
		return uw.fromString(e, !0, 16);
	}
	var cw = lw("c3a5c85c97cb3127"),
		pw = lw("b492b66fbe98f273"),
		hw = lw("9ae16a3b2f90404f");
	function fw(e) {
		return e.xor(e.shru(47));
	}
	function dw(e, t, n) {
		var r = e.slice(t, t + n);
		return uw.fromBytes(Array.from(r), !0, !0);
	}
	function mw(e, t) {
		return dw(e, t, 8);
	}
	function gw(e, t) {
		return dw(e, t, 4);
	}
	function vw(e, t) {
		return 0 === t ? e : e.shru(t).or(e.shl(64 - t));
	}
	function yw(e, t, n) {
		void 0 === n && (n = lw("9ddfea08eb382d69"));
		var r = e.xor(t).mul(n);
		r = r.xor(r.shru(47));
		var a = t.xor(r).mul(n);
		return (a = a.xor(a.shru(47))).mul(n);
	}
	function bw(e, t, n, r) {
		return (function (e, t, n, r, a, i) {
			(a = a.add(e)), (i = vw(i.add(a).add(r), 21));
			var o = a;
			return (a = (a = a.add(t)).add(n)), (i = i.add(vw(a, 44))), [a.add(r), i.add(o)];
		})(mw(e, t), mw(e, t + 8), mw(e, t + 16), mw(e, t + 24), n, r);
	}
	function xw(e, t) {
		void 0 === t && (t = e.length);
		var n = uw.fromNumber(81, !0);
		if (t <= 32)
			return t <= 16
				? (function (e, t) {
						if ((void 0 === t && (t = e.length), t >= 8)) {
							var n = hw.add(2 * t),
								r = mw(e, 0).add(hw),
								a = mw(e, t - 8);
							return yw(vw(a, 37).mul(n).add(r), vw(r, 25).add(a).mul(n), n);
						}
						if (t >= 4) {
							var i = hw.add(2 * t);
							return yw(gw(e, 0).shl(3).add(t), gw(e, t - 4), i);
						}
						if (t > 0) {
							var o = e[0] + (e[t >> 1] << 8),
								s = t + (e[t - 1] << 2);
							return fw(hw.mul(o).xor(cw.mul(s))).mul(hw);
						}
						return hw;
				  })(e, t)
				: (function (e, t) {
						void 0 === t && (t = e.length);
						var n = hw.add(2 * t),
							r = mw(e, 0).mul(pw),
							a = mw(e, 8),
							i = mw(e, t - 8).mul(n),
							o = mw(e, t - 16).mul(hw);
						return yw(vw(r.add(a), 43).add(vw(i, 30)).add(o), r.add(vw(a.add(hw), 18)).add(i), n);
				  })(e, t);
		if (t <= 64)
			return (function (e, t) {
				void 0 === t && (t = e.length);
				var n = hw.add(2 * t),
					r = mw(e, 0).mul(hw),
					a = mw(e, 8),
					i = mw(e, t - 8).mul(n),
					o = mw(e, t - 16).mul(hw),
					s = vw(r.add(a), 43).add(vw(i, 30)).add(o),
					u = yw(s, r.add(vw(a.add(hw), 18)).add(i), n),
					l = mw(e, 16).mul(n),
					c = mw(e, 24),
					p = s.add(mw(e, t - 32)).mul(n),
					h = u.add(mw(e, t - 24)).mul(n);
				return yw(vw(l.add(c), 43).add(vw(p, 30)).add(h), l.add(vw(c.add(r), 18)).add(p), n);
			})(e, t);
		var r = n,
			a = n.mul(pw).add(113),
			i = fw(a.mul(hw).add(113)).mul(hw),
			o = [uw.UZERO, uw.UZERO],
			s = [uw.UZERO, uw.UZERO];
		r = r.mul(hw).add(mw(e, 0));
		var u = 0,
			l = 64 * ((t - 1) >> 6),
			c = l + ((t - 1) & 63) - 63;
		do {
			(r = vw(
				r
					.add(a)
					.add(o[0])
					.add(mw(e, u + 8)),
				37
			).mul(pw)),
				(a = vw(a.add(o[1]).add(mw(e, u + 48)), 42).mul(pw)),
				(r = r.xor(s[1])),
				(a = a.add(o[0]).add(mw(e, u + 40))),
				(i = vw(i.add(s[0]), 33).mul(pw)),
				(o = bw(e, u, o[1].mul(pw), r.add(s[0]))),
				(s = bw(e, u + 32, i.add(s[1]), a.add(mw(e, u + 16))));
			var p = [r, i];
			(i = p[0]), (r = p[1]), (u += 64);
		} while (u !== l);
		var h = pw.add(i.and(255).shl(1));
		(u = c),
			(s[0] = s[0].add((t - 1) & 63)),
			(o[0] = o[0].add(s[0])),
			(s[0] = s[0].add(o[0])),
			(r = vw(
				r
					.add(a)
					.add(o[0])
					.add(mw(e, u + 8)),
				37
			).mul(h)),
			(a = vw(a.add(o[1]).add(mw(e, u + 48)), 42).mul(h)),
			(r = r.xor(s[1].mul(9))),
			(a = a.add(o[0].mul(9).add(mw(e, u + 40)))),
			(i = vw(i.add(s[0]), 33).mul(h)),
			(o = bw(e, u, o[1].mul(h), r.add(s[0]))),
			(s = bw(e, u + 32, i.add(s[1]), a.add(mw(e, u + 16))));
		var f = [r, i];
		return (i = f[0]), (r = f[1]), yw(yw(o[0], s[0], h).add(fw(a).mul(cw)).add(i), yw(o[1], s[1], h).add(r), h);
	}
	function ww(e, t) {
		return "string" === t ? Sw(e) : kw([e], t);
	}
	function kw(e, t) {
		if ("string" === t) throw new Error("Cannot convert a string[] to a TypedArray");
		if (
			(Array.isArray(e) && (e = Lg(e)),
			xv().getBool("DEBUG") && Xg(e, t),
			(function (e, t) {
				return (
					(e instanceof Float32Array && "float32" === t) ||
					(e instanceof Int32Array && "int32" === t) ||
					(e instanceof Uint8Array && "bool" === t)
				);
			})(e, t))
		)
			return e;
		if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
		if ("int32" === t) return new Int32Array(e);
		if ("bool" === t) {
			for (var n = new Uint8Array(e.length), r = 0; r < n.length; ++r) 0 !== Math.round(e[r]) && (n[r] = 1);
			return n;
		}
		throw new Error("Unknown data type " + t);
	}
	function Nw() {
		return xv().platform.now();
	}
	function Iw(e, t) {
		return xv().platform.fetch(e, t);
	}
	function Sw(e, t) {
		return void 0 === t && (t = "utf-8"), (t = t || "utf-8"), xv().platform.encode(e, t);
	}
	function Tw(e, t) {
		return void 0 === t && (t = "utf-8"), (t = t || "utf-8"), xv().platform.decode(e, t);
	}
	var Cw = {
			__proto__: null,
			createScalarValue: ww,
			toTypedArray: kw,
			now: Nw,
			fetch: Iw,
			encodeString: Sw,
			decodeString: Tw,
			shuffle: Eg,
			shuffleCombo: function (e, t) {
				if (e.length !== t.length)
					throw new Error(
						"Array sizes must match to be shuffled together First array length was " +
							e.length +
							"Second array length was " +
							t.length
					);
				for (var n = e.length, r = 0; n > 0; ) (r = (Math.random() * n) | 0), _g(e, --n, r), _g(t, n, r);
			},
			clamp: Rg,
			nearestLargerEven: Ag,
			swap: _g,
			sum: Fg,
			randUniform: function (e, t) {
				var n = Math.random();
				return t * n + (1 - n) * e;
			},
			distSquared: function (e, t) {
				for (var n = 0, r = 0; r < e.length; r++) {
					var a = Number(e[r]) - Number(t[r]);
					n += a * a;
				}
				return n;
			},
			assert: Dg,
			assertShapesMatch: Og,
			assertNonNull: Mg,
			flatten: Lg,
			sizeFromShape: zg,
			isScalarShape: function (e) {
				return 0 === e.length;
			},
			arraysEqual: Pg,
			isInt: Bg,
			tanh: function (e) {
				if (null != Math.tanh) return Math.tanh(e);
				if (e === 1 / 0) return 1;
				if (e === -1 / 0) return -1;
				var t = Math.exp(2 * e);
				return (t - 1) / (t + 1);
			},
			sizeToSquarishShape: Wg,
			createShuffledIndices: function (e) {
				for (var t = new Uint32Array(e), n = 0; n < e; ++n) t[n] = n;
				return Eg(t), t;
			},
			rightPad: Ug,
			repeatedTry: Vg,
			inferFromImplicitShape: Gg,
			parseAxisParam: jg,
			squeezeShape: Hg,
			getTypedArrayFromDType: qg,
			getArrayFromDType: Kg,
			checkConversionForErrors: Xg,
			isValidDtype: Yg,
			hasEncodingLoss: Jg,
			isTypedArray: Zg,
			bytesPerElement: Qg,
			bytesFromStringArray: $g,
			isString: ev,
			isBoolean: tv,
			isNumber: nv,
			inferDtype: rv,
			isFunction: av,
			nearestDivisor: iv,
			computeStrides: ov,
			toNestedArray: uv,
			makeOnesTypedArray: lv,
			makeZerosTypedArray: cv,
			makeZerosNestedTypedArray: pv,
			assertNonNegativeIntegerDimensions: hv,
			locToIndex: fv,
			indexToLoc: dv,
			isPromise: mv,
			hexToLong: lw,
			fingerPrint64: xw,
		},
		Ew = (function () {
			function e(e, t) {
				(this.backendTimer = e), (this.logger = t), null == t && (this.logger = new Rw());
			}
			var t = e.prototype;
			return (
				(t.profileKernel = function (e, t, n) {
					var r,
						a,
						i = function () {
							r = n();
						},
						o = Nw();
					if (this.backendTimer.timerAvailable()) a = this.backendTimer.time(i);
					else {
						i();
						for (var s, u = Ig(r); !(s = u()).done; ) s.value.dataSync();
						a = Promise.resolve({ kernelMs: Nw() - o });
					}
					if (xv().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
						for (
							var l = function (t) {
									var n = r[t];
									n.data().then(function (t) {
										!(function (e, t, n) {
											if ("float32" !== t) return !1;
											for (var r = 0; r < e.length; r++) {
												var a = e[r];
												if (isNaN(a) || !isFinite(a))
													return (
														console.warn("Found " + a + " in the result of '" + n + "'"), !0
													);
											}
										})(t, n.dtype, e);
									});
								},
								c = 0;
							c < r.length;
							c++
						)
							l(c);
					return {
						kernelName: e,
						outputs: r,
						inputs: t,
						timeMs: a.then(function (e) {
							return e.kernelMs;
						}),
						extraInfo: a.then(function (e) {
							return null != e.getExtraProfileInfo ? e.getExtraProfileInfo() : "";
						}),
					};
				}),
				(t.logKernelProfile = function (e) {
					var t = this,
						n = e.kernelName,
						r = e.outputs,
						a = e.timeMs,
						i = e.inputs,
						o = e.extraInfo;
					r.forEach(function (e) {
						Promise.all([e.data(), a, o]).then(function (r) {
							t.logger.logKernelProfile(n, e, r[0], r[1], i, r[2]);
						});
					});
				}),
				e
			);
		})(),
		Rw = (function () {
			function e() {}
			return (
				(e.prototype.logKernelProfile = function (e, t, n, r, a, i) {
					var o = "number" == typeof r ? Ug(r + "ms", 9) : r.error,
						s = Ug(e, 25),
						u = t.rank,
						l = t.size,
						c = Ug(t.shape.toString(), 14),
						p = "";
					for (var h in a) {
						var f = a[h];
						if (null != f) {
							var d = f.shape || t.shape,
								m = d.length;
							p += h + ": " + m + "D " + (m > 0 ? d : "") + " ";
						}
					}
					console.log(
						"%c" + s + "\t%c" + o + "\t%c" + u + "D " + c + "\t%c" + l + "\t%c" + p + "\t%c" + i,
						"font-weight:bold",
						"color:red",
						"color:blue",
						"color: orange",
						"color: green",
						"color: steelblue"
					);
				}),
				e
			);
		})();
	function Aw(e, t, n, r) {
		var a = ov(t),
			i = (function (e, t, n, r) {
				var a = zg(t),
					i = r[r.length - 1],
					o = new Array(i).fill(0),
					s = t.length,
					u = "complex64" === n ? Ow(e) : e;
				if (s > 1)
					for (var l = 0; l < a / i; l++)
						for (var c = l * i, p = 0; p < i; p++) o[p] = Math.max(o[p], _w(u[c + p], 0, n).length);
				return o;
			})(e, t, n, a),
			o = t.length,
			s = Dw(e, t, n, a, i),
			u = ["Tensor"];
		return (
			r && (u.push("  dtype: " + n), u.push("  rank: " + o), u.push("  shape: [" + t + "]"), u.push("  values:")),
			u.push(
				s
					.map(function (e) {
						return "    " + e;
					})
					.join("\n")
			),
			u.join("\n")
		);
	}
	function _w(e, t, n) {
		return Ug(
			Array.isArray(e)
				? parseFloat(e[0].toFixed(7)) + " + " + parseFloat(e[1].toFixed(7)) + "j"
				: ev(e)
				? "'" + e + "'"
				: "bool" === n
				? Fw(e)
				: parseFloat(e.toFixed(7)).toString(),
			t
		);
	}
	function Fw(e) {
		return 0 === e ? "false" : "true";
	}
	function Dw(e, t, n, r, a, i) {
		void 0 === i && (i = !0);
		var o = "complex64" === n ? 2 : 1,
			s = t[0],
			u = t.length;
		if (0 === u) return "complex64" === n ? [_w(Ow(e)[0], 0, n)] : "bool" === n ? [Fw(e[0])] : [e[0].toString()];
		if (1 === u) {
			if (s > 20) {
				var l = 3 * o,
					c = Array.from(e.slice(0, l)),
					p = Array.from(e.slice((s - 3) * o, s * o));
				return (
					"complex64" === n && ((c = Ow(c)), (p = Ow(p))),
					[
						"[" +
							c
								.map(function (e, t) {
									return _w(e, a[t], n);
								})
								.join(", ") +
							", ..., " +
							p
								.map(function (e, t) {
									return _w(e, a[s - 3 + t], n);
								})
								.join(", ") +
							"]",
					]
				);
			}
			return [
				"[" +
					("complex64" === n ? Ow(e) : Array.from(e))
						.map(function (e, t) {
							return _w(e, a[t], n);
						})
						.join(", ") +
					"]",
			];
		}
		var h = t.slice(1),
			f = r.slice(1),
			d = r[0] * o,
			m = [];
		if (s > 20) {
			for (var g = 0; g < 3; g++) {
				var v = g * d,
					y = v + d;
				m.push.apply(m, Dw(e.slice(v, y), h, n, f, a, !1));
			}
			m.push("...");
			for (var b = s - 3; b < s; b++) {
				var x = b * d,
					w = x + d;
				m.push.apply(m, Dw(e.slice(x, w), h, n, f, a, b === s - 1));
			}
		} else
			for (var k = 0; k < s; k++) {
				var N = k * d,
					I = N + d;
				m.push.apply(m, Dw(e.slice(N, I), h, n, f, a, k === s - 1));
			}
		var S = 2 === u ? "," : "";
		m[0] = "[" + m[0] + S;
		for (var T = 1; T < m.length - 1; T++) m[T] = " " + m[T] + S;
		for (var C = ",\n", E = 2; E < u; E++) C += "\n";
		return (m[m.length - 1] = " " + m[m.length - 1] + "]" + (i ? "" : C)), m;
	}
	function Ow(e) {
		for (var t = [], n = 0; n < e.length; n += 2) t.push([e[n], e[n + 1]]);
		return t;
	}
	var Mw = (function () {
			function e(e, t, n) {
				var r = this;
				if (((this.dtype = t), (this.shape = e.slice()), (this.size = zg(e)), null != n)) {
					var a = n.length;
					Dg(a === this.size, function () {
						return (
							"Length of values '" +
							a +
							"' does not match the size inferred by the shape '" +
							r.size +
							"'."
						);
					});
				}
				if ("complex64" === t)
					throw new Error(
						"complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag)."
					);
				(this.values = n || Kg(t, this.size)), (this.strides = ov(e));
			}
			var t = e.prototype;
			return (
				(t.set = function (e) {
					for (var t = this, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
						r[a - 1] = arguments[a];
					0 === r.length && (r = [0]),
						Dg(r.length === this.rank, function () {
							return (
								"The number of provided coordinates (" +
								r.length +
								") must match the rank (" +
								t.rank +
								")"
							);
						});
					var i = this.locToIndex(r);
					this.values[i] = e;
				}),
				(t.get = function () {
					for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
					0 === t.length && (t = [0]);
					for (var r = 0, a = 0, i = t; a < i.length; a++) {
						var o = i[a];
						if (o < 0 || o >= this.shape[r]) {
							var s = "Requested out of range element at " + t + ".   Buffer shape=" + this.shape;
							throw new Error(s);
						}
						r++;
					}
					for (var u = t[t.length - 1], l = 0; l < t.length - 1; ++l) u += this.strides[l] * t[l];
					return this.values[u];
				}),
				(t.locToIndex = function (e) {
					if (0 === this.rank) return 0;
					if (1 === this.rank) return e[0];
					for (var t = e[e.length - 1], n = 0; n < e.length - 1; ++n) t += this.strides[n] * e[n];
					return t;
				}),
				(t.indexToLoc = function (e) {
					if (0 === this.rank) return [];
					if (1 === this.rank) return [e];
					for (var t = new Array(this.shape.length), n = 0; n < t.length - 1; ++n)
						(t[n] = Math.floor(e / this.strides[n])), (e -= t[n] * this.strides[n]);
					return (t[t.length - 1] = e), t;
				}),
				(t.toTensor = function () {
					return Lw().makeTensor(this.values, this.shape, this.dtype);
				}),
				mg(e, [
					{
						key: "rank",
						get: function () {
							return this.shape.length;
						},
					},
				]),
				e
			);
		})(),
		Lw = null,
		zw = null,
		Pw = (function () {
			function e(e, t, n, r) {
				(this.kept = !1),
					(this.isDisposedInternal = !1),
					(this.shape = e.slice()),
					(this.dtype = t || "float32"),
					(this.size = zg(e)),
					(this.strides = ov(e)),
					(this.dataId = n),
					(this.id = r),
					(this.rankType = this.rank < 5 ? this.rank.toString() : "higher");
			}
			var t = e.prototype;
			return (
				(t.buffer = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.data();
											case 2:
												return (
													(t = e.sent),
													e.abrupt("return", zw.buffer(this.shape, this.dtype, t))
												);
											case 4:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.bufferSync = function () {
					return zw.buffer(this.shape, this.dtype, this.dataSync());
				}),
				(t.array = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.data();
											case 2:
												return (
													(t = e.sent),
													e.abrupt("return", uv(this.shape, t, "complex64" === this.dtype))
												);
											case 4:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.arraySync = function () {
					return uv(this.shape, this.dataSync(), "complex64" === this.dtype);
				}),
				(t.data = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (
													(this.throwIfDisposed(),
													(t = Lw().read(this.dataId)),
													"string" !== this.dtype)
												) {
													e.next = 13;
													break;
												}
												return (e.next = 5), t;
											case 5:
												return (
													(n = e.sent),
													(e.prev = 6),
													e.abrupt(
														"return",
														n.map(function (e) {
															return Tw(e);
														})
													)
												);
											case 10:
												throw (
													((e.prev = 10),
													(e.t0 = e.catch(6)),
													new Error(
														"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes()."
													))
												);
											case 13:
												return e.abrupt("return", t);
											case 14:
											case "end":
												return e.stop();
										}
								},
								e,
								this,
								[[6, 10]]
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.dataToGPU = function (e) {
					return this.throwIfDisposed(), Lw().readToGPU(this.dataId, e);
				}),
				(t.dataSync = function () {
					this.throwIfDisposed();
					var e = Lw().readSync(this.dataId);
					if ("string" === this.dtype)
						try {
							return e.map(function (e) {
								return Tw(e);
							});
						} catch (e) {
							throw new Error(
								"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes()."
							);
						}
					return e;
				}),
				(t.bytes = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return this.throwIfDisposed(), (e.next = 3), Lw().read(this.dataId);
											case 3:
												if (((t = e.sent), "string" !== this.dtype)) {
													e.next = 8;
													break;
												}
												return e.abrupt("return", t);
											case 8:
												return e.abrupt("return", new Uint8Array(t.buffer));
											case 9:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.dispose = function () {
					this.isDisposed || (Lw().disposeTensor(this), (this.isDisposedInternal = !0));
				}),
				(t.throwIfDisposed = function () {
					if (this.isDisposed) throw new Error("Tensor is disposed.");
				}),
				(t.print = function (e) {
					return void 0 === e && (e = !1), zw.print(this, e);
				}),
				(t.clone = function () {
					return this.throwIfDisposed(), zw.clone(this);
				}),
				(t.toString = function (e) {
					return void 0 === e && (e = !1), Aw(this.dataSync(), this.shape, this.dtype, e);
				}),
				(t.cast = function (e) {
					return this.throwIfDisposed(), zw.cast(this, e);
				}),
				(t.variable = function (e, t, n) {
					return void 0 === e && (e = !0), this.throwIfDisposed(), Lw().makeVariable(this, e, t, n);
				}),
				mg(e, [
					{
						key: "rank",
						get: function () {
							return this.shape.length;
						},
					},
					{
						key: "isDisposed",
						get: function () {
							return this.isDisposedInternal;
						},
					},
				]),
				e
			);
		})();
	function Bw() {
		return kv("Tensor", function () {
			return Pw;
		});
	}
	Object.defineProperty(Pw, Symbol.hasInstance, {
		value: function (e) {
			return !!e && null != e.data && null != e.dataSync && null != e.throwIfDisposed;
		},
	}),
		Bw();
	var Ww,
		Uw,
		Vw,
		Gw,
		jw,
		Hw = (function (e) {
			function t(t, n, r, a) {
				var i;
				return ((i = e.call(this, t.shape, t.dtype, t.dataId, a) || this).trainable = n), (i.name = r), i;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.assign = function (e) {
					if (e.dtype !== this.dtype)
						throw new Error(
							"dtype of the new value (" +
								e.dtype +
								") and previous value (" +
								this.dtype +
								") must match"
						);
					if (!Pg(e.shape, this.shape))
						throw new Error(
							"shape of the new value (" +
								e.shape +
								") and previous value (" +
								this.shape +
								") must match"
						);
					Lw().disposeTensor(this), (this.dataId = e.dataId), Lw().incRef(this, null);
				}),
				(n.dispose = function () {
					Lw().disposeVariable(this), (this.isDisposedInternal = !0);
				}),
				t
			);
		})(Pw);
	Object.defineProperty(Hw, Symbol.hasInstance, {
		value: function (e) {
			return e instanceof Pw && null != e.assign && e.assign instanceof Function;
		},
	}),
		((Ww = e.Rank || (e.Rank = {})).R0 = "R0"),
		(Ww.R1 = "R1"),
		(Ww.R2 = "R2"),
		(Ww.R3 = "R3"),
		(Ww.R4 = "R4"),
		(Ww.R5 = "R5"),
		(Ww.R6 = "R6"),
		(function (e) {
			(e.float32 = "float32"), (e.int32 = "int32"), (e.bool = "int32"), (e.complex64 = "complex64");
		})(Uw || (Uw = {})),
		(function (e) {
			(e.float32 = "float32"), (e.int32 = "int32"), (e.bool = "bool"), (e.complex64 = "complex64");
		})(Vw || (Vw = {})),
		(function (e) {
			(e.float32 = "float32"), (e.int32 = "float32"), (e.bool = "float32"), (e.complex64 = "complex64");
		})(Gw || (Gw = {})),
		(function (e) {
			(e.float32 = "complex64"), (e.int32 = "complex64"), (e.bool = "complex64"), (e.complex64 = "complex64");
		})(jw || (jw = {}));
	var qw = { float32: Gw, int32: Uw, bool: Vw, complex64: jw };
	function Kw(e, t) {
		if ("string" === e || "string" === t) {
			if ("string" === e && "string" === t) return "string";
			throw new Error("Can not upcast " + e + " with " + t);
		}
		return qw[e][t];
	}
	function Xw(e) {
		return Kw(e, "int32");
	}
	function Yw(e, t) {
		if (e.dtype === t.dtype) return [e, t];
		var n = Kw(e.dtype, t.dtype);
		return [e.cast(n), t.cast(n)];
	}
	function Jw(e, t) {
		Dg(e.dtype === t.dtype, function () {
			return "The dtypes of the first(" + e.dtype + ") and second(" + t.dtype + ") input must match";
		});
	}
	function Zw(e, t) {
		return t.some(function (t) {
			return t.id === e.id;
		});
	}
	function Qw(e) {
		var t = [];
		return $w(e, t, new Set()), t;
	}
	function $w(e, t, n) {
		if (null != e)
			if (e instanceof Pw) t.push(e);
			else if (((r = e), Array.isArray(r) || "object" == typeof r)) {
				var r,
					a = e;
				for (var i in a) {
					var o = a[i];
					n.has(o) || (n.add(o), $w(o, t, n));
				}
			}
	}
	var ek = {
		__proto__: null,
		makeTypesMatch: Yw,
		assertTypesMatch: Jw,
		isTensorInList: Zw,
		getTensorsInContainer: Qw,
	};
	function tk(e) {
		return null != e.kernelName;
	}
	var nk = (function () {
			function e() {
				(this.registeredVariables = {}),
					(this.nextTapeNodeId = 0),
					(this.numBytes = 0),
					(this.numTensors = 0),
					(this.numStringTensors = 0),
					(this.numDataBuffers = 0),
					(this.gradientDepth = 0),
					(this.kernelDepth = 0),
					(this.scopeStack = []),
					(this.numDataMovesStack = []),
					(this.nextScopeId = 0),
					(this.tensorInfo = new WeakMap()),
					(this.profiling = !1),
					(this.activeProfile = {
						newBytes: 0,
						newTensors: 0,
						peakBytes: 0,
						kernels: [],
						result: null,
						get kernelNames() {
							return Array.from(
								new Set(
									this.kernels.map(function (e) {
										return e.name;
									})
								)
							);
						},
					});
			}
			return (
				(e.prototype.dispose = function () {
					for (var e in this.registeredVariables) this.registeredVariables[e].dispose();
				}),
				e
			);
		})(),
		rk = (function () {
			function e(e) {
				(this.ENV = e),
					(this.registry = {}),
					(this.registryFactory = {}),
					(this.pendingBackendInitId = 0),
					(this.state = new nk());
			}
			var t = e.prototype;
			return (
				(t.ready = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (null == this.pendingBackendInit) {
													e.next = 2;
													break;
												}
												return e.abrupt(
													"return",
													this.pendingBackendInit.then(function () {})
												);
											case 2:
												if (null == this.backendInstance) {
													e.next = 4;
													break;
												}
												return e.abrupt("return");
											case 4:
												(t = this.getSortedBackends()), (n = 0);
											case 6:
												if (!(n < t.length)) {
													e.next = 18;
													break;
												}
												return (r = t[n]), (e.next = 10), this.initializeBackend(r).success;
											case 10:
												if (!e.sent) {
													e.next = 15;
													break;
												}
												return (e.next = 14), this.setBackend(r);
											case 14:
												return e.abrupt("return");
											case 15:
												n++, (e.next = 6);
												break;
											case 18:
												throw new Error(
													"Could not initialize any backends, all backend initializations failed."
												);
											case 19:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.backendNames = function () {
					return Object.keys(this.registryFactory);
				}),
				(t.findBackend = function (e) {
					if (!(e in this.registry)) {
						if (!(e in this.registryFactory)) return null;
						if (this.initializeBackend(e).asyncInit) return null;
					}
					return this.registry[e];
				}),
				(t.findBackendFactory = function (e) {
					return e in this.registryFactory ? this.registryFactory[e].factory : null;
				}),
				(t.registerBackend = function (e, t, n) {
					return (
						void 0 === n && (n = 1),
						e in this.registryFactory
							? (Ex(e + " backend was already registered. Reusing existing backend factory."), !1)
							: ((this.registryFactory[e] = { factory: t, priority: n }), !0)
					);
				}),
				(t.setBackend = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (null != this.registryFactory[t]) {
													e.next = 2;
													break;
												}
												throw new Error("Backend name '" + t + "' not found in registry");
											case 2:
												if (((this.backendName = t), null != this.registry[t])) {
													e.next = 16;
													break;
												}
												if (
													((this.backendInstance = null),
													(n = this.initializeBackend(t)),
													(r = n.success),
													!n.asyncInit)
												) {
													e.next = 12;
													break;
												}
												return (e.next = 9), r;
											case 9:
												(e.t0 = e.sent), (e.next = 13);
												break;
											case 12:
												e.t0 = r;
											case 13:
												if (e.t0) {
													e.next = 16;
													break;
												}
												return e.abrupt("return", !1);
											case 16:
												return (
													(this.backendInstance = this.registry[t]),
													this.setupRegisteredKernels(),
													(this.profiler = new Ew(this.backendInstance)),
													e.abrupt("return", !0)
												);
											case 20:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.setupRegisteredKernels = function () {
					var e = this;
					Dx(this.backendName).forEach(function (t) {
						null != t.setupFunc && t.setupFunc(e.backendInstance);
					});
				}),
				(t.disposeRegisteredKernels = function (e) {
					var t = this;
					Dx(e).forEach(function (n) {
						null != n.disposeFunc && n.disposeFunc(t.registry[e]);
					});
				}),
				(t.initializeBackend = function (e) {
					var t = this,
						n = this.registryFactory[e];
					if (null == n) throw new Error("Cannot initialize backend " + e + ", no registration found.");
					try {
						var r = n.factory();
						if (!r || r instanceof Tg || "function" != typeof r.then)
							return (this.registry[e] = r), { success: !0, asyncInit: !1 };
						var a = ++this.pendingBackendInitId,
							i = r
								.then(function (n) {
									return !(
										a < t.pendingBackendInitId ||
										((t.registry[e] = n), (t.pendingBackendInit = null), 0)
									);
								})
								.catch(function (n) {
									return (
										a < t.pendingBackendInitId ||
											((t.pendingBackendInit = null),
											Ex("Initialization of backend " + e + " failed"),
											Ex(n.stack || n.message)),
										!1
									);
								});
						return (this.pendingBackendInit = i), { success: i, asyncInit: !0 };
					} catch (t) {
						return (
							Ex("Initialization of backend " + e + " failed"),
							Ex(t.stack || t.message),
							{ success: !1, asyncInit: !1 }
						);
					}
				}),
				(t.removeBackend = function (e) {
					if (!(e in this.registryFactory)) throw new Error(e + " backend not found in registry");
					this.backendName === e && null != this.pendingBackendInit && this.pendingBackendInitId++,
						e in this.registry &&
							(this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]),
						delete this.registryFactory[e],
						this.backendName === e &&
							((this.pendingBackendInit = null),
							(this.backendName = null),
							(this.backendInstance = null));
				}),
				(t.getSortedBackends = function () {
					var e = this;
					if (0 === Object.keys(this.registryFactory).length)
						throw new Error("No backend found in registry.");
					return Object.keys(this.registryFactory).sort(function (t, n) {
						return e.registryFactory[n].priority - e.registryFactory[t].priority;
					});
				}),
				(t.initializeBackendsAndReturnBest = function () {
					for (var e = this.getSortedBackends(), t = 0; t < e.length; t++) {
						var n = e[t],
							r = this.initializeBackend(n),
							a = r.success,
							i = r.asyncInit;
						if (i || a) return { name: n, asyncInit: i };
					}
					throw new Error("Could not initialize any backends, all backend initializations failed.");
				}),
				(t.moveData = function (e, t) {
					var n = this.state.tensorInfo.get(t),
						r = n.backend,
						a = this.readSync(t),
						i = r.refCount(t);
					r.disposeData(t, !0),
						(n.backend = e),
						e.move(t, a, n.shape, n.dtype, i),
						this.shouldCheckForMemLeaks() &&
							this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
				}),
				(t.tidy = function (e, t) {
					var n,
						r = this,
						a = null;
					if (null == t) {
						if ("function" != typeof e) throw new Error("Please provide a function to tidy()");
						t = e;
					} else {
						if ("string" != typeof e && !(e instanceof String))
							throw new Error(
								"When calling with two arguments, the first argument to tidy() must be a string"
							);
						if ("function" != typeof t)
							throw new Error(
								"When calling with two arguments, the 2nd argument to tidy() must be a function"
							);
						a = e;
					}
					return this.scopedRun(
						function () {
							return r.startScope(a);
						},
						function () {
							return r.endScope(n);
						},
						function () {
							return (
								(n = t()) instanceof Promise &&
									console.error("Cannot return a Promise inside of tidy."),
								n
							);
						}
					);
				}),
				(t.scopedRun = function (e, t, n) {
					e();
					try {
						var r = n();
						return t(), r;
					} catch (e) {
						throw (t(), e);
					}
				}),
				(t.nextTensorId = function () {
					return e.nextTensorId++;
				}),
				(t.nextVariableId = function () {
					return e.nextVariableId++;
				}),
				(t.clone = function (e) {
					var t = ok.runKernel(zy, { x: e }),
						n = { x: e };
					return (
						this.addTapeNode(
							this.state.activeScope.name,
							n,
							[t],
							function (e) {
								return {
									x: function () {
										var t = { x: e };
										return ok.runKernel(qv, t, { dtype: "float32" });
									},
								};
							},
							[],
							{}
						),
						t
					);
				}),
				(t.runKernel = function (e, t, n) {
					if ((null == this.backendName && this.backend, null == _x(e, this.backendName)))
						throw new Error("Kernel '" + e + "' not registered for backend '" + this.backendName + "'");
					return this.runKernelFunc({ kernelName: e, inputs: t, attrs: n });
				}),
				(t.shouldCheckForMemLeaks = function () {
					return this.ENV.getBool("IS_TEST");
				}),
				(t.checkKernelForMemLeak = function (e, t, n) {
					var r = this.backend.numDataIds(),
						a = 0;
					n.forEach(function (e) {
						a += "complex64" === e.dtype ? 3 : 1;
					});
					var i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
						o = r - t - a - i;
					if (o > 0)
						throw new Error(
							"Backend '" +
								this.backendName +
								"' has an internal memory leak (" +
								o +
								" data ids) after running '" +
								e +
								"'"
						);
				}),
				(t.runKernelFunc = function (e) {
					var t,
						n,
						r,
						a = this,
						i = [],
						o = this.isTapeOn(),
						s = this.state.numBytes,
						u = this.state.numTensors;
					this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0),
						null == this.backendName && this.backend;
					var l = tk(e) ? e.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";
					if (tk(e)) {
						var c = e.kernelName,
							p = e.inputs,
							h = e.attrs;
						null == this.backendName && this.backend;
						var f = _x(c, this.backendName);
						Dg(null != f, function () {
							return "Cannot find registered kernel '" + c + "' for backend '" + a.backendName + "'";
						}),
							(n = function () {
								var e = a.backend.numDataIds();
								r = f.kernelFunc({ inputs: p, attrs: h, backend: a.backend });
								var t = Array.isArray(r) ? r : [r];
								a.shouldCheckForMemLeaks() && a.checkKernelForMemLeak(c, e, t);
								var n = t.map(function (e) {
									if (null != e.rank) return e;
									var t = e.dataId,
										n = e.shape,
										r = e.dtype;
									return a.makeTensorFromDataId(t, n, r);
								});
								if (o) {
									var s = a.getTensorsForGradient(c, p, n);
									i = a.saveTensorsForBackwardMode(s);
								}
								return n;
							});
					} else {
						var d = e.forwardFunc,
							m = function (e) {
								o &&
									(i = e.map(function (e) {
										return a.keep(a.clone(e));
									}));
							};
						n = function () {
							var e = a.backend.numDataIds();
							r = a.tidy(function () {
								return d(a.backend, m);
							});
							var t = Array.isArray(r) ? r : [r];
							return a.shouldCheckForMemLeaks() && a.checkKernelForMemLeak(l, e, t), t;
						};
					}
					var g,
						v = e.inputs,
						y = e.attrs,
						b = tk(e) ? null : e.backwardsFunc;
					return (
						this.scopedRun(
							function () {
								return a.state.kernelDepth++;
							},
							function () {
								return a.state.kernelDepth--;
							},
							function () {
								a.ENV.getBool("DEBUG") || a.state.profiling
									? ((g = a.profiler.profileKernel(l, v, function () {
											return n();
									  })),
									  a.ENV.getBool("DEBUG") && a.profiler.logKernelProfile(g),
									  (t = g.outputs))
									: (t = n());
							}
						),
						o && this.addTapeNode(l, v, t, b, i, y),
						this.state.profiling &&
							this.state.activeProfile.kernels.push({
								name: l,
								bytesAdded: this.state.numBytes - s,
								totalBytesSnapshot: this.state.numBytes,
								tensorsAdded: this.state.numTensors - u,
								totalTensorsSnapshot: this.state.numTensors,
								inputShapes: Object.keys(v).map(function (e) {
									return null != v[e] ? v[e].shape : null;
								}),
								outputShapes: t.map(function (e) {
									return e.shape;
								}),
								kernelTimeMs: g.timeMs,
								extraInfo: g.extraInfo,
							}),
						Array.isArray(r) ? t : t[0]
					);
				}),
				(t.saveTensorsForBackwardMode = function (e) {
					var t = this;
					return e.map(function (e) {
						return t.keep(t.clone(e));
					});
				}),
				(t.getTensorsForGradient = function (e, t, n) {
					var r = Fx(e);
					if (null != r) {
						var a,
							i = r.inputsToSave || [],
							o = r.outputsToSave || [];
						r.saveAllInputs
							? (Dg(Array.isArray(t), function () {
									return "saveAllInputs is true, expected inputs to be an array.";
							  }),
							  (a = Object.keys(t).map(function (e) {
									return t[e];
							  })))
							: (a = i.map(function (e) {
									return t[e];
							  }));
						var s = n.filter(function (e, t) {
							return o[t];
						});
						return a.concat(s);
					}
					return [];
				}),
				(t.makeTensor = function (e, t, n, r) {
					if (null == e) throw new Error("Values passed to engine.makeTensor() are null");
					(n = n || "float32"), (r = r || this.backend);
					var a = e;
					"string" === n &&
						ev(e[0]) &&
						(a = e.map(function (e) {
							return Sw(e);
						}));
					var i = r.write(a, t, n),
						o = new Pw(t, n, i, this.nextTensorId());
					if ((this.trackTensor(o, r), "string" === n)) {
						var s = this.state.tensorInfo.get(i),
							u = $g(a);
						(this.state.numBytes += u - s.bytes), (s.bytes = u);
					}
					return o;
				}),
				(t.makeTensorFromDataId = function (e, t, n, r) {
					var a = new Pw(t, (n = n || "float32"), e, this.nextTensorId());
					return this.trackTensor(a, r), a;
				}),
				(t.makeVariable = function (e, t, n, r) {
					void 0 === t && (t = !0),
						(n = n || this.nextVariableId().toString()),
						null != r && r !== e.dtype && (e = e.cast(r));
					var a = new Hw(e, t, n, this.nextTensorId());
					if (null != this.state.registeredVariables[a.name])
						throw new Error("Variable with name " + a.name + " was already registered");
					return (this.state.registeredVariables[a.name] = a), this.incRef(a, this.backend), a;
				}),
				(t.trackTensor = function (e, t) {
					this.state.numTensors++, "string" === e.dtype && this.state.numStringTensors++;
					var n = 0;
					"complex64" !== e.dtype && "string" !== e.dtype && (n = e.size * Qg(e.dtype)),
						(this.state.numBytes += n),
						this.state.tensorInfo.has(e.dataId) ||
							(this.state.numDataBuffers++,
							this.state.tensorInfo.set(e.dataId, {
								backend: t || this.backend,
								dtype: e.dtype,
								shape: e.shape,
								bytes: n,
							})),
						e instanceof Hw || this.track(e);
				}),
				(t.incRef = function (e, t) {
					this.trackTensor(e, t), this.backend.incRef(e.dataId);
				}),
				(t.removeDataId = function (e, t) {
					this.state.tensorInfo.has(e) &&
						this.state.tensorInfo.get(e).backend === t &&
						(this.state.tensorInfo.delete(e), this.state.numDataBuffers--);
				}),
				(t.disposeTensor = function (e) {
					if (this.state.tensorInfo.has(e.dataId)) {
						var t = this.state.tensorInfo.get(e.dataId);
						if (
							(this.state.numTensors--,
							"string" === e.dtype && (this.state.numStringTensors--, (this.state.numBytes -= t.bytes)),
							"complex64" !== e.dtype && "string" !== e.dtype)
						) {
							var n = e.size * Qg(e.dtype);
							this.state.numBytes -= n;
						}
						t.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, t.backend);
					}
				}),
				(t.disposeVariables = function () {
					for (var e in this.state.registeredVariables) {
						var t = this.state.registeredVariables[e];
						this.disposeVariable(t);
					}
				}),
				(t.disposeVariable = function (e) {
					this.disposeTensor(e),
						null != this.state.registeredVariables[e.name] && delete this.state.registeredVariables[e.name];
				}),
				(t.memory = function () {
					var e = this.backend.memory();
					return (
						(e.numTensors = this.state.numTensors),
						(e.numDataBuffers = this.state.numDataBuffers),
						(e.numBytes = this.state.numBytes),
						this.state.numStringTensors > 0 &&
							((e.unreliable = !0),
							null == e.reasons && (e.reasons = []),
							e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),
						e
					);
				}),
				(t.profile = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r, a, i, o;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.state.profiling = !0),
													(n = this.state.numBytes),
													(r = this.state.numTensors),
													(this.state.activeProfile.kernels = []),
													(e.next = 6),
													t()
												);
											case 6:
												(this.state.activeProfile.result = e.sent),
													(this.state.profiling = !1),
													(this.state.activeProfile.peakBytes = Math.max.apply(
														Math,
														this.state.activeProfile.kernels.map(function (e) {
															return e.totalBytesSnapshot;
														})
													)),
													(this.state.activeProfile.newBytes = this.state.numBytes - n),
													(this.state.activeProfile.newTensors = this.state.numTensors - r),
													(a = Ig(this.state.activeProfile.kernels));
											case 12:
												if ((i = a()).done) {
													e.next = 22;
													break;
												}
												return (o = i.value), (e.next = 16), o.kernelTimeMs;
											case 16:
												return (o.kernelTimeMs = e.sent), (e.next = 19), o.extraInfo;
											case 19:
												o.extraInfo = e.sent;
											case 20:
												e.next = 12;
												break;
											case 22:
												return e.abrupt("return", this.state.activeProfile);
											case 23:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.isTapeOn = function () {
					return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
				}),
				(t.addTapeNode = function (e, t, n, r, a, i) {
					var o = this,
						s = { id: this.state.nextTapeNodeId++, kernelName: e, inputs: t, outputs: n, saved: a },
						u = Fx(e);
					null != u && (r = u.gradFunc),
						null != r &&
							(s.gradient = function (e) {
								return (
									(e = e.map(function (e, t) {
										if (null == e) {
											var r = n[t],
												a = cv(r.size, r.dtype);
											return o.makeTensor(a, r.shape, r.dtype);
										}
										return e;
									})),
									r(e.length > 1 ? e : e[0], a, i)
								);
							}),
						this.state.activeTape.push(s);
				}),
				(t.keep = function (e) {
					return (e.kept = !0), e;
				}),
				(t.startTape = function () {
					0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
				}),
				(t.endTape = function () {
					this.state.gradientDepth--;
				}),
				(t.startScope = function (e) {
					var t = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
					e && (t.name = e), this.state.scopeStack.push(t), (this.state.activeScope = t);
				}),
				(t.endScope = function (e) {
					for (
						var t = this,
							n = Qw(e),
							r = new Set(
								n.map(function (e) {
									return e.id;
								})
							),
							a = 0;
						a < this.state.activeScope.track.length;
						a++
					) {
						var i = this.state.activeScope.track[a];
						i.kept || r.has(i.id) || i.dispose();
					}
					var o = this.state.scopeStack.pop();
					(this.state.activeScope =
						0 === this.state.scopeStack.length
							? null
							: this.state.scopeStack[this.state.scopeStack.length - 1]),
						n.forEach(function (e) {
							e.kept || e.scopeId !== o.id || t.track(e);
						});
				}),
				(t.gradients = function (e, t, n, r) {
					var a = this;
					if (
						(void 0 === r && (r = !1),
						Dg(t.length > 0, function () {
							return "gradients() received an empty list of xs.";
						}),
						null != n && "float32" !== n.dtype)
					)
						throw new Error("dy must have 'float32' dtype, but has '" + n.dtype + "'");
					var i = this.scopedRun(
						function () {
							return a.startTape();
						},
						function () {
							return a.endTape();
						},
						function () {
							return a.tidy("forward", e);
						}
					);
					Dg(i instanceof Pw, function () {
						return "The result y returned by f() must be a tensor.";
					});
					var o = (function (e, t, n) {
						for (var r = {}, a = {}, i = 0; i < t.length; i++) r[t[i].id] = !0;
						for (var o = 0; o < e.length; o++) {
							var s = e[o],
								u = s.inputs;
							for (var l in u) {
								for (var c = u[l], p = !1, h = 0; h < t.length; h++)
									if (r[c.id]) {
										s.outputs.forEach(function (e) {
											return (r[e.id] = !0);
										}),
											(p = !0),
											(a[s.id] = !0);
										break;
									}
								if (p) break;
							}
						}
						var f = {};
						f[n.id] = !0;
						for (var d = {}, m = e.length - 1; m >= 0; m--)
							for (var g = e[m], v = g.inputs, y = 0; y < g.outputs.length; y++)
								if (f[g.outputs[y].id]) {
									for (var b in v) (f[v[b].id] = !0), (d[g.id] = !0);
									break;
								}
						for (var x = [], w = 0; w < e.length; w++) {
							var k = e[w];
							if (a[k.id] && d[k.id]) {
								var N = {};
								for (var I in k.inputs) {
									var S = k.inputs[I];
									r[S.id] && (N[I] = S);
								}
								var T = Object.assign({}, k);
								(T.inputs = N), (T.outputs = k.outputs), x.push(T);
							}
						}
						return x;
					})(this.state.activeTape, t, i);
					if (!r && 0 === o.length && t.length > 0)
						throw new Error(
							"Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y."
						);
					return this.tidy("backward", function () {
						var e,
							r,
							s = {};
						(s[i.id] =
							null == n ? ((r = lv(zg((e = i.shape)), "float32")), ok.makeTensor(r, e, "float32")) : n),
							(function (e, t, n, r) {
								for (
									var a = function (a) {
											var i = t[a],
												o = [];
											if (
												(i.outputs.forEach(function (t) {
													var n = e[t.id];
													null != n ? o.push(n) : o.push(null);
												}),
												null == i.gradient)
											)
												throw new Error(
													"Cannot compute gradient: gradient function not found for " +
														i.kernelName +
														"."
												);
											var s = i.gradient(o),
												u = function (t) {
													if (!(t in s))
														throw new Error(
															"Cannot backprop through input " +
																t +
																". Available gradients found: " +
																Object.keys(s) +
																"."
														);
													var a = n(function () {
														return s[t]();
													});
													if ("float32" !== a.dtype)
														throw new Error(
															"Error in gradient for op " +
																i.kernelName +
																". The gradient of input " +
																t +
																" must have 'float32' dtype, but has '" +
																a.dtype +
																"'"
														);
													var o = i.inputs[t];
													if (!Pg(a.shape, o.shape))
														throw new Error(
															"Error in gradient for op " +
																i.kernelName +
																". The gradient of input '" +
																t +
																"' has shape '" +
																a.shape +
																"', which does not match the shape of the input '" +
																o.shape +
																"'"
														);
													if (null == e[o.id]) e[o.id] = a;
													else {
														var u = e[o.id];
														(e[o.id] = r(u, a)), u.dispose();
													}
												};
											for (var l in i.inputs) u(l);
										},
										i = t.length - 1;
									i >= 0;
									i--
								)
									a(i);
							})(
								s,
								o,
								function (e) {
									return a.tidy(e);
								},
								sk
							);
						var u = t.map(function (e) {
							return s[e.id];
						});
						return (
							0 === a.state.gradientDepth &&
								(a.state.activeTape.forEach(function (e) {
									for (var t, n = Ig(e.saved); !(t = n()).done; ) t.value.dispose();
								}),
								(a.state.activeTape = null)),
							{ value: i, grads: u }
						);
					});
				}),
				(t.customGrad = function (e) {
					var t = this;
					return (
						Dg(av(e), function () {
							return "The f passed in customGrad(f) must be a function.";
						}),
						function () {
							for (var n = arguments.length, r = new Array(n), a = 0; a < n; a++) r[a] = arguments[a];
							var i;
							Dg(
								r.every(function (e) {
									return e instanceof Pw;
								}),
								function () {
									return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
								}
							);
							var o = {};
							r.forEach(function (e, t) {
								o[t] = e;
							});
							var s = function (t, n) {
									return (
										Dg((i = e.apply(void 0, [].concat(r, [n]))).value instanceof Pw, function () {
											return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
										}),
										Dg(av(i.gradFunc), function () {
											return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
										}),
										i.value
									);
								},
								u = function (e, t) {
									var n = i.gradFunc(e, t),
										a = Array.isArray(n) ? n : [n];
									Dg(a.length === r.length, function () {
										return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
									}),
										Dg(
											a.every(function (e) {
												return e instanceof Pw;
											}),
											function () {
												return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
											}
										);
									var o = {};
									return (
										a.forEach(function (e, t) {
											o[t] = function () {
												return e;
											};
										}),
										o
									);
								};
							return t.runKernelFunc({ forwardFunc: s, backwardsFunc: u, inputs: o });
						}
					);
				}),
				(t.readSync = function (e) {
					return this.state.tensorInfo.get(e).backend.readSync(e);
				}),
				(t.read = function (e) {
					return this.state.tensorInfo.get(e).backend.read(e);
				}),
				(t.readToGPU = function (e, t) {
					return this.state.tensorInfo.get(e).backend.readToGPU(e, t);
				}),
				(t.time = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (n = Nw()), (e.next = 3), this.backend.time(t);
											case 3:
												return ((r = e.sent).wallMs = Nw() - n), e.abrupt("return", r);
											case 6:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.track = function (e) {
					return (
						null != this.state.activeScope &&
							((e.scopeId = this.state.activeScope.id), this.state.activeScope.track.push(e)),
						e
					);
				}),
				(t.reset = function () {
					for (var e in (this.pendingBackendInitId++,
					this.state.dispose(),
					this.ENV.reset(),
					(this.state = new nk()),
					this.registry))
						this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
					(this.backendName = null), (this.backendInstance = null), (this.pendingBackendInit = null);
				}),
				mg(e, [
					{
						key: "backend",
						get: function () {
							if (null != this.pendingBackendInit)
								throw new Error(
									"Backend '" +
										this.backendName +
										"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"
								);
							if (null == this.backendInstance) {
								var e = this.initializeBackendsAndReturnBest(),
									t = e.name;
								if (e.asyncInit)
									throw new Error(
										"The highest priority backend '" +
											t +
											"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"
									);
								this.setBackend(t);
							}
							return this.backendInstance;
						},
					},
					{
						key: "registeredVariables",
						get: function () {
							return this.state.registeredVariables;
						},
					},
				]),
				e
			);
		})();
	function ak() {
		var t = wv();
		if (null == t._tfengine) {
			var n = new vv(t);
			t._tfengine = new rk(n);
		}
		return (
			(function (t) {
				e.ENV = t;
			})(t._tfengine.ENV),
			(Lw = function () {
				return t._tfengine;
			}),
			t._tfengine
		);
	}
	(rk.nextTensorId = 0), (rk.nextVariableId = 0);
	var ik,
		ok = ak();
	function sk(e, t) {
		var n = { a: e, b: t };
		return ok.runKernel(Tv, n);
	}
	function uk(e) {
		if (void 0 !== ik) return ik;
		if (e || ("undefined" != typeof navigator && null != navigator)) {
			if ((e || (e = navigator), "ReactNative" === e.product)) return !0;
			var t = e.userAgent || e.vendor || ("undefined" != typeof window ? window.opera : "");
			if (!t) {
				var n = e;
				return n.userAgentData && n.userAgentData.mobile;
			}
			return (
				/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
					t
				) ||
				/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
					t.substr(0, 4)
				)
			);
		}
		return !1;
	}
	function lk() {
		return ("undefined" != typeof window && null != window.document) || "undefined" != typeof WorkerGlobalScope;
	}
	var ck = {
			__proto__: null,
			mockIsMobile: function (e) {
				ik = e;
			},
			isMobile: uk,
			isBrowser: lk,
		},
		pk = xv();
	function hk(e, t) {
		var n = e;
		if (Zg(e)) return "string" === t ? [] : [e.length];
		if (!Array.isArray(e)) return [];
		for (var r = []; Array.isArray(n) || (Zg(n) && "string" !== t); ) r.push(n.length), (n = n[0]);
		return Array.isArray(e) && xv().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && fk(e, r, []), r;
	}
	function fk(e, t, n) {
		if (((n = n || []), Array.isArray(e) || Zg(e))) {
			Dg(t.length > 0, function () {
				return (
					"Element arr[" +
					n.join("][") +
					"] should be a primitive, but is an array of " +
					e.length +
					" elements"
				);
			}),
				Dg(e.length === t[0], function () {
					return (
						"Element arr[" +
						n.join("][") +
						"] should have " +
						t[0] +
						" elements, but has " +
						e.length +
						" elements"
					);
				});
			for (var r = t.slice(1), a = 0; a < e.length; ++a) fk(e[a], r, n.concat(a));
		} else
			Dg(0 === t.length, function () {
				return (
					"Element arr[" +
					n.join("][") +
					"] is a primitive, but should be an array/TypedArray of " +
					t[0] +
					" elements"
				);
			});
	}
	function dk(e, t, n, r) {
		if ("string_or_numeric" !== e) {
			if (null == e) throw new Error("Expected dtype cannot be null.");
			if (("numeric" !== e && e !== t) || ("numeric" === e && "string" === t))
				throw new Error(
					"Argument '" + n + "' passed to '" + r + "' must be " + e + " tensor, but got " + t + " tensor"
				);
		}
	}
	function mk(e, t, n, r) {
		if ((void 0 === r && (r = "numeric"), e instanceof Pw)) return dk(r, e.dtype, t, n), e;
		var a = rv(e);
		if (
			("string" !== a && ["bool", "int32", "float32"].indexOf(r) >= 0 && (a = r),
			dk(r, a, t, n),
			null == e ||
				(!Zg(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e))
		) {
			var i = null == e ? "null" : e.constructor.name;
			throw new Error(
				"Argument '" + t + "' passed to '" + n + "' must be a Tensor or TensorLike, but got '" + i + "'"
			);
		}
		var o = hk(e, a);
		Zg(e) || Array.isArray(e) || (e = [e]);
		var s = "string" !== a ? kw(e, a) : Lg(e, [], !0);
		return ok.makeTensor(s, o, a);
	}
	function gk(e, t, n, r) {
		if ((void 0 === r && (r = "numeric"), !Array.isArray(e)))
			throw new Error("Argument " + t + " passed to " + n + " must be a `Tensor[]` or `TensorLike[]`");
		return e.map(function (e, a) {
			return mk(e, t + "[" + a + "]", n, r);
		});
	}
	pk.registerFlag(
		"DEBUG",
		function () {
			return !1;
		},
		function (e) {
			e &&
				console.warn(
					"Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance."
				);
		}
	),
		pk.registerFlag("IS_BROWSER", function () {
			return lk();
		}),
		pk.registerFlag("IS_NODE", function () {
			return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
		}),
		pk.registerFlag("IS_CHROME", function () {
			return (
				"undefined" != typeof navigator &&
				null != navigator &&
				null != navigator.userAgent &&
				/Chrome/.test(navigator.userAgent) &&
				/Google Inc/.test(navigator.vendor)
			);
		}),
		pk.registerFlag("PROD", function () {
			return !1;
		}),
		pk.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function () {
			return pk.getBool("DEBUG");
		}),
		pk.registerFlag("DEPRECATION_WARNINGS_ENABLED", function () {
			return !0;
		}),
		pk.registerFlag("IS_TEST", function () {
			return !1;
		}),
		pk.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", function () {
			return !0;
		}),
		pk.registerFlag("WRAP_TO_IMAGEBITMAP", function () {
			return !1;
		}),
		pk.registerFlag("ENGINE_COMPILE_ONLY", function () {
			return !1;
		});
	var vk = "__op";
	function yk(e) {
		var t = Object.keys(e);
		if (1 !== t.length)
			throw new Error(
				"Please provide an object with a single key (operation name) mapping to a function. Got an object with " +
					t.length +
					" keys."
			);
		var n = t[0],
			r = e[n];
		n.endsWith("_") && (n = n.substring(0, n.length - 1)), (n += vk);
		var a = function () {
			ok.startScope(n);
			try {
				var e = r.apply(void 0, arguments);
				return mv(e) && console.error("Cannot return a Promise inside of tidy."), ok.endScope(e), e;
			} catch (e) {
				throw (ok.endScope(null), e);
			}
		};
		return Object.defineProperty(a, "name", { value: n, configurable: !0 }), a;
	}
	var bk = yk({
		complex_: function (e, t) {
			var n = mk(e, "real", "complex"),
				r = mk(t, "imag", "complex");
			Og(
				n.shape,
				r.shape,
				"real and imag shapes, " + n.shape + " and " + r.shape + ", must match in call to tf.complex()."
			);
			var a = { real: n, imag: r };
			return ok.runKernel(Yv, a);
		},
	});
	function xk(e, t, n, r) {
		if ((null == r && (r = rv(e)), "complex64" === r))
			throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
		if (!Zg(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e)
			throw new Error(
				"values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray"
			);
		if (null != t) {
			hv(t);
			var a = zg(t),
				i = zg(n);
			Dg(a === i, function () {
				return "Based on the provided shape, [" + t + "], the tensor should have " + a + " values but has " + i;
			});
			for (var o = 0; o < n.length; ++o) {
				var s = n[o],
					u = o !== n.length - 1 || s !== zg(t.slice(o));
				Dg(n[o] === t[o] || !u, function () {
					return (
						"Error creating a new Tensor. Inferred shape (" +
						n +
						") does not match the provided shape (" +
						t +
						"). "
					);
				});
			}
		}
		return (
			Zg(e) || Array.isArray(e) || (e = [e]),
			(t = t || n),
			(e = "string" !== r ? kw(e, r) : Lg(e, [], !0)),
			ok.makeTensor(e, t, r)
		);
	}
	function wk(e, t, n) {
		return xk(e, t, hk(e, n), n);
	}
	var kk = { float32: 4, float16: 2, int32: 4, uint16: 2, uint8: 1, bool: 1, complex64: 8 };
	function Nk(e, t) {
		return Ik.apply(this, arguments);
	}
	function Ik() {
		return (Ik = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r, a, i, o, s, u;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								for (
									r = [],
										a = [],
										i = Array.isArray(t)
											? t.map(function (e) {
													return e.name;
											  })
											: Object.keys(t),
										o = function (e) {
											var o = i[e],
												s = Array.isArray(t) ? t[e].tensor : t[o];
											if (
												"float32" !== s.dtype &&
												"int32" !== s.dtype &&
												"bool" !== s.dtype &&
												"string" !== s.dtype &&
												"complex64" !== s.dtype
											)
												throw new Error("Unsupported dtype in weight '" + o + "': " + s.dtype);
											var u = { name: o, shape: s.shape, dtype: s.dtype };
											if ("string" === s.dtype) {
												var l = new Promise(
													(function () {
														var e = fg(
															regeneratorRuntime.mark(function e(t) {
																var n, r, a, i, o, u, l;
																return regeneratorRuntime.wrap(function (e) {
																	for (;;)
																		switch ((e.prev = e.next)) {
																			case 0:
																				return (e.next = 2), s.bytes();
																			case 2:
																				for (
																					n = e.sent,
																						r =
																							n.reduce(function (e, t) {
																								return e + t.length;
																							}, 0) +
																							4 * n.length,
																						a = new Uint8Array(r),
																						i = 0,
																						o = 0;
																					o < n.length;
																					o++
																				)
																					(u = n[o]),
																						(l = new Uint8Array(
																							new Uint32Array([
																								u.length,
																							]).buffer
																						)),
																						a.set(l, i),
																						(i += 4),
																						a.set(u, i),
																						(i += u.length);
																				t(a);
																			case 8:
																			case "end":
																				return e.stop();
																		}
																}, e);
															})
														);
														return function (t) {
															return e.apply(this, arguments);
														};
													})()
												);
												a.push(l);
											} else a.push(s.data());
											null != n && (u.group = n), r.push(u);
										},
										s = 0;
									s < i.length;
									++s
								)
									o(s);
								return (e.next = 7), Promise.all(a);
							case 7:
								return (u = e.sent), e.abrupt("return", { data: Tk(u), specs: r });
							case 9:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function Sk(e, t) {
		for (var n, r, a = {}, i = 0, o = Ig(t); !(r = o()).done; ) {
			var s = r.value,
				u = s.name,
				l = s.dtype,
				c = s.shape,
				p = zg(c),
				h = void 0;
			if ("quantization" in s) {
				var f = s.quantization;
				if ("uint8" === f.dtype || "uint16" === f.dtype) {
					if (!("min" in f) || !("scale" in f))
						throw new Error(
							"Weight " +
								s.name +
								" with quantization " +
								f.dtype +
								" doesn't have corresponding metadata min and scale."
						);
				} else {
					if ("float16" !== f.dtype)
						throw new Error(
							"Weight " +
								s.name +
								" has unknown quantization dtype " +
								f.dtype +
								". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'."
						);
					if ("float32" !== l)
						throw new Error(
							"Weight " +
								s.name +
								" is quantized with " +
								f.dtype +
								" which only supports weights of type float32 not " +
								l +
								"."
						);
				}
				var d = kk[f.dtype],
					m = e.slice(i, i + p * d),
					g = "uint8" === f.dtype ? new Uint8Array(m) : new Uint16Array(m);
				if ("float32" === l)
					if ("uint8" === f.dtype || "uint16" === f.dtype) {
						h = new Float32Array(g.length);
						for (var v = 0; v < g.length; v++) {
							var y = g[v];
							h[v] = y * f.scale + f.min;
						}
					} else {
						if ("float16" !== f.dtype)
							throw new Error("Unsupported quantization type " + f.dtype + " for weight type float32.");
						void 0 === n && (n = zk()), (h = n(g));
					}
				else {
					if ("int32" !== l) throw new Error("Unsupported dtype in weight '" + u + "': " + l);
					if ("uint8" !== f.dtype && "uint16" !== f.dtype)
						throw new Error("Unsupported quantization type " + f.dtype + " for weight type int32.");
					h = new Int32Array(g.length);
					for (var b = 0; b < g.length; b++) {
						var x = g[b];
						h[b] = Math.round(x * f.scale + f.min);
					}
				}
				i += p * d;
			} else if ("string" === l) {
				var w = zg(s.shape);
				h = [];
				for (var k = 0; k < w; k++) {
					var N = new Uint32Array(e.slice(i, i + 4))[0];
					i += 4;
					var I = new Uint8Array(e.slice(i, i + N));
					h.push(I), (i += N);
				}
			} else {
				var S = kk[l],
					T = e.slice(i, i + p * S);
				if ("float32" === l) h = new Float32Array(T);
				else if ("int32" === l) h = new Int32Array(T);
				else if ("bool" === l) h = new Uint8Array(T);
				else {
					if ("complex64" !== l) throw new Error("Unsupported dtype in weight '" + u + "': " + l);
					h = new Float32Array(T);
					for (
						var C = new Float32Array(h.length / 2), E = new Float32Array(h.length / 2), R = 0;
						R < C.length;
						R++
					)
						(C[R] = h[2 * R]), (E[R] = h[2 * R + 1]);
					var A = wk(C, c, "float32"),
						_ = wk(E, c, "float32");
					(a[u] = bk(A, _)), A.dispose(), _.dispose();
				}
				i += p * S;
			}
			"complex64" !== l && (a[u] = wk(h, c, l));
		}
		return a;
	}
	function Tk(e) {
		if (null === e) throw new Error("Invalid input value: " + JSON.stringify(e));
		var t = 0,
			n = [];
		e.forEach(function (e) {
			if (
				((t += e.byteLength),
				n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)),
				!(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array))
			)
				throw new Error("Unsupported TypedArray subtype: " + e.constructor.name);
		});
		var r = new Uint8Array(t),
			a = 0;
		return (
			n.forEach(function (e) {
				r.set(new Uint8Array(e.buffer), a), (a += e.byteLength);
			}),
			r.buffer
		);
	}
	var Ck =
		"undefined" != typeof Buffer &&
		("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
	function Ek(e) {
		return Ck ? Buffer.byteLength(e) : new Blob([e]).size;
	}
	function Rk(e) {
		if (Ck) return Buffer.from(e).toString("base64");
		for (var t = new Uint8Array(e), n = "", r = 0, a = t.length; r < a; r++) n += String.fromCharCode(t[r]);
		return btoa(n);
	}
	function Ak(e) {
		if (Ck) {
			var t = Buffer.from(e, "base64");
			return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
		}
		for (var n = atob(e), r = new Uint8Array(n.length), a = 0; a < n.length; ++a) r.set([n.charCodeAt(a)], a);
		return r.buffer;
	}
	function _k(e) {
		if (1 === e.length) return e[0];
		var t = 0;
		e.forEach(function (e) {
			t += e.byteLength;
		});
		var n = new Uint8Array(t),
			r = 0;
		return (
			e.forEach(function (e) {
				n.set(new Uint8Array(e), r), (r += e.byteLength);
			}),
			n.buffer
		);
	}
	function Fk(e) {
		for (e = e.trim(); e.endsWith("/"); ) e = e.slice(0, e.length - 1);
		var t = e.split("/");
		return t[t.length - 1];
	}
	function Dk(e, t) {
		var n = {
			modelTopology: e.modelTopology,
			format: e.format,
			generatedBy: e.generatedBy,
			convertedBy: e.convertedBy,
			weightsManifest: t,
		};
		return (
			null != e.signature && (n.signature = e.signature),
			null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata),
			null != e.modelInitializer && (n.modelInitializer = e.modelInitializer),
			null != e.trainingConfig && (n.trainingConfig = e.trainingConfig),
			n
		);
	}
	function Ok(e, t) {
		return Mk.apply(this, arguments);
	}
	function Mk() {
		return (Mk = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r, a, i, o;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if (
									((r = {
										modelTopology: t.modelTopology,
										format: t.format,
										generatedBy: t.generatedBy,
										convertedBy: t.convertedBy,
									}),
									null != t.trainingConfig && (r.trainingConfig = t.trainingConfig),
									null == t.weightsManifest)
								) {
									e.next = 10;
									break;
								}
								return (e.next = 5), n(t.weightsManifest);
							case 5:
								(a = e.sent), (i = a[0]), (o = a[1]), (r.weightSpecs = i), (r.weightData = o);
							case 10:
								return (
									null != t.signature && (r.signature = t.signature),
									null != t.userDefinedMetadata && (r.userDefinedMetadata = t.userDefinedMetadata),
									null != t.modelInitializer && (r.modelInitializer = t.modelInitializer),
									e.abrupt("return", r)
								);
							case 14:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function Lk(e) {
		if (e.modelTopology instanceof ArrayBuffer)
			throw new Error("Expected JSON model topology, received ArrayBuffer.");
		return {
			dateSaved: new Date(),
			modelTopologyType: "JSON",
			modelTopologyBytes: null == e.modelTopology ? 0 : Ek(JSON.stringify(e.modelTopology)),
			weightSpecsBytes: null == e.weightSpecs ? 0 : Ek(JSON.stringify(e.weightSpecs)),
			weightDataBytes: null == e.weightData ? 0 : e.weightData.byteLength,
		};
	}
	function zk() {
		var e = (function () {
				var e = function (e) {
						for (var t = e << 13, n = 0; 0 == (8388608 & t); ) (n -= 8388608), (t <<= 1);
						return (t &= -8388609) | (n + 947912704);
					},
					t = new Uint32Array(2048);
				t[0] = 0;
				for (var n = 1; n < 1024; n++) t[n] = e(n);
				for (var r = 1024; r < 2048; r++) t[r] = 939524096 + ((r - 1024) << 13);
				return t;
			})(),
			t = (function () {
				var e = new Uint32Array(64);
				(e[0] = 0), (e[31] = 1199570944), (e[32] = 2147483648), (e[63] = 3347054592);
				for (var t = 1; t < 31; t++) e[t] = t << 23;
				for (var n = 33; n < 63; n++) e[n] = 2147483648 + ((n - 32) << 23);
				return e;
			})(),
			n = (function () {
				for (var e = new Uint32Array(64), t = 0; t < 64; t++) e[t] = 1024;
				return (e[0] = e[32] = 0), e;
			})();
		return function (r) {
			for (var a = new ArrayBuffer(4 * r.length), i = new Uint32Array(a), o = 0; o < r.length; o++) {
				var s = r[o],
					u = e[n[s >> 10] + (1023 & s)] + t[s >> 10];
				i[o] = u;
			}
			return new Float32Array(a);
		};
	}
	var Pk = (function () {
			function e() {
				(this.saveRouters = []), (this.loadRouters = []);
			}
			return (
				(e.getInstance = function () {
					return null == e.instance && (e.instance = new e()), e.instance;
				}),
				(e.registerSaveRouter = function (t) {
					e.getInstance().saveRouters.push(t);
				}),
				(e.registerLoadRouter = function (t) {
					e.getInstance().loadRouters.push(t);
				}),
				(e.getSaveHandlers = function (t) {
					return e.getHandlers(t, "save");
				}),
				(e.getLoadHandlers = function (t, n) {
					return e.getHandlers(t, "load", n);
				}),
				(e.getHandlers = function (t, n, r) {
					var a = [];
					return (
						("load" === n ? e.getInstance().loadRouters : e.getInstance().saveRouters).forEach(function (
							e
						) {
							var n = e(t, r);
							null !== n && a.push(n);
						}),
						a
					);
				}),
				e
			);
		})(),
		Bk = function (e) {
			return Pk.getSaveHandlers(e);
		},
		Wk = function (e, t) {
			return Pk.getLoadHandlers(e, t);
		},
		Uk = "tensorflowjs",
		Vk = "models_store",
		Gk = "model_info_store";
	function jk() {
		if (!xv().getBool("IS_BROWSER"))
			throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
		var e = "undefined" == typeof window ? self : window,
			t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
		if (null == t) throw new Error("The current browser does not appear to support IndexedDB.");
		return t;
	}
	function Hk(e) {
		var t = e.result;
		t.createObjectStore(Vk, { keyPath: "modelPath" }), t.createObjectStore(Gk, { keyPath: "modelPath" });
	}
	var qk = (function () {
		function e(e) {
			if (((this.indexedDB = jk()), null == e || !e))
				throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
			this.modelPath = e;
		}
		var t = e.prototype;
		return (
			(t.save = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if (!(t.modelTopology instanceof ArrayBuffer)) {
												e.next = 2;
												break;
											}
											throw new Error(
												"BrowserLocalStorage.save() does not support saving model topology in binary formats yet."
											);
										case 2:
											return e.abrupt("return", this.databaseAction(this.modelPath, t));
										case 3:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(t.load = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return e.abrupt("return", this.databaseAction(this.modelPath));
										case 1:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(t.databaseAction = function (e, t) {
				var n = this;
				return new Promise(function (e, r) {
					var a = n.indexedDB.open(Uk, 1);
					(a.onupgradeneeded = function () {
						return Hk(a);
					}),
						(a.onsuccess = function () {
							var i = a.result;
							if (null == t) {
								var o = i.transaction(Vk, "readonly"),
									s = o.objectStore(Vk).get(n.modelPath);
								(s.onsuccess = function () {
									if (null == s.result)
										return (
											i.close(),
											r(
												new Error(
													"Cannot find model with path '" + n.modelPath + "' in IndexedDB."
												)
											)
										);
									e(s.result.modelArtifacts);
								}),
									(s.onerror = function (e) {
										return i.close(), r(s.error);
									}),
									(o.oncomplete = function () {
										return i.close();
									});
							} else {
								var u,
									l = Lk(t),
									c = i.transaction(Gk, "readwrite"),
									p = c.objectStore(Gk),
									h = p.put({ modelPath: n.modelPath, modelArtifactsInfo: l });
								(h.onsuccess = function () {
									var a = (u = i.transaction(Vk, "readwrite"))
										.objectStore(Vk)
										.put({ modelPath: n.modelPath, modelArtifacts: t, modelArtifactsInfo: l });
									(a.onsuccess = function () {
										return e({ modelArtifactsInfo: l });
									}),
										(a.onerror = function (e) {
											var t = (p = c.objectStore(Gk)).delete(n.modelPath);
											(t.onsuccess = function () {
												return i.close(), r(a.error);
											}),
												(t.onerror = function (e) {
													return i.close(), r(a.error);
												});
										});
								}),
									(h.onerror = function (e) {
										return i.close(), r(h.error);
									}),
									(c.oncomplete = function () {
										null == u
											? i.close()
											: (u.oncomplete = function () {
													return i.close();
											  });
									});
							}
						}),
						(a.onerror = function (e) {
							return r(a.error);
						});
				});
			}),
			e
		);
	})();
	qk.URL_SCHEME = "indexeddb://";
	var Kk = function (e) {
		return xv().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(qk.URL_SCHEME)
			? ((t = e.slice(qk.URL_SCHEME.length)), new qk(t))
			: null;
		var t;
	};
	function Xk(e) {
		return e.startsWith(qk.URL_SCHEME) ? e.slice(qk.URL_SCHEME.length) : e;
	}
	Pk.registerSaveRouter(Kk), Pk.registerLoadRouter(Kk);
	var Yk = (function () {
			function e() {
				this.indexedDB = jk();
			}
			var t = e.prototype;
			return (
				(t.listModels = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t = this;
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return e.abrupt(
												"return",
												new Promise(function (e, n) {
													var r = t.indexedDB.open(Uk, 1);
													(r.onupgradeneeded = function () {
														return Hk(r);
													}),
														(r.onsuccess = function () {
															var t = r.result,
																a = t.transaction(Gk, "readonly"),
																i = a.objectStore(Gk).getAll();
															(i.onsuccess = function () {
																for (
																	var t, n = {}, r = Ig(i.result);
																	!(t = r()).done;

																) {
																	var a = t.value;
																	n[a.modelPath] = a.modelArtifactsInfo;
																}
																e(n);
															}),
																(i.onerror = function (e) {
																	return t.close(), n(i.error);
																}),
																(a.oncomplete = function () {
																	return t.close();
																});
														}),
														(r.onerror = function (e) {
															return n(r.error);
														});
												})
											);
										case 1:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.removeModel = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n = this;
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (
												(t = Xk(t)),
												e.abrupt(
													"return",
													new Promise(function (e, r) {
														var a = n.indexedDB.open(Uk, 1);
														(a.onupgradeneeded = function () {
															return Hk(a);
														}),
															(a.onsuccess = function () {
																var n,
																	i = a.result,
																	o = i.transaction(Gk, "readwrite"),
																	s = o.objectStore(Gk),
																	u = s.get(t);
																(u.onsuccess = function () {
																	if (null == u.result)
																		return (
																			i.close(),
																			r(
																				new Error(
																					"Cannot find model with path '" +
																						t +
																						"' in IndexedDB."
																				)
																			)
																		);
																	var a = s.delete(t),
																		o = function () {
																			var a = (n = i.transaction(Vk, "readwrite"))
																				.objectStore(Vk)
																				.delete(t);
																			(a.onsuccess = function () {
																				return e(u.result.modelArtifactsInfo);
																			}),
																				(a.onerror = function (e) {
																					return r(u.error);
																				});
																		};
																	(a.onsuccess = o),
																		(a.onerror = function (e) {
																			return o(), i.close(), r(u.error);
																		});
																}),
																	(u.onerror = function (e) {
																		return i.close(), r(u.error);
																	}),
																	(o.oncomplete = function () {
																		null == n
																			? i.close()
																			: (n.oncomplete = function () {
																					return i.close();
																			  });
																	});
															}),
															(a.onerror = function (e) {
																return r(a.error);
															});
													})
												)
											);
										case 2:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				e
			);
		})(),
		Jk = "/",
		Zk = "tensorflowjs_models",
		Qk = "info",
		$k = "model_topology",
		eN = "weight_specs",
		tN = "weight_data",
		nN = "model_metadata";
	function rN(e) {
		return {
			info: [Zk, e, Qk].join(Jk),
			topology: [Zk, e, $k].join(Jk),
			weightSpecs: [Zk, e, eN].join(Jk),
			weightData: [Zk, e, tN].join(Jk),
			modelMetadata: [Zk, e, nN].join(Jk),
		};
	}
	function aN(e) {
		for (var t = 0, n = Object.values(e); t < n.length; t++) {
			var r = n[t];
			window.localStorage.removeItem(r);
		}
	}
	function iN(e) {
		var t = e.split(Jk);
		if (t.length < 3) throw new Error("Invalid key format: " + e);
		return t.slice(1, t.length - 1).join(Jk);
	}
	function oN(e) {
		return e.startsWith(sN.URL_SCHEME) ? e.slice(sN.URL_SCHEME.length) : e;
	}
	var sN = (function () {
		function e(e) {
			if (!xv().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage)
				throw new Error("The current environment does not support local storage.");
			if (((this.LS = window.localStorage), null == e || !e))
				throw new Error("For local storage, modelPath must not be null, undefined or empty.");
			(this.modelPath = e), (this.keys = rN(this.modelPath));
		}
		var t = e.prototype;
		return (
			(t.save = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						var n, r, a, i;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if (!(t.modelTopology instanceof ArrayBuffer)) {
												e.next = 4;
												break;
											}
											throw new Error(
												"BrowserLocalStorage.save() does not support saving model topology in binary formats yet."
											);
										case 4:
											return (
												(n = JSON.stringify(t.modelTopology)),
												(r = JSON.stringify(t.weightSpecs)),
												(a = Lk(t)),
												(e.prev = 7),
												this.LS.setItem(this.keys.info, JSON.stringify(a)),
												this.LS.setItem(this.keys.topology, n),
												this.LS.setItem(this.keys.weightSpecs, r),
												this.LS.setItem(this.keys.weightData, Rk(t.weightData)),
												(i = {
													format: t.format,
													generatedBy: t.generatedBy,
													convertedBy: t.convertedBy,
													signature: null != t.signature ? t.signature : void 0,
													userDefinedMetadata:
														null != t.userDefinedMetadata ? t.userDefinedMetadata : void 0,
													modelInitializer:
														null != t.modelInitializer ? t.modelInitializer : void 0,
													trainingConfig:
														null != t.trainingConfig ? t.trainingConfig : void 0,
												}),
												this.LS.setItem(this.keys.modelMetadata, JSON.stringify(i)),
												e.abrupt("return", { modelArtifactsInfo: a })
											);
										case 17:
											throw (
												((e.prev = 17),
												(e.t0 = e.catch(7)),
												aN(this.keys),
												new Error(
													"Failed to save model '" +
														this.modelPath +
														"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" +
														a.modelTopologyBytes +
														", weightSpecsBytes=" +
														a.weightSpecsBytes +
														", weightDataBytes=" +
														a.weightDataBytes +
														"."
												))
											);
										case 21:
										case "end":
											return e.stop();
									}
							},
							e,
							this,
							[[7, 17]]
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(t.load = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						var t, n, r, a, i, o, s;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if (null != (t = JSON.parse(this.LS.getItem(this.keys.info)))) {
												e.next = 3;
												break;
											}
											throw new Error(
												"In local storage, there is no model with name '" + this.modelPath + "'"
											);
										case 3:
											if ("JSON" === t.modelTopologyType) {
												e.next = 5;
												break;
											}
											throw new Error(
												"BrowserLocalStorage does not support loading non-JSON model topology yet."
											);
										case 5:
											if (
												((n = {}),
												null != (r = JSON.parse(this.LS.getItem(this.keys.topology))))
											) {
												e.next = 9;
												break;
											}
											throw new Error(
												"In local storage, the topology of model '" +
													this.modelPath +
													"' is missing."
											);
										case 9:
											if (
												((n.modelTopology = r),
												null != (a = JSON.parse(this.LS.getItem(this.keys.weightSpecs))))
											) {
												e.next = 13;
												break;
											}
											throw new Error(
												"In local storage, the weight specs of model '" +
													this.modelPath +
													"' are missing."
											);
										case 13:
											if (
												((n.weightSpecs = a),
												null != (i = this.LS.getItem(this.keys.modelMetadata)) &&
													((o = JSON.parse(i)),
													(n.format = o.format),
													(n.generatedBy = o.generatedBy),
													(n.convertedBy = o.convertedBy),
													null != o.signature && (n.signature = o.signature),
													null != o.userDefinedMetadata &&
														(n.userDefinedMetadata = o.userDefinedMetadata),
													null != o.modelInitializer &&
														(n.modelInitializer = o.modelInitializer),
													null != o.trainingConfig && (n.trainingConfig = o.trainingConfig)),
												null != (s = this.LS.getItem(this.keys.weightData)))
											) {
												e.next = 19;
												break;
											}
											throw new Error(
												"In local storage, the binary weight values of model '" +
													this.modelPath +
													"' are missing."
											);
										case 19:
											return (n.weightData = Ak(s)), e.abrupt("return", n);
										case 21:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			e
		);
	})();
	sN.URL_SCHEME = "localstorage://";
	var uN = function (e) {
		return xv().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(sN.URL_SCHEME)
			? ((t = e.slice(sN.URL_SCHEME.length)), new sN(t))
			: null;
		var t;
	};
	Pk.registerSaveRouter(uN), Pk.registerLoadRouter(uN);
	var lN = (function () {
			function e() {
				Dg(xv().getBool("IS_BROWSER"), function () {
					return "Current environment is not a web browser";
				}),
					Dg("undefined" == typeof window || void 0 !== window.localStorage, function () {
						return "Current browser does not appear to support localStorage";
					}),
					(this.LS = window.localStorage);
			}
			var t = e.prototype;
			return (
				(t.listModels = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r, a, i, o;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												for (t = {}, n = Zk + Jk, r = Jk + Qk, a = 0; a < this.LS.length; ++a)
													(i = this.LS.key(a)).startsWith(n) &&
														i.endsWith(r) &&
														((o = iN(i)), (t[o] = JSON.parse(this.LS.getItem(i))));
												return e.abrupt("return", t);
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.removeModel = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (((t = oN(t)), (n = rN(t)), null != this.LS.getItem(n.info))) {
													e.next = 4;
													break;
												}
												throw new Error("Cannot find model at path '" + t + "'");
											case 4:
												return (
													(r = JSON.parse(this.LS.getItem(n.info))),
													aN(n),
													e.abrupt("return", r)
												);
											case 7:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				e
			);
		})(),
		cN = "://",
		pN = (function () {
			function e() {
				this.managers = {};
			}
			return (
				(e.getInstance = function () {
					return null == e.instance && (e.instance = new e()), e.instance;
				}),
				(e.registerManager = function (t, n) {
					Dg(null != t, function () {
						return "scheme must not be undefined or null.";
					}),
						t.endsWith(cN) && (t = t.slice(0, t.indexOf(cN))),
						Dg(t.length > 0, function () {
							return "scheme must not be an empty string.";
						});
					var r = e.getInstance();
					Dg(null == r.managers[t], function () {
						return "A model store manager is already registered for scheme '" + t + "'.";
					}),
						(r.managers[t] = n);
				}),
				(e.getManager = function (e) {
					var t = this.getInstance().managers[e];
					if (null == t) throw new Error("Cannot find model manager for scheme '" + e + "'");
					return t;
				}),
				(e.getSchemes = function () {
					return Object.keys(this.getInstance().managers);
				}),
				e
			);
		})();
	function hN(e) {
		if (-1 === e.indexOf(cN))
			throw new Error(
				"The url string provided does not contain a scheme. Supported schemes are: " + pN.getSchemes().join(",")
			);
		return { scheme: e.split(cN)[0], path: e.split(cN)[1] };
	}
	function fN(e, t, n) {
		return dN.apply(this, arguments);
	}
	function dN() {
		return (dN = fg(
			regeneratorRuntime.mark(function e(t, n, r) {
				var a, i, o, s, u, l, c, p, h;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (
									void 0 === r && (r = !1),
									Dg(t !== n, function () {
										return "Old path and new path are the same: '" + t + "'";
									}),
									Dg((a = Pk.getLoadHandlers(t)).length > 0, function () {
										return (
											"Copying failed because no load handler is found for source URL " + t + "."
										);
									}),
									Dg(a.length < 2, function () {
										return (
											"Copying failed because more than one (" +
											a.length +
											") load handlers for source URL " +
											t +
											"."
										);
									}),
									(i = a[0]),
									Dg((o = Pk.getSaveHandlers(n)).length > 0, function () {
										return (
											"Copying failed because no save handler is found for destination URL " +
											n +
											"."
										);
									}),
									Dg(o.length < 2, function () {
										return (
											"Copying failed because more than one (" +
											a.length +
											") save handlers for destination URL " +
											n +
											"."
										);
									}),
									(s = o[0]),
									(u = hN(t).scheme),
									(l = hN(t).path),
									(c = u === hN(t).scheme),
									(e.next = 15),
									i.load()
								);
							case 15:
								if (((p = e.sent), !r || !c)) {
									e.next = 19;
									break;
								}
								return (e.next = 19), pN.getManager(u).removeModel(l);
							case 19:
								return (e.next = 21), s.save(p);
							case 21:
								if (((h = e.sent), !r || c)) {
									e.next = 25;
									break;
								}
								return (e.next = 25), pN.getManager(u).removeModel(l);
							case 25:
								return e.abrupt("return", h.modelArtifactsInfo);
							case 26:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function mN() {
		return (mN = fg(
			regeneratorRuntime.mark(function e() {
				var t, n, r, a, i, o, s;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								(t = pN.getSchemes()), (n = {}), (r = Ig(t));
							case 3:
								if ((a = r()).done) {
									e.next = 11;
									break;
								}
								return (i = a.value), (e.next = 7), pN.getManager(i).listModels();
							case 7:
								for (s in (o = e.sent)) n[i + cN + s] = o[s];
							case 9:
								e.next = 3;
								break;
							case 11:
								return e.abrupt("return", n);
							case 12:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function gN() {
		return (gN = fg(
			regeneratorRuntime.mark(function e(t) {
				var n, r;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (
									(n = hN(t)),
									(r = pN.getManager(n.scheme)),
									e.abrupt("return", r.removeModel(n.path))
								);
							case 3:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function vN() {
		return (vN = fg(
			regeneratorRuntime.mark(function e(t, n) {
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return e.abrupt("return", fN(t, n, !1));
							case 2:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function yN() {
		return (yN = fg(
			regeneratorRuntime.mark(function e(t, n) {
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return e.abrupt("return", fN(t, n, !0));
							case 2:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var bN = (function () {
		function e() {}
		var t = e.prototype;
		return (
			(t.fetch = (function (e) {
				function t(t, n) {
					return e.apply(this, arguments);
				}
				return (
					(t.toString = function () {
						return e.toString();
					}),
					t
				);
			})(function (e, t) {
				return fetch(e, t);
			})),
			(t.now = function () {
				return performance.now();
			}),
			(t.encode = function (e, t) {
				if ("utf-8" !== t && "utf8" !== t)
					throw new Error("Browser's encoder only supports utf-8, but got " + t);
				return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e);
			}),
			(t.decode = function (e, t) {
				return new TextDecoder(t).decode(e);
			}),
			e
		);
	})();
	if (xv().get("IS_BROWSER")) {
		xv().setPlatform("browser", new bN());
		try {
			pN.registerManager(sN.URL_SCHEME, new lN());
		} catch (e) {}
		try {
			pN.registerManager(qk.URL_SCHEME, new Yk());
		} catch (e) {}
	}
	var xN,
		wN = (function () {
			function e() {
				(this.util = require("util")), (this.textEncoder = new this.util.TextEncoder());
			}
			var t = e.prototype;
			return (
				(t.fetch = function (e, t) {
					return null != xv().global.fetch
						? xv().global.fetch(e, t)
						: (null == xN && (xN = require("node-fetch")), xN(e, t));
				}),
				(t.now = function () {
					var e = process.hrtime();
					return 1e3 * e[0] + e[1] / 1e6;
				}),
				(t.encode = function (e, t) {
					if ("utf-8" !== t && "utf8" !== t)
						throw new Error("Node built-in encoder only supports utf-8, but got " + t);
					return this.textEncoder.encode(e);
				}),
				(t.decode = function (e, t) {
					return 0 === e.length ? "" : new this.util.TextDecoder(t).decode(e);
				}),
				e
			);
		})();
	function kN(e, t, n) {
		return void 0 === t && (t = "float32"), (t = t || "float32"), hv(e), new Mw(e, t, n);
	}
	xv().get("IS_NODE") && !xv().get("IS_BROWSER") && xv().setPlatform("node", new wN());
	var NN = yk({
			cast_: function (e, t) {
				var n = mk(e, "x", "cast");
				if (!Yg(t)) throw new Error("Failed to cast to unknown dtype " + t);
				if (("string" === t && "string" !== n.dtype) || ("string" !== t && "string" === n.dtype))
					throw new Error("Only strings can be casted to strings");
				var r = { x: n },
					a = { dtype: t };
				return ok.runKernel(qv, r, a);
			},
		}),
		IN = yk({
			clone_: function (e) {
				var t = { x: mk(e, "x", "clone", "string_or_numeric") };
				return ok.runKernel(zy, t);
			},
		});
	function SN(e, t) {
		void 0 === t && (t = !1), console.log(e.toString(t));
	}
	function TN(e) {
		return new Promise(function (e) {
			return setTimeout(e);
		}).then(e);
	}
	ak(), (zw = { buffer: kN, cast: NN, clone: IN, print: SN });
	var CN = (function () {
		function e(t) {
			if (!xv().getBool("IS_BROWSER"))
				throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
			t.startsWith(e.URL_SCHEME) && (t = t.slice(e.URL_SCHEME.length)),
				(null != t && 0 !== t.length) || (t = "model"),
				(this.modelJsonFileName = t + ".json"),
				(this.weightDataFileName = t + ".weights.bin");
		}
		return (
			(e.prototype.save = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						var n, r, a, i, o, s;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if ("undefined" != typeof document) {
												e.next = 2;
												break;
											}
											throw new Error(
												"Browser downloads are not supported in this environment since `document` is not present"
											);
										case 2:
											if (
												((n = window.URL.createObjectURL(
													new Blob([t.weightData], { type: "application/octet-stream" })
												)),
												!(t.modelTopology instanceof ArrayBuffer))
											) {
												e.next = 7;
												break;
											}
											throw new Error(
												"BrowserDownloads.save() does not support saving model topology in binary formats yet."
											);
										case 7:
											return (
												(r = [
													{ paths: ["./" + this.weightDataFileName], weights: t.weightSpecs },
												]),
												(a = Dk(t, r)),
												(i = window.URL.createObjectURL(
													new Blob([JSON.stringify(a)], { type: "application/json" })
												)),
												((o =
													null == this.modelJsonAnchor
														? document.createElement("a")
														: this.modelJsonAnchor).download = this.modelJsonFileName),
												(o.href = i),
												(e.next = 15),
												TN(function () {
													return o.dispatchEvent(new MouseEvent("click"));
												})
											);
										case 15:
											if (null == t.weightData) {
												e.next = 21;
												break;
											}
											return (
												((s =
													null == this.weightDataAnchor
														? document.createElement("a")
														: this.weightDataAnchor).download = this.weightDataFileName),
												(s.href = n),
												(e.next = 21),
												TN(function () {
													return s.dispatchEvent(new MouseEvent("click"));
												})
											);
										case 21:
											return e.abrupt("return", { modelArtifactsInfo: Lk(t) });
										case 22:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			e
		);
	})();
	CN.URL_SCHEME = "downloads://";
	var EN = (function () {
		function e(e) {
			if (null == e || e.length < 1)
				throw new Error("When calling browserFiles, at least 1 file is required, but received " + e);
			(this.jsonFile = e[0]), (this.weightsFiles = e.slice(1));
		}
		var t = e.prototype;
		return (
			(t.load = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						var t = this;
						return regeneratorRuntime.wrap(function (e) {
							for (;;)
								switch ((e.prev = e.next)) {
									case 0:
										return e.abrupt(
											"return",
											new Promise(function (e, n) {
												var r = new FileReader();
												(r.onload = function (r) {
													var a = JSON.parse(r.target.result),
														i = a.modelTopology;
													if (null != i)
														if (null != a.weightsManifest)
															if (0 !== t.weightsFiles.length) {
																var o = Ok(a, function (e) {
																	return t.loadWeights(e);
																});
																e(o);
															} else e({ modelTopology: i });
														else
															n(
																new Error(
																	"weightManifest field is missing from file " +
																		t.jsonFile.name
																)
															);
													else
														n(
															new Error(
																"modelTopology field is missing from file " +
																	t.jsonFile.name
															)
														);
												}),
													(r.onerror = function (e) {
														return n(
															"Failed to read model topology and weights manifest JSON from file '" +
																t.jsonFile.name +
																"'. BrowserFiles supports loading Keras-style tf.Model artifacts only."
														);
													}),
													r.readAsText(t.jsonFile);
											})
										);
									case 1:
									case "end":
										return e.stop();
								}
						}, e);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(t.loadWeights = function (e) {
				for (var t, n = this, r = [], a = [], i = Ig(e); !(t = i()).done; ) {
					var o = t.value;
					r.push.apply(r, o.weights), a.push.apply(a, o.paths);
				}
				var s = this.checkManifestAndWeightFiles(e),
					u = a.map(function (e) {
						return n.loadWeightsFile(e, s[e]);
					});
				return Promise.all(u).then(function (e) {
					return [r, _k(e)];
				});
			}),
			(t.loadWeightsFile = function (e, t) {
				return new Promise(function (n, r) {
					var a = new FileReader();
					(a.onload = function (e) {
						var t = e.target.result;
						n(t);
					}),
						(a.onerror = function (t) {
							return r("Failed to weights data from file of path '" + e + "'.");
						}),
						a.readAsArrayBuffer(t);
				});
			}),
			(t.checkManifestAndWeightFiles = function (e) {
				for (
					var t,
						n = this,
						r = [],
						a = this.weightsFiles.map(function (e) {
							return Fk(e.name);
						}),
						i = {},
						o = Ig(e);
					!(t = o()).done;

				)
					t.value.paths.forEach(function (e) {
						var t = Fk(e);
						if (-1 !== r.indexOf(t))
							throw new Error("Duplicate file basename found in weights manifest: '" + t + "'");
						if ((r.push(t), -1 === a.indexOf(t)))
							throw new Error("Weight file with basename '" + t + "' is not provided.");
						i[e] = n.weightsFiles[a.indexOf(t)];
					});
				if (r.length !== this.weightsFiles.length)
					throw new Error(
						"Mismatch in the number of files in weights manifest (" +
							r.length +
							") and the number of weight files provided (" +
							this.weightsFiles.length +
							")."
					);
				return i;
			}),
			e
		);
	})();
	function RN(e, t, n, r) {
		!(function (e) {
			Dg(null != e && Array.isArray(e) && e.length > 0, function () {
				return "promises must be a none empty array";
			});
		})(e),
			(function (e, t) {
				Dg(e >= 0 && e <= 1, function () {
					return "Progress fraction must be in range [0, 1], but got startFraction " + e;
				}),
					Dg(t >= 0 && t <= 1, function () {
						return "Progress fraction must be in range [0, 1], but got endFraction " + t;
					}),
					Dg(t >= e, function () {
						return (
							"startFraction must be no more than endFraction, but got startFraction " +
							e +
							" and endFraction " +
							t
						);
					});
			})((n = null == n ? 0 : n), (r = null == r ? 1 : r));
		var a = 0;
		return Promise.all(
			e.map(function (i) {
				return (
					i.then(function (i) {
						var o = n + (++a / e.length) * (r - n);
						return t(o), i;
					}),
					i
				);
			})
		);
	}
	function AN(e, t) {
		return _N.apply(this, arguments);
	}
	function _N() {
		return (_N = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r, a, i, o, s, u, l, c, p;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if (
									(null == n && (n = {}),
									(r = null == n.fetchFunc ? xv().platform.fetch : n.fetchFunc),
									(a = t.map(function (e) {
										return r(e, n.requestInit, { isBinary: !0 });
									})),
									(i = 0),
									(o = 0.5),
									null != n.onProgress)
								) {
									e.next = 11;
									break;
								}
								return (e.next = 8), Promise.all(a);
							case 8:
								(e.t0 = e.sent), (e.next = 14);
								break;
							case 11:
								return (e.next = 13), RN(a, n.onProgress, i, o);
							case 13:
								e.t0 = e.sent;
							case 14:
								if (
									((s = e.t0),
									(u = s.map(function (e) {
										return e.arrayBuffer();
									})),
									(l = 0.5),
									(c = 1),
									null != n.onProgress)
								) {
									e.next = 24;
									break;
								}
								return (e.next = 21), Promise.all(u);
							case 21:
								(e.t1 = e.sent), (e.next = 27);
								break;
							case 24:
								return (e.next = 26), RN(u, n.onProgress, l, c);
							case 26:
								e.t1 = e.sent;
							case 27:
								return (p = e.t1), e.abrupt("return", p);
							case 29:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function FN(e, t, n, r) {
		return DN.apply(this, arguments);
	}
	function DN() {
		return (DN = fg(
			regeneratorRuntime.mark(function e(t, n, r, a) {
				var i;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (
									void 0 === n && (n = ""),
									(i = ON(function (e) {
										return AN(e, { requestInit: a });
									})),
									e.abrupt("return", i(t, n, r))
								);
							case 4:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function ON(e) {
		return (function () {
			var t = fg(
				regeneratorRuntime.mark(function t(n, r, a) {
					var i, o, s, u, l, c, p, h, f, d;
					return regeneratorRuntime.wrap(function (t) {
						for (;;)
							switch ((t.prev = t.next)) {
								case 0:
									if (
										(void 0 === r && (r = ""),
										(i = n.map(function () {
											return !1;
										})),
										(o = {}),
										(s =
											null != a
												? a.map(function () {
														return !1;
												  })
												: []),
										(u = []),
										n.forEach(function (e, t) {
											var n = 0;
											e.weights.forEach(function (e) {
												var r = "quantization" in e ? e.quantization.dtype : e.dtype,
													l = kk[r] * zg(e.shape),
													c = function () {
														(i[t] = !0),
															null == o[t] && (o[t] = []),
															o[t].push({
																manifestEntry: e,
																groupOffset: n,
																sizeBytes: l,
															});
													};
												null != a
													? a.forEach(function (t, n) {
															t === e.name && (c(), (s[n] = !0));
													  })
													: c(),
													u.push(e.name),
													(n += l);
											});
										}),
										s.every(function (e) {
											return e;
										}))
									) {
										t.next = 9;
										break;
									}
									throw (
										((l = a.filter(function (e, t) {
											return !s[t];
										})),
										new Error(
											"Could not find weights in manifest with names: " +
												l.join(", ") +
												". \nManifest JSON has weights with names: " +
												u.join(", ") +
												"."
										))
									);
								case 9:
									return (
										(c = i.reduce(function (e, t, n) {
											return t && e.push(n), e;
										}, [])),
										(p = []),
										c.forEach(function (e) {
											n[e].paths.forEach(function (e) {
												var t = r + (r.endsWith("/") ? "" : "/") + e;
												p.push(t);
											});
										}),
										(t.next = 14),
										e(p)
									);
								case 14:
									return (
										(h = t.sent),
										(f = {}),
										(d = 0),
										c.forEach(function (e) {
											for (var t = n[e].paths.length, r = 0, a = 0; a < t; a++)
												r += h[d + a].byteLength;
											for (
												var i = new ArrayBuffer(r), s = new Uint8Array(i), u = 0, l = 0;
												l < t;
												l++
											) {
												var c = new Uint8Array(h[d + l]);
												s.set(c, u), (u += c.byteLength);
											}
											o[e].forEach(function (e) {
												var t = Sk(i.slice(e.groupOffset, e.groupOffset + e.sizeBytes), [
													e.manifestEntry,
												]);
												for (var n in t) f[n] = t[n];
											}),
												(d += t);
										}),
										t.abrupt("return", f)
									);
								case 19:
								case "end":
									return t.stop();
							}
					}, t);
				})
			);
			return function (e, n, r) {
				return t.apply(this, arguments);
			};
		})();
	}
	Pk.registerSaveRouter(function (e) {
		return xv().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(CN.URL_SCHEME)
			? (function (e) {
					return void 0 === e && (e = "model"), new CN(e);
			  })(e.slice(CN.URL_SCHEME.length))
			: null;
	});
	var MN = (function () {
		function e(e, t) {
			if (
				((this.DEFAULT_METHOD = "POST"),
				null == t && (t = {}),
				(this.weightPathPrefix = t.weightPathPrefix),
				(this.onProgress = t.onProgress),
				(this.weightUrlConverter = t.weightUrlConverter),
				null != t.fetchFunc
					? (Dg("function" == typeof t.fetchFunc, function () {
							return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
					  }),
					  (this.fetch = t.fetchFunc))
					: (this.fetch = xv().platform.fetch),
				Dg(null != e && e.length > 0, function () {
					return "URL path for http must not be null, undefined or empty.";
				}),
				Array.isArray(e) &&
					Dg(2 === e.length, function () {
						return "URL paths for http must have a length of 2, (actual length is " + e.length + ").";
					}),
				(this.path = e),
				null != t.requestInit && null != t.requestInit.body)
			)
				throw new Error("requestInit is expected to have no pre-existing body, but has one.");
			this.requestInit = t.requestInit || {};
		}
		var t = e.prototype;
		return (
			(t.save = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						var n, r, a, i;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if (!(t.modelTopology instanceof ArrayBuffer)) {
												e.next = 2;
												break;
											}
											throw new Error(
												"BrowserHTTPRequest.save() does not support saving model topology in binary formats yet."
											);
										case 2:
											return (
												((n = Object.assign(
													{ method: this.DEFAULT_METHOD },
													this.requestInit
												)).body = new FormData()),
												(r = [{ paths: ["./model.weights.bin"], weights: t.weightSpecs }]),
												(a = Dk(t, r)),
												n.body.append(
													"model.json",
													new Blob([JSON.stringify(a)], { type: "application/json" }),
													"model.json"
												),
												null != t.weightData &&
													n.body.append(
														"model.weights.bin",
														new Blob([t.weightData], { type: "application/octet-stream" }),
														"model.weights.bin"
													),
												(e.next = 10),
												this.fetch(this.path, n)
											);
										case 10:
											if (!(i = e.sent).ok) {
												e.next = 15;
												break;
											}
											return e.abrupt("return", { modelArtifactsInfo: Lk(t), responses: [i] });
										case 15:
											throw new Error(
												"BrowserHTTPRequest.save() failed due to HTTP response status " +
													i.status +
													"."
											);
										case 16:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(t.load = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						var t,
							n,
							r,
							a,
							i,
							o = this;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.fetch(this.path, this.requestInit);
										case 2:
											if ((t = e.sent).ok) {
												e.next = 5;
												break;
											}
											throw new Error(
												"Request to " +
													this.path +
													" failed with status code " +
													t.status +
													". Please verify this URL points to the model JSON of the model to load."
											);
										case 5:
											return (e.prev = 5), (e.next = 8), t.json();
										case 8:
											(n = e.sent), (e.next = 16);
											break;
										case 11:
											throw (
												((e.prev = 11),
												(e.t0 = e.catch(5)),
												(r = "Failed to parse model JSON of response from " + this.path + "."),
												this.path.endsWith(".pb")
													? (r +=
															" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.")
													: (r +=
															" Please make sure the server is serving valid JSON for this request."),
												new Error(r))
											);
										case 16:
											if (
												((a = n.modelTopology), (i = n.weightsManifest), null != a || null != i)
											) {
												e.next = 20;
												break;
											}
											throw new Error(
												"The JSON from HTTP path " +
													this.path +
													" contains neither model topology or manifest for weights."
											);
										case 20:
											return e.abrupt(
												"return",
												Ok(n, function (e) {
													return o.loadWeights(e);
												})
											);
										case 21:
										case "end":
											return e.stop();
									}
							},
							e,
							this,
							[[5, 11]]
						);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(t.loadWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						var n, r, a, i, o, s, u, l, c, p, h, f, d, m, g, v, y, b;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											for (
												n = Array.isArray(this.path) ? this.path[1] : this.path,
													r = LN(n),
													a = r[0],
													i = r[1],
													o = this.weightPathPrefix || a,
													s = [],
													u = Ig(t);
												!(l = u()).done;

											)
												(c = l.value), s.push.apply(s, c.weights);
											for (p = [], h = [], f = Ig(t); !(d = f()).done; )
												for (m = d.value, g = Ig(m.paths); !(v = g()).done; )
													(y = v.value),
														null != this.weightUrlConverter
															? h.push(this.weightUrlConverter(y))
															: p.push(o + y + i);
											if (!this.weightUrlConverter) {
												e.next = 15;
												break;
											}
											return (e.t0 = p.push), (e.t1 = p), (e.next = 13), Promise.all(h);
										case 13:
											(e.t2 = e.sent), e.t0.apply.call(e.t0, e.t1, e.t2);
										case 15:
											return (
												(e.next = 17),
												AN(p, {
													requestInit: this.requestInit,
													fetchFunc: this.fetch,
													onProgress: this.onProgress,
												})
											);
										case 17:
											return (b = e.sent), e.abrupt("return", [s, _k(b)]);
										case 19:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			e
		);
	})();
	function LN(e) {
		var t = e.lastIndexOf("/"),
			n = e.lastIndexOf("?");
		return [e.substring(0, t) + "/", n > t ? e.substring(n) : ""];
	}
	function zN(e) {
		return null != e.match(MN.URL_SCHEME_REGEX);
	}
	MN.URL_SCHEME_REGEX = /^https?:\/\//;
	var PN = function (e, t) {
		return ("undefined" != typeof fetch || (null != t && null != t.fetchFunc)) &&
			(Array.isArray(e)
				? e.every(function (e) {
						return zN(e);
				  })
				: zN(e))
			? BN(e, t)
			: null;
	};
	function BN(e, t) {
		return new MN(e, t);
	}
	function WN(e, t) {
		return BN(e, t);
	}
	Pk.registerSaveRouter(PN), Pk.registerLoadRouter(PN);
	var UN = (function () {
			function e(e) {
				this.modelArtifacts = e;
			}
			return (
				(e.prototype.load = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return e.abrupt("return", this.modelArtifacts);
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				e
			);
		})(),
		VN = (function () {
			function e(e) {
				this.saveHandler = e;
			}
			return (
				(e.prototype.save = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return e.abrupt("return", this.saveHandler(t));
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				e
			);
		})(),
		GN = {
			__proto__: null,
			browserFiles: function (e) {
				return new EN(e);
			},
			browserHTTPRequest: WN,
			concatenateArrayBuffers: _k,
			decodeWeights: Sk,
			encodeWeights: Nk,
			fromMemory: function (e, t, n, r) {
				if (1 === arguments.length) {
					var a = null != e.modelTopology || null != e.weightSpecs;
					return a
						? new UN(e)
						: (console.warn(
								"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."
						  ),
						  new UN({ modelTopology: e }));
				}
				return (
					console.warn(
						"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."
					),
					new UN({ modelTopology: e, weightSpecs: t, weightData: n, trainingConfig: r })
				);
			},
			getLoadHandlers: Wk,
			getModelArtifactsForJSON: Ok,
			getModelArtifactsInfoForJSON: Lk,
			getSaveHandlers: Bk,
			http: BN,
			isHTTPScheme: zN,
			loadWeights: FN,
			registerLoadRouter: function (e) {
				return Pk.registerLoadRouter(e);
			},
			registerSaveRouter: function (e) {
				return Pk.registerSaveRouter(e);
			},
			weightsLoaderFactory: ON,
			withSaveHandler: function (e) {
				return new VN(e);
			},
			copyModel: function (e, t) {
				return vN.apply(this, arguments);
			},
			listModels: function () {
				return mN.apply(this, arguments);
			},
			moveModel: function (e, t) {
				return yN.apply(this, arguments);
			},
			removeModel: function (e) {
				return gN.apply(this, arguments);
			},
		},
		jN = yk({
			matMul_: function (e, t, n, r) {
				void 0 === n && (n = !1), void 0 === r && (r = !1);
				var a = mk(e, "a", "matMul"),
					i = mk(t, "b", "matMul"),
					o = Yw(a, i),
					s = { a: (a = o[0]), b: (i = o[1]) },
					u = { transposeA: n, transposeB: r };
				return ok.runKernel(Uv, s, u);
			},
		}),
		HN = yk({
			oneHot_: function (e, t, n, r) {
				if ((void 0 === n && (n = 1), void 0 === r && (r = 0), t < 2))
					throw new Error("Error in oneHot: depth must be >=2, but it is " + t);
				var a = { indices: mk(e, "indices", "oneHot", "int32") },
					i = { depth: t, onValue: n, offValue: r };
				return ok.runKernel(wb, a, i);
			},
		}),
		qN = yk({
			transpose_: function (e, t) {
				var n = mk(e, "x", "transpose");
				if (
					(null == t &&
						(t = n.shape
							.map(function (e, t) {
								return t;
							})
							.reverse()),
					Dg(n.rank === t.length, function () {
						return "Error in transpose: rank of input " + n.rank + " must match length of perm " + t + ".";
					}),
					t.forEach(function (e) {
						Dg(e >= 0 && e < n.rank, function () {
							return "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got " + t;
						});
					}),
					n.rank <= 1)
				)
					return n.clone();
				var r = { x: n },
					a = { perm: t };
				return ok.runKernel(vx, r, a);
			},
		}),
		KN = {
			__proto__: null,
			confusionMatrix: yk({
				confusionMatrix_: function (e, t, n) {
					var r = mk(e, "labels", "confusionMatrix"),
						a = mk(t, "predictions", "confusionMatrix");
					Dg(null == n || (n > 0 && Number.isInteger(n)), function () {
						return "If provided, numClasses must be a positive integer, but got " + n;
					}),
						Dg(1 === r.rank, function () {
							return "Expected the rank of labels to be 1, but got " + r.rank;
						}),
						Dg(1 === a.rank, function () {
							return "Expected the rank of predictions to be 1, but got " + a.rank;
						}),
						Dg(r.shape[0] === a.shape[0], function () {
							return (
								"Mismatch in the number of examples: " +
								r.shape[0] +
								" vs. " +
								a.shape[0] +
								". Labels and predictions should have the same number of elements."
							);
						}),
						Dg(n > 0 && Number.isInteger(n), function () {
							return "numClasses is required to be a positive integer, but got " + n;
						});
					var i = HN(NN(r, "int32"), n),
						o = HN(NN(a, "int32"), n),
						s = qN(i),
						u = jN(s, o);
					return NN(u, "int32");
				},
			}),
		};
	function XN(e, t) {
		for (var n = e.length, r = [], a = 0; a < n; a++) {
			var i = n - 1 - a,
				o = e[i] || 1;
			(t[t.length - 1 - a] || 1) > 1 && 1 === o && r.unshift(i);
		}
		return r;
	}
	function YN(e, t) {
		for (var n = [], r = 0; r < t.length; r++) {
			var a = e[e.length - r - 1],
				i = t.length - r - 1,
				o = t[i];
			(null == a || (1 === a && o > 1)) && n.unshift(i);
		}
		return n;
	}
	function JN(e, t) {
		for (var n = [], r = Math.max(e.length, t.length), a = 0; a < r; a++) {
			var i = e[e.length - a - 1];
			null == i && (i = 1);
			var o = t[t.length - a - 1];
			if ((null == o && (o = 1), 1 === i)) n.unshift(o);
			else if (1 === o) n.unshift(i);
			else {
				if (i !== o)
					throw Error("Operands could not be broadcast together with shapes " + e + " and " + t + ".");
				n.unshift(i);
			}
		}
		return n;
	}
	var ZN,
		QN = { __proto__: null, getBroadcastDims: XN, getReductionAxes: YN, assertAndGetBroadcastShape: JN };
	function $N(e, t, n) {
		if ((Mg(e), null != t && 3 !== t.length)) throw new Error("tensor3d() requires shape to have three numbers");
		var r = hk(e, n);
		if (3 !== r.length && 1 !== r.length)
			throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
		if (1 === r.length && null == t)
			throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
		return xk(e, t, r, n);
	}
	function eI(e, t) {
		if ((void 0 === t && (t = 3), t > 4))
			throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
		if (null == e) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
		var n = !1,
			r = !1,
			a = !1,
			i = !1,
			o = !1,
			s = !1;
		if (e.data instanceof Uint8Array) n = !0;
		else if ("undefined" != typeof ImageData && e instanceof ImageData) r = !0;
		else if ("undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement) a = !0;
		else if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement) i = !0;
		else if (null != e.getContext) o = !0;
		else {
			if (!("undefined" != typeof ImageBitmap && e instanceof ImageBitmap))
				throw new Error(
					"pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " +
						e.constructor.name
				);
			s = !0;
		}
		if (a && a && e.readyState < 2)
			throw new Error(
				"The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element."
			);
		if (null != _x(Nx, ok.backendName)) {
			var u = { pixels: e },
				l = { numChannels: t };
			return ok.runKernel(Nx, u, l);
		}
		var c,
			p,
			h = a ? [e.videoWidth, e.videoHeight] : [e.width, e.height],
			f = h[0],
			d = h[1];
		if (o) c = e.getContext("2d").getImageData(0, 0, f, d).data;
		else if (r || n) c = e.data;
		else if (i || a || s) {
			if (null == ZN)
				if ("undefined" == typeof document) {
					if (
						"undefined" == typeof OffscreenCanvas ||
						"undefined" == typeof OffscreenCanvasRenderingContext2D
					)
						throw new Error(
							"Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported."
						);
					ZN = new OffscreenCanvas(1, 1).getContext("2d");
				} else ZN = document.createElement("canvas").getContext("2d");
			(ZN.canvas.width = f),
				(ZN.canvas.height = d),
				ZN.drawImage(e, 0, 0, f, d),
				(c = ZN.getImageData(0, 0, f, d).data);
		}
		if (4 === t) p = new Int32Array(c);
		else {
			var m = f * d;
			p = new Int32Array(m * t);
			for (var g = 0; g < m; g++) for (var v = 0; v < t; ++v) p[g * t + v] = c[4 * g + v];
		}
		return $N(p, [d, f, t], "int32");
	}
	function tI(e) {
		return (
			"undefined" != typeof window &&
			"undefined" != typeof ImageBitmap &&
			window.hasOwnProperty("createImageBitmap") &&
			!(e instanceof ImageBitmap) &&
			(function (e) {
				return null != e && 0 !== e.width && 0 !== e.height;
			})(e) &&
			!(function (e) {
				return null != e && e.data instanceof Uint8Array;
			})(e)
		);
	}
	function nI() {
		return (nI = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r, a;
				return regeneratorRuntime.wrap(
					function (e) {
						for (;;)
							switch ((e.prev = e.next)) {
								case 0:
									if (
										(void 0 === n && (n = 3),
										(r = null),
										!xv().getBool("WRAP_TO_IMAGEBITMAP") || !tI(t))
									) {
										e.next = 15;
										break;
									}
									return (
										(e.prev = 3), (e.next = 6), createImageBitmap(t, { premultiplyAlpha: "none" })
									);
								case 6:
									(a = e.sent), (e.next = 12);
									break;
								case 9:
									(e.prev = 9), (e.t0 = e.catch(3)), (a = null);
								case 12:
									(r = null != a && a.width === t.width && a.height === t.height ? a : t),
										(e.next = 16);
									break;
								case 15:
									r = t;
								case 16:
									return e.abrupt("return", eI(r, n));
								case 17:
								case "end":
									return e.stop();
							}
					},
					e,
					null,
					[[3, 9]]
				);
			})
		)).apply(this, arguments);
	}
	function rI() {
		return (rI = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r, a, i, o, s, u, l, c, p, h, f, d, m, g, v, y;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if (
									((r = mk(t, "img", "toPixels")),
									t instanceof Pw || ((r = NN((a = r), "int32")), a.dispose()),
									2 === r.rank || 3 === r.rank)
								) {
									e.next = 4;
									break;
								}
								throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + r.rank + ".");
							case 4:
								if (
									((i = r.shape.slice(0, 2)),
									(o = i[0]),
									(s = i[1]),
									!((u = 2 === r.rank ? 1 : r.shape[2]) > 4 || 2 === u))
								) {
									e.next = 8;
									break;
								}
								throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + u);
							case 8:
								if ("float32" === r.dtype || "int32" === r.dtype) {
									e.next = 10;
									break;
								}
								throw new Error(
									"Unsupported type for toPixels: " +
										r.dtype +
										". Please use float32 or int32 tensors."
								);
							case 10:
								return (e.next = 12), r.data();
							case 12:
								(l = e.sent),
									(c = "float32" === r.dtype ? 255 : 1),
									(p = new Uint8ClampedArray(s * o * 4)),
									(h = 0);
							case 16:
								if (!(h < o * s)) {
									e.next = 41;
									break;
								}
								(f = [0, 0, 0, 255]), (d = 0);
							case 19:
								if (!(d < u)) {
									e.next = 33;
									break;
								}
								if (((m = l[h * u + d]), "float32" !== r.dtype)) {
									e.next = 26;
									break;
								}
								if (!(m < 0 || m > 1)) {
									e.next = 24;
									break;
								}
								throw new Error(
									"Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered " +
										m +
										"."
								);
							case 24:
								e.next = 29;
								break;
							case 26:
								if ("int32" !== r.dtype) {
									e.next = 29;
									break;
								}
								if (!(m < 0 || m > 255)) {
									e.next = 29;
									break;
								}
								throw new Error(
									"Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered " +
										m +
										"."
								);
							case 29:
								1 === u ? ((f[0] = m * c), (f[1] = m * c), (f[2] = m * c)) : (f[d] = m * c);
							case 30:
								d++, (e.next = 19);
								break;
							case 33:
								(p[0 + (g = 4 * h)] = Math.round(f[0])),
									(p[g + 1] = Math.round(f[1])),
									(p[g + 2] = Math.round(f[2])),
									(p[g + 3] = Math.round(f[3]));
							case 38:
								++h, (e.next = 16);
								break;
							case 41:
								return (
									null != n &&
										((n.width = s),
										(n.height = o),
										(v = n.getContext("2d")),
										(y = new ImageData(p, s, o)),
										v.putImageData(y, 0, 0)),
									r !== t && r.dispose(),
									e.abrupt("return", p)
								);
							case 44:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var aI = yk({ fromPixels_: eI }),
		iI = {
			__proto__: null,
			fromPixelsAsync: function (e, t) {
				return nI.apply(this, arguments);
			},
			toPixels: function (e, t) {
				return rI.apply(this, arguments);
			},
			fromPixels: aI,
		};
	function oI(e, t) {
		var n = e.shape.length,
			r = t.shape.length;
		if (n < 1)
			throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + n + ".");
		if (r < 1)
			throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + r + ".");
		if ("int32" !== t.dtype)
			throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + t.dtype + ".");
		if (t.shape[r - 1] > n)
			throw new Error(
				"index innermost dimension length must be <= tensor rank; saw: " + t.shape[r - 1] + " vs. " + n
			);
		if (0 === zg(e.shape))
			throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + e.shape + ".");
		for (var a = t.shape, i = a[a.length - 1], o = 1, s = 0; s < a.length - 1; ++s) o *= a[s];
		var u = e.shape,
			l = a.slice();
		l.pop();
		for (var c = 1, p = i; p < n; ++p) (c *= u[p]), l.push(u[p]);
		var h = []
			.concat(
				ov(e.shape).map(function (e) {
					return e / c;
				}),
				[1]
			)
			.slice(0, i);
		return [l, o, c, h];
	}
	var sI = { __proto__: null, prepareAndValidate: oI };
	function uI(e, t, n) {
		var r = t.rank > 1 ? t.shape[t.rank - 1] : 1,
			a = t.rank > 1 ? t.rank - 1 : 1,
			i =
				"Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " +
				n.shape +
				", indices.shape: " +
				t.shape +
				", shape: " +
				e +
				", sliceDim: " +
				r +
				", and batchDim: " +
				a +
				".";
		if (n.rank < a) throw new Error(i + " update.rank < " + a + ". ");
		if (e.length < r + (n.rank - a)) throw new Error(i + " Output shape length < " + (r + (n.rank - a)));
		if (n.rank !== a + e.length - r) throw new Error(i + " update.rank != " + (a + e.length - r));
		for (var o = 0; o < a; ++o)
			if (n.shape[o] !== t.shape[o])
				throw new Error(
					i +
						" updates.shape[" +
						o +
						"] (" +
						n.shape[o] +
						") != indices.shape[" +
						o +
						"] (" +
						t.shape[o] +
						")."
				);
		for (var s = 0; s < n.rank - a; ++s)
			if (n.shape[s + a] !== e[s + r])
				throw new Error(
					i +
						" updates.shape[" +
						(s + a) +
						"] (" +
						n.shape[s + a] +
						") != shape[" +
						(s + a) +
						"] (" +
						e[s + a] +
						")"
				);
	}
	function lI(e, t, n) {
		if (t.rank < 1)
			throw new Error(
				"tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + t.rank + "."
			);
		if (e.rank < 1)
			throw new Error(
				"tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + e.rank + "."
			);
		if ("int32" !== t.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + t.dtype);
		if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n);
		if (0 === n.length) {
			if (0 === t.size) throw new Error("Indices specified for empty output. indices shape: " + t.shape);
			if (0 === e.size) throw new Error("Updates specified for empty output. updates shape: " + e.shape);
		}
		uI(n, t, e);
	}
	function cI(e, t, n) {
		for (var r = t.shape.length, a = r > 1 ? t.shape[r - 1] : 1, i = n.length, o = 1, s = a; s < i; ++s) o *= n[s];
		var u = a < 1 ? 1 : a;
		return {
			sliceRank: a,
			numUpdates: zg(t.shape) / u,
			sliceSize: o,
			strides: [].concat(ov(n.slice(0, a)), [1]),
			outputSize: zg(n),
		};
	}
	var pI = { __proto__: null, validateUpdateShape: uI, validateInput: lI, calculateShapes: cI };
	function hI(e, t, n) {
		var r = e.shape.length;
		Dg(r === t.length, function () {
			return "Error in slice" + r + "D: Length of begin " + t + " must match the rank of the array (" + r + ").";
		}),
			Dg(r === n.length, function () {
				return (
					"Error in slice" + r + "D: Length of size " + n + " must match the rank of the array (" + r + ")."
				);
			});
		for (
			var a = function (a) {
					Dg(t[a] + n[a] <= e.shape[a], function () {
						return (
							"Error in slice" +
							r +
							"D: begin[" +
							a +
							"] + size[" +
							a +
							"] (" +
							(t[a] + n[a]) +
							") would overflow input.shape[" +
							a +
							"] (" +
							e.shape[a] +
							")"
						);
					});
				},
				i = 0;
			i < r;
			++i
		)
			a(i);
	}
	function fI(e, t, n) {
		for (var r = [], a = 0; a < e.length; a++) r[a] = Math.ceil((t[a] - e[a]) / n[a]);
		return r;
	}
	function dI(e, t, n, r) {
		for (var a = [].concat(e), i = a.length; i < r.length; i++) a.push(1);
		for (var o = 0; o < n; o++) 0 === o ? (a[t] = 1) : (a.splice(t, 0, 1), a.pop());
		return a;
	}
	function mI(e, t, n) {
		return n <= e ? n : n - (t - 1);
	}
	function gI(e, t) {
		for (var n = [], r = 0; r < e; r++) n.push(t + r);
		return n;
	}
	function vI(e, t, n, r, a) {
		for (var i = [].concat(a), o = gI(n, t), s = 0; s < i.length; s++)
			if (o.indexOf(s) > -1) i[s] = 0;
			else {
				var u = mI(t, n, s),
					l = r[u];
				e & (1 << u) && (l = 0), (i[s] = l);
			}
		return i;
	}
	function yI(e, t, n, r, a) {
		for (var i = [].concat(a), o = gI(n, t), s = 0; s < i.length; s++)
			if (o.indexOf(s) > -1) i[s] = Number.MAX_SAFE_INTEGER;
			else {
				var u = mI(t, n, s),
					l = r[u];
				e & (1 << u) && (l = Number.MAX_SAFE_INTEGER), (i[s] = l);
			}
		for (var c = 0; c < i.length; c++) {
			var p = a[c];
			i[c] < 0 && (i[c] += p), (i[c] = Rg(0, i[c], a[c]));
		}
		return i;
	}
	function bI(e, t, n) {
		var r = e[t];
		return (n & (1 << t) || null == r) && (r = 1), r;
	}
	function xI(e, t, n, r, a, i) {
		var o = t[a],
			s = n[a] || 1;
		(e & (1 << a) || i & (1 << a) || null == o) && (o = s > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
		var u = r[a];
		return o < 0 && (o += u), Rg(0, o, u - 1);
	}
	function wI(e, t, n, r, a, i) {
		var o = t[a],
			s = n[a] || 1;
		(e & (1 << a) || i & (1 << a) || null == o) && (o = s > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
		var u = r[a];
		return o < 0 && (o += u), s > 0 ? Rg(0, o, u) : Rg(-1, o, u - 1);
	}
	function kI(e, t, n) {
		for (var r = n.length, a = 0; a < n.length; a++)
			if (n[a] > 1) {
				r = a;
				break;
			}
		for (var i = r + 1; i < n.length; i++) if (t[i] > 0 || n[i] !== e[i]) return !1;
		return !0;
	}
	function NI(e, t) {
		for (var n = e.length > 0 ? e[e.length - 1] : 1, r = 0; r < e.length - 1; r++) n += e[r] * t[r];
		return n;
	}
	function II(e, t, n) {
		var r,
			a,
			i = e.shape.length;
		return (
			(r =
				"number" == typeof t
					? [t].concat(new Array(i - 1).fill(0))
					: t.length < i
					? t.concat(new Array(i - t.length).fill(0))
					: t.slice()).forEach(function (e) {
				Dg(-1 !== e, function () {
					return "slice() does not support negative begin indexing.";
				});
			}),
			(a = (a =
				null == n
					? new Array(i).fill(-1)
					: "number" == typeof n
					? [n].concat(new Array(i - 1).fill(-1))
					: n.length < i
					? n.concat(new Array(i - n.length).fill(-1))
					: n).map(function (t, n) {
				return t >= 0
					? t
					: (Dg(-1 === t, function () {
							return (
								"Negative size values should be exactly -1 but got " +
								t +
								" for the slice() size at index " +
								n +
								"."
							);
					  }),
					  e.shape[n] - r[n]);
			})),
			[r, a]
		);
	}
	function SI(e, t, n, r, a, i, o, s, u) {
		var l;
		if ((null == r ? (l = new Array(t.length)).fill(1) : (l = r), null != o && 0 != (o & (o - 1))))
			throw new Error("Multiple ellipses in slice is not allowed.");
		for (
			var c = !1,
				p = {
					dims: l.length,
					numAddAxisAfterEllipsis: 0,
					begin: t.slice(),
					end: n.slice(),
					strides: l.slice(),
					beginMask: a,
					endMask: i,
					ellipsisMask: o,
					newAxisMask: s,
					shrinkAxisMask: u,
				},
				h = 0;
			h < p.dims;
			h++
		)
			c && 0 != ((1 << h) & s) && p.numAddAxisAfterEllipsis++, (1 << h) & o && (c = !0);
		c || ((p.ellipsisMask |= 1 << p.dims), p.dims++);
		var f = { dims: e.length, beginMask: 0, endMask: 0, beginValid: !1, endValid: !1 };
		!(function (e, t) {
			(t.beginMask = 0), (t.endMask = 0), (t.shrinkAxisMask = 0);
			var n = 0;
			(t.beginValid = null != e.begin),
				(t.endValid = null != e.end),
				(t.begin = new Array(t.dims)),
				(t.end = new Array(t.dims)),
				(t.strides = new Array(t.dims)),
				(t.finalShapeGatherIndices = []),
				(t.finalShapeGatherIndicesSparse = []),
				(t.inputShapeGatherIndicesSparse = new Array(t.dims));
			for (var r = 0; r < e.dims; r++)
				if ((1 << r) & e.ellipsisMask)
					for (var a = Math.min(t.dims - (e.dims - r) + 1 + e.numAddAxisAfterEllipsis, t.dims); n < a; n++)
						(t.begin[n] = 0),
							(t.end[n] = 0),
							(t.strides[n] = 1),
							(t.beginMask |= 1 << n),
							(t.endMask |= 1 << n),
							t.finalShapeGatherIndices.push(n),
							t.finalShapeGatherIndicesSparse.push(-1),
							(t.inputShapeGatherIndicesSparse[n] = r);
				else if ((1 << r) & e.newAxisMask)
					t.finalShapeGatherIndices.push(-2), t.finalShapeGatherIndicesSparse.push(-1);
				else {
					if (n === t.begin.length)
						throw Error(
							"Index out of range using input dim " +
								n +
								"; input has only " +
								t.dims +
								" dims, " +
								t.begin.length +
								"."
						);
					null != e.begin && (t.begin[n] = e.begin[r]),
						null != e.end && (t.end[n] = e.end[r]),
						(t.strides[n] = e.strides[r]),
						e.beginMask & (1 << r) && (t.beginMask |= 1 << n),
						e.endMask & (1 << r) && (t.endMask |= 1 << n),
						e.shrinkAxisMask & (1 << r)
							? (t.finalShapeGatherIndices.push(-1),
							  t.finalShapeGatherIndicesSparse.push(-1),
							  (t.shrinkAxisMask |= 1 << n))
							: (t.finalShapeGatherIndices.push(n), t.finalShapeGatherIndicesSparse.push(r)),
						(t.inputShapeGatherIndicesSparse[n] = r),
						n++;
				}
		})(p, f);
		for (var d = !0, m = !0, g = !0, v = [], y = [], b = 0; b < e.length; ++b) {
			if (0 === f.strides[b]) throw Error("strides[" + b + "] must be non-zero");
			var x = !!(f.shrinkAxisMask & (1 << b)),
				w = e[b];
			if (-1 !== w) {
				var k = [f.beginMask & (1 << b), f.endMask & (1 << b)],
					N = [f.strides[b] > 0 ? 0 : -1, f.strides[b] > 0 ? w : w - 1];
				if (x && f.strides[b] <= 0) throw Error("only stride 1 allowed on non-range indexing.");
				g = g && 1 === f.strides[b];
				var I = !!(f.beginMask & (1 << b) && f.endMask & (1 << b));
				if (f.beginValid && f.endValid) {
					if (x) {
						var S = f.begin[b] < 0 ? w + f.begin[b] : f.begin[b];
						if (((f.begin[b] = S), (f.end[b] = f.begin[b] + 1), S < 0 || S >= w))
							throw Error("slice index " + f.begin[b] + " of dimension " + b + " out of bounds.");
					} else
						(f.begin[b] = TI(f.begin[b], 0, f.strides[b], w, k, N)),
							(f.end[b] = TI(f.end[b], 1, f.strides[b], w, k, N));
					var T = 1 === f.strides[b] && 0 === f.begin[b] && f.end[b] === w;
					(d = d && T), (m = m && ((0 === b && 1 === f.strides[b]) || T));
				} else (d = d && 1 === f.strides[b] && I), (m = m && ((0 === b && 1 === f.strides[b]) || I));
				var C = void 0,
					E = !1;
				if (
					(f.beginValid && f.endValid
						? ((C = f.end[b] - f.begin[b]), (E = !0))
						: x
						? ((C = 1), (E = !0))
						: I && w >= 0 && ((C = f.strides[b] < 0 ? -w : w), (E = !0)),
					E)
				) {
					var R;
					(R =
						0 === C || C < 0 != f.strides[b] < 0
							? 0
							: Math.trunc(C / f.strides[b]) + (C % f.strides[b] != 0 ? 1 : 0)),
						v.push(R);
				} else v.push(-1);
			} else v.push(x ? 1 : -1);
		}
		for (var A = 0; A < f.finalShapeGatherIndices.length; ++A) {
			var _ = f.finalShapeGatherIndices[A];
			_ >= 0 ? y.push(v[_]) : -2 === _ && y.push(1);
		}
		return {
			finalShapeSparse: y.filter(function (e, t) {
				return -2 !== f.finalShapeGatherIndices[t];
			}),
			finalShape: y,
			isIdentity: d,
			sliceDim0: m,
			isSimpleSlice: g,
			begin: f.begin,
			end: f.end,
			strides: f.strides,
		};
	}
	function TI(e, t, n, r, a, i) {
		if (a[t]) return n > 0 ? i[t] : i[(t + 1) & 1];
		var o = e < 0 ? r + e : e;
		return o < i[0] ? i[0] : o > i[1] ? i[1] : o;
	}
	var CI = {
			__proto__: null,
			assertParamsValid: hI,
			maskToAxes: function (e) {
				for (var t = [], n = 0; e > 0; ) 1 & e && t.push(n), (e /= 2), n++;
				return t;
			},
			computeOutShape: fI,
			stridesWithElidedDims: dI,
			getNormalizedAxes: function (e, t, n, r, a, i, o, s, u) {
				var l = e.length,
					c = new Array(l),
					p = new Array(l),
					h = new Array(l);
				if (t.length && n > 0) {
					var f = t[0],
						d = n + 1;
					(c = vI(o, f, d, r, e)), (p = yI(s, f, d, a, e)), (h = dI(i, f, d, e));
				} else
					for (var m = 0; m < l; m++)
						(c[m] = xI(o, r, i, e, m, u)), (p[m] = wI(s, a, i, e, m, u)), (h[m] = bI(i, m, u));
				return { begin: c, end: p, strides: h };
			},
			startIndicesWithElidedDims: vI,
			stopIndicesWithElidedDims: yI,
			stridesForAxis: bI,
			startForAxis: xI,
			stopForAxis: wI,
			isSliceContinous: kI,
			computeFlatOffset: NI,
			parseSliceParams: II,
			sliceInfo: SI,
		},
		EI = (function () {
			function e() {}
			return (
				(e.prototype.getClassName = function () {
					return this.constructor.className;
				}),
				(e.fromConfig = function (e, t) {
					return new e(t);
				}),
				e
			);
		})(),
		RI = (function () {
			function e() {
				this.classNameMap = {};
			}
			return (
				(e.getMap = function () {
					return null == e.instance && (e.instance = new e()), e.instance;
				}),
				(e.register = function (t) {
					e.getMap().classNameMap[t.className] = [t, t.fromConfig];
				}),
				e
			);
		})();
	function AI(e) {
		Dg(null != e.className, function () {
			return "Class being registered does not have the static className property defined.";
		}),
			Dg("string" == typeof e.className, function () {
				return "className is required to be a string, but got type " + typeof e.className;
			}),
			Dg(e.className.length > 0, function () {
				return "Class being registered has an empty-string as its className, which is disallowed.";
			}),
			RI.register(e);
	}
	var _I = { __proto__: null, Serializable: EI, SerializationMap: RI, registerClass: AI };
	function FI() {
		return 32 === ok.backend.floatPrecision() ? 0.001 : 0.1;
	}
	function DI(e, t, n) {
		var r = !0;
		if (((Zg(e) || Zg(t)) && (r = !1), Zg(e) && Zg(t) && (r = !0), r)) {
			var a = e.constructor.name,
				i = t.constructor.name;
			if (a !== i) throw new Error("Arrays are of different type. Actual: " + a + ". Expected: " + i);
		}
		if (Array.isArray(e) && Array.isArray(t)) {
			var o = hk(e),
				s = hk(t);
			if (!Pg(o, s)) throw new Error("Arrays have different shapes. Actual: [" + o + "]. Expected: [" + s + "]");
		}
		var u = Zg(e) ? e : Lg(e),
			l = Zg(t) ? t : Lg(t);
		if (u.length !== l.length)
			throw new Error(
				"Arrays have different lengths actual: " +
					u.length +
					" vs expected: " +
					l.length +
					".\nActual:   " +
					u +
					".\nExpected: " +
					l +
					"."
			);
		for (var c = 0; c < l.length; ++c) {
			var p = u[c],
				h = l[c];
			if (!n(p, h))
				throw new Error(
					"Arrays differ: actual[" +
						c +
						"] = " +
						p +
						", expected[" +
						c +
						"] = " +
						h +
						".\nActual:   " +
						u +
						".\nExpected: " +
						l +
						"."
				);
		}
	}
	function OI(e, t, n) {
		return (!isFinite(e) && !isFinite(t)) || !(isNaN(e) || isNaN(t) || Math.abs(e - t) > n);
	}
	var MI = {
			__proto__: null,
			TEST_EPSILON_FLOAT16: 0.1,
			expectArraysClose: function (e, t, n) {
				return (
					null == n && (n = FI()),
					DI(e, t, function (e, t) {
						return OI(e, t, n);
					})
				);
			},
			testEpsilon: FI,
			expectPromiseToFail: function (e, t) {
				e().then(
					function () {
						return t.fail();
					},
					function () {
						return t();
					}
				);
			},
			expectArraysEqual: function (e, t) {
				var n = "string" == typeof t || "number" == typeof t || "boolean" == typeof t ? [t] : t;
				return ev(e) || ev(e[0]) || ev(t) || ev(t[0])
					? DI(e, n, function (e, t) {
							return e == t;
					  })
					: DI(e, t, function (e, t) {
							return OI(e, t, 0);
					  });
			},
			expectNumbersClose: function (e, t, n) {
				if ((null == n && (n = FI()), !OI(e, t, n)))
					throw new Error("Numbers differ: actual === " + e + ", expected === " + t);
			},
			expectValuesInRange: function (e, t, n) {
				for (var r = 0; r < e.length; r++)
					if (e[r] < t || e[r] > n)
						throw new Error("Value out of range:" + e[r] + " low: " + t + ", high: " + n);
			},
			expectArrayBuffersEqual: function (e, t) {
				var n = new Float32Array(e),
					r = new Float32Array(t);
				if (n.length !== r.length)
					throw new Error("Expected ArrayBuffer to be of length " + r.length + ", but it was " + n.length);
				for (var a = 0; a < r.length; a++)
					if (n[a] !== r[a])
						throw new Error(
							"Expected ArrayBuffer value at " + a + " to be " + r[a] + " but got " + n[a] + " instead"
						);
			},
			encodeStrings: function e(t) {
				for (var n = 0; n < t.length; n++) {
					var r = t[n];
					Array.isArray(r) ? e(r) : (t[n] = Sw(r));
				}
				return t;
			},
		},
		LI = "3.15.0";
	function zI() {
		return ok;
	}
	function PI() {
		return ok.memory();
	}
	function BI(e, t) {
		return ok.tidy(e, t);
	}
	function WI(e) {
		Qw(e).forEach(function (e) {
			return e.dispose();
		});
	}
	function UI(e) {
		return ok.keep(e);
	}
	function VI(e, t, n) {
		return void 0 === n && (n = 1), ok.registerBackend(e, t, n);
	}
	function GI() {
		return ok.backend;
	}
	var jI = yk({
			add_: function (e, t) {
				var n = mk(e, "a", "add"),
					r = mk(t, "b", "add"),
					a = Yw(n, r),
					i = { a: (n = a[0]), b: (r = a[1]) };
				return ok.runKernel(Tv, i);
			},
		}),
		HI = yk({
			floorDiv_: function (e, t) {
				var n = mk(e, "a", "floorDiv"),
					r = mk(t, "b", "floorDiv"),
					a = Yw(n, r),
					i = { a: (n = a[0]), b: (r = a[1]) };
				return ok.runKernel(_y, i);
			},
		}),
		qI = yk({
			div_: function (e, t) {
				var n = mk(e, "a", "div"),
					r = mk(t, "b", "div"),
					a = Yw(n, r);
				if (((n = a[0]), (r = a[1]), "int32" === n.dtype && "int32" === r.dtype)) return HI(n, r);
				var i = { a: n, b: r };
				return ok.runKernel(yy, i, {});
			},
		}),
		KI = yk({
			mul_: function (e, t) {
				var n = mk(e, "a", "mul"),
					r = mk(t, "b", "mul"),
					a = Yw(n, r),
					i = { a: (n = a[0]), b: (r = a[1]) };
				return ok.runKernel(db, i);
			},
		}),
		XI = yk({
			abs_: function (e) {
				var t = mk(e, "x", "abs");
				if ("complex64" === t.dtype) {
					var n = { x: t };
					return ok.runKernel(Jv, n);
				}
				var r = { x: t };
				return ok.runKernel(Nv, r);
			},
		}),
		YI = yk({
			acos_: function (e) {
				var t = { x: mk(e, "x", "acos") };
				return ok.runKernel(Iv, t);
			},
		}),
		JI = yk({
			acosh_: function (e) {
				var t = { x: mk(e, "x", "acosh") };
				return ok.runKernel(Sv, t);
			},
		}),
		ZI = yk({
			addN_: function (e) {
				Dg(Array.isArray(e), function () {
					return "The argument passed to tf.addN() must be a list of tensors";
				}),
					Dg(e.length >= 1, function () {
						return "Must pass at least one tensor to tf.addN(), but got " + e.length;
					});
				var t = e.map(function (e, t) {
						return mk(e, "tensors" + t, "addN");
					}),
					n = t[0];
				t.forEach(function (e) {
					if (e.dtype !== n.dtype)
						throw new Error("All tensors passed to tf.addN() must have the same dtype");
				}),
					t.forEach(function (e) {
						if (!Pg(e.shape, n.shape))
							throw new Error("All tensors passed to tf.addN() must have the same shape");
					});
				var r = t;
				return ok.runKernel(Cv, r);
			},
		}),
		QI = yk({
			all_: function (e, t, n) {
				void 0 === t && (t = null), void 0 === n && (n = !1);
				var r = { x: mk(e, "x", "all", "bool") },
					a = { axis: t, keepDims: n };
				return ok.runKernel(Ev, r, a);
			},
		}),
		$I = yk({
			any_: function (e, t, n) {
				void 0 === t && (t = null), void 0 === n && (n = !1);
				var r = { x: mk(e, "x", "any", "bool") },
					a = { axis: t, keepDims: n };
				return ok.runKernel(Rv, r, a);
			},
		}),
		eS = yk({
			argMax_: function (e, t) {
				void 0 === t && (t = 0);
				var n = { x: mk(e, "x", "argMax") },
					r = { axis: t };
				return ok.runKernel(Av, n, r);
			},
		}),
		tS = yk({
			argMin_: function (e, t) {
				void 0 === t && (t = 0);
				var n = { x: mk(e, "x", "argMin") },
					r = { axis: t };
				return ok.runKernel(_v, n, r);
			},
		}),
		nS = yk({
			asin_: function (e) {
				var t = { x: mk(e, "x", "asin") };
				return ok.runKernel(Fv, t);
			},
		}),
		rS = yk({
			asinh_: function (e) {
				var t = { x: mk(e, "x", "asinh") };
				return ok.runKernel(Dv, t);
			},
		}),
		aS = yk({
			atan_: function (e) {
				var t = { x: mk(e, "x", "atan") };
				return ok.runKernel(Ov, t);
			},
		}),
		iS = yk({
			atan2_: function (e, t) {
				var n = mk(e, "a", "atan2"),
					r = mk(t, "b", "atan2"),
					a = Yw(n, r),
					i = { a: (n = a[0]), b: (r = a[1]) };
				return ok.runKernel(Lv, i);
			},
		}),
		oS = yk({
			atanh_: function (e) {
				var t = { x: mk(e, "x", "atanh") };
				return ok.runKernel(Mv, t);
			},
		});
	function sS(e, t, n, r, a, i) {
		void 0 === a && (a = "NHWC");
		var o = e[3];
		return cS(e, [].concat(t, [o]), n, i, r, null, null, bS(a));
	}
	function uS(e, t, n, r, a, i, o) {
		void 0 === o && (o = "channelsLast");
		var s,
			u = fS(t),
			l = u[0],
			c = u[1];
		if ("channelsLast" === o) s = [l, c, e[3], e[3]];
		else {
			if ("channelsFirst" !== o) throw new Error("Unknown dataFormat " + o);
			s = [l, c, e[1], e[1]];
		}
		return cS(e, s, n, r, a, i, !1, o);
	}
	function lS(e, t, n, r, a, i, o) {
		void 0 === o && (o = "NDHWC");
		var s,
			u,
			l = dS(t),
			c = l[0],
			p = l[1],
			h = l[2];
		if ("NDHWC" === o) (u = "channelsLast"), (s = [c, p, h, e[4], e[4]]);
		else {
			if ("NCDHW" !== o) throw new Error("Unknown dataFormat " + o);
			(u = "channelsFirst"), (s = [c, p, h, e[1], e[1]]);
		}
		return pS(e, s, n, r, a, !1, u, i);
	}
	function cS(e, t, n, r, a, i, o, s) {
		void 0 === o && (o = !1), void 0 === s && (s = "channelsLast");
		var u = -1,
			l = -1,
			c = -1,
			p = -1;
		if ("channelsLast" === s) (u = e[0]), (l = e[1]), (c = e[2]), (p = e[3]);
		else {
			if ("channelsFirst" !== s) throw new Error("Unknown dataFormat " + s);
			(u = e[0]), (p = e[1]), (l = e[2]), (c = e[3]);
		}
		var h,
			f = t[0],
			d = t[1],
			m = t[3],
			g = fS(n),
			v = g[0],
			y = g[1],
			b = fS(r),
			x = b[0],
			w = b[1],
			k = mS(f, x),
			N = mS(d, w),
			I = (function (e, t, n, r, a, i, o, s, u) {
				var l, c, p;
				if ("number" == typeof e) {
					l = { top: e, bottom: e, left: e, right: e, type: 0 === e ? "VALID" : "NUMBER" };
					var h = (function (e, t, n, r, a) {
						null == r && (r = hS(e, t, n));
						var i = e[1];
						return [gS((e[0] - t + 2 * r) / n + 1, a), gS((i - t + 2 * r) / n + 1, a)];
					})([t, n], i, r, e, s);
					(c = h[0]), (p = h[1]);
				} else if ("same" === e) {
					(c = Math.ceil(t / r)), (p = Math.ceil(n / a));
					var f = Math.max(0, (c - 1) * r + i - t),
						d = Math.max(0, (p - 1) * a + o - n),
						m = Math.floor(f / 2),
						g = f - m,
						v = Math.floor(d / 2);
					l = { top: m, bottom: g, left: v, right: d - v, type: "SAME" };
				} else if ("valid" === e)
					(l = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }),
						(c = Math.ceil((t - i + 1) / r)),
						(p = Math.ceil((n - o + 1) / a));
				else {
					if ("object" != typeof e) throw Error("Unknown padding parameter: " + e);
					var y = "channelsLast" === u ? e[1][0] : e[2][0],
						b = "channelsLast" === u ? e[1][1] : e[2][1],
						x = "channelsLast" === u ? e[2][0] : e[3][0],
						w = "channelsLast" === u ? e[2][1] : e[3][1];
					(l = {
						top: y,
						bottom: b,
						left: x,
						right: w,
						type: 0 === y && 0 === b && 0 === x && 0 === w ? "VALID" : "EXPLICIT",
					}),
						(c = gS((t - i + y + b) / r + 1, s)),
						(p = gS((n - o + x + w) / a + 1, s));
				}
				return { padInfo: l, outHeight: c, outWidth: p };
			})(a, l, c, v, y, k, N, i, s),
			S = I.padInfo,
			T = I.outHeight,
			C = I.outWidth,
			E = o ? m * p : m;
		return (
			"channelsFirst" === s ? (h = [u, E, T, C]) : "channelsLast" === s && (h = [u, T, C, E]),
			{
				batchSize: u,
				dataFormat: s,
				inHeight: l,
				inWidth: c,
				inChannels: p,
				outHeight: T,
				outWidth: C,
				outChannels: E,
				padInfo: S,
				strideHeight: v,
				strideWidth: y,
				filterHeight: f,
				filterWidth: d,
				effectiveFilterHeight: k,
				effectiveFilterWidth: N,
				dilationHeight: x,
				dilationWidth: w,
				inShape: e,
				outShape: h,
				filterShape: t,
			}
		);
	}
	function pS(e, t, n, r, a, i, o, s) {
		void 0 === i && (i = !1), void 0 === o && (o = "channelsLast");
		var u = -1,
			l = -1,
			c = -1,
			p = -1,
			h = -1;
		if ("channelsLast" === o) (u = e[0]), (l = e[1]), (c = e[2]), (p = e[3]), (h = e[4]);
		else {
			if ("channelsFirst" !== o) throw new Error("Unknown dataFormat " + o);
			(u = e[0]), (h = e[1]), (l = e[2]), (c = e[3]), (p = e[4]);
		}
		var f,
			d = t[0],
			m = t[1],
			g = t[2],
			v = t[4],
			y = dS(n),
			b = y[0],
			x = y[1],
			w = y[2],
			k = dS(r),
			N = k[0],
			I = k[1],
			S = k[2],
			T = mS(d, N),
			C = mS(m, I),
			E = mS(g, S),
			R = (function (e, t, n, r, a, i, o, s, u, l, c) {
				var p, h, f, d;
				if ("number" == typeof e) {
					p = { top: e, bottom: e, left: e, right: e, front: e, back: e, type: 0 === e ? "VALID" : "NUMBER" };
					var m = (function (e, t, n, r, a, i) {
						null == a && (a = hS(e, t, r));
						var o = e[1],
							s = e[2];
						return [
							gS((e[0] - t + 2 * a) / r + 1, i),
							gS((o - t + 2 * a) / r + 1, i),
							gS((s - t + 2 * a) / r + 1, i),
							1,
						];
					})([t, n, r, 1], s, 0, a, e, c);
					(h = m[0]), (f = m[1]), (d = m[2]);
				} else if ("same" === e) {
					var g = ((h = Math.ceil(t / a)) - 1) * a + s - t,
						v = ((f = Math.ceil(n / i)) - 1) * i + u - n,
						y = ((d = Math.ceil(r / o)) - 1) * o + l - r,
						b = Math.floor(g / 2),
						x = g - b,
						w = Math.floor(v / 2),
						k = v - w,
						N = Math.floor(y / 2);
					p = { top: w, bottom: k, left: N, right: y - N, front: b, back: x, type: "SAME" };
				} else {
					if ("valid" !== e) throw Error("Unknown padding parameter: " + e);
					(p = { top: 0, bottom: 0, left: 0, right: 0, front: 0, back: 0, type: "VALID" }),
						(h = Math.ceil((t - s + 1) / a)),
						(f = Math.ceil((n - u + 1) / i)),
						(d = Math.ceil((r - l + 1) / o));
				}
				return { padInfo: p, outDepth: h, outHeight: f, outWidth: d };
			})(a, l, c, p, b, x, w, T, C, E, s),
			A = R.padInfo,
			_ = R.outDepth,
			F = R.outHeight,
			D = R.outWidth,
			O = i ? v * h : v;
		return (
			"channelsFirst" === o ? (f = [u, O, _, F, D]) : "channelsLast" === o && (f = [u, _, F, D, O]),
			{
				batchSize: u,
				dataFormat: o,
				inDepth: l,
				inHeight: c,
				inWidth: p,
				inChannels: h,
				outDepth: _,
				outHeight: F,
				outWidth: D,
				outChannels: O,
				padInfo: A,
				strideDepth: b,
				strideHeight: x,
				strideWidth: w,
				filterDepth: d,
				filterHeight: m,
				filterWidth: g,
				effectiveFilterDepth: T,
				effectiveFilterHeight: C,
				effectiveFilterWidth: E,
				dilationDepth: N,
				dilationHeight: I,
				dilationWidth: S,
				inShape: e,
				outShape: f,
				filterShape: t,
			}
		);
	}
	function hS(e, t, n, r) {
		void 0 === r && (r = 1);
		var a = mS(t, r);
		return Math.floor((e[0] * (n - 1) - n + a) / 2);
	}
	function fS(e) {
		return "number" == typeof e ? [e, e, e] : 2 === e.length ? [e[0], e[1], 1] : e;
	}
	function dS(e) {
		return "number" == typeof e ? [e, e, e] : e;
	}
	function mS(e, t) {
		return t <= 1 ? e : e + (e - 1) * (t - 1);
	}
	function gS(e, t) {
		if (!t) return Math.trunc(e);
		switch (t) {
			case "round":
				return Math.round(e);
			case "ceil":
				return Math.ceil(e);
			case "floor":
				return Math.floor(e);
			default:
				throw new Error("Unknown roundingMode " + t);
		}
	}
	function vS(e) {
		var t = fS(e),
			n = t[0],
			r = t[1],
			a = t[2];
		return 1 === n && 1 === r && 1 === a;
	}
	function yS(e, t) {
		return vS(e) || vS(t);
	}
	function bS(e) {
		if ("NHWC" === e) return "channelsLast";
		if ("NCHW" === e) return "channelsFirst";
		throw new Error("Unknown dataFormat " + e);
	}
	function xS(e, t, n) {
		if (null != n) {
			if ("string" == typeof t)
				throw Error(
					"Error in " +
						e +
						": pad must be an integer when using dimRoundingMode " +
						n +
						" but got pad " +
						t +
						"."
				);
			if ("number" == typeof t)
				Dg(Bg(t), function () {
					return (
						"Error in " +
						e +
						": pad must be an integer when using dimRoundingMode " +
						n +
						" but got pad " +
						t +
						"."
					);
				});
			else {
				if ("object" != typeof t) throw Error("Error in " + e + ": Unknown padding parameter: " + t);
				t.forEach(function (t) {
					t.forEach(function (t) {
						Dg(Bg(t), function () {
							return (
								"Error in " +
								e +
								": pad must be an integer when using dimRoundingMode " +
								n +
								" but got pad " +
								t +
								"."
							);
						});
					});
				});
			}
		}
	}
	var wS = yk({
			reshape_: function (e, t) {
				var n = { x: mk(e, "x", "reshape", "string_or_numeric") },
					r = { shape: t };
				return ok.runKernel(_b, n, r);
			},
		}),
		kS = yk({
			avgPool_: function (e, t, n, r, a) {
				var i = mk(e, "x", "avgPool", "float32");
				Dg(yS(n, 1), function () {
					return (
						"Error in avgPool: Either strides or dilations must be 1. Got strides " +
						n +
						" and dilations '1'"
					);
				});
				var o = i,
					s = !1;
				3 === i.rank && ((s = !0), (o = wS(i, [1, i.shape[0], i.shape[1], i.shape[2]]))),
					Dg(4 === o.rank, function () {
						return "Error in avgPool: x must be rank 4 but got rank " + o.rank + ".";
					}),
					xS("avgPool", r, a);
				var u = { x: o },
					l = { filterSize: t, strides: n, pad: r, dimRoundingMode: a },
					c = ok.runKernel(zv, u, l);
				return (c = NN(c, i.dtype)), s ? wS(c, [c.shape[1], c.shape[2], c.shape[3]]) : c;
			},
		}),
		NS = yk({
			avgPool3d_: function (e, t, n, r, a, i) {
				void 0 === i && (i = "NDHWC");
				var o = mk(e, "x", "avgPool3d", "float32"),
					s = o,
					u = !1;
				4 === o.rank && ((u = !0), (s = wS(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]))),
					Dg(5 === s.rank, function () {
						return "Error in avgPool3d: x must be rank 5 but got rank " + s.rank + ".";
					}),
					Dg("NDHWC" === i, function () {
						return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + i;
					}),
					xS("avgPool3d", r, a);
				var l = { x: s },
					c = { filterSize: t, strides: n, pad: r, dimRoundingMode: a, dataFormat: i },
					p = ok.runKernel(Bv, l, c);
				return (p = NN(p, s.dtype)), u ? wS(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p;
			},
		}),
		IS = yk({
			concat_: function (e, t) {
				void 0 === t && (t = 0),
					Dg(e.length >= 1, function () {
						return "Pass at least one tensor to concat";
					});
				var n = gk(e, "tensors", "concat", "string_or_numeric");
				if (
					("complex64" === n[0].dtype &&
						n.forEach(function (e) {
							if ("complex64" !== e.dtype)
								throw new Error(
									"Cannot concatenate complex64 tensors with a tensor\n          with dtype " +
										e.dtype +
										". "
								);
						}),
					1 === n.length)
				)
					return IN(n[0]);
				var r = n,
					a = { axis: t };
				return ok.runKernel(Zv, r, a);
			},
		}),
		SS = yk({
			sigmoid_: function (e) {
				var t = { x: mk(e, "x", "sigmoid", "float32") };
				return ok.runKernel(Kb, t);
			},
		}),
		TS = yk({
			slice_: function (e, t, n) {
				var r = mk(e, "x", "slice", "string_or_numeric");
				if (0 === r.rank) throw new Error("Slicing scalar is not possible");
				var a = { x: r },
					i = { begin: t, size: n };
				return ok.runKernel(Gb, a, i);
			},
		}),
		CS = yk({
			tanh_: function (e) {
				var t = { x: mk(e, "x", "tanh", "float32") };
				return ok.runKernel(fx, t);
			},
		}),
		ES = yk({
			basicLSTMCell_: function (e, t, n, r, a, i) {
				var o = mk(e, "forgetBias", "basicLSTMCell"),
					s = mk(t, "lstmKernel", "basicLSTMCell"),
					u = mk(n, "lstmBias", "basicLSTMCell"),
					l = mk(r, "data", "basicLSTMCell"),
					c = mk(a, "c", "basicLSTMCell"),
					p = mk(i, "h", "basicLSTMCell"),
					h = IS([l, p], 1),
					f = jN(h, s),
					d = jI(f, u),
					m = d.shape[0],
					g = d.shape[1] / 4,
					v = [m, g],
					y = TS(d, [0, 0], v),
					b = TS(d, [0, g], v),
					x = TS(d, [0, 2 * g], v),
					w = TS(d, [0, 3 * g], v),
					k = jI(KI(SS(y), CS(b)), KI(c, SS(jI(o, x))));
				return [k, KI(CS(k), SS(w))];
			},
		}),
		RS = yk({
			batchToSpaceND_: function (e, t, n) {
				var r = mk(e, "x", "batchToSpaceND"),
					a = t.reduce(function (e, t) {
						return e * t;
					});
				Dg(r.rank >= 1 + t.length, function () {
					return "input rank is " + r.rank + " but should be > than blockShape.length " + t.length;
				}),
					Dg(n.length === t.length, function () {
						return "crops.length is " + n.length + " but should be equal to blockShape.length  " + t.length;
					}),
					Dg(r.shape[0] % a == 0, function () {
						return (
							"input tensor batch is " +
							r.shape[0] +
							" but is not divisible by the product of the elements of blockShape " +
							t.join(" * ") +
							" === " +
							a
						);
					});
				var i = { x: r },
					o = { blockShape: t, crops: n };
				return ok.runKernel(Vv, i, o);
			},
		}),
		AS = yk({
			batchNorm_: function (e, t, n, r, a, i) {
				null == i && (i = 0.001);
				var o,
					s,
					u = mk(e, "x", "batchNorm"),
					l = mk(t, "mean", "batchNorm"),
					c = mk(n, "variance", "batchNorm");
				null != a && (o = mk(a, "scale", "batchNorm")),
					null != r && (s = mk(r, "offset", "batchNorm")),
					Dg(l.rank === c.rank, function () {
						return "Batch normalization gradient requires mean and variance to have equal ranks.";
					}),
					Dg(null == s || l.rank === s.rank, function () {
						return "Batch normalization gradient requires mean and offset to have equal ranks.";
					}),
					Dg(null == o || l.rank === o.rank, function () {
						return "Batch normalization gradient requires mean and scale to have equal ranks.";
					});
				var p = {
						x: (function (e) {
							return 0 === e.rank || 1 === e.rank
								? wS(e, [1, 1, 1, e.size])
								: 2 === e.rank
								? wS(e, [1, 1, e.shape[0], e.shape[1]])
								: 3 === e.rank
								? wS(e, [1, e.shape[0], e.shape[1], e.shape[2]])
								: e;
						})(u),
						scale: o,
						offset: s,
						mean: l,
						variance: c,
					},
					h = { varianceEpsilon: i },
					f = ok.runKernel(Fy, p, h);
				return wS(f, u.shape);
			},
		}),
		_S = yk({
			batchNorm2d_: function (e, t, n, r, a, i) {
				var o,
					s,
					u = mk(e, "x", "batchNorm"),
					l = mk(t, "mean", "batchNorm"),
					c = mk(n, "variance", "batchNorm");
				return (
					null != a && (o = mk(a, "scale", "batchNorm")),
					null != r && (s = mk(r, "offset", "batchNorm")),
					Dg(2 === u.rank, function () {
						return "Error in batchNorm2D: x must be rank 2 but got rank " + u.rank + ".";
					}),
					Dg(2 === l.rank || 1 === l.rank, function () {
						return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + l.rank + ".";
					}),
					Dg(2 === c.rank || 1 === c.rank, function () {
						return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + c.rank + ".";
					}),
					null != o &&
						Dg(2 === o.rank || 1 === o.rank, function () {
							return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + o.rank + ".";
						}),
					null != s &&
						Dg(2 === s.rank || 1 === s.rank, function () {
							return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s.rank + ".";
						}),
					AS(u, l, c, s, o, i)
				);
			},
		}),
		FS = yk({
			batchNorm3d_: function (e, t, n, r, a, i) {
				var o,
					s,
					u = mk(e, "x", "batchNorm"),
					l = mk(t, "mean", "batchNorm"),
					c = mk(n, "variance", "batchNorm");
				return (
					null != a && (o = mk(a, "scale", "batchNorm")),
					null != r && (s = mk(r, "offset", "batchNorm")),
					Dg(3 === u.rank, function () {
						return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + ".";
					}),
					Dg(3 === l.rank || 1 === l.rank, function () {
						return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + l.rank + ".";
					}),
					Dg(3 === c.rank || 1 === c.rank, function () {
						return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + c.rank + ".";
					}),
					null != o &&
						Dg(3 === o.rank || 1 === o.rank, function () {
							return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + o.rank + ".";
						}),
					null != s &&
						Dg(3 === s.rank || 1 === s.rank, function () {
							return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s.rank + ".";
						}),
					AS(u, l, c, s, o, i)
				);
			},
		}),
		DS = yk({
			batchNorm4d_: function (e, t, n, r, a, i) {
				var o,
					s,
					u = mk(e, "x", "batchNorm"),
					l = mk(t, "mean", "batchNorm"),
					c = mk(n, "variance", "batchNorm");
				return (
					null != a && (o = mk(a, "scale", "batchNorm")),
					null != r && (s = mk(r, "offset", "batchNorm")),
					Dg(4 === u.rank, function () {
						return "Error in batchNorm4D: x must be rank 4 but got rank " + u.rank + ".";
					}),
					Dg(4 === l.rank || 1 === l.rank, function () {
						return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + l.rank + ".";
					}),
					Dg(4 === c.rank || 1 === c.rank, function () {
						return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + c.rank + ".";
					}),
					null != o &&
						Dg(4 === o.rank || 1 === o.rank, function () {
							return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + o.rank + ".";
						}),
					null != s &&
						Dg(4 === s.rank || 1 === s.rank, function () {
							return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s.rank + ".";
						}),
					AS(u, l, c, s, o, i)
				);
			},
		}),
		OS = yk({
			bincount_: function (e, t, n) {
				var r = mk(e, "x", "bincount"),
					a = mk(t, "weights", "bincount");
				Dg("int32" === r.dtype, function () {
					return "Error in bincount: input dtype must be int32, but got " + r.dtype;
				}),
					Dg(n >= 0, function () {
						return "size must be non-negative, but got " + n + ".";
					}),
					Dg(a.size === r.size || 0 === a.size, function () {
						return (
							"Error in bincount: weights must have the same size as input or0-length, but got input shape: " +
							r.shape +
							", weights shape: " +
							a.shape +
							"."
						);
					});
				var i = { x: r, weights: a },
					o = { size: n };
				return ok.runKernel(Gv, i, o);
			},
		}),
		MS = yk({
			broadcastArgs_: function (e, t) {
				var n = mk(e, "s0", "broadcastArgs", "int32"),
					r = mk(t, "s1", "broadcastArgs", "int32");
				if (1 !== n.rank)
					throw new Error("broadcastArgs(): first input must be a vector (rank=1). Has rank " + n.rank);
				if (1 !== r.rank)
					throw new Error("broadcastArgs(): second input must be a vector (rank=1). Has rank " + r.rank);
				var a = { s0: n, s1: r };
				return ok.runKernel(Hv, a);
			},
		}),
		LS = yk({
			broadcastTo_: function (e, t) {
				var n = mk(e, "broadcastTo", "x"),
					r = n.shape;
				if (
					t.some(function (e) {
						return !(e > 0) || e % 1 != 0;
					})
				)
					throw new Error("broadcastTo(): Invalid broadcast shape [" + t + "].");
				if (t.length < n.rank)
					throw new Error("broadcastTo(): shape.length=" + t.length + " < input.rank=" + n.rank + ".");
				if (t.length > n.rank) {
					for (var a = n.shape.slice(); a.length < t.length; ) a.unshift(1);
					n = wS(n, a);
				}
				for (var i = n.shape, o = Array.from(t), s = t.length - 1; s >= 0; s--)
					if (i[s] === t[s]) o[s] = 1;
					else if (1 !== n.shape[s])
						throw new Error("broadcastTo(): [" + r + "] cannot be broadcast to [" + t + "].");
				if (
					0 ===
					o
						.map(function (e, t) {
							return e > 1 ? t : -1;
						})
						.filter(function (e) {
							return e >= 0;
						}).length
				)
					return IN(n);
				var u = { x: n },
					l = { reps: o };
				return ok.runKernel(dx, u, l);
			},
		}),
		zS = yk({
			ceil_: function (e) {
				var t = { x: mk(e, "x", "ceil", "float32") };
				return ok.runKernel(Kv, t);
			},
		}),
		PS = yk({
			clipByValue_: function (e, t, n) {
				var r = mk(e, "x", "clipByValue");
				Dg(t <= n, function () {
					return "Error in clip: min (" + t + ") must be less than or equal to max (" + n + ").";
				});
				var a = { x: r },
					i = { clipValueMin: t, clipValueMax: n };
				return ok.runKernel(Xv, a, i);
			},
		}),
		BS = yk({
			concat1d_: function (e) {
				return IS(e, 0);
			},
		}),
		WS = yk({
			concat2d_: function (e, t) {
				return IS(e, t);
			},
		}),
		US = yk({
			concat3d_: function (e, t) {
				return IS(e, t);
			},
		}),
		VS = yk({
			concat4d_: function (e, t) {
				return IS(e, t);
			},
		}),
		GS = yk({
			conv2d_: function (e, t, n, r, a, i, o) {
				void 0 === a && (a = "NHWC"), void 0 === i && (i = [1, 1]);
				var s = mk(e, "x", "conv2d", "float32"),
					u = mk(t, "filter", "conv2d", "float32"),
					l = s,
					c = !1;
				3 === s.rank && ((c = !0), (l = wS(s, [1, s.shape[0], s.shape[1], s.shape[2]]))),
					Dg(4 === l.rank, function () {
						return "Error in conv2d: input must be rank 4, but got rank " + l.rank + ".";
					}),
					Dg(4 === u.rank, function () {
						return "Error in conv2d: filter must be rank 4, but got rank " + u.rank + ".";
					}),
					xS("conv2d", r, o);
				var p = "NHWC" === a ? l.shape[3] : l.shape[1];
				Dg(p === u.shape[2], function () {
					return (
						"Error in conv2d: depth of input (" +
						p +
						") must match input depth for filter " +
						u.shape[2] +
						"."
					);
				}),
					Dg(yS(n, i), function () {
						return (
							"Error in conv2D: Either strides or dilations must be 1. Got strides " +
							n +
							" and dilations '" +
							i +
							"'"
						);
					});
				var h = { x: l, filter: u },
					f = { strides: n, pad: r, dataFormat: a, dilations: i, dimRoundingMode: o },
					d = ok.runKernel(Qv, h, f);
				return c ? wS(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
			},
		}),
		jS = yk({
			conv1d_: function (e, t, n, r, a, i, o) {
				void 0 === a && (a = "NWC"), void 0 === i && (i = 1);
				var s = mk(e, "x", "conv1d"),
					u = mk(t, "filter", "conv1d"),
					l = s,
					c = !1;
				2 === s.rank && ((c = !0), (l = wS(s, [1, s.shape[0], s.shape[1]]))),
					Dg(3 === l.rank, function () {
						return "Error in conv1d: input must be rank 3, but got rank " + l.rank + ".";
					}),
					Dg(3 === u.rank, function () {
						return "Error in conv1d: filter must be rank 3, but got rank " + u.rank + ".";
					}),
					xS("conv1d", r, o),
					Dg(l.shape[2] === u.shape[1], function () {
						return (
							"Error in conv1d: depth of input (" +
							l.shape[2] +
							") must match input depth for filter " +
							u.shape[1] +
							"."
						);
					}),
					Dg(yS(n, i), function () {
						return (
							"Error in conv1D: Either stride or dilation must be 1. Got stride " +
							n +
							" and dilation '" +
							i +
							"'"
						);
					}),
					Dg("NWC" === a, function () {
						return "Error in conv1d: got dataFormat of " + a + " but only NWC is currently supported.";
					});
				var p = wS(u, [1, u.shape[0], u.shape[1], u.shape[2]]),
					h = wS(l, [l.shape[0], 1, l.shape[1], l.shape[2]]),
					f = GS(h, p, [1, n], r, "NHWC", [1, i], o);
				return wS(f, c ? [f.shape[2], f.shape[3]] : [f.shape[0], f.shape[2], f.shape[3]]);
			},
		}),
		HS = yk({
			conv2DBackpropInput_: function (e, t, n, r, a, i, o) {
				void 0 === i && (i = "NHWC"),
					Dg(e.length === t.rank, function () {
						return "Length of inShape (" + e.length + ") and rank of dy (" + t.rank + ") must match";
					});
				var s = e,
					u = t,
					l = !1;
				3 === t.rank &&
					((l = !0), (u = wS(t, [1, t.shape[0], t.shape[1], t.shape[2]])), (s = [1, e[0], e[1], e[2]])),
					Dg(4 === s.length, function () {
						return "Error in conv2dDerInput: inShape must be length 4, but got length " + s.length + ".";
					}),
					Dg(4 === u.rank, function () {
						return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u.rank;
					}),
					Dg(4 === n.rank, function () {
						return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n.rank;
					});
				var c = "NHWC" === i ? s[3] : s[1],
					p = "NHWC" === i ? u.shape[3] : u.shape[1];
				Dg(c === n.shape[2], function () {
					return (
						"Error in conv2dDerInput: depth of input (" +
						c +
						") must match input depth for filter " +
						n.shape[2] +
						"."
					);
				}),
					Dg(p === n.shape[3], function () {
						return (
							"Error in conv2dDerInput: depth of output (" +
							p +
							") must match output depth for filter " +
							n.shape[3] +
							"."
						);
					}),
					xS("conv2dDerInput", a, o);
				var h = { dy: u, filter: n },
					f = { strides: r, pad: a, dataFormat: i, dimRoundingMode: o, inputShape: s },
					d = ok.runKernel(ey, h, f);
				return l ? wS(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
			},
		}),
		qS = yk({
			conv2dTranspose_: function (e, t, n, r, a, i) {
				var o = mk(e, "x", "conv2dTranspose"),
					s = mk(t, "filter", "conv2dTranspose");
				return HS(n, o, s, r, a, "NHWC", i);
			},
		}),
		KS = yk({
			conv3d_: function (e, t, n, r, a, i) {
				void 0 === a && (a = "NDHWC"), void 0 === i && (i = [1, 1, 1]);
				var o = mk(e, "x", "conv3d"),
					s = mk(t, "filter", "conv3d"),
					u = o,
					l = !1;
				4 === o.rank && ((l = !0), (u = wS(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]))),
					Dg(5 === u.rank, function () {
						return "Error in conv3d: input must be rank 5, but got rank " + u.rank + ".";
					}),
					Dg(5 === s.rank, function () {
						return "Error in conv3d: filter must be rank 5, but got rank " + s.rank + ".";
					}),
					Dg(u.shape[4] === s.shape[3], function () {
						return (
							"Error in conv3d: depth of input (" +
							u.shape[4] +
							") must match input depth for filter " +
							s.shape[3] +
							"."
						);
					}),
					Dg(yS(n, i), function () {
						return (
							"Error in conv3D: Either strides or dilations must be 1. Got strides " +
							n +
							" and dilations '" +
							i +
							"'"
						);
					}),
					Dg("NDHWC" === a, function () {
						return "Error in conv3d: got dataFormat of " + a + " but only NDHWC is currently supported.";
					});
				var c = { x: u, filter: s },
					p = { strides: n, pad: r, dataFormat: a, dilations: i },
					h = ok.runKernel(ty, c, p);
				return l ? wS(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
			},
		}),
		XS = yk({
			conv3DBackpropInput_: function (e, t, n, r, a) {
				Dg(e.length === t.rank, function () {
					return "Length of inShape (" + e.length + ") and rank of dy (" + t.rank + ") must match";
				});
				var i = e,
					o = t,
					s = !1;
				4 === t.rank &&
					((s = !0),
					(o = wS(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])),
					(i = [1, e[0], e[1], e[2], e[3]]));
				var u = i[4],
					l = o.shape[4];
				Dg(5 === i.length, function () {
					return "Error in conv3dDerInput: inShape must be length 5, but got length " + i.length + ".";
				}),
					Dg(5 === o.rank, function () {
						return "Error in conv3dDerInput: dy must be rank 5, but got rank " + o.rank;
					}),
					Dg(5 === n.rank, function () {
						return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n.rank;
					}),
					Dg(u === n.shape[3], function () {
						return (
							"Error in conv3dDerInput: depth of input (" +
							u +
							") must match input depth for filter " +
							n.shape[3] +
							"."
						);
					}),
					Dg(l === n.shape[4], function () {
						return (
							"Error in conv3dDerInput: depth of output (" +
							l +
							") must match output depth for filter " +
							n.shape[4] +
							"."
						);
					});
				var c = { dy: o, filter: n },
					p = { pad: a, strides: r, inputShape: i },
					h = ok.runKernel(ry, c, p);
				return s ? wS(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
			},
		}),
		YS = yk({
			conv3dTranspose_: function (e, t, n, r, a) {
				var i = mk(e, "x", "conv3dTranspose"),
					o = mk(t, "filter", "conv3dTranspose");
				return XS(n, i, o, r, a);
			},
		}),
		JS = yk({
			cos_: function (e) {
				var t = { x: mk(e, "x", "cos", "float32") };
				return ok.runKernel(ay, t);
			},
		}),
		ZS = yk({
			cosh_: function (e) {
				var t = { x: mk(e, "x", "cosh", "float32") };
				return ok.runKernel(iy, t);
			},
		}),
		QS = yk({
			cumprod_: function (e, t, n, r) {
				void 0 === t && (t = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);
				var a = { x: mk(e, "x", "cumprod") },
					i = { axis: t, exclusive: n, reverse: r };
				return ok.runKernel(oy, a, i);
			},
		}),
		$S = yk({
			cumsum_: function (e, t, n, r) {
				void 0 === t && (t = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);
				var a = { x: mk(e, "x", "cumsum") },
					i = { axis: t, exclusive: n, reverse: r };
				return ok.runKernel(sy, a, i);
			},
		}),
		eT = yk({
			denseBincount_: function (e, t, n, r) {
				void 0 === r && (r = !1);
				var a = mk(e, "x", "denseBincount"),
					i = mk(t, "weights", "denseBincount");
				Dg("int32" === a.dtype, function () {
					return "Error in denseBincount: input dtype must be int32, but got " + a.dtype;
				}),
					Dg(a.rank <= 2, function () {
						return "Error in denseBincount: input must be at most rank 2, but got rank " + a.rank + ".";
					}),
					Dg(n >= 0, function () {
						return "size must be non-negative, but got " + n + ".";
					}),
					Dg(i.size === a.size || 0 === i.size, function () {
						return (
							"Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: " +
							a.shape +
							", weights shape: " +
							i.shape +
							"."
						);
					});
				var o = { x: a, weights: i },
					s = { size: n, binaryOutput: r };
				return ok.runKernel(ly, o, s);
			},
		}),
		tT = yk({
			depthToSpace_: function (e, t, n) {
				void 0 === n && (n = "NHWC");
				var r = mk(e, "x", "depthToSpace", "float32"),
					a = "NHWC" === n ? r.shape[1] : r.shape[2],
					i = "NHWC" === n ? r.shape[2] : r.shape[3],
					o = "NHWC" === n ? r.shape[3] : r.shape[1];
				Dg(t > 1, function () {
					return "blockSize should be > 1 for depthToSpace, but was: " + t;
				}),
					Dg(a * t >= 0, function () {
						return (
							"Negative dimension size caused by overflow when multiplying\n    " +
							a +
							" and " +
							t +
							"  for depthToSpace with input shape\n    " +
							r.shape
						);
					}),
					Dg(i * t >= 0, function () {
						return (
							"Negative dimension size caused by overflow when multiplying\n    " +
							i +
							" and " +
							t +
							" for depthToSpace with input shape\n        " +
							r.shape
						);
					}),
					Dg(o % (t * t) == 0, function () {
						return (
							"Dimension size must be evenly divisible by " +
							t * t +
							" but is " +
							o +
							" for depthToSpace with input shape " +
							r.shape
						);
					});
				var s = { x: r },
					u = { blockSize: t, dataFormat: n };
				return ok.runKernel(cy, s, u);
			},
		}),
		nT = yk({
			depthwiseConv2d_: function (e, t, n, r, a, i, o) {
				void 0 === a && (a = "NHWC"), void 0 === i && (i = [1, 1]);
				var s = mk(e, "x", "depthwiseConv2d", "float32"),
					u = mk(t, "filter", "depthwiseConv2d", "float32"),
					l = s,
					c = !1;
				3 === s.rank && ((c = !0), (l = wS(s, [1, s.shape[0], s.shape[1], s.shape[2]]))),
					Dg(4 === l.rank, function () {
						return "Error in depthwiseConv2d: input must be rank 4, but got rank " + l.rank + ".";
					}),
					Dg(4 === u.rank, function () {
						return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u.rank + ".";
					}),
					Dg(l.shape[3] === u.shape[2], function () {
						return (
							"Error in depthwiseConv2d: number of input channels (" +
							l.shape[3] +
							") must match the inChannels dimension in filter " +
							u.shape[2] +
							"."
						);
					}),
					xS("depthwiseConv2d", r, o);
				var p = { x: l, filter: u },
					h = { strides: n, pad: r, dataFormat: a, dilations: i, dimRoundingMode: o },
					f = ok.runKernel(py, p, h);
				return c ? wS(f, [f.shape[1], f.shape[2], f.shape[3]]) : f;
			},
		}),
		rT = yk({
			diag_: function (e) {
				var t = { x: mk(e, "x", "diag") };
				return ok.runKernel(dy, t);
			},
		}),
		aT = yk({
			dilation2d_: function (e, t, n, r, a, i) {
				void 0 === a && (a = [1, 1]), void 0 === i && (i = "NHWC");
				var o = mk(e, "x", "dilation2d"),
					s = mk(t, "filter", "dilation2d");
				Dg(3 === o.rank || 4 === o.rank, function () {
					return "Error in dilation2d: input must be rank 3 or 4, but got rank " + o.rank + ".";
				}),
					Dg(3 === s.rank, function () {
						return "Error in dilation2d: filter must be rank 3, but got rank " + s.rank + ".";
					}),
					Dg("NHWC" === i, function () {
						return "Error in dilation2d: Only NHWC is currently supported, but got dataFormat of " + i;
					});
				var u = o,
					l = !1;
				3 === o.rank && ((u = wS(o, [1, o.shape[0], o.shape[1], o.shape[2]])), (l = !0));
				var c = { x: u, filter: s },
					p = { strides: n, pad: r, dilations: a },
					h = ok.runKernel(my, c, p);
				return l ? wS(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
			},
		}),
		iT = yk({
			equal_: function (e, t) {
				var n = mk(e, "a", "equal", "string_or_numeric"),
					r = mk(t, "b", "equal", "string_or_numeric"),
					a = Yw(n, r);
				(n = a[0]), (r = a[1]), JN(n.shape, r.shape);
				var i = { a: n, b: r };
				return ok.runKernel(Ny, i);
			},
		}),
		oT = yk({
			where_: function (e, t, n) {
				var r = mk(t, "a", "where"),
					a = mk(n, "b", "where"),
					i = mk(e, "condition", "where", "bool"),
					o = JN(JN(i.shape, r.shape), a.shape),
					s = { condition: LS(i, o), t: LS(r, o), e: LS(a, o) };
				return ok.runKernel(Ub, s);
			},
		}),
		sT = yk({
			zerosLike_: function (e) {
				var t = { x: mk(e, "x", "zerosLike") };
				return ok.runKernel(wx, t);
			},
		}),
		uT = yk({
			divNoNan_: function (e, t) {
				var n = mk(e, "a", "div"),
					r = mk(t, "b", "div"),
					a = Yw(n, r);
				(n = a[0]), (r = a[1]);
				var i = qI(n, r),
					o = sT(i),
					s = iT(r, o);
				return oT(s, o, i);
			},
		}),
		lT = yk({
			dot_: function (e, t) {
				var n = mk(e, "t1", "dot"),
					r = mk(t, "t2", "dot");
				Dg(!((1 !== n.rank && 2 !== n.rank) || (1 !== r.rank && 2 !== r.rank)), function () {
					return (
						"Error in dot: inputs must all be rank 1 or 2, but got ranks " + n.rank + " and " + r.rank + "."
					);
				});
				var a = 1 === n.rank ? n.size : n.shape[1],
					i = 1 === r.rank ? r.size : r.shape[0];
				if (
					(Dg(a === i, function () {
						return "Error in dot: inner dimensions of inputs must match, but got " + a + " and " + i + ".";
					}),
					1 === n.rank && 1 === r.rank)
				) {
					var o = wS(n, [1, -1]),
						s = wS(r, [-1, 1]),
						u = jN(o, s);
					return wS(u, []);
				}
				if (1 === n.rank && 2 === r.rank) {
					var l = wS(n, [1, -1]),
						c = wS(r, [r.shape[0], r.shape[1]]),
						p = jN(l, c);
					return wS(p, [p.size]);
				}
				if (2 === n.rank && 1 === r.rank) {
					var h = wS(r, [-1, 1]),
						f = jN(n, h);
					return wS(f, [f.size]);
				}
				var d = wS(r, [r.shape[0], r.shape[1]]);
				return jN(n, d);
			},
		}),
		cT = yk({
			einsum_: function (e) {
				for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
					n[r - 1] = arguments[r];
				var a = n.map(function (e, t) {
						return mk(e, "tensors" + t, "einsum");
					}),
					i = { equation: e };
				return ok.runKernel(by, a, i);
			},
		}),
		pT = yk({
			elu_: function (e) {
				var t = { x: mk(e, "x", "elu", "float32") };
				return ok.runKernel(xy, t);
			},
		}),
		hT = yk({
			erf_: function (e) {
				var t = mk(e, "x", "erf");
				Dg("int32" === t.dtype || "float32" === t.dtype, function () {
					return "Input dtype must be `int32` or `float32`.";
				}),
					"int32" === t.dtype && (t = NN(t, "float32"));
				var n = { x: t };
				return ok.runKernel(ky, n);
			},
		}),
		fT = yk({
			exp_: function (e) {
				var t = { x: mk(e, "x", "exp") };
				return ok.runKernel(Iy, t);
			},
		}),
		dT = yk({
			expandDims_: function (e, t) {
				void 0 === t && (t = 0);
				var n = mk(e, "x", "expandDims", "string_or_numeric");
				Dg(t <= n.rank, function () {
					return "Axis must be <= rank of the tensor";
				});
				var r = { input: n },
					a = { dim: t };
				return ok.runKernel(Sy, r, a);
			},
		}),
		mT = yk({
			expm1_: function (e) {
				var t = { x: mk(e, "x", "expm1") };
				return ok.runKernel(Ty, t);
			},
		}),
		gT = yk({
			tile_: function (e, t) {
				var n = mk(e, "x", "tile", "string_or_numeric");
				Dg(n.rank === t.length, function () {
					return "Error in transpose: rank of input " + n.rank + " must match length of reps " + t + ".";
				});
				var r = { x: n },
					a = { reps: t };
				return ok.runKernel(dx, r, a);
			},
		}),
		vT = yk({
			eye_: function (e, t, n, r) {
				void 0 === r && (r = "float32"), null == t && (t = e);
				for (var a = kN([e, t], r), i = e <= t ? e : t, o = 0; o < i; ++o) a.set(1, o, o);
				var s = wS(a.toTensor(), [e, t]);
				if (null == n) return s;
				if (1 === n.length) return gT(dT(s, 0), [n[0], 1, 1]);
				if (2 === n.length) return gT(dT(dT(s, 0), 0), [n[0], n[1], 1, 1]);
				if (3 === n.length) return gT(dT(dT(dT(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
				throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n.length + "D.");
			},
		});
	function yT(e, t, n) {
		var r = { shape: e, value: t, dtype: n };
		return ok.runKernel(Ey, {}, r);
	}
	var bT = yk({
			floor_: function (e) {
				var t = { x: mk(e, "x", "floor", "float32") };
				return ok.runKernel(Ay, t);
			},
		}),
		xT = yk({
			gather_: function (e, t, n, r) {
				void 0 === n && (n = 0), void 0 === r && (r = 0);
				var a = { x: mk(e, "x", "gather"), indices: mk(t, "indices", "gather", "int32") },
					i = { axis: n, batchDims: r };
				return ok.runKernel(Dy, a, i);
			},
		}),
		wT = yk({
			greater_: function (e, t) {
				var n = mk(e, "a", "greater", "string_or_numeric"),
					r = mk(t, "b", "greater", "string_or_numeric"),
					a = Yw(n, r);
				(n = a[0]), (r = a[1]), JN(n.shape, r.shape);
				var i = { a: n, b: r };
				return ok.runKernel(My, i);
			},
		}),
		kT = yk({
			greaterEqual_: function (e, t) {
				var n = mk(e, "a", "greaterEqual", "string_or_numeric"),
					r = mk(t, "b", "greaterEqual", "string_or_numeric"),
					a = Yw(n, r);
				(n = a[0]), (r = a[1]), JN(n.shape, r.shape);
				var i = { a: n, b: r };
				return ok.runKernel(Ly, i);
			},
		}),
		NT = yk({
			imag_: function (e) {
				var t = { input: mk(e, "input", "imag") };
				return ok.runKernel(By, t);
			},
		}),
		IT = yk({
			isFinite_: function (e) {
				var t = { x: mk(e, "x", "isFinite") };
				return ok.runKernel(Wy, t);
			},
		}),
		ST = yk({
			isInf_: function (e) {
				var t = { x: mk(e, "x", "isInf") };
				return ok.runKernel(Uy, t);
			},
		}),
		TT = yk({
			isNaN_: function (e) {
				var t = { x: mk(e, "x", "isNaN") };
				return ok.runKernel(Vy, t);
			},
		}),
		CT = yk({
			leakyRelu_: function (e, t) {
				void 0 === t && (t = 0.2);
				var n = { x: mk(e, "x", "leakyRelu") },
					r = { alpha: t };
				return ok.runKernel(Gy, n, r);
			},
		}),
		ET = yk({
			less_: function (e, t) {
				var n = mk(e, "a", "less", "string_or_numeric"),
					r = mk(t, "b", "less", "string_or_numeric"),
					a = Yw(n, r);
				(n = a[0]), (r = a[1]), JN(n.shape, r.shape);
				var i = { a: n, b: r };
				return ok.runKernel(jy, i);
			},
		}),
		RT = yk({
			lessEqual_: function (e, t) {
				var n = mk(e, "a", "lessEqual", "string_or_numeric"),
					r = mk(t, "b", "lessEqual", "string_or_numeric"),
					a = Yw(n, r);
				(n = a[0]), (r = a[1]), JN(n.shape, r.shape);
				var i = { a: n, b: r };
				return ok.runKernel(Hy, i);
			},
		});
	function AT(e, t, n) {
		if (n <= 0) throw new Error("The number of values should be positive.");
		var r = { start: e, stop: t, num: n };
		return ok.runKernel(qy, {}, r);
	}
	var _T = yk({
			localResponseNormalization_: function (e, t, n, r, a) {
				void 0 === t && (t = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === a && (a = 0.5);
				var i = mk(e, "x", "localResponseNormalization");
				Dg(4 === i.rank || 3 === i.rank, function () {
					return (
						"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " +
						i.rank +
						"."
					);
				}),
					Dg(Bg(t), function () {
						return (
							"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " +
							t +
							"."
						);
					});
				var o = i,
					s = !1;
				3 === i.rank && ((s = !0), (o = wS(i, [1, i.shape[0], i.shape[1], i.shape[2]])));
				var u = { x: o },
					l = { depthRadius: t, bias: n, alpha: r, beta: a },
					c = ok.runKernel($y, u, l);
				return s ? wS(c, [c.shape[1], c.shape[2], c.shape[3]]) : c;
			},
		}),
		FT = yk({
			log_: function (e) {
				var t = { x: mk(e, "x", "log", "float32") };
				return ok.runKernel(Ky, t);
			},
		}),
		DT = yk({
			log1p_: function (e) {
				var t = { x: mk(e, "x", "log1p") };
				return ok.runKernel(Xy, t);
			},
		});
	function OT(e, t) {
		Dg(av(e), function () {
			return "The f passed in variableGrads(f) must be a function";
		}),
			Dg(
				null == t ||
					(Array.isArray(t) &&
						t.every(function (e) {
							return e instanceof Hw;
						})),
				function () {
					return "The varList passed in variableGrads(f, varList) must be an array of variables";
				}
			);
		var n = null != t;
		if (!n) for (var r in ((t = []), ok.registeredVariables)) t.push(ok.registeredVariables[r]);
		var a = n
				? t.filter(function (e) {
						return !e.trainable;
				  })
				: null,
			i = t.length;
		Dg(
			(t = t.filter(function (e) {
				return e.trainable;
			})).length > 0,
			function () {
				return (
					"variableGrads() expects at least one of the input variables to be trainable, but none of the " +
					i +
					" variables is trainable."
				);
			}
		);
		var o = ok.gradients(e, t, null, !0),
			s = o.value,
			u = o.grads;
		Dg(
			u.some(function (e) {
				return null != e;
			}),
			function () {
				return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
			}
		),
			Dg(0 === s.rank, function () {
				return (
					"The f passed in variableGrads(f) must return a scalar, but it returned a rank-" +
					s.rank +
					" tensor"
				);
			});
		var l = {};
		return (
			t.forEach(function (e, t) {
				null != u[t] && (l[e.name] = u[t]);
			}),
			null != a &&
				a.forEach(function (e) {
					return (l[e.name] = null);
				}),
			{ value: s, grads: l }
		);
	}
	function MT(e) {
		return ok.customGrad(e);
	}
	function LT(e) {
		if (
			e.filter(function (e) {
				return null == e;
			}).length > 0
		)
			throw new Error(
				"Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y."
			);
	}
	var zT = yk({
			neg_: function (e) {
				var t = { x: mk(e, "x", "neg") };
				return ok.runKernel(mb, t);
			},
		}),
		PT = yk({
			softplus_: function (e) {
				var t = { x: mk(e, "x", "softplus") };
				return ok.runKernel(Xb, t);
			},
		}),
		BT = yk({
			logSigmoid_: function (e) {
				var t = mk(e, "x", "logSigmoid");
				return MT(function (e) {
					return {
						value: zT(PT(zT(e))),
						gradFunc: function (t) {
							return KI(t, SS(zT(e)));
						},
					};
				})(t);
			},
		}),
		WT = yk({
			max_: function (e, t, n) {
				void 0 === t && (t = null), void 0 === n && (n = !1);
				var r = { x: mk(e, "x", "max") },
					a = { reductionIndices: t, keepDims: n };
				return ok.runKernel(tb, r, a);
			},
		}),
		UT = yk({
			sub_: function (e, t) {
				var n = mk(e, "a", "sub"),
					r = mk(t, "b", "sub"),
					a = Yw(n, r),
					i = { a: (n = a[0]), b: (r = a[1]) };
				return ok.runKernel(px, i);
			},
		}),
		VT = yk({
			sum_: function (e, t, n) {
				void 0 === t && (t = null), void 0 === n && (n = !1);
				var r = mk(e, "x", "sum");
				"bool" === r.dtype && (r = NN(r, "int32"));
				var a = { x: r },
					i = { axis: t, keepDims: n };
				return ok.runKernel(Jb, a, i);
			},
		}),
		GT = yk({
			logSoftmax_: function (e, t) {
				void 0 === t && (t = -1);
				var n = mk(e, "logits", "logSoftmax");
				if ((-1 === t && (t = n.rank - 1), t !== n.rank - 1))
					throw Error(
						"Log Softmax along a non-last dimension is not yet supported. Logits was rank " +
							n.rank +
							" and axis was " +
							t
					);
				return MT(function (e, n) {
					var r = WT(e, t, !0),
						a = UT(e, r),
						i = UT(NN(a, "float32"), FT(VT(fT(a), t, !0)));
					return (
						n([i]),
						{
							value: i,
							gradFunc: function (e, n) {
								var r = n[0],
									a = fT(r);
								return UT(e, KI(VT(e, t, !0), a));
							},
						}
					);
				})(n);
			},
		});
	function jT(e, t) {
		for (var n = 0; n < e.length; ++n) if (e[e.length - n - 1] !== t - 1 - n) return !1;
		return !0;
	}
	function HT(e, t, n) {
		for (var r = e.length + t.length, a = [], i = 0, o = 0, s = 0; s < r; s++)
			-1 === n.indexOf(s) ? a.push(e[i++]) : a.push(t[o++]);
		return a;
	}
	function qT(e, t) {
		for (var n = [], r = e.length, a = 0; a < r; a++) -1 === t.indexOf(a) && n.push(e[a]);
		return [
			n,
			t.map(function (t) {
				return e[t];
			}),
		];
	}
	function KT(e, t) {
		return HT(
			e,
			t.map(function (e) {
				return 1;
			}),
			t
		);
	}
	function XT(e, t, n) {
		Dg(jT(t, n), function () {
			return e + " supports only inner-most axes for now. Got axes " + t + " and rank-" + n + " input.";
		});
	}
	function YT(e, t) {
		if (jT(e, t)) return null;
		for (var n = [], r = 0; r < t; ++r) -1 === e.indexOf(r) && n.push(r);
		return (
			e.forEach(function (e) {
				return n.push(e);
			}),
			n
		);
	}
	function JT(e) {
		return e
			.map(function (e, t) {
				return [t, e];
			})
			.sort(function (e, t) {
				return e[1] - t[1];
			})
			.map(function (e) {
				return e[0];
			});
	}
	function ZT(e, t) {
		for (var n = [], r = t - e; r < t; ++r) n.push(r);
		return n;
	}
	var QT = yk({
			logSumExp_: function (e, t, n) {
				void 0 === t && (t = null), void 0 === n && (n = !1);
				var r = mk(e, "x", "logSumExp"),
					a = jg(t, r.shape),
					i = WT(r, a, !0),
					o = UT(r, i),
					s = fT(o),
					u = VT(s, a),
					l = FT(u),
					c = jI(wS(i, l.shape), l);
				if (n) {
					var p = KT(c.shape, a);
					return wS(c, p);
				}
				return c;
			},
		}),
		$T = yk({
			logicalAnd_: function (e, t) {
				var n = mk(e, "a", "logicalAnd", "bool"),
					r = mk(t, "b", "logicalAnd", "bool");
				JN(n.shape, r.shape);
				var a = { a: n, b: r };
				return ok.runKernel(Yy, a);
			},
		}),
		eC = yk({
			logicalNot_: function (e) {
				var t = { x: mk(e, "x", "logicalNot", "bool") };
				return ok.runKernel(Jy, t);
			},
		}),
		tC = yk({
			logicalOr_: function (e, t) {
				var n = mk(e, "a", "logicalOr", "bool"),
					r = mk(t, "b", "logicalOr", "bool");
				JN(n.shape, r.shape);
				var a = { a: n, b: r };
				return ok.runKernel(Zy, a);
			},
		}),
		nC = yk({
			logicalXor_: function (e, t) {
				var n = mk(e, "a", "logicalXor", "bool"),
					r = mk(t, "b", "logicalXor", "bool");
				return JN(n.shape, r.shape), $T(tC(e, t), eC($T(e, t)));
			},
		}),
		rC = yk({
			maxPool_: function (e, t, n, r, a) {
				var i = mk(e, "x", "maxPool"),
					o = i,
					s = !1;
				3 === i.rank && ((s = !0), (o = wS(i, [1, i.shape[0], i.shape[1], i.shape[2]]))),
					Dg(4 === o.rank, function () {
						return "Error in maxPool: input must be rank 4 but got rank " + o.rank + ".";
					}),
					Dg(yS(n, 1), function () {
						return (
							"Error in maxPool: Either strides or dilations must be 1. Got strides " +
							n +
							" and dilations '1'"
						);
					}),
					xS("maxPool", r, a);
				var u = { x: o },
					l = { filterSize: t, strides: n, pad: r, dimRoundingMode: a },
					c = ok.runKernel(rb, u, l);
				return s ? wS(c, [c.shape[1], c.shape[2], c.shape[3]]) : c;
			},
		}),
		aC = yk({
			maxPool3d_: function (e, t, n, r, a, i) {
				void 0 === t && (t = [1, 1, 1]), void 0 === i && (i = "NDHWC");
				var o = mk(e, "x", "maxPool3d"),
					s = o,
					u = !1;
				4 === o.rank && ((u = !0), (s = wS(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]))),
					Dg(5 === s.rank, function () {
						return "Error in maxPool3d: x must be rank 5 but got rank " + s.rank + ".";
					}),
					Dg("NDHWC" === i, function () {
						return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + i;
					}),
					xS("maxPool3d", r, a);
				var l = { x: s },
					c = { filterSize: t, strides: n, pad: r, dimRoundingMode: a, dataFormat: i },
					p = ok.runKernel(ib, l, c);
				return u ? wS(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p;
			},
		}),
		iC = yk({
			maxPoolWithArgmax_: function (e, t, n, r, a) {
				void 0 === a && (a = !1);
				var i = { x: mk(e, "x", "maxPoolWithArgmax") },
					o = { filterSize: t, strides: n, pad: r, includeBatchInIndex: a },
					s = ok.runKernel(sb, i, o);
				return { result: s[0], indexes: s[1] };
			},
		}),
		oC = yk({
			maximum_: function (e, t) {
				var n = mk(e, "a", "maximum"),
					r = mk(t, "b", "maximum"),
					a = Yw(n, r);
				(n = a[0]),
					(r = a[1]),
					"bool" === n.dtype && ((n = NN(n, "int32")), (r = NN(r, "int32"))),
					JN(n.shape, r.shape);
				var i = { a: n, b: r };
				return ok.runKernel(nb, i);
			},
		}),
		sC = yk({
			mean_: function (e, t, n) {
				void 0 === t && (t = null), void 0 === n && (n = !1);
				var r = { x: mk(e, "x", "mean") },
					a = { axis: t, keepDims: n };
				return ok.runKernel(ub, r, a);
			},
		});
	function uC(e, t) {
		if ((void 0 === t && (t = "float32"), "complex64" === t)) {
			var n = uC(e, "float32"),
				r = uC(e, "float32");
			return bk(n, r);
		}
		var a = cv(zg(e), t);
		return ok.makeTensor(a, e, t);
	}
	function lC(e, t) {
		if ((void 0 === t && (t = "float32"), "complex64" === t)) {
			var n = lC(e, "float32"),
				r = uC(e, "float32");
			return bk(n, r);
		}
		var a = lv(zg(e), t);
		return ok.makeTensor(a, e, t);
	}
	function cC(e, t, n) {
		var r = (void 0 === n ? {} : n).indexing,
			a = void 0 === r ? "xy" : r;
		if ("xy" !== a && "ij" !== a) throw new TypeError(a + " is not a valid third argument to meshgrid");
		if (void 0 === e) return [];
		var i = mk(e, "x", "meshgrid", e instanceof Pw ? e.dtype : "float32");
		if (void 0 === t) return [i];
		var o = mk(t, "y", "meshgrid", t instanceof Pw ? t.dtype : "float32"),
			s = zg(i.shape),
			u = zg(o.shape);
		return "xy" === a
			? ((i = wS(i, [1, -1])), (o = wS(o, [-1, 1])), [jN(lC([u, 1], i.dtype), i), jN(o, lC([1, s], o.dtype))])
			: ((i = wS(i, [-1, 1])), (o = wS(o, [1, -1])), [jN(i, lC([1, u], i.dtype)), jN(lC([s, 1], o.dtype), o)]);
	}
	var pC = yk({
			min_: function (e, t, n) {
				void 0 === t && (t = null), void 0 === n && (n = !1);
				var r = { x: mk(e, "x", "min") },
					a = { axis: t, keepDims: n };
				return ok.runKernel(lb, r, a);
			},
		}),
		hC = yk({
			minimum_: function (e, t) {
				var n = mk(e, "a", "minimum"),
					r = mk(t, "b", "minimum"),
					a = Yw(n, r);
				(n = a[0]),
					(r = a[1]),
					"bool" === n.dtype && ((n = NN(n, "int32")), (r = NN(r, "int32"))),
					JN(n.shape, r.shape);
				var i = { a: n, b: r };
				return ok.runKernel(cb, i);
			},
		}),
		fC = yk({
			mirrorPad_: function (e, t, n) {
				Dg("reflect" === n || "symmetric" === n, function () {
					return "Invalid mode. Mode must be either reflect or symmetric. Got " + n + ".";
				});
				var r = mk(e, "x", "mirrorPad");
				if (0 === r.rank) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
				Dg(t.length === r.rank, function () {
					return "Padding doesn't match input. Must be " + r.rank + ". Got " + t.length + ".";
				});
				for (
					var a = "reflect" === n ? 1 : 0,
						i = function (e) {
							Dg(2 === t[e].length, function () {
								return "Invalid number of paddings. Must be length of 2 each.";
							}),
								Dg(
									t[e][0] >= 0 &&
										t[e][0] <= r.shape[e] - a &&
										t[e][1] >= 0 &&
										t[e][1] <= r.shape[e] - a,
									function () {
										return (
											"Padding in dimension " +
											e +
											" cannot be greater than or equal to " +
											(r.shape[e] - a) +
											" or less than 0 for input of shape " +
											r.shape
										);
									}
								);
						},
						o = 0;
					o < r.rank;
					o++
				)
					i(o);
				var s = { paddings: t, mode: n },
					u = { x: r };
				return ok.runKernel(pb, u, s);
			},
		}),
		dC = yk({
			mod_: function (e, t) {
				var n = mk(e, "a", "mod"),
					r = mk(t, "b", "mod"),
					a = Yw(n, r),
					i = { a: (n = a[0]), b: (r = a[1]) };
				return ok.runKernel(hb, i);
			},
		}),
		mC = yk({
			square_: function (e) {
				var t = mk(e, "x", "square");
				return ok.runKernel("Square", { x: t }, {});
			},
		}),
		gC = yk({
			moments_: function (e, t, n) {
				void 0 === t && (t = null), void 0 === n && (n = !1);
				var r = jg(t, (e = mk(e, "x", "moments")).shape),
					a = sC(e, r, n),
					i = a.shape;
				n || (i = KT(a.shape, r));
				var o = mC(UT(NN(e, "float32"), wS(a, i)));
				return { mean: a, variance: sC(o, r, n) };
			},
		}),
		vC = yk({
			multiRNNCell_: function (e, t, n, r) {
				for (
					var a = mk(t, "data", "multiRNNCell"),
						i = gk(n, "c", "multiRNNCell"),
						o = gk(r, "h", "multiRNNCell"),
						s = a,
						u = [],
						l = 0;
					l < e.length;
					l++
				) {
					var c = e[l](s, i[l], o[l]);
					u.push(c[0]), u.push(c[1]), (s = c[1]);
				}
				for (var p = [], h = [], f = 0; f < u.length; f += 2) p.push(u[f]), h.push(u[f + 1]);
				return [p, h];
			},
		}),
		yC = yk({
			multinomial_: function (e, t, n, r) {
				void 0 === r && (r = !1);
				var a = mk(e, "logits", "multinomial"),
					i = a.size,
					o = a.rank;
				if (i < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + i + ".");
				if (o > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + o);
				n = n || Math.random();
				var s = { logits: 1 === o ? wS(a, [1, -1]) : a },
					u = { numSamples: t, seed: n, normalized: r },
					l = ok.runKernel(fb, s, u);
				return 1 === o ? wS(l, [l.size]) : l;
			},
		}),
		bC = yk({
			notEqual_: function (e, t) {
				var n = mk(e, "a", "notEqual", "string_or_numeric"),
					r = mk(t, "b", "notEqual", "string_or_numeric"),
					a = Yw(n, r);
				(n = a[0]), (r = a[1]), JN(n.shape, r.shape);
				var i = { a: n, b: r };
				return ok.runKernel(gb, i);
			},
		}),
		xC = yk({
			onesLike_: function (e) {
				var t = { x: mk(e, "x", "onesLike") };
				return ok.runKernel(xb, t);
			},
		}),
		wC = yk({
			outerProduct_: function (e, t) {
				var n = mk(e, "v1", "outerProduct"),
					r = mk(t, "v2", "outerProduct");
				Dg(1 === n.rank && 1 === r.rank, function () {
					return (
						"Error in outerProduct: inputs must be rank 1, but got ranks " + n.rank + " and " + r.rank + "."
					);
				});
				var a = wS(n, [-1, 1]),
					i = wS(r, [1, -1]);
				return jN(a, i);
			},
		}),
		kC = yk({
			pad_: function (e, t, n) {
				void 0 === n && (n = 0);
				var r = mk(e, "x", "pad");
				if (0 === r.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
				var a = { paddings: t, constantValue: n },
					i = { x: r };
				return ok.runKernel(Nb, i, a);
			},
		}),
		NC = yk({
			pad1d_: function (e, t, n) {
				return (
					void 0 === n && (n = 0),
					Dg(2 === t.length, function () {
						return "Invalid number of paddings. Must be length of 2.";
					}),
					kC(e, [t], n)
				);
			},
		}),
		IC = yk({
			pad2d_: function (e, t, n) {
				return (
					void 0 === n && (n = 0),
					Dg(2 === t.length && 2 === t[0].length && 2 === t[1].length, function () {
						return "Invalid number of paddings. Must be length of 2 each.";
					}),
					kC(e, t, n)
				);
			},
		}),
		SC = yk({
			pad3d_: function (e, t, n) {
				return (
					void 0 === n && (n = 0),
					Dg(3 === t.length && 2 === t[0].length && 2 === t[1].length && 2 === t[2].length, function () {
						return "Invalid number of paddings. Must be length of 2 each.";
					}),
					kC(e, t, n)
				);
			},
		}),
		TC = yk({
			pad4d_: function (e, t, n) {
				return (
					void 0 === n && (n = 0),
					Dg(
						4 === t.length &&
							2 === t[0].length &&
							2 === t[1].length &&
							2 === t[2].length &&
							2 === t[3].length,
						function () {
							return "Invalid number of paddings. Must be length of 2 each.";
						}
					),
					kC(e, t, n)
				);
			},
		}),
		CC = yk({
			spaceToBatchND_: function (e, t, n) {
				var r = mk(e, "x", "spaceToBatchND");
				Dg(r.rank >= 1 + t.length, function () {
					return "input rank " + r.rank + " should be > than [blockShape] " + t.length;
				}),
					Dg(n.length === t.length, function () {
						return "paddings.shape[0] " + n.length + " must be equal to [blockShape] " + t.length;
					}),
					Dg(
						r.shape.reduce(function (e, r, a) {
							return a > 0 && a <= t.length ? e && (r + n[a - 1][0] + n[a - 1][1]) % t[a - 1] == 0 : e;
						}, !0),
						function () {
							return (
								"input spatial dimensions " +
								r.shape.slice(1) +
								" with paddings " +
								n.toString() +
								" must be divisible by blockShapes " +
								t.toString()
							);
						}
					);
				var a = { x: r },
					i = { blockShape: t, paddings: n };
				return ok.runKernel(Zb, a, i);
			},
		}),
		EC = yk({
			pool_: function (e, t, n, r, a, i, o) {
				null == a && (a = [1, 1]), null == i && (i = 1), 0 === r && (r = "valid");
				var s = mk(e, "x", "maxPool"),
					u = s,
					l = !1;
				3 === s.rank && ((l = !0), (u = wS(s, [1, s.shape[0], s.shape[1], s.shape[2]]))),
					Dg(yS(i, a), function () {
						return (
							"Error in pool: Either strides or dilations must be 1. Got strides " +
							i +
							" and dilations '" +
							a +
							"'"
						);
					});
				var c,
					p = uS(u.shape, t, i, a, r),
					h = [p.dilationHeight, p.dilationWidth];
				c =
					"same" === r
						? (function (e, t) {
								var n = e
										.map(function (e, n) {
											return e + (e - 1) * (t[n] - 1);
										})
										.map(function (e) {
											return e - 1;
										}),
									r = n.map(function (e) {
										return Math.floor(e / 2);
									}),
									a = n.map(function (e, t) {
										return e - r[t];
									});
								return n.map(function (e, t) {
									return [r[t], a[t]];
								});
						  })([p.filterHeight, p.filterWidth], h)
						: [
								[0, 0],
								[0, 0],
						  ];
				var f = 1 === h[0] && 1 === h[1],
					d = (function (e, t, n) {
						var r = n.map(function (e) {
								return e[0];
							}),
							a = n.map(function (e) {
								return e[1];
							}),
							i = e.concat(r, a),
							o = t.map(function (e, t) {
								return (e - (i[t] % e)) % e;
							}),
							s = a.map(function (e, t) {
								return e + o[t];
							});
						return [
							t.map(function (e, t) {
								return [r[t], s[t]];
							}),
							t.map(function (e, t) {
								return [0, o[t]];
							}),
						];
					})([p.inHeight, p.inWidth], h, c),
					m = d[0],
					g = d[1],
					v = f ? r : "valid",
					y = f ? u : CC(u, h, m),
					b = (
						"avg" === n
							? function () {
									return kS(y, t, i, v, o);
							  }
							: function () {
									return rC(y, t, i, v, o);
							  }
					)(),
					x = f ? b : RS(b, h, g);
				return l ? wS(x, [x.shape[1], x.shape[2], x.shape[3]]) : x;
			},
		}),
		RC = yk({
			pow_: function (e, t) {
				var n = mk(e, "base", "pow"),
					r = mk(t, "exp", "pow"),
					a = Yw(n, r),
					i = { a: (n = a[0]), b: (r = a[1]) };
				return ok.runKernel(Ib, i);
			},
		}),
		AC = yk({
			prelu_: function (e, t) {
				var n = { x: mk(e, "x", "prelu"), alpha: mk(t, "alpha", "prelu") };
				return ok.runKernel(Sb, n);
			},
		}),
		_C = yk({
			prod_: function (e, t, n) {
				void 0 === t && (t = null), void 0 === n && (n = !1);
				var r = mk(e, "x", "prod");
				"bool" === r.dtype && (r = NN(r, "int32"));
				var a = { x: r },
					i = { axis: t, keepDims: n };
				return ok.runKernel(Tb, a, i);
			},
		}),
		FC = yk({
			rand_: function (e, t, n) {
				var r = zg(e),
					a = null;
				if (null == n || "float32" === n) a = new Float32Array(r);
				else if ("int32" === n) a = new Int32Array(r);
				else {
					if ("bool" !== n) throw new Error("Unknown data type " + n);
					a = new Uint8Array(r);
				}
				for (var i = 0; i < r; i++) a[i] = t();
				return ok.makeTensor(a, e, n);
			},
		}),
		DC = n(function (e) {
			!(function (e, t, n) {
				function r(e) {
					var t,
						n = this,
						r =
							((t = 4022871197),
							function (e) {
								e = e.toString();
								for (var n = 0; n < e.length; n++) {
									var r = 0.02519603282416938 * (t += e.charCodeAt(n));
									(r -= t = r >>> 0), (t = (r *= t) >>> 0), (t += 4294967296 * (r -= t));
								}
								return 2.3283064365386963e-10 * (t >>> 0);
							});
					(n.next = function () {
						var e = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
						return (n.s0 = n.s1), (n.s1 = n.s2), (n.s2 = e - (n.c = 0 | e));
					}),
						(n.c = 1),
						(n.s0 = r(" ")),
						(n.s1 = r(" ")),
						(n.s2 = r(" ")),
						(n.s0 -= r(e)),
						n.s0 < 0 && (n.s0 += 1),
						(n.s1 -= r(e)),
						n.s1 < 0 && (n.s1 += 1),
						(n.s2 -= r(e)),
						n.s2 < 0 && (n.s2 += 1),
						(r = null);
				}
				function a(e, t) {
					return (t.c = e.c), (t.s0 = e.s0), (t.s1 = e.s1), (t.s2 = e.s2), t;
				}
				function i(e, t) {
					var n = new r(e),
						i = t && t.state,
						o = n.next;
					return (
						(o.int32 = function () {
							return (4294967296 * n.next()) | 0;
						}),
						(o.double = function () {
							return o() + 11102230246251565e-32 * ((2097152 * o()) | 0);
						}),
						(o.quick = o),
						i &&
							("object" == typeof i && a(i, n),
							(o.state = function () {
								return a(n, {});
							})),
						o
					);
				}
				t && t.exports ? (t.exports = i) : (this.alea = i);
			})(0, e);
		}),
		OC = n(function (e) {
			!(function (e, t, n) {
				function r(e) {
					var t = this,
						n = "";
					(t.x = 0),
						(t.y = 0),
						(t.z = 0),
						(t.w = 0),
						(t.next = function () {
							var e = t.x ^ (t.x << 11);
							return (t.x = t.y), (t.y = t.z), (t.z = t.w), (t.w ^= (t.w >>> 19) ^ e ^ (e >>> 8));
						}),
						e === (0 | e) ? (t.x = e) : (n += e);
					for (var r = 0; r < n.length + 64; r++) (t.x ^= 0 | n.charCodeAt(r)), t.next();
				}
				function a(e, t) {
					return (t.x = e.x), (t.y = e.y), (t.z = e.z), (t.w = e.w), t;
				}
				function i(e, t) {
					var n = new r(e),
						i = t && t.state,
						o = function () {
							return (n.next() >>> 0) / 4294967296;
						};
					return (
						(o.double = function () {
							do {
								var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
							} while (0 === e);
							return e;
						}),
						(o.int32 = n.next),
						(o.quick = o),
						i &&
							("object" == typeof i && a(i, n),
							(o.state = function () {
								return a(n, {});
							})),
						o
					);
				}
				t && t.exports ? (t.exports = i) : (this.xor128 = i);
			})(0, e);
		}),
		MC = n(function (e) {
			!(function (e, t, n) {
				function r(e) {
					var t = this,
						n = "";
					(t.next = function () {
						var e = t.x ^ (t.x >>> 2);
						return (
							(t.x = t.y),
							(t.y = t.z),
							(t.z = t.w),
							(t.w = t.v),
							((t.d = (t.d + 362437) | 0) + (t.v = t.v ^ (t.v << 4) ^ e ^ (e << 1))) | 0
						);
					}),
						(t.x = 0),
						(t.y = 0),
						(t.z = 0),
						(t.w = 0),
						(t.v = 0),
						e === (0 | e) ? (t.x = e) : (n += e);
					for (var r = 0; r < n.length + 64; r++)
						(t.x ^= 0 | n.charCodeAt(r)), r == n.length && (t.d = (t.x << 10) ^ (t.x >>> 4)), t.next();
				}
				function a(e, t) {
					return (t.x = e.x), (t.y = e.y), (t.z = e.z), (t.w = e.w), (t.v = e.v), (t.d = e.d), t;
				}
				function i(e, t) {
					var n = new r(e),
						i = t && t.state,
						o = function () {
							return (n.next() >>> 0) / 4294967296;
						};
					return (
						(o.double = function () {
							do {
								var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
							} while (0 === e);
							return e;
						}),
						(o.int32 = n.next),
						(o.quick = o),
						i &&
							("object" == typeof i && a(i, n),
							(o.state = function () {
								return a(n, {});
							})),
						o
					);
				}
				t && t.exports ? (t.exports = i) : (this.xorwow = i);
			})(0, e);
		}),
		LC = n(function (e) {
			!(function (e, t, n) {
				function r(e) {
					var t = this;
					(t.next = function () {
						var e,
							n,
							r = t.x,
							a = t.i;
						return (
							(e = r[a]),
							(n = (e ^= e >>> 7) ^ (e << 24)),
							(n ^= (e = r[(a + 1) & 7]) ^ (e >>> 10)),
							(n ^= (e = r[(a + 3) & 7]) ^ (e >>> 3)),
							(n ^= (e = r[(a + 4) & 7]) ^ (e << 7)),
							(e = r[(a + 7) & 7]),
							(n ^= (e ^= e << 13) ^ (e << 9)),
							(r[a] = n),
							(t.i = (a + 1) & 7),
							n
						);
					}),
						(function (e, t) {
							var n,
								r = [];
							if (t === (0 | t)) r[0] = t;
							else
								for (t = "" + t, n = 0; n < t.length; ++n)
									r[7 & n] = (r[7 & n] << 15) ^ ((t.charCodeAt(n) + r[(n + 1) & 7]) << 13);
							for (; r.length < 8; ) r.push(0);
							for (n = 0; n < 8 && 0 === r[n]; ++n);
							for (8 == n ? (r[7] = -1) : r[n], e.x = r, e.i = 0, n = 256; n > 0; --n) e.next();
						})(t, e);
				}
				function a(e, t) {
					return (t.x = e.x.slice()), (t.i = e.i), t;
				}
				function i(e, t) {
					null == e && (e = +new Date());
					var n = new r(e),
						i = t && t.state,
						o = function () {
							return (n.next() >>> 0) / 4294967296;
						};
					return (
						(o.double = function () {
							do {
								var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
							} while (0 === e);
							return e;
						}),
						(o.int32 = n.next),
						(o.quick = o),
						i &&
							(i.x && a(i, n),
							(o.state = function () {
								return a(n, {});
							})),
						o
					);
				}
				t && t.exports ? (t.exports = i) : (this.xorshift7 = i);
			})(0, e);
		}),
		zC = n(function (e) {
			!(function (e, t, n) {
				function r(e) {
					var t = this;
					(t.next = function () {
						var e,
							n,
							r = t.w,
							a = t.X,
							i = t.i;
						return (
							(t.w = r = (r + 1640531527) | 0),
							(n = a[(i + 34) & 127]),
							(e = a[(i = (i + 1) & 127)]),
							(n ^= n << 13),
							(e ^= e << 17),
							(n ^= n >>> 15),
							(e ^= e >>> 12),
							(n = a[i] = n ^ e),
							(t.i = i),
							(n + (r ^ (r >>> 16))) | 0
						);
					}),
						(function (e, t) {
							var n,
								r,
								a,
								i,
								o,
								s = [],
								u = 128;
							for (
								t === (0 | t)
									? ((r = t), (t = null))
									: ((t += "\0"), (r = 0), (u = Math.max(u, t.length))),
									a = 0,
									i = -32;
								i < u;
								++i
							)
								t && (r ^= t.charCodeAt((i + 32) % t.length)),
									0 === i && (o = r),
									(r ^= r << 10),
									(r ^= r >>> 15),
									(r ^= r << 4),
									(r ^= r >>> 13),
									i >= 0 &&
										((o = (o + 1640531527) | 0), (a = 0 == (n = s[127 & i] ^= r + o) ? a + 1 : 0));
							for (a >= 128 && (s[127 & ((t && t.length) || 0)] = -1), a = 127, i = 512; i > 0; --i)
								(r = s[(a + 34) & 127]),
									(n = s[(a = (a + 1) & 127)]),
									(r ^= r << 13),
									(n ^= n << 17),
									(r ^= r >>> 15),
									(n ^= n >>> 12),
									(s[a] = r ^ n);
							(e.w = o), (e.X = s), (e.i = a);
						})(t, e);
				}
				function a(e, t) {
					return (t.i = e.i), (t.w = e.w), (t.X = e.X.slice()), t;
				}
				function i(e, t) {
					null == e && (e = +new Date());
					var n = new r(e),
						i = t && t.state,
						o = function () {
							return (n.next() >>> 0) / 4294967296;
						};
					return (
						(o.double = function () {
							do {
								var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
							} while (0 === e);
							return e;
						}),
						(o.int32 = n.next),
						(o.quick = o),
						i &&
							(i.X && a(i, n),
							(o.state = function () {
								return a(n, {});
							})),
						o
					);
				}
				t && t.exports ? (t.exports = i) : (this.xor4096 = i);
			})(0, e);
		}),
		PC = n(function (e) {
			!(function (e, t, n) {
				function r(e) {
					var t = this,
						n = "";
					(t.next = function () {
						var e = t.b,
							n = t.c,
							r = t.d,
							a = t.a;
						return (
							(e = (e << 25) ^ (e >>> 7) ^ n),
							(n = (n - r) | 0),
							(r = (r << 24) ^ (r >>> 8) ^ a),
							(a = (a - e) | 0),
							(t.b = e = (e << 20) ^ (e >>> 12) ^ n),
							(t.c = n = (n - r) | 0),
							(t.d = (r << 16) ^ (n >>> 16) ^ a),
							(t.a = (a - e) | 0)
						);
					}),
						(t.a = 0),
						(t.b = 0),
						(t.c = -1640531527),
						(t.d = 1367130551),
						e === Math.floor(e) ? ((t.a = (e / 4294967296) | 0), (t.b = 0 | e)) : (n += e);
					for (var r = 0; r < n.length + 20; r++) (t.b ^= 0 | n.charCodeAt(r)), t.next();
				}
				function a(e, t) {
					return (t.a = e.a), (t.b = e.b), (t.c = e.c), (t.d = e.d), t;
				}
				function i(e, t) {
					var n = new r(e),
						i = t && t.state,
						o = function () {
							return (n.next() >>> 0) / 4294967296;
						};
					return (
						(o.double = function () {
							do {
								var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
							} while (0 === e);
							return e;
						}),
						(o.int32 = n.next),
						(o.quick = o),
						i &&
							("object" == typeof i && a(i, n),
							(o.state = function () {
								return a(n, {});
							})),
						o
					);
				}
				t && t.exports ? (t.exports = i) : (this.tychei = i);
			})(0, e);
		}),
		BC = n(function (e) {
			!(function (t, n) {
				var r,
					a = this,
					i = 256,
					o = n.pow(i, 6),
					s = n.pow(2, 52),
					u = 2 * s,
					l = 255;
				function c(e, l, c) {
					var g = [],
						v = d(
							f(
								(l = 1 == l ? { entropy: !0 } : l || {}).entropy
									? [e, m(t)]
									: null == e
									? (function () {
											try {
												var e;
												return (
													r && (e = r.randomBytes)
														? (e = e(i))
														: ((e = new Uint8Array(i)),
														  (a.crypto || a.msCrypto).getRandomValues(e)),
													m(e)
												);
											} catch (e) {
												var n = a.navigator,
													o = n && n.plugins;
												return [+new Date(), a, o, a.screen, m(t)];
											}
									  })()
									: e,
								3
							),
							g
						),
						y = new p(g),
						b = function () {
							for (var e = y.g(6), t = o, n = 0; e < s; ) (e = (e + n) * i), (t *= i), (n = y.g(1));
							for (; e >= u; ) (e /= 2), (t /= 2), (n >>>= 1);
							return (e + n) / t;
						};
					return (
						(b.int32 = function () {
							return 0 | y.g(4);
						}),
						(b.quick = function () {
							return y.g(4) / 4294967296;
						}),
						(b.double = b),
						d(m(y.S), t),
						(
							l.pass ||
							c ||
							function (e, t, r, a) {
								return (
									a &&
										(a.S && h(a, y),
										(e.state = function () {
											return h(y, {});
										})),
									r ? ((n.random = e), t) : e
								);
							}
						)(b, v, "global" in l ? l.global : this == n, l.state)
					);
				}
				function p(e) {
					var t,
						n = e.length,
						r = this,
						a = 0,
						o = (r.i = r.j = 0),
						s = (r.S = []);
					for (n || (e = [n++]); a < i; ) s[a] = a++;
					for (a = 0; a < i; a++) (s[a] = s[(o = l & (o + e[a % n] + (t = s[a])))]), (s[o] = t);
					(r.g = function (e) {
						for (var t, n = 0, a = r.i, o = r.j, s = r.S; e--; )
							(t = s[(a = l & (a + 1))]),
								(n = n * i + s[l & ((s[a] = s[(o = l & (o + t))]) + (s[o] = t))]);
						return (r.i = a), (r.j = o), n;
					})(i);
				}
				function h(e, t) {
					return (t.i = e.i), (t.j = e.j), (t.S = e.S.slice()), t;
				}
				function f(e, t) {
					var n,
						r = [],
						a = typeof e;
					if (t && "object" == a)
						for (n in e)
							try {
								r.push(f(e[n], t - 1));
							} catch (e) {}
					return r.length ? r : "string" == a ? e : e + "\0";
				}
				function d(e, t) {
					for (var n, r = e + "", a = 0; a < r.length; )
						t[l & a] = l & ((n ^= 19 * t[l & a]) + r.charCodeAt(a++));
					return m(t);
				}
				function m(e) {
					return String.fromCharCode.apply(0, e);
				}
				if (((n.seedrandom = c), d(n.random(), t), e.exports)) {
					e.exports = c;
					try {
						r = require("crypto");
					} catch (e) {}
				}
			})([], Math);
		});
	(BC.alea = DC), (BC.xor128 = OC), (BC.xorwow = MC), (BC.xorshift7 = LC), (BC.xor4096 = zC), (BC.tychei = PC);
	var WC = BC.alea,
		UC = (function () {
			function e(e, t, n, r, a) {
				(this.mean = e),
					(this.stdDev = t),
					(this.dtype = n),
					(this.nextVal = NaN),
					(this.truncated = r),
					this.truncated &&
						((this.upper = this.mean + 2 * this.stdDev), (this.lower = this.mean - 2 * this.stdDev));
				var i = a || Math.random();
				this.random = WC(i.toString());
			}
			var t = e.prototype;
			return (
				(t.nextValue = function () {
					if (!isNaN(this.nextVal)) {
						var e = this.nextVal;
						return (this.nextVal = NaN), e;
					}
					for (var t, n, r = !1; !r; ) {
						var a = void 0,
							i = void 0,
							o = void 0;
						do {
							o = (a = 2 * this.random() - 1) * a + (i = 2 * this.random() - 1) * i;
						} while (o >= 1 || 0 === o);
						var s = Math.sqrt((-2 * Math.log(o)) / o);
						(t = this.mean + this.stdDev * a * s),
							(n = this.mean + this.stdDev * i * s),
							(this.truncated && !this.isValidTruncated(t)) || (r = !0);
					}
					return (
						(this.truncated && !this.isValidTruncated(n)) || (this.nextVal = this.convertValue(n)),
						this.convertValue(t)
					);
				}),
				(t.convertValue = function (e) {
					return null == this.dtype || "float32" === this.dtype ? e : Math.round(e);
				}),
				(t.isValidTruncated = function (e) {
					return e <= this.upper && e >= this.lower;
				}),
				e
			);
		})(),
		VC = (function () {
			function e(e, t, n, r) {
				(this.alpha = e), (this.beta = 1 / t), (this.dtype = n);
				var a = r || Math.random();
				(this.randu = WC(a.toString())),
					(this.randn = new UC(0, 1, n, !1, this.randu())),
					(this.d = e < 1 ? e + 2 / 3 : e - 1 / 3),
					(this.c = 1 / Math.sqrt(9 * this.d));
			}
			var t = e.prototype;
			return (
				(t.nextValue = function () {
					for (var e, t, n, r, a, i; ; ) {
						do {
							(r = this.randn.nextValue()), (i = 1 + this.c * r);
						} while (i <= 0);
						if (
							((i *= i * i),
							(t = 1 - 0.331 * (e = r * r) * e),
							(n = 0.5 * e + this.d * (1 - i + Math.log(i))),
							(a = this.randu()) < t || Math.log(a) < n)
						)
							break;
					}
					return (
						(i = (1 / this.beta) * this.d * i),
						this.alpha < 1 && (i *= Math.pow(this.randu(), 1 / this.alpha)),
						this.convertValue(i)
					);
				}),
				(t.convertValue = function (e) {
					return "float32" === this.dtype ? e : Math.round(e);
				}),
				e
			);
		})(),
		GC = (function () {
			function e(e, t, n, r) {
				var a = this;
				if (
					(void 0 === e && (e = 0),
					void 0 === t && (t = 1),
					(this.canReturnFloat = function () {
						return null == a.dtype || "float32" === a.dtype;
					}),
					(this.min = e),
					(this.range = t - e),
					(this.dtype = n),
					null == r && (r = Math.random()),
					"number" == typeof r && (r = r.toString()),
					!this.canReturnFloat() && this.range <= 1)
				)
					throw new Error("The difference between " + e + " - " + t + " <= 1 and dtype is not float");
				this.random = WC(r);
			}
			var t = e.prototype;
			return (
				(t.convertValue = function (e) {
					return this.canReturnFloat() ? e : Math.round(e);
				}),
				(t.nextValue = function () {
					return this.convertValue(this.min + this.range * this.random());
				}),
				e
			);
		})(),
		jC = yk({
			randomGamma_: function (e, t, n, r, a) {
				if (
					(void 0 === n && (n = 1),
					void 0 === r && (r = "float32"),
					null == n && (n = 1),
					null == r && (r = "float32"),
					"float32" !== r && "int32" !== r)
				)
					throw new Error("Unsupported data type " + r);
				for (var i = new VC(t, n, r, a), o = kN(e, r), s = 0; s < o.values.length; s++)
					o.values[s] = i.nextValue();
				return o.toTensor();
			},
		}),
		HC = yk({
			randomNormal_: function (e, t, n, r, a) {
				if ((void 0 === t && (t = 0), void 0 === n && (n = 1), null != r && "bool" === r))
					throw new Error("Unsupported data type " + r);
				for (var i = new UC(t, n, r, !1, a), o = kN(e, r), s = 0; s < o.values.length; s++)
					o.values[s] = i.nextValue();
				return o.toTensor();
			},
		}),
		qC = yk({
			randomUniform_: function (e, t, n, r, a) {
				void 0 === t && (t = 0), void 0 === n && (n = 1), void 0 === r && (r = "float32");
				for (var i = kN(e, r), o = new GC(t, n, null, a), s = 0; s < i.values.length; s++)
					i.values[s] = o.nextValue();
				return i.toTensor();
			},
		});
	function KC(e, t, n, r) {
		if ((void 0 === n && (n = 1), void 0 === r && (r = "float32"), 0 === n))
			throw new Error("Cannot have a step of zero");
		var a = { start: e, stop: t, step: n, dtype: r };
		return ok.runKernel(Cb, {}, a);
	}
	var XC = yk({
			real_: function (e) {
				var t = { input: mk(e, "input", "real") };
				return ok.runKernel(Eb, t);
			},
		}),
		YC = yk({
			reciprocal_: function (e) {
				var t = { x: mk(e, "x", "reciprocal") };
				return ok.runKernel(Rb, t);
			},
		}),
		JC = yk({
			relu_: function (e) {
				var t = { x: mk(e, "x", "relu") };
				return ok.runKernel(Ab, t);
			},
		}),
		ZC = yk({
			relu6_: function (e) {
				var t = { x: mk(e, "x", "relu6") };
				return ok.runKernel(Lb, t);
			},
		}),
		QC = yk({
			reverse_: function (e, t) {
				var n = { x: mk(e, "x", "reverse") },
					r = { dims: t };
				return ok.runKernel(zb, n, r);
			},
		}),
		$C = yk({
			reverse1d_: function (e) {
				var t = mk(e, "x", "reverse");
				return (
					Dg(1 === t.rank, function () {
						return "Error in reverse1D: x must be rank 1 but got rank " + t.rank + ".";
					}),
					QC(t, 0)
				);
			},
		}),
		eE = yk({
			reverse2d_: function (e, t) {
				var n = mk(e, "x", "reverse");
				return (
					Dg(2 === n.rank, function () {
						return "Error in reverse2D: x must be rank 2 but got rank " + n.rank + ".";
					}),
					QC(n, t)
				);
			},
		}),
		tE = yk({
			reverse3d_: function (e, t) {
				var n = mk(e, "x", "reverse");
				return (
					Dg(3 === n.rank, function () {
						return "Error in reverse3D: x must be rank 3 but got rank " + n.rank + ".";
					}),
					QC(n, t)
				);
			},
		}),
		nE = yk({
			reverse4d_: function (e, t) {
				var n = mk(e, "x", "reverse");
				return (
					Dg(4 === n.rank, function () {
						return "Error in reverse4D: x must be rank 4 but got rank " + n.rank + ".";
					}),
					QC(n, t)
				);
			},
		}),
		rE = yk({
			round_: function (e) {
				var t = { x: mk(e, "x", "round") };
				return ok.runKernel(Pb, t);
			},
		}),
		aE = yk({
			rsqrt_: function (e) {
				var t = { x: mk(e, "x", "rsqrt", "float32") };
				return ok.runKernel(Bb, t);
			},
		});
	function iE(e, t) {
		if (((Zg(e) && "string" !== t) || Array.isArray(e)) && "complex64" !== t)
			throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
		if ("string" === t && Zg(e) && !(e instanceof Uint8Array))
			throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
		return xk(e, [], [], t);
	}
	var oE = yk({
			selu_: function (e) {
				var t = { x: mk(e, "x", "selu") };
				return ok.runKernel(Vb, t);
			},
		}),
		sE = yk({
			separableConv2d_: function (e, t, n, r, a, i, o) {
				void 0 === i && (i = [1, 1]), void 0 === o && (o = "NHWC");
				var s = mk(e, "x", "separableConv2d"),
					u = mk(t, "depthwiseFilter", "separableConv2d"),
					l = mk(n, "pointwiseFilter", "separableConv2d"),
					c = s,
					p = !1;
				if ((3 === s.rank && ((p = !0), (c = wS(s, [1, s.shape[0], s.shape[1], s.shape[2]]))), "NCHW" === o))
					throw new Error(
						"separableConv2d currently does not support dataFormat NCHW; only NHWC is supported"
					);
				Dg(4 === c.rank, function () {
					return "Error in separableConv2d: input must be rank 4, but got rank " + c.rank + ".";
				}),
					Dg(4 === u.rank, function () {
						return (
							"Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u.rank + "."
						);
					}),
					Dg(4 === l.rank, function () {
						return (
							"Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u.rank + "."
						);
					}),
					Dg(1 === l.shape[0], function () {
						return (
							"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " +
							l.shape[0] +
							"."
						);
					}),
					Dg(1 === l.shape[1], function () {
						return (
							"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " +
							l.shape[1] +
							"."
						);
					});
				var h = u.shape[2],
					f = u.shape[3];
				Dg(l.shape[2] === h * f, function () {
					return (
						"Error in separableConv2d: the third dimension of pointwise filter must be " +
						h * f +
						", but got " +
						l.shape[2] +
						"."
					);
				});
				var d = nT(c, u, r, a, o, i),
					m = GS(d, l, 1, "valid", o);
				return p ? wS(m, [m.shape[1], m.shape[2], m.shape[3]]) : m;
			},
		});
	function uE() {
		return (uE = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r, a, i, o, s, u, l, c, p, h, f;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (
									(r = mk(t, "x", "setdiff1d")),
									(a = mk(n, "y", "setdiff1d")),
									Dg(r.dtype === a.dtype, function () {
										return (
											"x and y should have the same dtype, but got x (" +
											r.dtype +
											") and y (" +
											a.dtype +
											")."
										);
									}),
									Dg(1 === r.rank, function () {
										return "x should be 1D tensor, but got x (" + r.shape + ").";
									}),
									Dg(1 === a.rank, function () {
										return "y should be 1D tensor, but got y (" + a.shape + ").";
									}),
									(e.next = 7),
									r.data()
								);
							case 7:
								return (i = e.sent), (e.next = 10), a.data();
							case 10:
								for (o = e.sent, s = new Set(o), u = 0, l = 0; l < i.length; l++) s.has(i[l]) || u++;
								for (
									c = new Mw([u], r.dtype), p = new Mw([u], "int32"), h = 0, f = 0;
									h < i.length;
									h++
								)
									s.has(i[h]) || ((c.values[f] = i[h]), (p.values[f] = h), f++);
								return e.abrupt("return", [c.toTensor(), p.toTensor()]);
							case 18:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var lE = function (e, t) {
			return uE.apply(this, arguments);
		},
		cE = yk({
			sign_: function (e) {
				var t = { x: mk(e, "x", "sign") };
				return ok.runKernel(qb, t);
			},
		}),
		pE = yk({
			sin_: function (e) {
				var t = { x: mk(e, "x", "sin", "float32") };
				return ok.runKernel(jb, t);
			},
		}),
		hE = yk({
			sinh_: function (e) {
				var t = { x: mk(e, "x", "sinh") };
				return ok.runKernel(Hb, t);
			},
		}),
		fE = yk({
			slice1d_: function (e, t, n) {
				var r = mk(e, "x", "slice1d");
				return (
					Dg(1 === r.rank, function () {
						return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor";
					}),
					TS(r, [t], [n])
				);
			},
		}),
		dE = yk({
			slice2d_: function (e, t, n) {
				var r = mk(e, "x", "slice2d");
				return (
					Dg(2 === r.rank, function () {
						return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor";
					}),
					TS(r, t, n)
				);
			},
		}),
		mE = yk({
			slice3d_: function (e, t, n) {
				var r = mk(e, "x", "slice3d");
				return (
					Dg(3 === r.rank, function () {
						return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor";
					}),
					TS(r, t, n)
				);
			},
		}),
		gE = yk({
			slice4d_: function (e, t, n) {
				var r = mk(e, "x", "slice4d");
				return (
					Dg(4 === r.rank, function () {
						return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor";
					}),
					TS(r, t, n)
				);
			},
		}),
		vE = yk({
			softmax_: function (e, t) {
				void 0 === t && (t = -1);
				var n = mk(e, "logits", "softmax", "float32");
				if ((-1 === t && (t = n.rank - 1), t !== n.rank - 1))
					throw Error(
						"Softmax along a non-last dimension is not yet supported. Logits was rank " +
							n.rank +
							" and dim was " +
							t
					);
				var r = { logits: n },
					a = { dim: t };
				return ok.runKernel($b, r, a);
			},
		}),
		yE = yk({
			fft_: function (e) {
				Dg("complex64" === e.dtype, function () {
					return "The dtype for tf.spectral.fft() must be complex64 but got " + e.dtype + ".";
				});
				var t = { input: e };
				return ok.runKernel(Cy, t);
			},
		}),
		bE = yk({
			ifft_: function (e) {
				Dg("complex64" === e.dtype, function () {
					return "The dtype for tf.spectral.ifft() must be complex64 but got " + e.dtype + ".";
				});
				var t = { input: e };
				return ok.runKernel(Py, t);
			},
		}),
		xE = yk({
			irfft_: function (e) {
				var t,
					n = e.shape[e.shape.length - 1],
					r = e.size / n;
				if (n <= 2) {
					var a = wS(e, [r, n]);
					t = bE(a);
				} else {
					var i = [r, 2 * (n - 1)],
						o = wS(XC(e), [r, n]),
						s = wS(NT(e), [r, n]),
						u = QC(TS(o, [0, 1], [r, n - 2]), 1),
						l = KI(QC(TS(s, [0, 1], [r, n - 2]), 1), iE(-1)),
						c = IS([o, u], 1),
						p = IS([s, l], 1),
						h = wS(bk(c, p), [i[0], i[1]]);
					t = bE(h);
				}
				if (((t = XC(t)), 3 === e.rank && 0 !== e.shape[0])) {
					var f = t,
						d = e.shape[0];
					(t = wS(t, [d, t.shape[0] / d, t.shape[1]])), f.dispose();
				}
				return t;
			},
		}),
		wE = yk({
			split_: function (e, t, n) {
				void 0 === n && (n = 0);
				var r = { x: mk(e, "x", "split") },
					a = { numOrSizeSplits: t, axis: n };
				return ok.runKernel(Qb, r, a);
			},
		}),
		kE = yk({
			rfft_: function (e, t) {
				Dg("float32" === e.dtype, function () {
					return "The dtype for rfft() must be real value but got " + e.dtype;
				});
				var n,
					r = e.shape[e.shape.length - 1],
					a = e.size / r;
				if (null != t && t < r) {
					var i = e.shape.map(function (e) {
							return 0;
						}),
						o = e.shape.map(function (e) {
							return e;
						});
					(o[e.shape.length - 1] = t), (n = TS(e, i, o)), (r = t);
				} else if (null != t && t > r) {
					var s = e.shape.map(function (e) {
						return e;
					});
					(s[e.shape.length - 1] = t - r), (n = IS([e, uC(s)], e.shape.length - 1)), (r = t);
				} else n = e;
				var u = sT(n),
					l = wS(bk(n, u), [a, r]),
					c = yE(l),
					p = Math.floor(r / 2) + 1,
					h = XC(c),
					f = NT(c),
					d = wE(h, [p, r - p], h.shape.length - 1),
					m = wE(f, [p, r - p], f.shape.length - 1),
					g = n.shape.slice();
				return (g[n.shape.length - 1] = p), wS(bk(d[0], m[0]), g);
			},
		}),
		NE = yk({
			sqrt_: function (e) {
				var t = { x: mk(e, "x", "sqrt", "float32") };
				return ok.runKernel(Yb, t);
			},
		}),
		IE = yk({
			squaredDifference_: function (e, t) {
				var n = mk(e, "a", "squaredDifference"),
					r = mk(t, "b", "squaredDifference"),
					a = Yw(n, r);
				(n = a[0]), (r = a[1]), JN(n.shape, r.shape);
				var i = { a: n, b: r };
				return ok.runKernel(ix, i, {});
			},
		}),
		SE = yk({
			squeeze_: function (e, t) {
				var n = mk(e, "x", "squeeze");
				return wS(n, Hg(n.shape, t).newShape);
			},
		}),
		TE = yk({
			stack_: function (e, t) {
				void 0 === t && (t = 0);
				var n = gk(e, "tensors", "stack", "string_or_numeric");
				Dg(n.length >= 1, function () {
					return "Pass at least one tensor to tf.stack";
				}),
					n.length > 0 &&
						Dg(t <= n[0].rank, function () {
							return "Axis must be <= rank of the tensor";
						});
				var r = n,
					a = { axis: t };
				return ok.runKernel(kb, r, a);
			},
		}),
		CE = yk({
			step_: function (e, t) {
				void 0 === t && (t = 0);
				var n = { x: mk(e, "x", "step") },
					r = { alpha: t };
				return ok.runKernel(kx, n, r);
			},
		}),
		EE = yk({
			stridedSlice_: function (e, t, n, r, a, i, o, s, u) {
				void 0 === a && (a = 0),
					void 0 === i && (i = 0),
					void 0 === o && (o = 0),
					void 0 === s && (s = 0),
					void 0 === u && (u = 0);
				var l = { x: mk(e, "x", "stridedSlice", "string_or_numeric") },
					c = {
						begin: t,
						end: n,
						strides: r,
						beginMask: a,
						endMask: i,
						ellipsisMask: o,
						newAxisMask: s,
						shrinkAxisMask: u,
					};
				return ok.runKernel(sx, l, c);
			},
		}),
		RE = yk({
			tan_: function (e) {
				var t = { x: mk(e, "x", "tan", "float32") };
				return ok.runKernel(hx, t);
			},
		});
	function AE(e, t) {
		Mg(e);
		var n = hk(e, t);
		if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
		return xk(e, null, n, t);
	}
	function _E(e, t, n) {
		if ((Mg(e), null != t && 2 !== t.length)) throw new Error("tensor2d() requires shape to have two numbers");
		var r = hk(e, n);
		if (2 !== r.length && 1 !== r.length)
			throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
		if (1 === r.length && null == t)
			throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
		return xk(e, t, r, n);
	}
	function FE(e, t, n) {
		if ((Mg(e), null != t && 4 !== t.length)) throw new Error("tensor4d() requires shape to have four numbers");
		var r = hk(e, n);
		if (4 !== r.length && 1 !== r.length)
			throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
		if (1 === r.length && null == t)
			throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
		return xk(e, t, r, n);
	}
	function DE(e, t, n) {
		if ((Mg(e), null != t && 5 !== t.length)) throw new Error("tensor5d() requires shape to have five numbers");
		var r = hk(e, n);
		if (5 !== r.length && 1 !== r.length)
			throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
		if (1 === r.length && null == t)
			throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
		return xk(e, t, r, n);
	}
	function OE(e, t, n) {
		if ((Mg(e), null != t && 6 !== t.length)) throw new Error("tensor6d() requires shape to have six numbers");
		var r = hk(e, n);
		if (6 !== r.length && 1 !== r.length)
			throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
		if (1 === r.length && null == t)
			throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
		return xk(e, (t = t || r), r, n);
	}
	var ME = yk({
			topk_: function (e, t, n) {
				void 0 === t && (t = 1), void 0 === n && (n = !0);
				var r = mk(e, "x", "topk");
				if (0 === r.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
				var a = r.shape[r.shape.length - 1];
				if (t < 0) throw new Error("'k' passed to topk() must be >= 0 but got " + t);
				if (t > a)
					throw new Error("'k' passed to topk() must be <= the last dimension (" + a + ") but got " + t);
				var i = { x: r },
					o = { k: t, sorted: n },
					s = ok.runKernel(mx, i, o);
				return { values: s[0], indices: s[1] };
			},
		}),
		LE = yk({
			truncatedNormal_: function (e, t, n, r, a) {
				if ((void 0 === t && (t = 0), void 0 === n && (n = 1), null != r && "bool" === r))
					throw new Error("Unsupported data type $ { dtype }");
				for (var i = new UC(t, n, r, !0, a), o = kN(e, r), s = 0; s < o.values.length; s++)
					o.values[s] = i.nextValue();
				return o.toTensor();
			},
		}),
		zE = yk({
			unique_: function (e, t) {
				void 0 === t && (t = 0);
				var n = mk(e, "x", "unique", "string_or_numeric");
				Dg(n.rank > 0, function () {
					return "The input tensor must be at least 1D";
				});
				var r = { x: n },
					a = { axis: t },
					i = ok.runKernel(yx, r, a);
				return { values: i[0], indices: i[1] };
			},
		}),
		PE = yk({
			unsortedSegmentSum_: function (e, t, n) {
				var r = mk(e, "x", "unsortedSegmentSum"),
					a = mk(t, "segmentIds", "unsortedSegmentSum", "int32");
				Dg(Bg(n), function () {
					return "numSegments must be of dtype int";
				});
				var i = { x: r, segmentIds: a },
					o = { numSegments: n };
				return ok.runKernel(xx, i, o);
			},
		}),
		BE = yk({
			unstack_: function (e, t) {
				void 0 === t && (t = 0);
				var n = mk(e, "x", "unstack", "string_or_numeric");
				Dg(t >= -n.shape.length && t < n.shape.length, function () {
					return "Axis = " + t + " is not in [-" + n.shape.length + ", " + n.shape.length + ")";
				});
				var r = { value: n },
					a = { axis: t };
				return ok.runKernel(bx, r, a);
			},
		});
	function WE(e, t, n, r) {
		return void 0 === t && (t = !0), ok.makeVariable(e, t, n, r);
	}
	function UE(e, t) {
		for (var n = [], r = 0; r < t.length; r++) t[r] && n.push(r);
		for (var a = kN(e, "int32"), i = kN([n.length, e.length], "int32"), o = 0; o < n.length; o++) {
			var s = a.indexToLoc(n[o]),
				u = o * e.length;
			i.values.set(s, u);
		}
		return i.toTensor();
	}
	function VE() {
		return (VE = fg(
			regeneratorRuntime.mark(function e(t) {
				var n, r, a;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (n = mk(t, "condition", "whereAsync", "bool")), (e.next = 3), n.data();
							case 3:
								return (
									(r = e.sent), (a = UE(n.shape, r)), t !== n && n.dispose(), e.abrupt("return", a)
								);
							case 7:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var GE = function (e) {
		return VE.apply(this, arguments);
	};
	function jE() {
		return (jE = fg(
			regeneratorRuntime.mark(function e(t, n, r) {
				var a, i, o, s, u, l, c, p, h, f, d, m, g;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								for (
									a = mk(t, "tensor", "boolMask"),
										i = mk(n, "mask", "boolMask", "bool"),
										o = null == r ? 0 : r,
										s = i.rank,
										u = a.shape,
										Dg(s > 0, function () {
											return "mask cannot be scalar";
										}),
										Og(
											u.slice(o, o + s),
											i.shape,
											"mask's shape must match the first K dimensions of tensor's shape,"
										),
										l = 1,
										c = o;
									c < o + s;
									c++
								)
									l *= u[c];
								return (
									(p = u.slice(0, o).concat([l], u.slice(o + s))),
									(h = wS(a, p)),
									(f = wS(i, [-1])),
									(e.next = 14),
									GE(f)
								);
							case 14:
								return (
									(d = e.sent),
									(m = SE(d, [1])),
									(g = xT(h, m, o)),
									t !== a && a.dispose(),
									n !== i && i.dispose(),
									m.dispose(),
									h.dispose(),
									f.dispose(),
									d.dispose(),
									e.abrupt("return", g)
								);
							case 24:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var HE = function (e, t, n) {
		return jE.apply(this, arguments);
	};
	function qE(e, t, n) {
		if ((void 0 === n && (n = null), 0 === e.rank)) return XI(e);
		if (1 !== e.rank && null === n) return qE(wS(e, [-1]), t, n);
		if (1 === e.rank || "number" == typeof n || (Array.isArray(n) && 1 === n.length)) {
			if (1 === t) return VT(XI(e), n);
			if (t === 1 / 0) return WT(XI(e), n);
			if (t === -1 / 0) return pC(XI(e), n);
			if ("euclidean" === t || 2 === t) return NE(VT(RC(XI(e), iE(2, "int32")), n));
			throw new Error("Error in norm: invalid ord value: " + t);
		}
		if (Array.isArray(n) && 2 === n.length) {
			if (1 === t) return WT(VT(XI(e), n[0]), n[1] - 1);
			if (t === 1 / 0) return WT(VT(XI(e), n[1]), n[0]);
			if (t === -1 / 0) return pC(VT(XI(e), n[1]), n[0]);
			if ("fro" === t || "euclidean" === t) return NE(VT(mC(e), n));
			throw new Error("Error in norm: invalid ord value: " + t);
		}
		throw new Error("Error in norm: invalid axis: " + n);
	}
	var KE = yk({
			norm_: function (e, t, n, r) {
				void 0 === t && (t = "euclidean"), void 0 === n && (n = null), void 0 === r && (r = !1);
				var a = qE((e = mk(e, "x", "norm")), t, n),
					i = a.shape;
				if (r) {
					var o = jg(n, e.shape);
					i = KT(a.shape, o);
				}
				return wS(a, i);
			},
		}),
		XE = yk({
			movingAverage_: function (e, t, n, r, a) {
				void 0 === a && (a = !0);
				var i = mk(e, "v", "movingAverage"),
					o = mk(t, "x", "movingAverage"),
					s = mk(n, "decay", "movingAverage");
				Jw(i, o),
					Dg(Pg(i.shape, o.shape), function () {
						return "Shape mismatch in v and x";
					});
				var u = iE(1),
					l = UT(u, s),
					c = KI(UT(o, i), l);
				if (a) {
					Dg(null != r, function () {
						return "When using zeroDebias: true, step is required.";
					});
					var p = mk(r, "step", "movingAverage");
					c = qI(c, UT(u, RC(s, p)));
				}
				return jI(i, c);
			},
		}),
		YE = yk({
			scatterND_: function (e, t, n) {
				var r = mk(e, "indices", "scatterND", "int32"),
					a = mk(t, "updates", "scatterND");
				lI(a, r, n);
				var i = { indices: r, updates: a },
					o = { shape: n };
				return ok.runKernel(Wb, i, o);
			},
		}),
		JE = yk({
			sparseToDense_: function (e, t, n, r) {
				void 0 === r && (r = 0);
				var a = mk(e, "sparseIndices", "sparseToDense", "int32"),
					i = mk(t, "sparseValues", "sparseToDense"),
					o = mk(r, "defaultValue", "sparseToDense", i.dtype);
				!(function (e, t, n, r) {
					if ("int32" !== e.dtype)
						throw new Error(
							"tf.sparseToDense() expects the indices to be int32 type, but the dtype was " +
								e.dtype +
								"."
						);
					if (e.rank > 2)
						throw new Error(
							"sparseIndices should be a scalar, vector, or matrix, but got shape " + e.shape + "."
						);
					var a = e.rank > 0 ? e.shape[0] : 1,
						i = e.rank > 1 ? e.shape[1] : 1;
					if (n.length !== i)
						throw new Error(
							"outputShape has incorrect number of elements:, " + n.length + ", should be: " + i + "."
						);
					var o = t.size;
					if (0 !== t.rank && (1 !== t.rank || o !== a))
						throw new Error(
							"sparseValues has incorrect shape " + t.shape + ", should be [] or [" + a + "]"
						);
					if (t.dtype !== r.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
				})(a, i, n, o);
				var s = { sparseIndices: a, sparseValues: i, defaultValue: o },
					u = { outputShape: n };
				return ok.runKernel(ax, s, u);
			},
		}),
		ZE = yk({
			gatherND_: function (e, t) {
				var n = mk(t, "indices", "gatherND", "int32"),
					r = { params: mk(e, "x", "gatherND", "string_or_numeric"), indices: n };
				return ok.runKernel(Oy, r);
			},
		}),
		QE = yk({
			dropout_: function (e, t, n, r) {
				var a = mk(e, "x", "dropout");
				if (
					(Dg("float32" === a.dtype, function () {
						return (
							"x has to be a floating point tensor since it's going to be scaled, but got a " +
							a.dtype +
							" tensor instead."
						);
					}),
					Dg(t >= 0 && t < 1, function () {
						return "rate must be a float in the range [0, 1), but got " + t + ".";
					}),
					0 === t)
				)
					return e instanceof Pw ? a.clone() : a;
				var i = (function (e, t) {
						if (null == t) return e.shape.slice();
						if (Pg(e.shape, t)) return t;
						if (e.shape.length === t.length) {
							for (var n = [], r = 0; r < e.shape.length; r++)
								null == t[r] && null != e.shape[r] ? n.push(e.shape[r]) : n.push(t[r]);
							return n;
						}
						return t;
					})(a, n),
					o = 1 - t,
					s = qI(bT(jI(qC(i, 0, 1, "float32", r), o)), o);
				return KI(a, s);
			},
		});
	function $E(e) {
		return Math.floor(Math.pow(2, Math.ceil(Math.log(e) / Math.log(2))));
	}
	function eR(e, t, n) {
		for (var r = 1 - (e % 2), a = new Float32Array(e), i = 0; i < e; ++i) {
			var o = (2 * Math.PI * i) / (e + r - 1);
			a[i] = t - n * Math.cos(o);
		}
		return AE(a, "float32");
	}
	function tR() {
		return (tR = fg(
			regeneratorRuntime.mark(function e(t, n, r) {
				var a, i, o, s, u, l, c, p, h, f, d, m, g, v;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (
									void 0 === r && (r = 1),
									(a = mk(t, "predictions", "inTopK")),
									(i = mk(n, "targets", "inTopK")),
									Dg(a.rank > 1, function () {
										return (
											"inTopK() expects the predictions to be of rank 2 or higher, but got " +
											a.rank
										);
									}),
									Dg(a.rank - 1 === i.rank, function () {
										return (
											"predictions rank should be 1 larger than targets rank, but got predictions rank " +
											a.rank +
											" and targets rank " +
											i.rank
										);
									}),
									Og(
										a.shape.slice(0, a.shape.length - 1),
										i.shape,
										"predictions's shape should be align with the targets' shape, except the last dimension."
									),
									(o = a.shape[a.shape.length - 1]),
									Dg(r > 0 && r <= o, function () {
										return (
											"'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" +
											o +
											"), but got " +
											r
										);
									}),
									(e.next = 10),
									a.data()
								);
							case 10:
								return (s = e.sent), (e.next = 13), i.data();
							case 13:
								(u = e.sent), (l = s.length / o), (c = o), (p = qg("bool", l)), (h = 0);
							case 17:
								if (!(h < l)) {
									e.next = 35;
									break;
								}
								for (f = h * c, d = s.subarray(f, f + c), m = [], g = 0; g < d.length; g++)
									m.push({ value: d[g], index: g });
								m.sort(function (e, t) {
									return t.value - e.value;
								}),
									(p[h] = 0),
									(v = 0);
							case 25:
								if (!(v < r)) {
									e.next = 32;
									break;
								}
								if (m[v].index !== u[h]) {
									e.next = 29;
									break;
								}
								return (p[h] = 1), e.abrupt("break", 32);
							case 29:
								v++, (e.next = 25);
								break;
							case 32:
								h++, (e.next = 17);
								break;
							case 35:
								return (
									t !== a && a.dispose(),
									n !== i && i.dispose(),
									e.abrupt("return", wk(p, i.shape, "bool"))
								);
							case 38:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var nR = function (e, t, n) {
			return tR.apply(this, arguments);
		},
		rR = yk({
			conv2DBackpropFilter_: function (e, t, n, r, a, i, o) {
				void 0 === i && (i = "NHWC");
				var s = e;
				3 === e.rank && (s = wS(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
				var u = t;
				3 === u.rank && (u = wS(t, [1, t.shape[0], t.shape[1], t.shape[2]])),
					Dg(4 === s.rank, function () {
						return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s.shape + ".";
					}),
					Dg(4 === u.rank, function () {
						return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u.shape + ".";
					}),
					Dg(4 === n.length, function () {
						return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n + ".";
					});
				var l = "NHWC" === i ? s.shape[3] : s.shape[1],
					c = "NHWC" === i ? u.shape[3] : u.shape[1];
				Dg(l === n[2], function () {
					return (
						"Error in conv2dDerFilter: depth of input " +
						l +
						") must match input depth in filter (" +
						n[2] +
						"."
					);
				}),
					Dg(c === n[3], function () {
						return (
							"Error in conv2dDerFilter: depth of dy (" +
							c +
							") must match output depth for filter (" +
							n[3] +
							")."
						);
					}),
					xS("conv2dDerFilter", a, o);
				var p = { x: s, dy: u },
					h = { strides: r, pad: a, dataFormat: i, dimRoundingMode: o, filterShape: n };
				return ok.runKernel($v, p, h);
			},
		});
	function aR(e, t, n) {
		if (null == n || "linear" === n) return e;
		if ("relu" === n) return KI(e, CE(t));
		throw new Error("Cannot compute gradient for fused activation " + n + ".");
	}
	function iR(e, t) {
		var n = t,
			r = YN(e.shape, t.shape);
		return r.length > 0 && (n = VT(n, r)), wS(n, e.shape);
	}
	function oR(e, t, n, r) {
		if ("linear" === t) return e;
		if ("relu" === t) return JC(e);
		if ("elu" === t) return pT(e);
		if ("relu6" === t) return ZC(e);
		if ("prelu" === t) return AC(e, n);
		if ("leakyrelu" === t) return CT(e, r);
		if ("sigmoid" === t) return SS(e);
		throw new Error("Unknown fused activation " + t + ".");
	}
	var sR = function (e, t) {
			return !(e > 0) || "linear" === t;
		},
		uR = yk({
			fusedConv2d_: function (e) {
				var t = e.x,
					n = e.filter,
					r = e.strides,
					a = e.pad,
					i = e.dataFormat,
					o = void 0 === i ? "NHWC" : i,
					s = e.dilations,
					u = void 0 === s ? [1, 1] : s,
					l = e.dimRoundingMode,
					c = e.bias,
					p = e.activation,
					h = void 0 === p ? "linear" : p,
					f = e.preluActivationWeights,
					d = e.leakyreluAlpha;
				if (((h = h || "linear"), !1 === sR(ok.state.gradientDepth, h))) {
					var m = GS(t, n, r, a, o, u, l);
					return null != c && (m = jI(m, c)), oR(m, h, f, d);
				}
				var g = mk(t, "x", "conv2d", "float32"),
					v = mk(n, "filter", "conv2d", "float32"),
					y = g,
					b = !1;
				3 === g.rank && ((b = !0), (y = wS(g, [1, g.shape[0], g.shape[1], g.shape[2]]))),
					Dg(4 === y.rank, function () {
						return "Error in fused conv2d: input must be rank 4, but got rank " + y.rank + ".";
					}),
					Dg(4 === v.rank, function () {
						return "Error in fused conv2d: filter must be rank 4, but got rank " + v.rank + ".";
					}),
					xS("fused conv2d", a, l),
					Dg(y.shape[3] === v.shape[2], function () {
						return (
							"Error in conv2d: depth of input (" +
							y.shape[3] +
							") must match input depth for filter " +
							v.shape[2] +
							"."
						);
					}),
					Dg(yS(r, u), function () {
						return (
							"Error in conv2D: Either strides or dilations must be 1. Got strides " +
							r +
							" and dilations '" +
							u +
							"'"
						);
					}),
					Dg("NHWC" === o, function () {
						return "Error in conv2d: got dataFormat of " + o + " but only NHWC is currently supported.";
					});
				var x,
					w,
					k = cS(y.shape, v.shape, r, u, a, l);
				null != c && ((x = Yw((x = mk(c, "bias", "fused conv2d")), g)[0]), JN(k.outShape, x.shape)),
					null != f && (w = mk(f, "prelu weights", "fused conv2d"));
				var N = function (e, t) {
						var n = t[0],
							i = t[1],
							o = t[2],
							s = t[3],
							l = aR(e, o, h);
						Dg(vS(u), function () {
							return (
								"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" +
								u +
								"'"
							);
						});
						var c = [HS(i.shape, l, n, r, a), rR(i, l, n.shape, r, a)];
						if (null != s) {
							var p = iR(s, l);
							c.push(p);
						}
						return c;
					},
					I = { x: y, filter: v, bias: x, preluActivationWeights: w },
					S = {
						strides: r,
						pad: a,
						dataFormat: o,
						dilations: u,
						dimRoundingMode: l,
						activation: h,
						leakyreluAlpha: d,
					};
				return null == c
					? MT(function (e, t, n) {
							var r = ok.runKernel(Tx, I, S);
							return (
								n([t, e, r]),
								b && (r = wS(r, [r.shape[1], r.shape[2], r.shape[3]])),
								{ value: r, gradFunc: N }
							);
					  })(y, v)
					: MT(function (e, t, n, r) {
							var a = ok.runKernel(Tx, I, S);
							return (
								r([t, e, a, n]),
								b && (a = wS(a, [a.shape[1], a.shape[2], a.shape[3]])),
								{ value: a, gradFunc: N }
							);
					  })(y, v, x);
			},
		}),
		lR = yk({
			depthwiseConv2dNativeBackpropFilter_: function (e, t, n, r, a, i, o) {
				void 0 === i && (i = [1, 1]);
				var s = e;
				3 === e.rank && (s = wS(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
				var u = t;
				3 === u.rank && (u = wS(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
				var l = { x: s, dy: u },
					c = { strides: r, pad: a, dimRoundingMode: o, dilations: i, filterShape: n };
				return ok.runKernel(hy, l, c);
			},
		}),
		cR = yk({
			depthwiseConv2dNativeBackpropInput_: function (e, t, n, r, a, i, o) {
				void 0 === i && (i = [1, 1]);
				var s = t,
					u = !1;
				3 === t.rank && ((u = !0), (s = wS(t, [1, t.shape[0], t.shape[1], t.shape[2]])));
				var l = { dy: s, filter: n },
					c = { strides: r, pad: a, dimRoundingMode: o, dilations: i, inputShape: e },
					p = ok.runKernel(fy, l, c);
				return u ? wS(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
			},
		}),
		pR = yk({
			fusedDepthwiseConv2d_: function (e) {
				var t = e.x,
					n = e.filter,
					r = e.strides,
					a = e.pad,
					i = e.dataFormat,
					o = void 0 === i ? "NHWC" : i,
					s = e.dilations,
					u = void 0 === s ? [1, 1] : s,
					l = e.dimRoundingMode,
					c = e.bias,
					p = e.activation,
					h = void 0 === p ? "linear" : p,
					f = e.preluActivationWeights,
					d = e.leakyreluAlpha;
				if (!1 === sR(ok.state.gradientDepth, h)) {
					var m = nT(t, n, r, a, o, u, l);
					return null != c && (m = jI(m, c)), oR(m, h, f, d);
				}
				var g = mk(t, "x", "depthwiseConv2d", "float32"),
					v = mk(n, "filter", "depthwiseConv2d", "float32"),
					y = g,
					b = !1;
				3 === g.rank && ((b = !0), (y = wS(g, [1, g.shape[0], g.shape[1], g.shape[2]]))),
					Dg(4 === y.rank, function () {
						return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + y.rank + ".";
					}),
					Dg(4 === v.rank, function () {
						return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + v.rank + ".";
					}),
					Dg(y.shape[3] === v.shape[2], function () {
						return (
							"Error in fused depthwiseConv2d: number of input channels (" +
							y.shape[3] +
							") must match the inChannels dimension in filter " +
							v.shape[2] +
							"."
						);
					}),
					null == u && (u = [1, 1]),
					Dg(yS(r, u), function () {
						return (
							"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " +
							r +
							" and dilations '" +
							u +
							"'"
						);
					}),
					xS("fused depthwiseConv2d", a, l);
				var x,
					w,
					k = cS(y.shape, v.shape, r, u, a, l, !0);
				if (null != c) {
					var N = Yw((x = mk(c, "bias", "fused conv2d")), g);
					(x = N[0]), JN(k.outShape, x.shape);
				}
				null != f && (w = mk(f, "prelu weights", "fused depthwiseConv2d"));
				var I = function (e, t) {
						Dg(vS(u), function () {
							return (
								"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" +
								u +
								"'"
							);
						});
						var n = t[0],
							i = t[1],
							o = t[2],
							s = t[3],
							c = aR(e, o, h),
							p = cR(i.shape, c, n, r, a, u, l),
							f = lR(i, c, n.shape, r, a, u, l);
						return null != s ? [p, f, iR(x, c)] : [p, f];
					},
					S = { x: y, filter: v, bias: x, preluActivationWeights: w },
					T = {
						strides: r,
						pad: a,
						dataFormat: o,
						dilations: u,
						dimRoundingMode: l,
						activation: h,
						leakyreluAlpha: d,
					};
				return null == c
					? MT(function (e, t, n) {
							var r = ok.runKernel(Cx, S, T);
							return (
								n([t, e, r]),
								b && (r = wS(r, [r.shape[1], r.shape[2], r.shape[3]])),
								{ value: r, gradFunc: I }
							);
					  })(y, v)
					: MT(function (e, t, n, r) {
							var a = ok.runKernel(Cx, S, T);
							return (
								r([t, e, a, n]),
								b && (a = wS(a, [a.shape[1], a.shape[2], a.shape[3]])),
								{ value: a, gradFunc: I }
							);
					  })(y, v, x);
			},
		}),
		hR = yk({
			fusedMatMul_: function (e) {
				var t = e.a,
					n = e.b,
					r = e.transposeA,
					a = void 0 !== r && r,
					i = e.transposeB,
					o = void 0 !== i && i,
					s = e.bias,
					u = e.activation,
					l = void 0 === u ? "linear" : u,
					c = e.preluActivationWeights,
					p = e.leakyreluAlpha;
				if (!1 === sR(ok.state.gradientDepth, l)) {
					var h = jN(t, n, a, o);
					return null != s && (h = jI(h, s)), oR(h, l, c, p);
				}
				var f = mk(t, "a", "fused matMul"),
					d = mk(n, "b", "fused matMul"),
					m = Yw(f, d);
				(f = m[0]), (d = m[1]);
				var g = a ? f.shape[f.rank - 2] : f.shape[f.rank - 1],
					v = o ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
					y = a ? f.shape[f.rank - 1] : f.shape[f.rank - 2],
					b = o ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
					x = f.shape.slice(0, -2),
					w = d.shape.slice(0, -2),
					k = zg(x),
					N = zg(w);
				Dg(g === v, function () {
					return (
						"Error in fused matMul: inner shapes (" +
						g +
						") and (" +
						v +
						") of Tensors with shapes " +
						f.shape +
						" and " +
						d.shape +
						" and transposeA=" +
						a +
						" and transposeB=" +
						o +
						" must match."
					);
				});
				var I,
					S,
					T = JN(f.shape.slice(0, -2), d.shape.slice(0, -2)).concat([y, b]),
					C = wS(f, a ? [k, g, y] : [k, y, g]),
					E = wS(d, o ? [N, b, v] : [N, v, b]);
				null != s && ((I = Yw((I = mk(s, "bias", "fused matMul")), f)[0]), JN(T, I.shape)),
					null != c && (S = mk(c, "prelu weights", "fused matMul"));
				var R = function (e, t) {
						var n,
							r,
							i = t[0],
							u = t[1],
							c = t[2],
							p = t[3],
							h = aR(wS(e, c.shape), c, l);
						return (
							a || o
								? !a && o
									? ((n = jN(h, u, !1, !1)), (r = jN(h, i, !0, !1)))
									: a && !o
									? ((n = jN(u, h, !1, !0)), (r = jN(i, h, !1, !1)))
									: ((n = jN(u, h, !0, !0)), (r = jN(h, i, !0, !0)))
								: ((n = jN(h, u, !1, !0)), (r = jN(i, h, !0, !1))),
							null != s ? [n, r, iR(p, h)] : [n, r]
						);
					},
					A = { a: C, b: E, bias: I, preluActivationWeights: S },
					_ = { transposeA: a, transposeB: o, activation: l, leakyreluAlpha: p };
				return null == s
					? MT(function (e, t, n) {
							var r = ok.runKernel(Sx, A, _);
							return n([e, t, r]), { value: wS(r, T), gradFunc: R };
					  })(C, E)
					: MT(function (e, t, n, r) {
							var a = ok.runKernel(Sx, A, _);
							return r([e, t, a, n]), { value: wS(a, T), gradFunc: R };
					  })(C, E, I);
			},
		}),
		fR = { __proto__: null, conv2d: uR, depthwiseConv2d: pR, matMul: hR },
		dR = yk({
			hammingWindow_: function (e) {
				return eR(e, 0.54, 0.46);
			},
		}),
		mR = yk({
			hannWindow_: function (e) {
				return eR(e, 0.5, 0.5);
			},
		}),
		gR = yk({
			frame_: function (e, t, n, r, a) {
				void 0 === r && (r = !1), void 0 === a && (a = 0);
				for (var i = 0, o = []; i + t <= e.size; ) o.push(TS(e, i, t)), (i += n);
				if (r)
					for (; i < e.size; ) {
						var s = i + t - e.size,
							u = IS([TS(e, i, t - s), yT([s], a)]);
						o.push(u), (i += n);
					}
				return 0 === o.length ? _E([], [0, t]) : wS(IS(o), [o.length, t]);
			},
		}),
		vR = yk({
			stft_: function (e, t, n, r, a) {
				void 0 === a && (a = mR), null == r && (r = $E(t));
				var i = gR(e, t, n),
					o = KI(i, a(t));
				return kE(o, r);
			},
		}),
		yR = yk({
			cropAndResize_: function (e, t, n, r, a, i) {
				void 0 === a && (a = "bilinear"), void 0 === i && (i = 0);
				var o = mk(e, "image", "cropAndResize"),
					s = mk(t, "boxes", "cropAndResize", "float32"),
					u = mk(n, "boxInd", "cropAndResize", "int32"),
					l = s.shape[0];
				Dg(4 === o.rank, function () {
					return "Error in cropAndResize: image must be rank 4,but got rank " + o.rank + ".";
				}),
					Dg(2 === s.rank && 4 === s.shape[1], function () {
						return (
							"Error in cropAndResize: boxes must be have size [" +
							l +
							",4] but had shape " +
							s.shape +
							"."
						);
					}),
					Dg(1 === u.rank && u.shape[0] === l, function () {
						return (
							"Error in cropAndResize: boxInd must be have size [" +
							l +
							"] but had shape " +
							s.shape +
							"."
						);
					}),
					Dg(2 === r.length, function () {
						return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + ".";
					}),
					Dg(r[0] >= 1 && r[1] >= 1, function () {
						return "cropSize must be atleast [1,1], but was " + r;
					}),
					Dg("bilinear" === a || "nearest" === a, function () {
						return "method must be bilinear or nearest, but was " + a;
					});
				var c = { image: o, boxes: s, boxInd: u },
					p = { method: a, extrapolationValue: i, cropSize: r };
				return ok.runKernel(uy, c, p);
			},
		}),
		bR = yk({
			flipLeftRight_: function (e) {
				var t = mk(e, "image", "flipLeftRight", "float32");
				Dg(4 === t.rank, function () {
					return "Error in flipLeftRight: image must be rank 4,but got rank " + t.rank + ".";
				});
				var n = { image: t };
				return ok.runKernel(Ry, n, {});
			},
		}),
		xR = yk({
			grayscaleToRGB_: function (e) {
				var t = mk(e, "image", "grayscaleToRGB"),
					n = t.rank - 1,
					r = t.shape[n];
				Dg(t.rank >= 2, function () {
					return "Error in grayscaleToRGB: images must be at least rank 2, but got rank " + t.rank + ".";
				}),
					Dg(1 === r, function () {
						return (
							"Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size " +
							r +
							"."
						);
					});
				var a = new Array(t.rank);
				return a.fill(1, 0, n), (a[n] = 3), gT(t, a);
			},
		}),
		wR = yk({
			rotateWithOffset_: function (e, t, n, r) {
				void 0 === n && (n = 0), void 0 === r && (r = 0.5);
				var a = mk(e, "image", "rotateWithOffset", "float32");
				Dg(4 === a.rank, function () {
					return "Error in rotateWithOffset: image must be rank 4,but got rank " + a.rank + ".";
				});
				var i = { image: a },
					o = { radians: t, fillValue: n, center: r };
				return ok.runKernel(Ix, i, o);
			},
		});
	function kR(e, t, n, r, a, i) {
		null == r && (r = 0.5), null == a && (a = Number.NEGATIVE_INFINITY), null == i && (i = 0);
		var o = e.shape[0];
		return (
			(n = Math.min(n, o)),
			Dg(0 <= r && r <= 1, function () {
				return "iouThreshold must be in [0, 1], but was '" + r + "'";
			}),
			Dg(2 === e.rank, function () {
				return "boxes must be a 2D tensor, but was of rank '" + e.rank + "'";
			}),
			Dg(4 === e.shape[1], function () {
				return "boxes must have 4 columns, but 2nd dimension was " + e.shape[1];
			}),
			Dg(1 === t.rank, function () {
				return "scores must be a 1D tensor";
			}),
			Dg(t.shape[0] === o, function () {
				return "scores has incompatible shape with boxes. Expected " + o + ", but was " + t.shape[0];
			}),
			Dg(0 <= i && i <= 1, function () {
				return "softNmsSigma must be in [0, 1], but was '" + i + "'";
			}),
			{ maxOutputSize: n, iouThreshold: r, scoreThreshold: a, softNmsSigma: i }
		);
	}
	var NR = yk({
		nonMaxSuppression_: function (e, t, n, r, a) {
			void 0 === r && (r = 0.5), void 0 === a && (a = Number.NEGATIVE_INFINITY);
			var i = mk(e, "boxes", "nonMaxSuppression", "float32"),
				o = mk(t, "scores", "nonMaxSuppression", "float32"),
				s = kR(i, o, n, r, a),
				u = {
					maxOutputSize: (n = s.maxOutputSize),
					iouThreshold: (r = s.iouThreshold),
					scoreThreshold: (a = s.scoreThreshold),
				};
			return ok.runKernel(vb, { boxes: i, scores: o }, u);
		},
	});
	function IR(e, t, n) {
		var r = (function (e, t, n) {
				return (function (e, t, n) {
					for (var r = 0, a = e.length, i = 0, o = !1; r < a; ) {
						var s = n(t, e[(i = r + ((a - r) >>> 1))]);
						s > 0 ? (r = i + 1) : ((a = i), (o = !s));
					}
					return o ? r : -r - 1;
				})(e, t, n || SR);
			})(e, t, n),
			a = r < 0 ? -(r + 1) : r;
		e.splice(a, 0, t);
	}
	function SR(e, t) {
		return e > t ? 1 : e < t ? -1 : 0;
	}
	function TR(e, t, n, r, a) {
		return RR(e, t, n, r, a, 0);
	}
	function CR(e, t, n, r, a, i) {
		return RR(e, t, n, r, a, 0, !1, i, !0);
	}
	function ER(e, t, n, r, a, i) {
		return RR(e, t, n, r, a, i, !0);
	}
	function RR(e, t, n, r, a, i, o, s, u) {
		void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === u && (u = !1);
		for (var l = [], c = 0; c < t.length; c++)
			t[c] > a && l.push({ score: t[c], boxIndex: c, suppressBeginIndex: 0 });
		l.sort(FR);
		for (var p = i > 0 ? -0.5 / i : 0, h = [], f = []; h.length < n && l.length > 0; ) {
			var d = l.pop(),
				m = d.score,
				g = d.boxIndex,
				v = d.suppressBeginIndex;
			if (m < a) break;
			for (var y = !1, b = h.length - 1; b >= v; --b) {
				var x = AR(e, g, h[b]);
				if (x >= r) {
					y = !0;
					break;
				}
				if (((d.score = d.score * _R(r, p, x)), d.score <= a)) break;
			}
			(d.suppressBeginIndex = h.length),
				y || (d.score === m ? (h.push(g), f.push(d.score)) : d.score > a && IR(l, d, FR));
		}
		var w = h.length,
			k = n - w;
		s && k > 0 && (h.push.apply(h, new Array(k).fill(0)), f.push.apply(f, new Array(k).fill(0)));
		var N = { selectedIndices: h };
		return o && (N.selectedScores = f), u && (N.validOutputs = w), N;
	}
	function AR(e, t, n) {
		var r = e.subarray(4 * t, 4 * t + 4),
			a = e.subarray(4 * n, 4 * n + 4),
			i = Math.min(r[0], r[2]),
			o = Math.min(r[1], r[3]),
			s = Math.max(r[0], r[2]),
			u = Math.max(r[1], r[3]),
			l = Math.min(a[0], a[2]),
			c = Math.min(a[1], a[3]),
			p = Math.max(a[0], a[2]),
			h = Math.max(a[1], a[3]),
			f = (s - i) * (u - o),
			d = (p - l) * (h - c);
		if (f <= 0 || d <= 0) return 0;
		var m = Math.max(i, l),
			g = Math.max(o, c),
			v = Math.min(s, p),
			y = Math.min(u, h),
			b = Math.max(v - m, 0) * Math.max(y - g, 0);
		return b / (f + d - b);
	}
	function _R(e, t, n) {
		var r = Math.exp(t * n * n);
		return n <= e ? r : 0;
	}
	function FR(e, t) {
		return e.score - t.score || (e.score === t.score && t.boxIndex - e.boxIndex);
	}
	function DR() {
		return (DR = fg(
			regeneratorRuntime.mark(function e(t, n, r, a, i) {
				var o, s, u, l, c, p, h, f;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (
									void 0 === a && (a = 0.5),
									void 0 === i && (i = Number.NEGATIVE_INFINITY),
									(o = mk(t, "boxes", "nonMaxSuppressionAsync")),
									(s = mk(n, "scores", "nonMaxSuppressionAsync")),
									(u = kR(o, s, r, a, i)),
									(r = u.maxOutputSize),
									(a = u.iouThreshold),
									(i = u.scoreThreshold),
									(e.next = 10),
									Promise.all([o.data(), s.data()])
								);
							case 10:
								return (
									(l = e.sent),
									(c = l[0]),
									(p = l[1]),
									(h = TR(c, p, r, a, i)),
									(f = h.selectedIndices),
									o !== t && o.dispose(),
									s !== n && s.dispose(),
									e.abrupt("return", AE(f, "int32"))
								);
							case 17:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var OR = yk({
		nonMaxSuppressionWithScore_: function (e, t, n, r, a, i) {
			void 0 === r && (r = 0.5), void 0 === a && (a = Number.NEGATIVE_INFINITY), void 0 === i && (i = 0);
			var o = mk(e, "boxes", "nonMaxSuppression"),
				s = mk(t, "scores", "nonMaxSuppression"),
				u = kR(o, s, n, r, a, i),
				l = { boxes: o, scores: s },
				c = {
					maxOutputSize: (n = u.maxOutputSize),
					iouThreshold: (r = u.iouThreshold),
					scoreThreshold: (a = u.scoreThreshold),
					softNmsSigma: (i = u.softNmsSigma),
				},
				p = ok.runKernel(bb, l, c);
			return { selectedIndices: p[0], selectedScores: p[1] };
		},
	});
	function MR() {
		return (MR = fg(
			regeneratorRuntime.mark(function e(t, n, r, a, i, o) {
				var s, u, l, c, p, h, f, d, m;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (
									void 0 === a && (a = 0.5),
									void 0 === i && (i = Number.NEGATIVE_INFINITY),
									void 0 === o && (o = 0),
									(s = mk(t, "boxes", "nonMaxSuppressionAsync")),
									(u = mk(n, "scores", "nonMaxSuppressionAsync")),
									(l = kR(s, u, r, a, i, o)),
									(r = l.maxOutputSize),
									(a = l.iouThreshold),
									(i = l.scoreThreshold),
									(o = l.softNmsSigma),
									(e.next = 12),
									Promise.all([s.data(), u.data()])
								);
							case 12:
								return (
									(c = e.sent),
									(p = c[0]),
									(h = c[1]),
									(f = ER(p, h, r, a, i, o)),
									(d = f.selectedIndices),
									(m = f.selectedScores),
									s !== t && s.dispose(),
									u !== n && u.dispose(),
									e.abrupt("return", { selectedIndices: AE(d, "int32"), selectedScores: AE(m) })
								);
							case 19:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var LR = yk({
		nonMaxSuppressionPadded_: function (e, t, n, r, a, i) {
			void 0 === r && (r = 0.5), void 0 === a && (a = Number.NEGATIVE_INFINITY), void 0 === i && (i = !1);
			var o = mk(e, "boxes", "nonMaxSuppression"),
				s = mk(t, "scores", "nonMaxSuppression"),
				u = kR(o, s, n, r, a, null),
				l = { boxes: o, scores: s },
				c = {
					maxOutputSize: u.maxOutputSize,
					iouThreshold: u.iouThreshold,
					scoreThreshold: u.scoreThreshold,
					padToMaxOutputSize: i,
				},
				p = ok.runKernel(yb, l, c);
			return { selectedIndices: p[0], validOutputs: p[1] };
		},
	});
	function zR() {
		return (zR = fg(
			regeneratorRuntime.mark(function e(t, n, r, a, i, o) {
				var s, u, l, c, p, h, f, d, m, g, v, y;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (
									void 0 === a && (a = 0.5),
									void 0 === i && (i = Number.NEGATIVE_INFINITY),
									void 0 === o && (o = !1),
									(s = mk(t, "boxes", "nonMaxSuppressionAsync")),
									(u = mk(n, "scores", "nonMaxSuppressionAsync")),
									(l = kR(s, u, r, a, i, null)),
									(c = l.maxOutputSize),
									(p = l.iouThreshold),
									(h = l.scoreThreshold),
									(e.next = 11),
									Promise.all([s.data(), u.data()])
								);
							case 11:
								return (
									(f = e.sent),
									(d = f[0]),
									(m = f[1]),
									(g = CR(d, m, c, p, h, o)),
									(v = g.selectedIndices),
									(y = g.validOutputs),
									s !== t && s.dispose(),
									u !== n && u.dispose(),
									e.abrupt("return", {
										selectedIndices: AE(v, "int32"),
										validOutputs: iE(y, "int32"),
									})
								);
							case 18:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var PR = yk({
			resizeBilinear_: function (e, t, n, r) {
				void 0 === n && (n = !1), void 0 === r && (r = !1);
				var a = mk(e, "images", "resizeBilinear");
				Dg(3 === a.rank || 4 === a.rank, function () {
					return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + a.rank + ".";
				}),
					Dg(2 === t.length, function () {
						return "Error in resizeBilinear: new shape must 2D, but got shape " + t + ".";
					}),
					Dg(!1 === r || !1 === n, function () {
						return "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.";
					});
				var i = a,
					o = !1;
				3 === a.rank && ((o = !0), (i = wS(a, [1, a.shape[0], a.shape[1], a.shape[2]])));
				var s = { images: i },
					u = { alignCorners: n, halfPixelCenters: r, size: t },
					l = ok.runKernel(Ob, s, u);
				return o ? wS(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
			},
		}),
		BR = yk({
			resizeNearestNeighbor_: function (e, t, n, r) {
				void 0 === n && (n = !1), void 0 === r && (r = !1);
				var a = mk(e, "images", "resizeNearestNeighbor");
				Dg(3 === a.rank || 4 === a.rank, function () {
					return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + a.rank + ".";
				}),
					Dg(2 === t.length, function () {
						return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + t + ".";
					}),
					Dg("float32" === a.dtype || "int32" === a.dtype, function () {
						return "`images` must have `int32` or `float32` as dtype";
					}),
					Dg(!1 === r || !1 === n, function () {
						return "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.";
					});
				var i = a,
					o = !1;
				3 === a.rank && ((o = !0), (i = wS(a, [1, a.shape[0], a.shape[1], a.shape[2]])));
				var s = { images: i },
					u = { alignCorners: n, halfPixelCenters: r, size: t },
					l = ok.runKernel(Fb, s, u);
				return o ? wS(l, [l.shape[1], l.shape[2], l.shape[3]]) : l;
			},
		}),
		WR = yk({
			threshold_: function (e, t, n, r) {
				void 0 === t && (t = "binary"), void 0 === n && (n = !1), void 0 === r && (r = 0.5);
				var a,
					i,
					o,
					s,
					u = mk(e, "image", "threshold"),
					l = u.shape[0] * u.shape[1],
					c = KI(AE([r]), 255);
				if (
					(Dg(3 === u.rank, function () {
						return "Error in threshold: image must be rank 3,but got rank " + u.rank + ".";
					}),
					Dg(3 === u.shape[2] || 1 === u.shape[2], function () {
						return (
							"Error in threshold: image color channel must be equal to 3 or 1but got " + u.shape[2] + "."
						);
					}),
					Dg("int32" === u.dtype || "float32" === u.dtype, function () {
						return "Error in dtype: image dtype must be int32 or float32,but got dtype " + u.dtype + ".";
					}),
					Dg("otsu" === t || "binary" === t, function () {
						return "Method must be binary or otsu, but was " + t;
					}),
					3 === u.shape[2])
				) {
					var p = wE(u, [1, 1, 1], -1);
					(a = p[0]), (i = p[1]), (o = p[2]);
					var h = KI(a, 0.2989),
						f = KI(i, 0.587),
						d = KI(o, 0.114);
					s = jI(jI(h, f), d);
				} else s = e;
				"otsu" === t &&
					(c = (function (e, t) {
						for (var n, r, a, i, o, s, u = AE([-1]), l = AE([0]), c = AE([0]), p = 0; p < e.size - 1; p++) {
							(n = TS(e, 0, p + 1)), (r = TS(e, p + 1)), (o = qI(VT(n), t)), (s = qI(VT(r), t));
							var h = VT(KI(n, KC(0, n.size)));
							a = qI(h, VT(n));
							var f = yT(r.shape, n.size),
								d = jI(KC(0, r.size), f),
								m = KI(r, d);
							i = qI(VT(m), VT(r));
							var g = UT(a, i),
								v = UT(a, i),
								y = KI(o, s);
							c = KI(KI(y, g), v);
							var b = wT(c, l);
							(l = oT(b, c, l)), (u = oT(b, AE([p]), u));
						}
						return u;
					})(OS(NN(rE(s), "int32"), wk([]), 256), l));
				var m = n ? RT(s, c) : wT(s, c);
				return NN(KI(m, 255), "int32");
			},
		}),
		UR = yk({
			transform_: function (e, t, n, r, a, i) {
				void 0 === n && (n = "nearest"), void 0 === r && (r = "constant"), void 0 === a && (a = 0);
				var o = mk(e, "image", "transform", "float32"),
					s = mk(t, "transforms", "transform", "float32");
				Dg(4 === o.rank, function () {
					return "Error in transform: image must be rank 4,but got rank " + o.rank + ".";
				}),
					Dg(
						2 === s.rank && (s.shape[0] === o.shape[0] || 1 === s.shape[0]) && 8 === s.shape[1],
						function () {
							return "Error in transform: Input transform should be batch x 8 or 1 x 8";
						}
					),
					Dg(null == i || 2 === i.length, function () {
						return "Error in transform: outputShape must be [height, width] or null, but got " + i + ".";
					});
				var u = { image: o, transforms: s },
					l = { interpolation: n, fillMode: r, fillValue: a, outputShape: i };
				return ok.runKernel(gx, u, l);
			},
		}),
		VR = yk({
			bandPart_: function (e, t, n) {
				Dg(t % 1 == 0, function () {
					return "bandPart(): numLower must be an integer, got " + t + ".";
				}),
					Dg(n % 1 == 0, function () {
						return "bandPart(): numUpper must be an integer, got " + n + ".";
					});
				var r = mk(e, "a", "bandPart");
				Dg(r.rank >= 2, function () {
					return "bandPart(): Rank must be at least 2, got " + r.rank + ".";
				});
				var a = r.shape,
					i = r.shape.slice(-2),
					o = i[0],
					s = i[1];
				if (!(t <= o))
					throw new Error(
						"bandPart(): numLower (" + t + ") must not be greater than the number of rows (" + o + ")."
					);
				if (!(n <= s))
					throw new Error(
						"bandPart(): numUpper (" + n + ") must not be greater than the number of columns (" + s + ")."
					);
				t < 0 && (t = o), n < 0 && (n = s);
				var u = wS(KC(0, o, 1, "int32"), [-1, 1]),
					l = KC(0, s, 1, "int32"),
					c = UT(u, l),
					p = $T(RT(c, iE(+t, "int32")), kT(c, iE(-n, "int32"))),
					h = uC([o, s], r.dtype);
				return wS(
					TE(
						BE(wS(r, [-1, o, s])).map(function (e) {
							return oT(p, e, h);
						})
					),
					a
				);
			},
		}),
		GR = yk({
			gramSchmidt_: function (e) {
				var t;
				Array.isArray(e)
					? (function () {
							(t = !1),
								Dg(null != e && e.length > 0, function () {
									return "Gram-Schmidt process: input must not be null, undefined, or empty";
								});
							for (
								var n = e[0].shape[0],
									r = function (t) {
										Dg(e[t].shape[0] === n, function () {
											return (
												"Gram-Schmidt: Non-unique lengths found in the input vectors: (" +
												e[t].shape[0] +
												" vs. " +
												n +
												")"
											);
										});
									},
									a = 1;
								a < e.length;
								++a
							)
								r(a);
					  })()
					: ((t = !0),
					  (e = wE(e, e.shape[0], 0).map(function (e) {
							return SE(e, [0]);
					  }))),
					Dg(e.length <= e[0].shape[0], function () {
						return (
							"Gram-Schmidt: Number of vectors (" +
							e.length +
							") exceeds number of dimensions (" +
							e[0].shape[0] +
							")."
						);
					});
				for (
					var n = [],
						r = e,
						a = function (e) {
							n.push(
								ok.tidy(function () {
									var t = r[e];
									if (e > 0)
										for (var a = 0; a < e; ++a) {
											var i = KI(VT(KI(n[a], t)), n[a]);
											t = UT(t, i);
										}
									return qI(t, KE(t, "euclidean"));
								})
							);
						},
						i = 0;
					i < e.length;
					++i
				)
					a(i);
				return t ? TE(n, 0) : n;
			},
		});
	function jR(e, t) {
		return (
			void 0 === t && (t = !1),
			ok.tidy(function () {
				Dg(2 === e.shape.length, function () {
					return "qr2d() requires a 2D Tensor, but got a " + e.shape.length + "D Tensor.";
				});
				for (
					var n = e.shape[0],
						r = e.shape[1],
						a = vT(n),
						i = IN(e),
						o = _E([[1]], [1, 1]),
						s = IN(o),
						u = n >= r ? r : n,
						l = function (e) {
							var t = i,
								u = s,
								l = a,
								c = ok.tidy(function () {
									var t = TS(i, [e, e], [n - e, 1]),
										u = KE(t),
										l = TS(i, [e, e], [1, 1]),
										c = oT(wT(l, 0), _E([[-1]]), _E([[1]])),
										p = UT(l, KI(c, u)),
										h = qI(t, p);
									s =
										1 === h.shape[0]
											? IN(o)
											: IS([o, TS(h, [1, 0], [h.shape[0] - 1, h.shape[1]])], 0);
									var f = zT(qI(jN(c, p), u)),
										d = TS(i, [e, 0], [n - e, r]),
										m = KI(f, s),
										g = qN(s);
									if (0 === e) i = UT(d, jN(m, jN(g, d)));
									else {
										var v = UT(d, jN(m, jN(g, d)));
										i = IS([TS(i, [0, 0], [e, r]), v], 0);
									}
									var y = qN(m),
										b = TS(a, [0, e], [n, a.shape[1] - e]);
									if (0 === e) a = UT(b, jN(jN(b, s), y));
									else {
										var x = UT(b, jN(jN(b, s), y));
										a = IS([TS(a, [0, 0], [n, e]), x], 1);
									}
									return [s, i, a];
								});
							(s = c[0]), (i = c[1]), (a = c[2]), WI([t, u, l]);
						},
						c = 0;
					c < u;
					++c
				)
					l(c);
				return !t && n > r && ((a = TS(a, [0, 0], [n, r])), (i = TS(i, [0, 0], [r, r]))), [a, i];
			})
		);
	}
	var HR,
		qR = yk({
			qr_: function (e, t) {
				if (
					(void 0 === t && (t = !1),
					Dg(e.rank >= 2, function () {
						return "qr() requires input tensor to have a rank >= 2, but got rank " + e.rank;
					}),
					2 === e.rank)
				)
					return jR(e, t);
				var n = e.shape.slice(0, e.shape.length - 2).reduce(function (e, t) {
						return e * t;
					}),
					r = BE(wS(e, [n, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0),
					a = [],
					i = [];
				return (
					r.forEach(function (e) {
						var n = jR(e, t),
							r = n[0],
							o = n[1];
						a.push(r), i.push(o);
					}),
					[wS(TE(a, 0), e.shape), wS(TE(i, 0), e.shape)]
				);
			},
		});
	((HR = e.Reduction || (e.Reduction = {}))[(HR.NONE = 0)] = "NONE"),
		(HR[(HR.MEAN = 1)] = "MEAN"),
		(HR[(HR.SUM = 2)] = "SUM"),
		(HR[(HR.SUM_BY_NONZERO_WEIGHTS = 3)] = "SUM_BY_NONZERO_WEIGHTS");
	var KR = yk({
			computeWeightedLoss_: function (t, n, r) {
				void 0 === r && (r = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
				var a = mk(t, "losses", "computeWeightedLoss"),
					i = null;
				null != n && (i = mk(n, "weights", "computeWeightedLoss"));
				var o = null == i ? a : KI(a, i);
				if (r === e.Reduction.NONE) return o;
				if (r === e.Reduction.SUM) return VT(o);
				if (r === e.Reduction.MEAN) {
					if (null == i) return sC(o);
					var s = a.size / i.size,
						u = qI(VT(o), VT(i));
					return s > 1 ? qI(u, iE(s)) : u;
				}
				if (r === e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
					if (null == i) return qI(VT(o), iE(a.size));
					var l = KI(i, lC(a.shape)),
						c = NN(VT(bC(l, iE(0))), "float32");
					return qI(VT(o), c);
				}
				throw Error("Unknown reduction: " + r);
			},
		}),
		XR = yk({
			absoluteDifference_: function (t, n, r, a) {
				void 0 === a && (a = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
				var i = mk(t, "labels", "absoluteDifference"),
					o = mk(n, "predictions", "absoluteDifference"),
					s = null;
				null != r && (s = mk(r, "weights", "absoluteDifference")),
					Og(i.shape, o.shape, "Error in absoluteDifference: ");
				var u = XI(UT(i, o));
				return KR(u, s, a);
			},
		}),
		YR = yk({
			cosineDistance_: function (t, n, r, a, i) {
				void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
				var o = mk(t, "labels", "cosineDistance"),
					s = mk(n, "predictions", "cosineDistance"),
					u = null;
				null != a && (u = mk(a, "weights", "cosineDistance")),
					Og(o.shape, s.shape, "Error in cosineDistance: ");
				var l = iE(1),
					c = UT(l, VT(KI(o, s), r, !0));
				return KR(c, u, i);
			},
		}),
		JR = yk({
			hingeLoss_: function (t, n, r, a) {
				void 0 === a && (a = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
				var i = mk(t, "labels", "hingeLoss"),
					o = mk(n, "predictions", "hingeLoss"),
					s = null;
				null != r && (s = mk(r, "weights", "hingeLoss")), Og(i.shape, o.shape, "Error in hingeLoss: ");
				var u = iE(1);
				i = UT(KI(iE(2), i), u);
				var l = JC(UT(u, KI(i, o)));
				return KR(l, s, a);
			},
		}),
		ZR = yk({
			huberLoss_: function (t, n, r, a, i) {
				void 0 === a && (a = 1), void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
				var o = mk(t, "labels", "huberLoss"),
					s = mk(n, "predictions", "huberLoss"),
					u = null;
				null != r && (u = mk(r, "weights", "huberLoss")), Og(o.shape, s.shape, "Error in huberLoss: ");
				var l = iE(a),
					c = XI(UT(s, o)),
					p = hC(c, l),
					h = UT(c, p),
					f = jI(KI(iE(0.5), mC(p)), KI(l, h));
				return KR(f, u, i);
			},
		}),
		QR = yk({
			logLoss_: function (t, n, r, a, i) {
				void 0 === a && (a = 1e-7), void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
				var o = mk(t, "labels", "logLoss"),
					s = mk(n, "predictions", "logLoss"),
					u = null;
				null != r && (u = mk(r, "weights", "logLoss")), Og(o.shape, s.shape, "Error in logLoss: ");
				var l = iE(1),
					c = iE(a),
					p = zT(KI(o, FT(jI(s, c)))),
					h = KI(UT(l, o), FT(jI(UT(l, s), c))),
					f = UT(p, h);
				return KR(f, u, i);
			},
		}),
		$R = yk({
			meanSquaredError_: function (t, n, r, a) {
				void 0 === a && (a = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
				var i = mk(t, "labels", "meanSquaredError"),
					o = mk(n, "predictions", "meanSquaredError"),
					s = null;
				null != r && (s = mk(r, "weights", "meanSquaredError")),
					Og(i.shape, o.shape, "Error in meanSquaredError: ");
				var u = IE(i, o);
				return KR(u, s, a);
			},
		}),
		eA = yk({
			sigmoidCrossEntropy_: function (t, n, r, a, i) {
				void 0 === a && (a = 0), void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
				var o = mk(t, "multiClassLabels", "sigmoidCrossEntropy"),
					s = mk(n, "logits", "sigmoidCrossEntropy"),
					u = null;
				if (
					(null != r && (u = mk(r, "weights", "sigmoidCrossEntropy")),
					Og(o.shape, s.shape, "Error in sigmoidCrossEntropy: "),
					a > 0)
				) {
					var l = iE(a),
						c = iE(1),
						p = iE(0.5);
					o = jI(KI(o, UT(c, l)), KI(p, l));
				}
				var h = (function (e, t) {
					var n = mk(e, "labels", "sigmoidCrossEntropyWithLogits"),
						r = mk(t, "logits", "sigmoidCrossEntropyWithLogits");
					Og(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
					var a = JC(r),
						i = KI(r, n),
						o = DT(fT(zT(XI(r))));
					return jI(UT(a, i), o);
				})(o, s);
				return KR(h, u, i);
			},
		}),
		tA = yk({
			softmaxCrossEntropy_: function (t, n, r, a, i) {
				void 0 === a && (a = 0), void 0 === i && (i = e.Reduction.SUM_BY_NONZERO_WEIGHTS);
				var o = mk(t, "onehotLabels", "softmaxCrossEntropy"),
					s = mk(n, "logits", "softmaxCrossEntropy"),
					u = null;
				if (
					(null != r && (u = mk(r, "weights", "softmaxCrossEntropy")),
					Og(o.shape, s.shape, "Error in softmaxCrossEntropy: "),
					a > 0)
				) {
					var l = iE(a),
						c = iE(1),
						p = iE(o.shape[1]);
					o = jI(KI(o, UT(c, l)), qI(l, p));
				}
				var h = (function (e, t, n) {
					if ((void 0 === n && (n = -1), -1 === n && (n = t.rank - 1), n !== t.rank - 1))
						throw Error(
							"Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " +
								t.rank +
								" and dim was " +
								n
						);
					return MT(function (e, t, r) {
						var a = QT(t, [n], !0),
							i = UT(NN(t, "float32"), a);
						r([e, i]);
						var o = zT(KI(i, e));
						return {
							value: VT(o, [n]),
							gradFunc: function (e, t) {
								var r = t[0],
									a = t[1],
									i = KT(e.shape, [n]);
								return [
									KI(wS(e, i), UT(NN(r, "float32"), fT(a))),
									KI(wS(e, i), UT(fT(a), NN(r, "float32"))),
								];
							},
						};
					})(e, t);
				})(o, s);
				return KR(h, u, i);
			},
		}),
		nA = yk({
			sparseFillEmptyRows_: function (e, t, n, r) {
				var a = mk(e, "indices", "sparseFillEmptyRows", "int32"),
					i = mk(t, "values", "sparseFillEmptyRows"),
					o = mk(n, "denseShape", "sparseFillEmptyRows", "int32"),
					s = mk(r, "defaultValue", "sparseFillEmptyRows", i.dtype);
				if (2 !== a.rank) throw new Error("Indices should be Tensor2D but received shape\n        " + a.shape);
				if (1 !== i.rank) throw new Error("Values should be Tensor1D but received shape " + i.shape);
				if (1 !== o.rank) throw new Error("Dense shape should be Tensor1D but received shape " + o.shape);
				if (0 !== s.rank) throw new Error("Default value should be a scalar but received shape " + s.shape);
				var u = { indices: a, values: i, denseShape: o, defaultValue: s },
					l = ok.runKernel(ex, u);
				return { outputIndices: l[0], outputValues: l[1], emptyRowIndicator: l[2], reverseIndexMap: l[3] };
			},
		}),
		rA = yk({
			sparseReshape_: function (e, t, n) {
				var r = mk(e, "inputIndices", "sparseReshape", "int32"),
					a = mk(t, "inputShape", "sparseReshape", "int32"),
					i = mk(n, "newShape", "sparseReshape", "int32");
				if (2 !== r.rank)
					throw new Error("Input indices should be Tensor2D but received shape\n        " + r.shape);
				if (1 !== a.rank) throw new Error("Input shape should be Tensor1D but received shape " + a.shape);
				if (1 !== i.rank) throw new Error("New shape should be Tensor1D but received shape " + i.shape);
				var o = { inputIndices: r, inputShape: a, newShape: i },
					s = ok.runKernel(tx, o);
				return { outputIndices: s[0], outputShape: s[1] };
			},
		}),
		aA = yk({
			sparseSegmentMean_: function (e, t, n) {
				var r = mk(e, "data", "sparseSegmentMean"),
					a = mk(t, "indices", "sparseSegmentMean", "int32"),
					i = mk(n, "segmentIds", "sparseSegmentMean", "int32");
				if (r.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
				if (1 !== a.rank)
					throw new Error("Indices should be Tensor1D but received shape\n          " + a.shape);
				if (1 !== i.rank)
					throw new Error("Segment ids should be Tensor1D but received shape\n          " + i.shape);
				var o = { data: r, indices: a, segmentIds: i };
				return ok.runKernel(nx, o);
			},
		}),
		iA = yk({
			sparseSegmentSum_: function (e, t, n) {
				var r = mk(e, "data", "sparseSegmentSum"),
					a = mk(t, "indices", "sparseSegmentSum", "int32"),
					i = mk(n, "segmentIds", "sparseSegmentSum", "int32");
				if (r.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
				if (1 !== a.rank) throw new Error("Indices should be Tensor1D but received shape\n         " + a.shape);
				if (1 !== i.rank)
					throw new Error("Segment ids should be Tensor1D but received shape\n         " + i.shape);
				var o = { data: r, indices: a, segmentIds: i };
				return ok.runKernel(rx, o);
			},
		}),
		oA = yk({
			stringNGrams_: function (e, t, n, r, a, i, o, s) {
				var u = mk(e, "data", "stringNGrams", "string");
				if ("string" !== u.dtype) throw new Error("Data must be of datatype string");
				if (1 !== u.shape.length) throw new Error("Data must be a vector, saw: " + u.shape);
				var l = mk(t, "dataSplits", "stringNGrams");
				if ("int32" !== l.dtype) throw new Error("Data splits must be of datatype int32");
				var c = {
						separator: n,
						nGramWidths: r,
						leftPad: a,
						rightPad: i,
						padWidth: o,
						preserveShortSequences: s,
					},
					p = { data: u, dataSplits: l },
					h = ok.runKernel(ux, p, c);
				return { nGrams: h[0], nGramsSplits: h[1] };
			},
		}),
		sA = yk({
			stringSplit_: function (e, t, n) {
				void 0 === n && (n = !0);
				var r = mk(e, "input", "stringSplit", "string"),
					a = mk(t, "delimiter", "stringSplit", "string");
				if (1 !== r.rank) throw new Error("Input should be Tensor1D but received shape " + r.shape);
				if (0 !== a.rank) throw new Error("Delimiter should be a scalar but received shape " + a.shape);
				var i = { skipEmpty: n },
					o = { input: r, delimiter: a },
					s = ok.runKernel(lx, o, i);
				return { indices: s[0], values: s[1], shape: s[2] };
			},
		}),
		uA = yk({
			stringToHashBucketFast_: function (e, t) {
				var n = mk(e, "input", "stringToHashBucketFast", "string"),
					r = { numBuckets: t };
				if (t <= 0) throw new Error("Number of buckets must be at least 1");
				var a = { input: n };
				return ok.runKernel(cx, a, r);
			},
		}),
		lA = { fft: yE, ifft: bE, rfft: kE, irfft: xE },
		cA = { hammingWindow: dR, hannWindow: mR, frame: gR, stft: vR },
		pA = {
			flipLeftRight: bR,
			grayscaleToRGB: xR,
			resizeNearestNeighbor: BR,
			resizeBilinear: PR,
			rotateWithOffset: wR,
			cropAndResize: yR,
			nonMaxSuppression: NR,
			nonMaxSuppressionAsync: function (e, t, n, r, a) {
				return DR.apply(this, arguments);
			},
			nonMaxSuppressionWithScore: OR,
			nonMaxSuppressionWithScoreAsync: function (e, t, n, r, a, i) {
				return MR.apply(this, arguments);
			},
			nonMaxSuppressionPadded: LR,
			nonMaxSuppressionPaddedAsync: function (e, t, n, r, a, i) {
				return zR.apply(this, arguments);
			},
			threshold: WR,
			transform: UR,
		},
		hA = { bandPart: VR, gramSchmidt: GR, qr: qR },
		fA = {
			absoluteDifference: XR,
			computeWeightedLoss: KR,
			cosineDistance: YR,
			hingeLoss: JR,
			huberLoss: ZR,
			logLoss: QR,
			meanSquaredError: $R,
			sigmoidCrossEntropy: eA,
			softmaxCrossEntropy: tA,
		},
		dA = { sparseFillEmptyRows: nA, sparseReshape: rA, sparseSegmentMean: aA, sparseSegmentSum: iA },
		mA = { stringNGrams: oA, stringSplit: sA, stringToHashBucketFast: uA },
		gA = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.minimize = function (e, t, n) {
					void 0 === t && (t = !1);
					var r = this.computeGradients(e, n),
						a = r.value,
						i = r.grads;
					if (null != n) {
						var o = n.map(function (e) {
							return { name: e.name, tensor: i[e.name] };
						});
						this.applyGradients(o);
					} else this.applyGradients(i);
					return WI(i), t ? a : (a.dispose(), null);
				}),
				(n.incrementIterations = function () {
					this.iterations_ = this.iterations + 1;
				}),
				(n.computeGradients = function (e, t) {
					return OT(e, t);
				}),
				(n.dispose = function () {
					null != this.iterations_ && WI(this.iterations_);
				}),
				(n.saveIterations = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													null == this.iterations_ && (this.iterations_ = 0),
													e.abrupt("return", {
														name: "iter",
														tensor: iE(this.iterations_, "int32"),
													})
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.getWeights = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											throw new Error("getWeights() is not implemented for this optimizer yet.");
										case 1:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.setWeights = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												throw new Error(
													"setWeights() is not implemented for this optimizer class " +
														this.getClassName()
												);
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.extractIterations = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), t[0].tensor.data();
											case 2:
												return (this.iterations_ = e.sent[0]), e.abrupt("return", t.slice(1));
											case 4:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				mg(t, [
					{
						key: "iterations",
						get: function () {
							return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
						},
					},
				]),
				t
			);
		})(EI);
	Object.defineProperty(gA, Symbol.hasInstance, {
		value: function (e) {
			return null != e.minimize && null != e.computeGradients && null != e.applyGradients;
		},
	});
	var vA = (function (e) {
		function t(t, n, r) {
			var a;
			return (
				void 0 === r && (r = null),
				((a = e.call(this) || this).learningRate = t),
				(a.rho = n),
				(a.epsilon = r),
				(a.accumulatedGrads = []),
				(a.accumulatedUpdates = []),
				null == r && (a.epsilon = ok.backend.epsilon()),
				a
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.applyGradients = function (e) {
				var t = this;
				(Array.isArray(e)
					? e.map(function (e) {
							return e.name;
					  })
					: Object.keys(e)
				).forEach(function (n, r) {
					var a = ok.registeredVariables[n];
					null == t.accumulatedGrads[r] &&
						(t.accumulatedGrads[r] = {
							originalName: n + "/accum_grad",
							variable: BI(function () {
								return sT(a).variable(!1);
							}),
						}),
						null == t.accumulatedUpdates[r] &&
							(t.accumulatedUpdates[r] = {
								originalName: n + "/accum_var",
								variable: BI(function () {
									return sT(a).variable(!1);
								}),
							});
					var i = Array.isArray(e) ? e[r].tensor : e[n];
					if (null != i) {
						var o = t.accumulatedGrads[r].variable,
							s = t.accumulatedUpdates[r].variable;
						BI(function () {
							var e = jI(KI(o, t.rho), KI(mC(i), 1 - t.rho)),
								n = KI(qI(NE(jI(s, t.epsilon)), NE(jI(o, t.epsilon))), i),
								r = jI(KI(s, t.rho), KI(mC(n), 1 - t.rho));
							o.assign(e), s.assign(r);
							var u = jI(KI(n, -t.learningRate), a);
							a.assign(u);
						});
					}
				}),
					this.incrementIterations();
			}),
			(n.dispose = function () {
				null != this.accumulatedUpdates &&
					(WI(
						this.accumulatedGrads.map(function (e) {
							return e.variable;
						})
					),
					WI(
						this.accumulatedUpdates.map(function (e) {
							return e.variable;
						})
					));
			}),
			(n.getWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						var t;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (
												(t = [].concat(this.accumulatedGrads, this.accumulatedUpdates)),
												(e.next = 3),
												this.saveIterations()
											);
										case 3:
											return (
												(e.t0 = e.sent),
												e.abrupt(
													"return",
													[e.t0].concat(
														t.map(function (e) {
															return { name: e.originalName, tensor: e.variable };
														})
													)
												)
											);
										case 5:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(n.setWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						var n;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.extractIterations(t);
										case 2:
											(t = e.sent),
												(n = t.length / 2),
												(this.accumulatedGrads = t.slice(0, n).map(function (e) {
													return { originalName: e.name, variable: e.tensor.variable(!1) };
												})),
												(this.accumulatedUpdates = t.slice(n, 2 * n).map(function (e) {
													return { originalName: e.name, variable: e.tensor.variable(!1) };
												}));
										case 7:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(n.getConfig = function () {
				return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
			}),
			(t.fromConfig = function (e, t) {
				return new e(t.learningRate, t.rho, t.epsilon);
			}),
			t
		);
	})(gA);
	(vA.className = "Adadelta"), AI(vA);
	var yA = (function (e) {
		function t(t, n) {
			var r;
			return (
				void 0 === n && (n = 0.1),
				((r = e.call(this) || this).learningRate = t),
				(r.initialAccumulatorValue = n),
				(r.accumulatedGrads = []),
				r
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.applyGradients = function (e) {
				var t = this;
				(Array.isArray(e)
					? e.map(function (e) {
							return e.name;
					  })
					: Object.keys(e)
				).forEach(function (n, r) {
					var a = ok.registeredVariables[n];
					null == t.accumulatedGrads[r] &&
						(t.accumulatedGrads[r] = {
							originalName: n + "/accumulator",
							variable: BI(function () {
								return yT(a.shape, t.initialAccumulatorValue).variable(!1);
							}),
						});
					var i = Array.isArray(e) ? e[r].tensor : e[n];
					if (null != i) {
						var o = t.accumulatedGrads[r].variable;
						BI(function () {
							var e = jI(o, mC(i));
							o.assign(e);
							var n = jI(KI(qI(i, NE(jI(e, ok.backend.epsilon()))), -t.learningRate), a);
							a.assign(n);
						});
					}
				}),
					this.incrementIterations();
			}),
			(n.dispose = function () {
				null != this.accumulatedGrads &&
					WI(
						this.accumulatedGrads.map(function (e) {
							return e.variable;
						})
					);
			}),
			(n.getWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.saveIterations();
										case 2:
											return (
												(e.t0 = e.sent),
												e.abrupt(
													"return",
													[e.t0].concat(
														this.accumulatedGrads.map(function (e) {
															return { name: e.originalName, tensor: e.variable };
														})
													)
												)
											);
										case 4:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(n.setWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.extractIterations(t);
										case 2:
											(t = e.sent),
												(this.accumulatedGrads = t.map(function (e) {
													return { originalName: e.name, variable: e.tensor.variable(!1) };
												}));
										case 5:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(n.getConfig = function () {
				return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
			}),
			(t.fromConfig = function (e, t) {
				return new e(t.learningRate, t.initialAccumulatorValue);
			}),
			t
		);
	})(gA);
	(yA.className = "Adagrad"), AI(yA);
	var bA = (function (e) {
		function t(t, n, r, a) {
			var i;
			return (
				void 0 === a && (a = null),
				((i = e.call(this) || this).learningRate = t),
				(i.beta1 = n),
				(i.beta2 = r),
				(i.epsilon = a),
				(i.accumulatedFirstMoment = []),
				(i.accumulatedSecondMoment = []),
				BI(function () {
					(i.accBeta1 = iE(n).variable()), (i.accBeta2 = iE(r).variable());
				}),
				null == a && (i.epsilon = ok.backend.epsilon()),
				i
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.applyGradients = function (e) {
				var t = this,
					n = Array.isArray(e)
						? e.map(function (e) {
								return e.name;
						  })
						: Object.keys(e);
				BI(function () {
					var r = UT(1, t.accBeta1),
						a = UT(1, t.accBeta2);
					n.forEach(function (n, i) {
						var o = ok.registeredVariables[n];
						null == t.accumulatedFirstMoment[i] &&
							(t.accumulatedFirstMoment[i] = {
								originalName: n + "/m",
								variable: BI(function () {
									return sT(o).variable(!1);
								}),
							}),
							null == t.accumulatedSecondMoment[i] &&
								(t.accumulatedSecondMoment[i] = {
									originalName: n + "/v",
									variable: BI(function () {
										return sT(o).variable(!1);
									}),
								});
						var s = Array.isArray(e) ? e[i].tensor : e[n];
						if (null != s) {
							var u = t.accumulatedFirstMoment[i].variable,
								l = t.accumulatedSecondMoment[i].variable,
								c = jI(KI(u, t.beta1), KI(s, 1 - t.beta1)),
								p = jI(KI(l, t.beta2), KI(mC(s), 1 - t.beta2)),
								h = qI(c, r),
								f = qI(p, a);
							u.assign(c), l.assign(p);
							var d = jI(KI(qI(h, jI(NE(f), t.epsilon)), -t.learningRate), o);
							o.assign(d);
						}
					}),
						t.accBeta1.assign(KI(t.accBeta1, t.beta1)),
						t.accBeta2.assign(KI(t.accBeta2, t.beta2));
				}),
					this.incrementIterations();
			}),
			(n.dispose = function () {
				this.accBeta1.dispose(),
					this.accBeta2.dispose(),
					null != this.accumulatedFirstMoment &&
						WI(
							this.accumulatedFirstMoment.map(function (e) {
								return e.variable;
							})
						),
					null != this.accumulatedSecondMoment &&
						WI(
							this.accumulatedSecondMoment.map(function (e) {
								return e.variable;
							})
						);
			}),
			(n.getWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						var t;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (
												(t = [].concat(
													this.accumulatedFirstMoment,
													this.accumulatedSecondMoment
												)),
												(e.next = 3),
												this.saveIterations()
											);
										case 3:
											return (
												(e.t0 = e.sent),
												e.abrupt(
													"return",
													[e.t0].concat(
														t.map(function (e) {
															return { name: e.originalName, tensor: e.variable };
														})
													)
												)
											);
										case 5:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(n.setWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						var n,
							r = this;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.extractIterations(t);
										case 2:
											(t = e.sent),
												BI(function () {
													r.accBeta1.assign(RC(r.beta1, r.iterations_ + 1)),
														r.accBeta2.assign(RC(r.beta2, r.iterations_ + 1));
												}),
												(n = t.length / 2),
												(this.accumulatedFirstMoment = t.slice(0, n).map(function (e) {
													return { originalName: e.name, variable: e.tensor.variable(!1) };
												})),
												(this.accumulatedSecondMoment = t.slice(n, 2 * n).map(function (e) {
													return { originalName: e.name, variable: e.tensor.variable(!1) };
												}));
										case 8:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(n.getConfig = function () {
				return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
			}),
			(t.fromConfig = function (e, t) {
				return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);
			}),
			t
		);
	})(gA);
	(bA.className = "Adam"), AI(bA);
	var xA = (function (e) {
		function t(t, n, r, a, i) {
			var o;
			return (
				void 0 === a && (a = null),
				void 0 === i && (i = 0),
				((o = e.call(this) || this).learningRate = t),
				(o.beta1 = n),
				(o.beta2 = r),
				(o.epsilon = a),
				(o.decay = i),
				(o.accumulatedFirstMoment = []),
				(o.accumulatedWeightedInfNorm = []),
				BI(function () {
					(o.iteration = iE(0).variable()), (o.accBeta1 = iE(n).variable());
				}),
				null == a && (o.epsilon = ok.backend.epsilon()),
				o
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.applyGradients = function (e) {
				var t = this,
					n = Array.isArray(e)
						? e.map(function (e) {
								return e.name;
						  })
						: Object.keys(e);
				BI(function () {
					var r = UT(1, t.accBeta1),
						a = qI(-t.learningRate, jI(KI(t.iteration, t.decay), 1));
					n.forEach(function (n, i) {
						var o = ok.registeredVariables[n];
						null == t.accumulatedFirstMoment[i] &&
							(t.accumulatedFirstMoment[i] = { originalName: n + "/m", variable: sT(o).variable(!1) }),
							null == t.accumulatedWeightedInfNorm[i] &&
								(t.accumulatedWeightedInfNorm[i] = {
									originalName: n + "/v",
									variable: sT(o).variable(!1),
								});
						var s = Array.isArray(e) ? e[i].tensor : e[n];
						if (null != s) {
							var u = t.accumulatedFirstMoment[i].variable,
								l = t.accumulatedWeightedInfNorm[i].variable,
								c = jI(KI(u, t.beta1), KI(s, 1 - t.beta1)),
								p = KI(l, t.beta2),
								h = XI(s),
								f = oC(p, h);
							u.assign(c), l.assign(f);
							var d = jI(KI(qI(a, r), qI(c, jI(f, t.epsilon))), o);
							o.assign(d);
						}
					}),
						t.iteration.assign(jI(t.iteration, 1)),
						t.accBeta1.assign(KI(t.accBeta1, t.beta1));
				}),
					this.incrementIterations();
			}),
			(n.dispose = function () {
				this.accBeta1.dispose(),
					this.iteration.dispose(),
					null != this.accumulatedFirstMoment &&
						WI(
							this.accumulatedFirstMoment.map(function (e) {
								return e.variable;
							})
						),
					null != this.accumulatedWeightedInfNorm &&
						WI(
							this.accumulatedWeightedInfNorm.map(function (e) {
								return e.variable;
							})
						);
			}),
			(n.getWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						return regeneratorRuntime.wrap(function (e) {
							for (;;)
								switch ((e.prev = e.next)) {
									case 0:
										throw new Error("getWeights() is not implemented for Adamax yet.");
									case 1:
									case "end":
										return e.stop();
								}
						}, e);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(n.setWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						return regeneratorRuntime.wrap(function (e) {
							for (;;)
								switch ((e.prev = e.next)) {
									case 0:
										throw new Error("setWeights() is not implemented for Adamax yet.");
									case 1:
									case "end":
										return e.stop();
								}
						}, e);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(n.getConfig = function () {
				return {
					learningRate: this.learningRate,
					beta1: this.beta1,
					beta2: this.beta2,
					epsilon: this.epsilon,
					decay: this.decay,
				};
			}),
			(t.fromConfig = function (e, t) {
				return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);
			}),
			t
		);
	})(gA);
	(xA.className = "Adamax"), AI(xA);
	var wA = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this) || this).learningRate = t), n.setLearningRate(t), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.applyGradients = function (e) {
				var t = this;
				(Array.isArray(e)
					? e.map(function (e) {
							return e.name;
					  })
					: Object.keys(e)
				).forEach(function (n, r) {
					var a = Array.isArray(e) ? e[r].tensor : e[n];
					if (null != a) {
						var i = ok.registeredVariables[n];
						BI(function () {
							var e = jI(KI(t.c, a), i);
							i.assign(e);
						});
					}
				}),
					this.incrementIterations();
			}),
			(n.setLearningRate = function (e) {
				(this.learningRate = e), null != this.c && this.c.dispose(), (this.c = UI(iE(-e)));
			}),
			(n.dispose = function () {
				this.c.dispose();
			}),
			(n.getWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.saveIterations();
										case 2:
											return (e.t0 = e.sent), e.abrupt("return", [e.t0]);
										case 4:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(n.setWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.extractIterations(t);
										case 2:
											if (0 === (t = e.sent).length) {
												e.next = 5;
												break;
											}
											throw new Error("SGD optimizer does not have settable weights.");
										case 5:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(n.getConfig = function () {
				return { learningRate: this.learningRate };
			}),
			(t.fromConfig = function (e, t) {
				return new e(t.learningRate);
			}),
			t
		);
	})(gA);
	(wA.className = "SGD"), AI(wA);
	var kA = (function (e) {
		function t(t, n, r) {
			var a;
			return (
				void 0 === r && (r = !1),
				((a = e.call(this, t) || this).learningRate = t),
				(a.momentum = n),
				(a.useNesterov = r),
				(a.accumulations = []),
				(a.m = iE(a.momentum)),
				a
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.applyGradients = function (e) {
				var t = this;
				(Array.isArray(e)
					? e.map(function (e) {
							return e.name;
					  })
					: Object.keys(e)
				).forEach(function (n, r) {
					var a = ok.registeredVariables[n];
					null == t.accumulations[r] &&
						(t.accumulations[r] = {
							originalName: n + "/momentum",
							variable: BI(function () {
								return sT(a).variable(!1);
							}),
						});
					var i = t.accumulations[r].variable,
						o = Array.isArray(e) ? e[r].tensor : e[n];
					null != o &&
						BI(function () {
							var e,
								n = jI(KI(t.m, i), o);
							(e = t.useNesterov ? jI(KI(t.c, jI(o, KI(n, t.m))), a) : jI(KI(t.c, n), a)),
								i.assign(n),
								a.assign(e);
						});
				}),
					this.incrementIterations();
			}),
			(n.dispose = function () {
				this.m.dispose(),
					null != this.accumulations &&
						WI(
							this.accumulations.map(function (e) {
								return e.variable;
							})
						);
			}),
			(n.setMomentum = function (e) {
				this.momentum = e;
			}),
			(n.getWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.saveIterations();
										case 2:
											return (
												(e.t0 = e.sent),
												e.abrupt(
													"return",
													[e.t0].concat(
														this.accumulations.map(function (e) {
															return { name: e.originalName, tensor: e.variable };
														})
													)
												)
											);
										case 4:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(n.setWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.extractIterations(t);
										case 2:
											(t = e.sent),
												(this.accumulations = t.map(function (e) {
													return { originalName: e.name, variable: e.tensor.variable(!1) };
												}));
										case 5:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(n.getConfig = function () {
				return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
			}),
			(t.fromConfig = function (e, t) {
				return new e(t.learningRate, t.momentum, t.useNesterov);
			}),
			t
		);
	})(wA);
	(kA.className = "Momentum"), AI(kA);
	var NA = (function (e) {
		function t(t, n, r, a, i) {
			var o;
			if (
				(void 0 === n && (n = 0.9),
				void 0 === r && (r = 0),
				void 0 === a && (a = null),
				void 0 === i && (i = !1),
				((o = e.call(this) || this).learningRate = t),
				(o.decay = n),
				(o.momentum = r),
				(o.epsilon = a),
				(o.accumulatedMeanSquares = []),
				(o.accumulatedMoments = []),
				(o.accumulatedMeanGrads = []),
				(o.centered = i),
				null == a && (o.epsilon = ok.backend.epsilon()),
				null == t)
			)
				throw new Error("learningRate for RMSPropOptimizer must be defined.");
			return o;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.applyGradients = function (e) {
				var t = this;
				(Array.isArray(e)
					? e.map(function (e) {
							return e.name;
					  })
					: Object.keys(e)
				).forEach(function (n, r) {
					var a = ok.registeredVariables[n],
						i = !1;
					null == t.accumulatedMeanSquares[r] &&
						(t.accumulatedMeanSquares[r] = {
							originalName: n + "/rms",
							variable: BI(function () {
								return sT(a).variable(i);
							}),
						}),
						null == t.accumulatedMoments[r] &&
							(t.accumulatedMoments[r] = {
								originalName: n + "/momentum",
								variable: BI(function () {
									return sT(a).variable(i);
								}),
							}),
						null == t.accumulatedMeanGrads[r] &&
							t.centered &&
							(t.accumulatedMeanGrads[r] = {
								originalName: n + "/mg",
								variable: BI(function () {
									return sT(a).variable(i);
								}),
							});
					var o = Array.isArray(e) ? e[r].tensor : e[n];
					if (null != o) {
						var s = t.accumulatedMeanSquares[r].variable,
							u = t.accumulatedMoments[r].variable;
						BI(function () {
							var e = jI(KI(s, t.decay), KI(mC(o), 1 - t.decay));
							if (t.centered) {
								var n = t.accumulatedMeanGrads[r].variable,
									i = jI(KI(n, t.decay), KI(o, 1 - t.decay)),
									l = qI(KI(o, t.learningRate), NE(UT(e, jI(mC(i), t.epsilon)))),
									c = jI(KI(u, t.momentum), l);
								s.assign(e), n.assign(i), u.assign(c);
								var p = UT(a, c);
								a.assign(p);
							} else {
								var h = jI(KI(s, t.decay), KI(mC(o), 1 - t.decay)),
									f = jI(KI(u, t.momentum), qI(KI(o, t.learningRate), NE(jI(h, t.epsilon))));
								s.assign(h), u.assign(f);
								var d = UT(a, f);
								a.assign(d);
							}
						});
					}
				}),
					this.incrementIterations();
			}),
			(n.dispose = function () {
				null != this.accumulatedMeanSquares &&
					WI(
						this.accumulatedMeanSquares.map(function (e) {
							return e.variable;
						})
					),
					null != this.accumulatedMeanGrads &&
						this.centered &&
						WI(
							this.accumulatedMeanGrads.map(function (e) {
								return e.variable;
							})
						),
					null != this.accumulatedMoments &&
						WI(
							this.accumulatedMoments.map(function (e) {
								return e.variable;
							})
						);
			}),
			(n.getWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e() {
						var t;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (
												(t = [].concat(this.accumulatedMeanSquares, this.accumulatedMoments)),
												this.centered && t.push.apply(t, this.accumulatedMeanGrads),
												(e.next = 4),
												this.saveIterations()
											);
										case 4:
											return (
												(e.t0 = e.sent),
												e.abrupt(
													"return",
													[e.t0].concat(
														t.map(function (e) {
															return { name: e.originalName, tensor: e.variable };
														})
													)
												)
											);
										case 6:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function () {
					return e.apply(this, arguments);
				};
			})()),
			(n.setWeights = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t) {
						var n, r;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.extractIterations(t);
										case 2:
											(t = e.sent),
												(n = this.centered ? t.length / 3 : t.length / 2),
												(r = !1),
												(this.accumulatedMeanSquares = t.slice(0, n).map(function (e) {
													return { originalName: e.name, variable: e.tensor.variable(r) };
												})),
												(this.accumulatedMoments = t.slice(n, 2 * n).map(function (e) {
													return { originalName: e.name, variable: e.tensor.variable(r) };
												})),
												this.centered &&
													(this.accumulatedMeanGrads = t
														.slice(2 * n, 3 * n)
														.map(function (e) {
															return {
																originalName: e.name,
																variable: e.tensor.variable(r),
															};
														}));
										case 8:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t) {
					return e.apply(this, arguments);
				};
			})()),
			(n.getConfig = function () {
				return {
					learningRate: this.learningRate,
					decay: this.decay,
					momentum: this.momentum,
					epsilon: this.epsilon,
					centered: this.centered,
				};
			}),
			(t.fromConfig = function (e, t) {
				return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);
			}),
			t
		);
	})(gA);
	(NA.className = "RMSProp"), AI(NA);
	var IA = (function () {
			function e() {}
			return (
				(e.sgd = function (e) {
					return new wA(e);
				}),
				(e.momentum = function (e, t, n) {
					return void 0 === n && (n = !1), new kA(e, t, n);
				}),
				(e.rmsprop = function (e, t, n, r, a) {
					return (
						void 0 === t && (t = 0.9),
						void 0 === n && (n = 0),
						void 0 === r && (r = null),
						void 0 === a && (a = !1),
						new NA(e, t, n, r, a)
					);
				}),
				(e.adam = function (e, t, n, r) {
					return (
						void 0 === e && (e = 0.001),
						void 0 === t && (t = 0.9),
						void 0 === n && (n = 0.999),
						void 0 === r && (r = null),
						new bA(e, t, n, r)
					);
				}),
				(e.adadelta = function (e, t, n) {
					return (
						void 0 === e && (e = 0.001),
						void 0 === t && (t = 0.95),
						void 0 === n && (n = null),
						new vA(e, t, n)
					);
				}),
				(e.adamax = function (e, t, n, r, a) {
					return (
						void 0 === e && (e = 0.002),
						void 0 === t && (t = 0.9),
						void 0 === n && (n = 0.999),
						void 0 === r && (r = null),
						void 0 === a && (a = 0),
						new xA(e, t, n, r, a)
					);
				}),
				(e.adagrad = function (e, t) {
					return void 0 === t && (t = 0.1), new yA(e, t);
				}),
				e
			);
		})(),
		SA = {
			sgd: IA.sgd,
			momentum: IA.momentum,
			adadelta: IA.adadelta,
			adagrad: IA.adagrad,
			rmsprop: IA.rmsprop,
			adamax: IA.adamax,
			adam: IA.adam,
		},
		TA =
			"undefined" != typeof requestAnimationFrame
				? requestAnimationFrame
				: "undefined" != typeof setImmediate
				? setImmediate
				: function (e) {
						return e();
				  };
	function CA() {
		return new Promise(function (e) {
			return TA(function () {
				return e();
			});
		});
	}
	function EA(e, t) {
		var n = e[0].length;
		e.forEach(function (e, t) {
			Dg(e.length === n, function () {
				return (
					"Error in concat" +
					n +
					"D: rank of tensors[" +
					t +
					"] must be the same as the rank of the rest (" +
					n +
					")"
				);
			});
		}),
			Dg(t >= 0 && t < n, function () {
				return "Error in concat" + n + "D: axis must be between 0 and " + (n - 1) + ".";
			});
		var r = e[0];
		e.forEach(function (e, a) {
			for (var i = 0; i < n; i++)
				Dg(i === t || e[i] === r[i], function () {
					return (
						"Error in concat" +
						n +
						"D: Shape of tensors[" +
						a +
						"] (" +
						e +
						") does not match the shape of the rest (" +
						r +
						") along the non-concatenated axis " +
						a +
						"."
					);
				});
		});
	}
	function RA(e, t) {
		for (var n = e[0].slice(), r = 1; r < e.length; r++) n[t] += e[r][t];
		return n;
	}
	function AA(e) {
		return e <= 30 ? e : iv(e, Math.floor(Math.sqrt(e)));
	}
	function _A(e, t, n) {
		return [n * ("number" == typeof e ? e : e[0]), t * ("number" == typeof e ? e : e[1])];
	}
	function FA(e, t, n, r) {
		void 0 === r && (r = !0);
		var a = [];
		if (r) (a = a.concat(t.slice(0))).push(e[0] / n), (a = a.concat(e.slice(1)));
		else {
			a = a.concat(e[0]);
			for (var i = t.length, o = 0; o < i; ++o) a = a.concat([e[o + 1] / t[o], t[o]]);
			a = a.concat(e.slice(i + 1));
		}
		return a;
	}
	function DA(e, t, n) {
		void 0 === n && (n = !0);
		var r = [];
		if (n) {
			r.push(t);
			for (var a = t + 1; a < e; ++a) a <= 2 * t ? (r.push(a), r.push(a - (t + 1))) : r.push(a);
		} else {
			for (var i = [], o = [], s = 1; s < e; ++s) s >= 2 * t + 1 || s % 2 == 1 ? o.push(s) : i.push(s);
			r.push.apply(r, i), r.push(0), r.push.apply(r, o);
		}
		return r;
	}
	function OA(e, t, n, r) {
		void 0 === r && (r = !0);
		var a = [];
		r ? a.push(e[0] / n) : a.push(e[0] * n);
		for (var i = 1; i < e.length; ++i)
			i <= t.length ? (r ? a.push(t[i - 1] * e[i]) : a.push(e[i] / t[i - 1])) : a.push(e[i]);
		return a;
	}
	function MA(e, t) {
		for (var n = [0], r = 0; r < t; ++r) n.push(e[r][0]);
		return n;
	}
	function LA(e, t, n) {
		for (var r = e.slice(0, 1), a = 0; a < n; ++a) r.push(e[a + 1] - t[a][0] - t[a][1]);
		return r;
	}
	var zA = 1.7580993408473768,
		PA = 1.0507009873554805;
	function BA(e, t) {
		if (e.length !== t.length)
			throw new Error(
				"Cannot merge real and imag arrays of different lengths. real:" + e.length + ", imag: " + t.length + "."
			);
		for (var n = new Float32Array(2 * e.length), r = 0; r < n.length; r += 2)
			(n[r] = e[r / 2]), (n[r + 1] = t[r / 2]);
		return n;
	}
	function WA(e) {
		for (var t = new Float32Array(e.length / 2), n = new Float32Array(e.length / 2), r = 0; r < e.length; r += 2)
			(t[r / 2] = e[r]), (n[r / 2] = e[r + 1]);
		return { real: t, imag: n };
	}
	function UA(e) {
		for (
			var t = Math.ceil(e.length / 4), n = new Float32Array(t), r = new Float32Array(t), a = 0;
			a < e.length;
			a += 4
		)
			(n[Math.floor(a / 4)] = e[a]), (r[Math.floor(a / 4)] = e[a + 1]);
		return { real: n, imag: r };
	}
	function VA(e) {
		for (
			var t = Math.floor(e.length / 4), n = new Float32Array(t), r = new Float32Array(t), a = 2;
			a < e.length;
			a += 4
		)
			(n[Math.floor(a / 4)] = e[a]), (r[Math.floor(a / 4)] = e[a + 1]);
		return { real: n, imag: r };
	}
	function GA(e, t) {
		return { real: e[2 * t], imag: e[2 * t + 1] };
	}
	function jA(e, t, n, r) {
		(e[2 * r] = t), (e[2 * r + 1] = n);
	}
	function HA(e, t) {
		for (var n = new Float32Array(e / 2), r = new Float32Array(e / 2), a = 0; a < Math.ceil(e / 2); a++) {
			var i = (t ? 2 : -2) * Math.PI * (a / e);
			(n[a] = Math.cos(i)), (r[a] = Math.sin(i));
		}
		return { real: n, imag: r };
	}
	function qA(e, t, n) {
		var r = (n ? 2 : -2) * Math.PI * (e / t);
		return { real: Math.cos(r), imag: Math.sin(r) };
	}
	var KA = /->/g;
	function XA(e, t) {
		var n = ((e = e.replace(/\s/g, "")).length - e.replace(KA, "").length) / "->".length;
		if (n < 1) throw new Error("Equations without an arrow are not supported.");
		if (n > 1) throw new Error('Equation must contain exactly one arrow ("->").');
		var r = e.split("->"),
			a = r[0],
			i = r[1];
		Dg(-1 === a.indexOf("..."), function () {
			return 'The ellipsis notation ("...") is not supported yet.';
		});
		var o = a.split(","),
			s = o.length;
		if (t !== s) throw new Error("Expected " + s + " input tensors, received " + t);
		if (s > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
		for (
			var u = [],
				l = function (e) {
					var t = i[e];
					if (
						!o.some(function (e) {
							return -1 !== e.indexOf(t);
						})
					)
						throw new Error(
							"Output subscripts contain the label " + t + " not present in the input subscripts."
						);
					-1 === u.indexOf(t) && u.push(t);
				},
				c = 0;
			c < i.length;
			++c
		)
			l(c);
		for (var p = 0; p < a.length; ++p) {
			var h = a[p];
			-1 === u.indexOf(h) && "," !== h && u.push(h);
		}
		for (var f = new Array(o.length), d = 0; d < s; ++d) {
			if (new Set(o[d].split("")).size !== o[d].length)
				throw new Error(
					"Found duplicate axes in input component " +
						o[d] +
						". Support for duplicate axes in input is not implemented yet."
				);
			f[d] = [];
			for (var m = 0; m < o[d].length; ++m) f[d].push(u.indexOf(o[d][m]));
		}
		for (var g = u.length, v = [], y = i.length; y < g; ++y) v.push(y);
		return { allDims: u, summedDims: v, idDims: f };
	}
	function YA(e, t) {
		var n = new Array(e);
		n.fill(-1);
		for (var r = 0; r < t.length; ++r) n[t[r]] = r;
		for (var a = [], i = 0; i < e; ++i) -1 === n[i] && a.push(i);
		return {
			permutationIndices: (n = n.filter(function (e) {
				return -1 !== e;
			})),
			expandDims: a,
		};
	}
	function JA(e, t, n) {
		for (
			var r = new Array(e),
				a = function (e) {
					for (
						var a = n[e].shape,
							i = function (n) {
								void 0 === r[t[e][n]]
									? (r[t[e][n]] = a[n])
									: Dg(r[t[e][n]] === a[n], function () {
											return (
												"Expected dimension " +
												r[t[e][n]] +
												" at axis " +
												n +
												" of input shaped " +
												JSON.stringify(a) +
												", but got dimension " +
												a[n]
											);
									  });
							},
							o = 0;
						o < t[e].length;
						++o
					)
						i(o);
				},
				i = 0;
			i < n.length;
			++i
		)
			a(i);
	}
	function ZA(e, t) {
		var n,
			r = e,
			a = [];
		0 === e.length && r.push(-1), (n = e.length + 1);
		for (var i = 0; i < n; ++i) a.push([]);
		for (var o = [], s = 0; s < r.length; ++s)
			for (var u, l = Ig($A(t, r[s])); !(u = l()).done; ) {
				var c = u.value;
				-1 === o.indexOf(c) && (a[s].push(c), o.push(c));
			}
		return { path: r, steps: a };
	}
	function QA(e) {
		return e.every(function (e, t) {
			return e === t;
		});
	}
	function $A(e, t) {
		for (var n = [], r = 0; r < e.length; ++r)
			(0 !== e[r].length && -1 === e[r].indexOf(t) && -1 !== t) || n.push(r);
		return n;
	}
	function e_(e, t, n) {
		void 0 === n && (n = 0);
		var r = [];
		if ("number" == typeof t)
			Dg(e.shape[n] % t == 0, function () {
				return "Number of splits must evenly divide the axis.";
			}),
				(r = new Array(t).fill(e.shape[n] / t));
		else {
			Dg(
				t.reduce(function (e, t) {
					return -1 === t && (e += 1), e;
				}, 0) <= 1,
				function () {
					return "There should be only one negative value in split array.";
				}
			);
			var a = t.indexOf(-1);
			if (-1 !== a) {
				var i = t.reduce(function (e, t) {
					return t > 0 ? e + t : e;
				});
				t[a] = e.shape[n] - i;
			}
			Dg(
				e.shape[n] ===
					t.reduce(function (e, t) {
						return e + t;
					}),
				function () {
					return "The sum of sizes must match the size of the axis dimension.";
				}
			),
				(r = t);
		}
		return r;
	}
	function t_(e) {
		return "Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = " + e;
	}
	function n_(e, t) {
		return "indices(" + e + ", 0) is invalid: " + t + " < 0";
	}
	function r_(e, t, n) {
		return "indices(" + e + ", 0) is invalid: " + t + " >= " + n;
	}
	function a_(e, t) {
		return "only one output dimension may be -1, not both " + e + " and " + t;
	}
	function i_(e, t) {
		return "size " + e + " must be non-negative, not " + t;
	}
	function o_(e, t) {
		return (
			"Input to reshape is a SparseTensor with " +
			zg(e) +
			"\n  dense values, but the requested shape requires a multiple of " +
			zg(t) +
			". inputShape=" +
			e +
			" outputShape= " +
			t
		);
	}
	function s_(e, t) {
		return (
			"Input to reshape is a tensor with " +
			zg(e) +
			" dense values, but the requested shape has " +
			zg(t) +
			". inputShape=" +
			e +
			" outputShape=" +
			t
		);
	}
	function u_(e, t) {
		return "Segment id " + e + " out of range [0, " + t + "), possibly because segmentIds input is not sorted.";
	}
	function l_(e, t, n) {
		return "Bad: indices[" + e + "] == " + t + " out of range [0, " + n + ")";
	}
	function c_(e, t) {
		var n,
			r = !1;
		for (e <= 30 ? ((n = e), (r = !0)) : (n = iv(e, Math.floor(Math.sqrt(e)))); !r; )
			n > t || n === e ? (r = !0) : (n = iv(e, n + 1));
		return n;
	}
	function p_(e, t, n) {
		for (var r = [], a = e.length, i = 0; i < a; i++) i !== t ? r.push(e[i]) : r.push(n);
		return r;
	}
	function h_(e, t, n, r) {
		var a = t.shape.length,
			i = e.shape.length;
		if (0 !== r && (r < -a || r > a))
			throw new Error("Expect batchDims in the range of [-" + a + ", " + a + "], but got " + r);
		if ((r < 0 && (r += a), r > i))
			throw new Error("batchDims (" + r + ") must be less than rank(x) (\n    " + i + ").");
		if (n < r) throw new Error("batchDims (" + r + ") must be less than or equal to axis (" + n + ").");
		for (var o = 0; o < r; ++o)
			if (e.shape[o] !== t.shape[o])
				throw new Error(
					"x.shape[" +
						o +
						"]: " +
						e.shape[o] +
						" should be equal to indices.shape[" +
						o +
						"]: " +
						t.shape[o] +
						"."
				);
		for (var s = e.shape[n], u = [], l = 1, c = 1, p = 1, h = 0; h < r; ++h) u.push(e.shape[h]), (l *= e.shape[h]);
		for (var f = r; f < n; f++) u.push(e.shape[f]), (c *= e.shape[f]);
		for (var d = r; d < a; d++) u.push(t.shape[d]);
		for (var m = n + 1; m < i; m++) u.push(e.shape[m]), (p *= e.shape[m]);
		return { batchSize: l, sliceSize: p, outerSize: c, dimSize: s, outputShape: u };
	}
	function f_(e) {
		try {
			return e.map(function (e) {
				return Tw(e);
			});
		} catch (e) {
			throw new Error("Failed to decode encoded string bytes into utf-8, error: " + e);
		}
	}
	function d_(e) {
		return e.map(function (e) {
			return Sw(e);
		});
	}
	var m_ = {
			__proto__: null,
			slice_util: CI,
			segment_util: {
				__proto__: null,
				segOpComputeOptimalWindowSize: c_,
				computeOutShape: p_,
				collectGatherOpShapeInfo: h_,
			},
			fromUint8ToStringArray: f_,
			fromStringArrayToUint8: d_,
			upcastType: Kw,
			axesAreInnerMostDims: jT,
			combineLocations: HT,
			computeOutAndReduceShapes: qT,
			expandShapeToKeepDim: KT,
			assertAxesAreInnerMostDims: XT,
			getAxesPermutation: YT,
			getUndoAxesPermutation: JT,
			getInnerMostAxes: ZT,
			getBroadcastDims: XN,
			getReductionAxes: YN,
			assertAndGetBroadcastShape: JN,
			assertParamsConsistent: EA,
			computeOutShape: RA,
			computeDilation2DInfo: sS,
			computePool2DInfo: uS,
			computePool3DInfo: lS,
			computeConv2DInfo: cS,
			computeConv3DInfo: pS,
			computeDefaultPad: hS,
			tupleValuesAreOne: vS,
			eitherStridesOrDilationsAreOne: yS,
			convertConv2DDataFormat: bS,
			checkPadOnDimRoundingMode: xS,
			getFusedDyActivation: aR,
			getFusedBiasGradient: iR,
			applyActivation: oR,
			shouldFuse: sR,
			PARALLELIZE_THRESHOLD: 30,
			computeOptimalWindowSize: AA,
			getImageCenter: _A,
			getReshaped: FA,
			getPermuted: DA,
			getReshapedPermuted: OA,
			getSliceBeginCoords: MA,
			getSliceSize: LA,
			prepareAndValidate: oI,
			validateUpdateShape: uI,
			validateInput: lI,
			calculateShapes: cI,
			SELU_SCALEALPHA: zA,
			SELU_SCALE: PA,
			ERF_P: 0.3275911,
			ERF_A1: 0.254829592,
			ERF_A2: -0.284496736,
			ERF_A3: 1.421413741,
			ERF_A4: -1.453152027,
			ERF_A5: 1.061405429,
			warn: Ex,
			log: function () {
				var e;
				xv().getBool("IS_TEST") || xv().getBool("PROD") || (e = console).log.apply(e, arguments);
			},
			mergeRealAndImagArrays: BA,
			splitRealAndImagArrays: WA,
			complexWithEvenIndex: UA,
			complexWithOddIndex: VA,
			getComplexWithIndex: GA,
			assignToTypedArray: jA,
			exponents: HA,
			exponent: qA,
			decodeEinsumEquation: XA,
			getEinsumPermutation: YA,
			checkEinsumDimSizes: JA,
			getEinsumComputePath: ZA,
			isIdentityPermutation: QA,
			prepareSplitSize: e_,
			getSparseFillEmptyRowsIndicesDenseShapeMismatch: t_,
			getSparseFillEmptyRowsNegativeIndexErrorMessage: n_,
			getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: r_,
			getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: a_,
			getSparseReshapeNegativeOutputDimErrorMessage: i_,
			getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: function () {
				return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
			},
			getSparseReshapeInputOutputMultipleErrorMessage: o_,
			getSparseReshapeInputOutputMismatchErrorMessage: s_,
			getSparseSegmentReductionNegativeSegmentIdsErrorMessage: function () {
				return "segment ids must be >= 0";
			},
			getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: function () {
				return "segment ids are not increasing";
			},
			getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: u_,
			getSparseSegmentReductionIndicesOutOfRangeErrorMessage: l_,
		},
		g_ = {
			__proto__: null,
			nonMaxSuppressionV3Impl: TR,
			nonMaxSuppressionV4Impl: CR,
			nonMaxSuppressionV5Impl: ER,
			whereImpl: UE,
		},
		v_ = {
			kernelName: Nv,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return KI(e, CE(NN(n, "float32"), -1));
					},
				};
			},
		},
		y_ = {
			kernelName: Iv,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						var t = mC(NN(n, "float32")),
							r = NE(UT(iE(1), t));
						return zT(qI(e, r));
					},
				};
			},
		},
		b_ = {
			kernelName: Sv,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						var t = NE(UT(mC(NN(n, "float32")), 1));
						return qI(e, t);
					},
				};
			},
		},
		x_ = {
			kernelName: Tv,
			inputsToSave: ["a", "b"],
			gradFunc: function (e, t) {
				var n = t[0],
					r = t[1],
					a = JN(n.shape, r.shape);
				return {
					a: function () {
						var t = e,
							r = YN(n.shape, a);
						return r.length > 0 && (t = VT(t, r)), wS(t, n.shape);
					},
					b: function () {
						var t = e,
							n = YN(r.shape, a);
						return n.length > 0 && (t = VT(t, n)), wS(t, r.shape);
					},
				};
			},
		},
		w_ = {
			kernelName: Cv,
			saveAllInputs: !0,
			gradFunc: function (e, t) {
				var n = {};
				return (
					t.forEach(function (t, r) {
						n[r] = function () {
							return e.clone();
						};
					}),
					n
				);
			},
		},
		k_ = {
			kernelName: Av,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return sT(n);
					},
				};
			},
		},
		N_ = {
			kernelName: _v,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return sT(n);
					},
				};
			},
		},
		I_ = {
			kernelName: Fv,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return qI(e, NE(UT(iE(1), mC(NN(n, "float32")))));
					},
				};
			},
		},
		S_ = {
			kernelName: Dv,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						var t = NE(jI(iE(1), mC(NN(n, "float32"))));
						return qI(e, t);
					},
				};
			},
		},
		T_ = {
			kernelName: Lv,
			inputsToSave: ["a", "b"],
			gradFunc: function (e, t) {
				var n = t[0],
					r = t[1],
					a = JN(n.shape, r.shape);
				return {
					a: function () {
						var t = jI(mC(n), mC(r)),
							i = KI(e, qI(r, t)),
							o = YN(n.shape, a);
						return o.length > 0 && (i = VT(i, o)), wS(i, n.shape);
					},
					b: function () {
						var t = jI(mC(n), mC(r)),
							i = zT(KI(e, qI(n, t))),
							o = YN(r.shape, a);
						return o.length > 0 && (i = VT(i, o)), wS(i, r.shape);
					},
				};
			},
		},
		C_ = {
			kernelName: Ov,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return qI(e, jI(mC(NN(n, "float32")), 1));
					},
				};
			},
		},
		E_ = {
			kernelName: Mv,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return qI(e, UT(iE(1), mC(NN(n, "float32"))));
					},
				};
			},
		},
		R_ = yk({
			avgPool3dGrad_: function (e, t, n, r, a, i) {
				var o = mk(e, "dy", "avgPool3dGrad"),
					s = mk(t, "input", "avgPool3dGrad"),
					u = o,
					l = s,
					c = !1;
				4 === s.rank &&
					((c = !0),
					(u = wS(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])),
					(l = wS(s, [1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]]))),
					Dg(5 === u.rank, function () {
						return "Error in avgPool3dGrad: dy must be rank 5 but got rank " + u.rank + ".";
					}),
					Dg(5 === l.rank, function () {
						return "Error in avgPool3dGrad: input must be rank 5 but got rank " + l.rank + ".";
					}),
					xS("avgPool3dGrad", a, i);
				var p = { dy: u, input: l },
					h = { filterSize: n, strides: r, pad: a, dimRoundingMode: i },
					f = ok.runKernel(Wv, p, h);
				return c ? wS(f, [f.shape[1], f.shape[2], f.shape[3], f.shape[4]]) : f;
			},
		}),
		A_ = {
			kernelName: Bv,
			inputsToSave: ["x"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = n.filterSize,
					i = n.strides,
					o = n.pad,
					s = n.dimRoundingMode;
				return {
					x: function () {
						return R_(e, r, a, i, o, s);
					},
				};
			},
		},
		__ = yk({
			avgPoolGrad_: function (e, t, n, r, a) {
				var i = mk(e, "dy", "avgPoolGrad"),
					o = mk(t, "input", "avgPoolGrad");
				Dg(o.rank === i.rank, function () {
					return "Rank of input (" + o.rank + ") does not match rank of dy (" + i.rank + ")";
				});
				var s = o,
					u = i,
					l = !1;
				3 === o.rank &&
					((l = !0),
					(s = wS(o, [1, o.shape[0], o.shape[1], o.shape[2]])),
					(u = wS(i, [1, i.shape[0], i.shape[1], i.shape[2]]))),
					Dg(4 === u.rank, function () {
						return "Error in avgPoolGrad: dy must be rank 4 but got rank " + u.rank + ".";
					}),
					Dg(4 === s.rank, function () {
						return "Error in avgPoolGrad: input must be rank 4 but got rank " + s.rank + ".";
					});
				var c = { dy: u, input: s },
					p = { filterSize: n, strides: r, pad: a },
					h = ok.runKernel(Pv, c, p);
				return l ? wS(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
			},
		}),
		F_ = {
			kernelName: zv,
			inputsToSave: ["x"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = n.filterSize,
					i = n.strides,
					o = n.pad;
				return {
					x: function () {
						return __(e, r, a, i, o);
					},
				};
			},
		},
		D_ = {
			kernelName: Uv,
			inputsToSave: ["a", "b"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = t[1],
					i = n.transposeA,
					o = n.transposeB;
				return i || o
					? !i && o
						? {
								a: function () {
									return jN(e, a, !1, !1);
								},
								b: function () {
									return jN(e, r, !0, !1);
								},
						  }
						: i && !o
						? {
								a: function () {
									return jN(a, e, !1, !0);
								},
								b: function () {
									return jN(r, e, !1, !1);
								},
						  }
						: {
								a: function () {
									return jN(a, e, !0, !0);
								},
								b: function () {
									return jN(e, r, !0, !0);
								},
						  }
					: {
							a: function () {
								return jN(e, a, !1, !0);
							},
							b: function () {
								return jN(r, e, !0, !1);
							},
					  };
			},
		},
		O_ = {
			kernelName: Vv,
			gradFunc: function (e, t, n) {
				var r = n.blockShape,
					a = n.crops;
				return {
					x: function () {
						return CC(e, r, a);
					},
				};
			},
		},
		M_ = {
			kernelName: jv,
			gradFunc: function (e, t, n) {
				for (var r = n, a = r.inputShape, i = r.shape, o = Array.from(i), s = a.length - 1; s >= 0; s--)
					if (a[s] === i[s]) o[s] = 1;
					else if (1 !== a[s])
						throw new Error("broadcastTo(): [" + a + "] cannot be broadcast to [" + i + "].");
				for (var u = [], l = 0; l < o.length; l++) o[l] > 1 && u.push(l);
				return {
					x: function () {
						return VT(e, u, !0);
					},
				};
			},
		},
		L_ = {
			kernelName: qv,
			gradFunc: function (e) {
				return {
					x: function () {
						return e.clone();
					},
				};
			},
		},
		z_ = {
			kernelName: Kv,
			gradFunc: function (e) {
				return {
					x: function () {
						return sT(e);
					},
				};
			},
		},
		P_ = {
			kernelName: Xv,
			inputsToSave: ["x"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = n.clipValueMin,
					i = n.clipValueMax;
				return {
					x: function () {
						return oT($T(kT(r, a), RT(r, i)), e, sT(e));
					},
				};
			},
		},
		B_ = { kernelName: Jv, inputsToSave: ["x"], gradFunc: v_.gradFunc },
		W_ = {
			kernelName: Zv,
			saveAllInputs: !0,
			gradFunc: function (e, t, n) {
				var r = t.map(function (e) {
						return e.shape;
					}),
					a = jg(n.axis, t[0].shape)[0],
					i = r.map(function (e) {
						return e[a];
					});
				return wE(e, i, a).map(function (e) {
					return function () {
						return e;
					};
				});
			},
		},
		U_ = {
			kernelName: Qv,
			inputsToSave: ["x", "filter"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = t[1],
					i = n.dilations,
					o = n.strides,
					s = n.pad,
					u = n.dataFormat;
				return (
					Dg(vS(i), function () {
						return (
							"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" +
							i +
							"'"
						);
					}),
					{
						x: function () {
							return HS(r.shape, e, a, o, s, u);
						},
						filter: function () {
							return rR(r, e, a.shape, o, s, u);
						},
					}
				);
			},
		},
		V_ = {
			kernelName: ey,
			inputsToSave: ["dy", "filter"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = t[1],
					i = n.strides,
					o = n.pad,
					s = n.dataFormat,
					u = n.dimRoundingMode;
				return {
					dy: function () {
						return GS(e, a, i, o, s, 1, u);
					},
					filter: function () {
						return rR(e, r, a.shape, i, o, s, u);
					},
				};
			},
		},
		G_ = yk({
			conv3DBackpropFilter_: function (e, t, n, r, a) {
				var i = e;
				4 === e.rank && (i = wS(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]));
				var o = t;
				4 === o.rank && (o = wS(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])),
					Dg(5 === i.rank, function () {
						return "Error in conv3dDerFilter: input must be rank 5, but got shape " + i.shape + ".";
					}),
					Dg(5 === o.rank, function () {
						return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + o.shape + ".";
					}),
					Dg(5 === n.length, function () {
						return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n + ".";
					}),
					Dg(i.shape[4] === n[3], function () {
						return (
							"Error in conv3dDerFilter: depth of input " +
							i.shape[4] +
							") must match input depth in filter (" +
							n[3] +
							"."
						);
					}),
					Dg(o.shape[4] === n[4], function () {
						return (
							"Error in conv3dDerFilter: depth of dy (" +
							o.shape[4] +
							") must match output depth for filter (" +
							n[4] +
							")."
						);
					});
				var s = { x: i, dy: o },
					u = { strides: r, pad: a, filterShape: n };
				return ok.runKernel(ny, s, u);
			},
		}),
		j_ = {
			kernelName: ty,
			inputsToSave: ["x", "filter"],
			gradFunc: function (e, t, n) {
				var r = n.dilations,
					a = n.strides,
					i = n.pad;
				Dg(vS(r), function () {
					return (
						"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" +
						r +
						"'"
					);
				});
				var o = t[0],
					s = t[1];
				return {
					x: function () {
						return XS(o.shape, e, s, a, i);
					},
					filter: function () {
						return G_(o, e, s.shape, a, i);
					},
				};
			},
		},
		H_ = {
			kernelName: ay,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return KI(zT(pE(NN(n, "float32"))), e);
					},
				};
			},
		},
		q_ = {
			kernelName: iy,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return KI(hE(NN(n, "float32")), e);
					},
				};
			},
		},
		K_ = {
			kernelName: sy,
			inputsToSave: ["x"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = n.axis,
					i = n.exclusive,
					o = n.reverse;
				return {
					x: function () {
						var t = YT([a], r.rank),
							n = $S(e, a, i, !o);
						return null != t && (n = qN(n, t)), n;
					},
				};
			},
		},
		X_ = {
			kernelName: py,
			inputsToSave: ["x", "filter"],
			gradFunc: function (e, t, n) {
				var r = n.dilations,
					a = n.strides,
					i = n.pad,
					o = n.dimRoundingMode,
					s = null == r ? [1, 1] : r;
				Dg(vS(s), function () {
					return (
						"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '" +
						s +
						"'"
					);
				});
				var u = t[0],
					l = t[1];
				return (
					Dg(4 === u.rank, function () {
						return (
							"Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank " +
							u.rank +
							"."
						);
					}),
					Dg(4 === l.rank, function () {
						return (
							"Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank " +
							l.rank +
							"."
						);
					}),
					Dg(u.shape[3] === l.shape[2], function () {
						return (
							"Error in gradient of depthwiseConv2d: number of input channels (" +
							u.shape[3] +
							") must match the inChannels dimension in filter " +
							l.shape[2] +
							"."
						);
					}),
					Dg(yS(a, s), function () {
						return (
							"Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides " +
							a +
							" and dilations '" +
							s +
							"'."
						);
					}),
					xS("depthwiseConv2d", i, o),
					{
						x: function () {
							return cR(u.shape, e, l, a, i, s, o);
						},
						filter: function () {
							return lR(u, e, l.shape, a, i, s, o);
						},
					}
				);
			},
		},
		Y_ = {
			kernelName: my,
			inputsToSave: ["x", "filter"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = t[1],
					i = { x: r, filter: a, dy: e },
					o = { x: r, filter: a, dy: e };
				return {
					x: function () {
						return ok.runKernel(gy, i, n);
					},
					filter: function () {
						return ok.runKernel(vy, o, n);
					},
				};
			},
		},
		J_ = {
			kernelName: xy,
			outputsToSave: [!0],
			gradFunc: function (e, t) {
				var n = { dy: e, y: t[0] };
				return {
					x: function () {
						return ok.runKernel(wy, n);
					},
				};
			},
		},
		Z_ = {
			kernelName: ky,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0],
					r = KI(fT(zT(mC(n))), 2 / Math.sqrt(Math.PI));
				return {
					x: function () {
						return KI(e, r);
					},
				};
			},
		},
		Q_ = {
			kernelName: Iy,
			outputsToSave: [!0],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return KI(e, n);
					},
				};
			},
		},
		$_ = {
			kernelName: Sy,
			inputsToSave: ["input"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					input: function () {
						return wS(e, n.shape);
					},
				};
			},
		},
		eF = {
			kernelName: Ty,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return KI(e, fT(n));
					},
				};
			},
		},
		tF = {
			kernelName: Ay,
			gradFunc: function (e) {
				return {
					x: function () {
						return sT(e);
					},
				};
			},
		},
		nF = {
			kernelName: _y,
			inputsToSave: ["a", "b"],
			gradFunc: function (e, t) {
				var n = t[0],
					r = t[1],
					a = JN(n.shape, r.shape);
				return {
					a: function () {
						var t = qI(e, NN(r, "float32")),
							i = YN(n.shape, a);
						return i.length > 0 ? wS(VT(t, i), n.shape) : t;
					},
					b: function () {
						var t = KI(e, NN(n, "float32")),
							i = YN(r.shape, a);
						i.length > 0 && (t = wS(VT(t, i), r.shape));
						var o = mC(r);
						return zT(qI(t, NN(o, "float32")));
					},
				};
			},
		},
		rF = {
			kernelName: Fy,
			inputsToSave: ["x", "mean", "variance", "scale"],
			gradFunc: function (e, t, n) {
				var r = n.varianceEpsilon,
					a = t[0],
					i = t[1],
					o = t[2],
					s = t[3],
					u = null == s ? iE(1) : s,
					l = YN(i.shape, a.shape),
					c = [];
				if (1 === i.rank) {
					for (var p = 0; p < a.shape.length - 1; ++p) c.push(a.shape[p]);
					c.push(1);
				}
				var h = UT(a, i),
					f = KI(e, u),
					d = aE(jI(o, iE(r))),
					m = KI(KI(KI(d, d), d), iE(-0.5));
				return {
					x: function () {
						return 1 === i.rank
							? wS(KI(KI(e, gT(wS(d, [1, 1, 1, i.shape[0]]), c)), u), a.shape)
							: wS(KI(KI(e, d), u), a.shape);
					},
					mean: function () {
						var e = KI(KI(d, iE(-1)), f);
						return 1 === i.rank && (e = VT(e, l)), wS(e, i.shape);
					},
					variance: function () {
						var e = KI(KI(m, h), f);
						return 1 === i.rank && (e = VT(e, l)), wS(e, i.shape);
					},
					scale: function () {
						var t = KI(h, d),
							n = KI(e, t);
						return 1 === i.rank && (n = VT(n, l)), wS(n, i.shape);
					},
					offset: function () {
						var t = e;
						return 1 === i.rank && (t = VT(t, l)), wS(t, i.shape);
					},
				};
			},
		},
		aF = {
			kernelName: Dy,
			inputsToSave: ["x", "indices"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = t[1],
					i = n.axis,
					o = jg(i, r.shape)[0];
				return {
					x: function () {
						var t = r.shape,
							n = a.size,
							s = t.slice(0, o),
							u = s.length,
							l = t.slice(i, t.length).slice(1),
							c = l.length,
							p = iF(0, u),
							h = iF(u + 1, u + 1 + c),
							f = oF([s, [n], l]),
							d = wS(e, f),
							m = wS(a, [n]),
							g = oF([[u], p, h]),
							v = qN(d, g),
							y = PE(v, m, r.shape[o]),
							b = JT(g);
						return qN(y, b);
					},
					indices: function () {
						return a;
					},
				};
			},
		};
	function iF(e, t) {
		for (var n = [], r = e; r < t; ++r) n.push(r);
		return n;
	}
	function oF(e) {
		for (var t = [], n = 0; n < e.length; ++n) for (var r = 0; r < e[n].length; ++r) t.push(e[n][r]);
		return t;
	}
	var sF = {
			kernelName: Ly,
			inputsToSave: ["a", "b"],
			gradFunc: function (e, t) {
				var n = t[0],
					r = t[1];
				return {
					a: function () {
						return sT(n);
					},
					b: function () {
						return sT(r);
					},
				};
			},
		},
		uF = {
			kernelName: zy,
			gradFunc: function (e) {
				return {
					x: function () {
						return NN(e, "float32");
					},
				};
			},
		},
		lF = {
			kernelName: Wy,
			gradFunc: function (e) {
				return {
					x: function () {
						return sT(e);
					},
				};
			},
		},
		cF = {
			kernelName: Uy,
			gradFunc: function (e) {
				return {
					x: function () {
						return sT(e);
					},
				};
			},
		},
		pF = {
			kernelName: Vy,
			gradFunc: function (e) {
				return {
					x: function () {
						return sT(e);
					},
				};
			},
		},
		hF = {
			kernelName: Gy,
			inputsToSave: ["x"],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = n.alpha,
					i = wT(r, 0);
				return {
					x: function () {
						return oT(i, e, KI(e, a));
					},
				};
			},
		},
		fF = {
			kernelName: Xy,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return qI(e, jI(n, 1));
					},
				};
			},
		},
		dF = {
			kernelName: Ky,
			inputsToSave: ["x"],
			gradFunc: function (e, t) {
				var n = t[0];
				return {
					x: function () {
						return qI(e, NN(n, "float32"));
					},
				};
			},
		},
		mF = {
			kernelName: Qy,
			inputsToSave: [],
			outputsToSave: [!0],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = n.axis;
				return {
					logits: function () {
						var t = fT(r);
						return UT(e, KI(VT(e, a, !0), t));
					},
				};
			},
		},
		gF = yk({
			localResponseNormalizationBackprop_: function (e, t, n, r, a, i, o) {
				void 0 === r && (r = 5), void 0 === a && (a = 1), void 0 === i && (i = 1), void 0 === o && (o = 0.5);
				var s = { x: e, y: t, dy: n },
					u = { depthRadius: r, bias: a, alpha: i, beta: o };
				return ok.runKernel(eb, s, u);
			},
		}),
		vF = {
			kernelName: $y,
			inputsToSave: ["x"],
			outputsToSave: [!0],
			gradFunc: function (e, t, n) {
				var r = t[0],
					a = t[1],
					i = n.depthRadius,
					o = n.bias,
					s = n.alpha,
					u = n.beta;
				return {
					x: function () {
						return gF(r, a, e, i, o, s, u);
					},
				};
			},
		};
	function yF(e, t, n, r) {
		return (
			t.rank < n.rank && (t = wS(t, KT(t.shape, r))),
			e.rank < n.rank && (e = wS(e, KT(e.shape, r))),
			{
				x: function () {
					return KI(e, NN(iT(n, t), e.dtype));
				},
			}
		);
	}
	for (
		var bF,
			xF = {
				kernelName: tb,
				inputsToSave: ["x"],
				outputsToSave: [!0],
				gradFunc: function (e, t, n) {
					var r = n.reductionIndices,
						a = t[0],
						i = yF(e, t[1], a, jg(r, a.shape));
					return {
						x: function () {
							return i.x();
						},
					};
				},
			},
			wF = {
				kernelName: nb,
				inputsToSave: ["a", "b"],
				gradFunc: function (e, t) {
					var n = t[0],
						r = t[1];
					return {
						a: function () {
							return KI(e, NN(kT(n, r), "float32"));
						},
						b: function () {
							return KI(e, NN(ET(n, r), "float32"));
						},
					};
				},
			},
			kF = yk({
				maxPool3dGrad_: function (e, t, n, r, a, i, o) {
					var s = mk(e, "dy", "maxPool3dGrad"),
						u = mk(t, "input", "maxPool3dGrad"),
						l = mk(n, "output", "maxPool3dGrad"),
						c = s,
						p = u,
						h = l,
						f = !1;
					4 === u.rank &&
						((f = !0),
						(c = wS(s, [1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]])),
						(p = wS(u, [1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]])),
						(h = wS(l, [1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]]))),
						Dg(5 === c.rank, function () {
							return "Error in maxPool3dGrad: dy must be rank 5 but got rank " + c.rank + ".";
						}),
						Dg(5 === p.rank, function () {
							return "Error in maxPool3dGrad: input must be rank 5 but got rank " + p.rank + ".";
						}),
						Dg(5 === h.rank, function () {
							return "Error in maxPool3dGrad: output must be rank 5 but got rank " + h.rank + ".";
						}),
						xS("maxPool3dGrad", i, o);
					var d = { dy: c, input: p, output: h },
						m = { filterSize: r, strides: a, pad: i, dimRoundingMode: o },
						g = ok.runKernel(ob, d, m);
					return f ? wS(g, [g.shape[1], g.shape[2], g.shape[3], g.shape[4]]) : g;
				},
			}),
			NF = {
				kernelName: ib,
				inputsToSave: ["x"],
				outputsToSave: [!0],
				gradFunc: function (e, t, n) {
					var r = t[0],
						a = t[1],
						i = n.filterSize,
						o = n.strides,
						s = n.pad,
						u = n.dimRoundingMode;
					return {
						x: function () {
							return kF(e, r, a, i, o, s, u);
						},
					};
				},
			},
			IF = yk({
				maxPoolGrad_: function (e, t, n, r, a, i, o) {
					var s = mk(e, "dy", "maxPoolGrad"),
						u = mk(t, "input", "maxPoolGrad"),
						l = mk(n, "output", "maxPoolGrad");
					Dg(u.rank === s.rank, function () {
						return "Rank of input (" + u.rank + ") does not match rank of dy (" + s.rank + ")";
					}),
						Dg(4 === s.rank, function () {
							return "Error in maxPoolGrad: dy must be rank 4 but got rank " + s.rank + ".";
						}),
						Dg(4 === u.rank, function () {
							return "Error in maxPoolGrad: input must be rank 4 but got rank " + u.rank + ".";
						}),
						xS("maxPoolGrad", i, o);
					var c = { dy: s, input: u, output: l },
						p = { filterSize: r, strides: a, pad: i, dimRoundingMode: o };
					return ok.runKernel(ab, c, p);
				},
			}),
			SF = {
				kernelName: Nb,
				inputsToSave: ["x"],
				gradFunc: function (e, t, n) {
					var r = t[0],
						a = n.paddings.map(function (e) {
							return e[0];
						});
					return {
						x: function () {
							return TS(e, a, r.shape);
						},
					};
				},
			},
			TF = {
				kernelName: Zb,
				gradFunc: function (e, t, n) {
					var r = n.blockShape,
						a = n.paddings;
					return {
						x: function () {
							return RS(e, r, a);
						},
					};
				},
			},
			CF = {
				kernelName: Qb,
				gradFunc: function (e, t, n) {
					var r = n.axis;
					return {
						x: function () {
							return IS(e, r);
						},
					};
				},
			},
			EF = {
				kernelName: dx,
				inputsToSave: ["x"],
				gradFunc: function (e, t, n) {
					var r = t[0],
						a = n.reps;
					return {
						x: function () {
							var t = sT(r);
							if (1 === r.rank)
								for (var n = 0; n < a[0]; ++n) t = jI(t, TS(e, [n * r.shape[0]], [r.shape[0]]));
							else if (2 === r.rank)
								for (var i = 0; i < a[0]; ++i)
									for (var o = 0; o < a[1]; ++o)
										t = jI(t, TS(e, [i * r.shape[0], o * r.shape[1]], [r.shape[0], r.shape[1]]));
							else if (3 === r.rank)
								for (var s = 0; s < a[0]; ++s)
									for (var u = 0; u < a[1]; ++u)
										for (var l = 0; l < a[2]; ++l)
											t = jI(
												t,
												TS(
													e,
													[s * r.shape[0], u * r.shape[1], l * r.shape[2]],
													[r.shape[0], r.shape[1], r.shape[2]]
												)
											);
							else {
								if (4 !== r.rank)
									throw new Error(
										"Gradient for tile operation is not implemented for rank-" +
											r.rank +
											" tensors yet."
									);
								for (var c = 0; c < a[0]; ++c)
									for (var p = 0; p < a[1]; ++p)
										for (var h = 0; h < a[2]; ++h)
											for (var f = 0; f < a[3]; ++f)
												t = jI(
													t,
													TS(
														e,
														[
															c * r.shape[0],
															p * r.shape[1],
															h * r.shape[2],
															f * r.shape[3],
														],
														[r.shape[0], r.shape[1], r.shape[2], r.shape[3]]
													)
												);
							}
							return t;
						},
					};
				},
			},
			RF = 0,
			AF = [
				v_,
				y_,
				b_,
				x_,
				w_,
				k_,
				N_,
				I_,
				S_,
				T_,
				C_,
				E_,
				A_,
				F_,
				D_,
				O_,
				M_,
				L_,
				z_,
				P_,
				B_,
				W_,
				V_,
				U_,
				j_,
				H_,
				q_,
				K_,
				X_,
				Y_,
				{
					kernelName: yy,
					inputsToSave: ["a", "b"],
					gradFunc: function (e, t) {
						var n = t[0],
							r = t[1],
							a = JN(n.shape, r.shape);
						return {
							a: function () {
								var t = qI(e, NN(r, "float32")),
									i = YN(n.shape, a);
								return i.length > 0 ? wS(VT(t, i), n.shape) : t;
							},
							b: function () {
								var t = KI(e, NN(n, "float32")),
									i = YN(r.shape, a);
								i.length > 0 && (t = wS(VT(t, i), r.shape));
								var o = mC(r);
								return zT(qI(t, NN(o, "float32")));
							},
						};
					},
				},
				J_,
				Z_,
				Q_,
				$_,
				eF,
				nF,
				tF,
				rF,
				aF,
				sF,
				uF,
				lF,
				cF,
				pF,
				hF,
				fF,
				dF,
				mF,
				vF,
				xF,
				xF,
				wF,
				NF,
				{
					kernelName: rb,
					inputsToSave: ["x"],
					outputsToSave: [!0],
					gradFunc: function (e, t, n) {
						var r = t[0],
							a = t[1],
							i = n.filterSize,
							o = n.strides,
							s = n.pad;
						return {
							x: function () {
								return IF(e, r, a, i, o, s);
							},
						};
					},
				},
				{
					kernelName: ub,
					inputsToSave: ["x"],
					gradFunc: function (e, t, n) {
						var r = t[0],
							a = jg(n.axis, r.shape),
							i = zg(qT(r.shape, a)[1]);
						return {
							x: function () {
								var t = r.shape.slice();
								a.forEach(function (e) {
									t[e] = 1;
								});
								var n = wS(e, t);
								return qI(KI(n, lC(r.shape, "float32")), i);
							},
						};
					},
				},
				{
					kernelName: lb,
					inputsToSave: ["x"],
					outputsToSave: [!0],
					gradFunc: function (e, t, n) {
						var r = n.axis,
							a = t[0],
							i = yF(e, t[1], a, jg(r, a.shape));
						return {
							x: function () {
								return i.x();
							},
						};
					},
				},
				{
					kernelName: cb,
					inputsToSave: ["a", "b"],
					gradFunc: function (e, t) {
						var n = t[0],
							r = t[1];
						return {
							a: function () {
								return KI(e, NN(RT(n, r), "float32"));
							},
							b: function () {
								return KI(e, NN(wT(n, r), "float32"));
							},
						};
					},
				},
				{
					kernelName: pb,
					inputsToSave: ["x"],
					gradFunc: function (e, t, n) {
						var r = t[0],
							a = n.paddings.map(function (e) {
								return e[0];
							});
						return {
							x: function () {
								return TS(e, a, r.shape);
							},
						};
					},
				},
				{
					kernelName: hb,
					inputsToSave: ["a", "b"],
					gradFunc: function (e, t) {
						var n = t[0],
							r = t[1],
							a = JN(n.shape, r.shape);
						return {
							a: function () {
								var t = YN(n.shape, a);
								return t.length > 0 ? wS(VT(e, t), n.shape) : e;
							},
							b: function () {
								var t = KI(e, zT(bT(qI(n, r)))),
									i = YN(r.shape, a);
								return i.length > 0 ? wS(VT(t, i), r.shape) : t;
							},
						};
					},
				},
				{
					kernelName: db,
					inputsToSave: ["a", "b"],
					gradFunc: function (e, t) {
						var n = t[0],
							r = t[1],
							a = JN(n.shape, r.shape);
						return {
							a: function () {
								var t = KI(e, NN(r, "float32")),
									i = YN(n.shape, a);
								return i.length > 0 ? wS(VT(t, i), n.shape) : t;
							},
							b: function () {
								var t = KI(e, NN(n, "float32")),
									i = YN(r.shape, a);
								return i.length > 0 ? wS(VT(t, i), r.shape) : t;
							},
						};
					},
				},
				{
					kernelName: mb,
					gradFunc: function (e) {
						return {
							x: function () {
								return zT(e);
							},
						};
					},
				},
				{
					kernelName: wb,
					inputsToSave: ["indices"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							indices: function () {
								return uC(n.shape, "float32");
							},
						};
					},
				},
				{
					kernelName: xb,
					gradFunc: function (e) {
						return {
							x: function () {
								return sT(e);
							},
						};
					},
				},
				{
					kernelName: kb,
					saveAllInputs: !0,
					gradFunc: function (e, t, n) {
						var r = n.axis;
						return BE(e, r).map(function (e) {
							return function () {
								return e;
							};
						});
					},
				},
				SF,
				SF,
				{
					kernelName: Ib,
					inputsToSave: ["a", "b"],
					outputsToSave: [!0],
					gradFunc: function (e, t) {
						var n = t[0],
							r = t[1],
							a = t[2],
							i = n,
							o = r,
							s = JN(i.shape, o.shape);
						return {
							a: function () {
								var t = NN(o, "float32"),
									n = KI(e, KI(t, RC(i, UT(t, iE(1))))),
									r = YN(i.shape, s);
								return r.length > 0 && (n = VT(n, r)), wS(n, i.shape);
							},
							b: function () {
								var t = wT(i, 0),
									n = oT(t, FT(i), sT(i)),
									r = KI(e, KI(a, n)),
									u = YN(o.shape, s);
								return u.length > 0 && (r = VT(r, u)), wS(r, o.shape);
							},
						};
					},
				},
				{
					kernelName: Sb,
					inputsToSave: ["x", "alpha"],
					gradFunc: function (e, t) {
						var n = t[0],
							r = t[1],
							a = wT(n, 0);
						return {
							x: function () {
								return oT(a, e, KI(e, r));
							},
							alpha: function () {
								var t = oT(a, sT(e), KI(e, n)),
									i = YN(r.shape, e.shape);
								return i.length > 0 && (t = VT(t, i)), wS(t, r.shape);
							},
						};
					},
				},
				{
					kernelName: Rb,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return qI(e, zT(mC(n)));
							},
						};
					},
				},
				{
					kernelName: Lb,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0],
							r = KI(RT(n, 6), CE(n));
						return {
							x: function () {
								return KI(e, NN(r, "float32"));
							},
						};
					},
				},
				{
					kernelName: Ab,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return KI(e, NN(CE(n), "float32"));
							},
						};
					},
				},
				{
					kernelName: _b,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return wS(e, n.shape);
							},
						};
					},
				},
				{
					kernelName: Ob,
					inputsToSave: ["images"],
					gradFunc: function (e, t, n) {
						var r = { dy: e, images: t[0] };
						return {
							images: function () {
								return ok.runKernel(Mb, r, n);
							},
						};
					},
				},
				{
					kernelName: Fb,
					inputsToSave: ["images"],
					gradFunc: function (e, t, n) {
						var r = { dy: e, images: t[0] };
						return {
							images: function () {
								return ok.runKernel(Db, r, n);
							},
						};
					},
				},
				{
					kernelName: zb,
					gradFunc: function (e, t, n) {
						var r = jg(n.dims, e.shape);
						return {
							x: function () {
								return QC(e, r);
							},
						};
					},
				},
				{
					kernelName: Pb,
					gradFunc: function (e) {
						return {
							x: function () {
								return sT(e);
							},
						};
					},
				},
				{
					kernelName: Bb,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return zT(qI(e, KI(RC(n, 1.5), 2)));
							},
						};
					},
				},
				{
					kernelName: Ub,
					inputsToSave: ["condition"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							condition: function () {
								return NN(sT(n), "float32");
							},
							t: function () {
								return KI(e, NN(n, e.dtype));
							},
							e: function () {
								return KI(e, NN(eC(n), e.dtype));
							},
						};
					},
				},
				{
					kernelName: Vb,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								var t = wT(n, iE(0)),
									r = iE(zA),
									a = iE(PA),
									i = KI(e, a),
									o = KI(KI(e, r), fT(NN(n, "float32")));
								return oT(t, i, o);
							},
						};
					},
				},
				{
					kernelName: Kb,
					outputsToSave: [!0],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return KI(e, KI(n, UT(iE(1), n)));
							},
						};
					},
				},
				{
					kernelName: qb,
					gradFunc: function (e) {
						return {
							x: function () {
								return sT(e);
							},
						};
					},
				},
				{
					kernelName: jb,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return KI(JS(NN(n, "float32")), e);
							},
						};
					},
				},
				{
					kernelName: Hb,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return KI(ZS(NN(n, "float32")), e);
							},
						};
					},
				},
				{
					kernelName: Gb,
					inputsToSave: ["x"],
					gradFunc: function (e, t, n) {
						for (
							var r = t[0],
								a = n.begin,
								i = n.size,
								o = r.shape,
								s = II(r, a, i),
								u = s[0],
								l = s[1],
								c = [],
								p = 0;
							p < e.rank;
							p++
						)
							c.push([u[p], o[p] - u[p] - l[p]]);
						return {
							x: function () {
								return kC(e, c);
							},
						};
					},
				},
				{
					kernelName: $b,
					outputsToSave: [!0],
					gradFunc: function (e, t, n) {
						var r = t[0],
							a = n.dim,
							i = KI(e, r);
						return {
							logits: function () {
								return UT(i, KI(VT(i, [a], !0), r));
							},
						};
					},
				},
				{
					kernelName: Xb,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return KI(e, SS(n));
							},
						};
					},
				},
				TF,
				TF,
				CF,
				CF,
				{
					kernelName: Yb,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return qI(e, KI(NE(NN(n, "float32")), 2));
							},
						};
					},
				},
				{
					kernelName: ix,
					inputsToSave: ["a", "b"],
					gradFunc: function (e, t) {
						var n = t[0],
							r = t[1],
							a = iE(2);
						return {
							a: function () {
								return KI(e, KI(a, UT(n, r)));
							},
							b: function () {
								return KI(e, KI(a, UT(r, n)));
							},
						};
					},
				},
				{
					kernelName: ox,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return KI(e, KI(NN(n, "float32"), 2));
							},
						};
					},
				},
				{
					kernelName: kx,
					gradFunc: function (e) {
						return {
							x: function () {
								return sT(e);
							},
						};
					},
				},
				{
					kernelName: px,
					inputsToSave: ["a", "b"],
					gradFunc: function (e, t) {
						var n = t[0],
							r = t[1],
							a = JN(n.shape, r.shape);
						return {
							a: function () {
								var t = e,
									r = YN(n.shape, a);
								return r.length > 0 && (t = VT(t, r)), wS(t, n.shape);
							},
							b: function () {
								var t = e,
									n = YN(r.shape, a);
								return n.length > 0 && (t = VT(t, n)), wS(zT(t), r.shape);
							},
						};
					},
				},
				{
					kernelName: Jb,
					inputsToSave: ["x"],
					gradFunc: function (e, t, n) {
						var r = t[0],
							a = r.shape.slice();
						jg(n.axis, r.shape).forEach(function (e) {
							a[e] = 1;
						});
						var i = wS(e, a),
							o = KI(i, lC(r.shape, "float32"));
						return {
							x: function () {
								return o;
							},
						};
					},
				},
				{
					kernelName: hx,
					inputsToSave: ["x"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return qI(e, mC(JS(n)));
							},
						};
					},
				},
				{
					kernelName: fx,
					outputsToSave: [!0],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return KI(UT(iE(1), mC(n)), e);
							},
						};
					},
				},
				EF,
				{
					kernelName: vx,
					gradFunc: function (e, t, n) {
						var r = JT(n.perm);
						return {
							x: function () {
								return qN(e, r);
							},
						};
					},
				},
				{
					kernelName: bx,
					gradFunc: function (e, t, n) {
						var r = n.axis;
						return {
							value: function () {
								return TE(e, r);
							},
						};
					},
				},
				{
					kernelName: xx,
					inputsToSave: ["segmentIds"],
					gradFunc: function (e, t) {
						var n = t[0];
						return {
							x: function () {
								return (function (e, t) {
									for (
										var n = oC(t, sT(t)),
											r = xT(e, n),
											a = kT(t, iE(0, "int32")),
											i = r.rank - a.rank,
											o = 0;
										o < i;
										++o
									)
										a = dT(a, o + 1);
									a = $T(a, lC(r.shape, "bool"));
									var s = sT(r);
									return oT(a, r, s);
								})(e, n);
							},
						};
					},
				},
				{
					kernelName: wx,
					gradFunc: function (e) {
						return {
							x: function () {
								return sT(e);
							},
						};
					},
				},
			];
		RF < AF.length;
		RF++
	)
		Mx(AF[RF]);
	function _F() {
		return null == bF && (bF = GI().epsilon()), bF;
	}
	(Bw().prototype.abs = function () {
		return this.throwIfDisposed(), XI(this);
	}),
		(Bw().prototype.acos = function () {
			return this.throwIfDisposed(), YI(this);
		}),
		(Bw().prototype.acosh = function () {
			return this.throwIfDisposed(), JI(this);
		}),
		(Bw().prototype.add = function (e) {
			return this.throwIfDisposed(), jI(this, e);
		}),
		(Bw().prototype.all = function (e, t) {
			return this.throwIfDisposed(), QI(this, e, t);
		}),
		(Bw().prototype.any = function (e, t) {
			return this.throwIfDisposed(), $I(this, e, t);
		}),
		(Bw().prototype.argMax = function (e) {
			return this.throwIfDisposed(), eS(this, e);
		}),
		(Bw().prototype.argMin = function (e) {
			return this.throwIfDisposed(), tS(this, e);
		}),
		(Bw().prototype.asScalar = function () {
			return (
				this.throwIfDisposed(),
				Dg(1 === this.size, function () {
					return "The array must have only 1 element.";
				}),
				wS(this, [])
			);
		}),
		(Bw().prototype.asType = function (e) {
			return this.throwIfDisposed(), NN(this, e);
		}),
		(Bw().prototype.as1D = function () {
			return this.throwIfDisposed(), wS(this, [this.size]);
		}),
		(Bw().prototype.as2D = function (e, t) {
			return this.throwIfDisposed(), wS(this, [e, t]);
		}),
		(Bw().prototype.as3D = function (e, t, n) {
			return this.throwIfDisposed(), wS(this, [e, t, n]);
		}),
		(Bw().prototype.as4D = function (e, t, n, r) {
			return this.throwIfDisposed(), wS(this, [e, t, n, r]);
		}),
		(Bw().prototype.as5D = function (e, t, n, r, a) {
			return this.throwIfDisposed(), wS(this, [e, t, n, r, a]);
		}),
		(Bw().prototype.asin = function () {
			return this.throwIfDisposed(), nS(this);
		}),
		(Bw().prototype.asinh = function () {
			return this.throwIfDisposed(), rS(this);
		}),
		(Bw().prototype.atan = function () {
			return this.throwIfDisposed(), aS(this);
		}),
		(Bw().prototype.atan2 = function (e) {
			return this.throwIfDisposed(), iS(this, e);
		}),
		(Bw().prototype.atanh = function () {
			return this.throwIfDisposed(), oS(this);
		}),
		(Bw().prototype.avgPool = function (e, t, n, r) {
			return this.throwIfDisposed(), kS(this, e, t, n, r);
		}),
		(Bw().prototype.batchToSpaceND = function (e, t) {
			return this.throwIfDisposed(), RS(this, e, t);
		}),
		(Bw().prototype.batchNorm = function (e, t, n, r, a) {
			return this.throwIfDisposed(), AS(this, e, t, n, r, a);
		}),
		(Bw().prototype.broadcastTo = function (e) {
			return this.throwIfDisposed(), LS(this, e);
		}),
		(Bw().prototype.cast = function (e) {
			return this.throwIfDisposed(), NN(this, e);
		}),
		(Bw().prototype.ceil = function () {
			return this.throwIfDisposed(), zS(this);
		}),
		(Bw().prototype.clipByValue = function (e, t) {
			return this.throwIfDisposed(), PS(this, e, t);
		}),
		(Bw().prototype.concat = function (e, t) {
			return this.throwIfDisposed(), e instanceof Pw && (e = [e]), IS([this].concat(e), t);
		}),
		(Bw().prototype.conv1d = function (e, t, n, r, a, i) {
			return this.throwIfDisposed(), jS(this, e, t, n, r, a, i);
		}),
		(Bw().prototype.conv2dTranspose = function (e, t, n, r, a) {
			return this.throwIfDisposed(), qS(this, e, t, n, r, a);
		}),
		(Bw().prototype.conv2d = function (e, t, n, r, a, i) {
			return this.throwIfDisposed(), GS(this, e, t, n, r, a, i);
		}),
		(Bw().prototype.cos = function () {
			return this.throwIfDisposed(), JS(this);
		}),
		(Bw().prototype.cosh = function () {
			return this.throwIfDisposed(), ZS(this);
		}),
		(Bw().prototype.cumprod = function (e, t, n) {
			return this.throwIfDisposed(), QS(this, e, t, n);
		}),
		(Bw().prototype.cumsum = function (e, t, n) {
			return this.throwIfDisposed(), $S(this, e, t, n);
		}),
		(Bw().prototype.depthToSpace = function (e, t) {
			return this.throwIfDisposed(), tT(this, e, t);
		}),
		(Bw().prototype.depthwiseConv2d = function (e, t, n, r, a, i) {
			return this.throwIfDisposed(), nT(this, e, t, n, r, a, i);
		}),
		(Bw().prototype.dilation2d = function (e, t, n, r, a) {
			return this.throwIfDisposed(), aT(this, e, t, n, r, a);
		}),
		(Bw().prototype.divNoNan = function (e) {
			return this.throwIfDisposed(), uT(this, e);
		}),
		(Bw().prototype.div = function (e) {
			return this.throwIfDisposed(), qI(this, e);
		}),
		(Bw().prototype.dot = function (e) {
			return this.throwIfDisposed(), lT(this, e);
		}),
		(Bw().prototype.elu = function () {
			return this.throwIfDisposed(), pT(this);
		}),
		(Bw().prototype.equal = function (e) {
			return this.throwIfDisposed(), iT(this, e);
		}),
		(Bw().prototype.erf = function () {
			return this.throwIfDisposed(), hT(this);
		}),
		(Bw().prototype.exp = function () {
			return this.throwIfDisposed(), fT(this);
		}),
		(Bw().prototype.expandDims = function (e) {
			return this.throwIfDisposed(), dT(this, e);
		}),
		(Bw().prototype.expm1 = function () {
			return this.throwIfDisposed(), mT(this);
		}),
		(Bw().prototype.fft = function () {
			return this.throwIfDisposed(), yE(this);
		}),
		(Bw().prototype.flatten = function () {
			return this.throwIfDisposed(), wS(this, [this.size]);
		}),
		(Bw().prototype.floor = function () {
			return this.throwIfDisposed(), bT(this);
		}),
		(Bw().prototype.floorDiv = function (e) {
			return this.throwIfDisposed(), HI(this, e);
		}),
		(Bw().prototype.gather = function (e, t) {
			return this.throwIfDisposed(), xT(this, e, t);
		}),
		(Bw().prototype.greaterEqual = function (e) {
			return this.throwIfDisposed(), kT(this, e);
		}),
		(Bw().prototype.greater = function (e) {
			return this.throwIfDisposed(), wT(this, e);
		}),
		(Bw().prototype.ifft = function () {
			return this.throwIfDisposed(), bE(this);
		}),
		(Bw().prototype.irfft = function () {
			return this.throwIfDisposed(), xE(this);
		}),
		(Bw().prototype.isFinite = function () {
			return this.throwIfDisposed(), IT(this);
		}),
		(Bw().prototype.isInf = function () {
			return this.throwIfDisposed(), ST(this);
		}),
		(Bw().prototype.isNaN = function () {
			return this.throwIfDisposed(), TT(this);
		}),
		(Bw().prototype.leakyRelu = function (e) {
			return this.throwIfDisposed(), CT(this, e);
		}),
		(Bw().prototype.lessEqual = function (e) {
			return this.throwIfDisposed(), RT(this, e);
		}),
		(Bw().prototype.less = function (e) {
			return this.throwIfDisposed(), ET(this, e);
		}),
		(Bw().prototype.localResponseNormalization = function (e, t, n, r) {
			return this.throwIfDisposed(), _T(this, e, t, n, r);
		}),
		(Bw().prototype.logSigmoid = function () {
			return this.throwIfDisposed(), BT(this);
		}),
		(Bw().prototype.logSoftmax = function (e) {
			return this.throwIfDisposed(), GT(this, e);
		}),
		(Bw().prototype.logSumExp = function (e, t) {
			return this.throwIfDisposed(), QT(this, e, t);
		}),
		(Bw().prototype.log = function () {
			return this.throwIfDisposed(), FT(this);
		}),
		(Bw().prototype.log1p = function () {
			return this.throwIfDisposed(), DT(this);
		}),
		(Bw().prototype.logicalAnd = function (e) {
			return this.throwIfDisposed(), $T(this, e);
		}),
		(Bw().prototype.logicalNot = function () {
			return this.throwIfDisposed(), eC(this);
		}),
		(Bw().prototype.logicalOr = function (e) {
			return this.throwIfDisposed(), tC(this, e);
		}),
		(Bw().prototype.logicalXor = function (e) {
			return this.throwIfDisposed(), nC(this, e);
		}),
		(Bw().prototype.matMul = function (e, t, n) {
			return this.throwIfDisposed(), jN(this, e, t, n);
		}),
		(Bw().prototype.maxPool = function (e, t, n, r) {
			return this.throwIfDisposed(), rC(this, e, t, n, r);
		}),
		(Bw().prototype.max = function (e, t) {
			return this.throwIfDisposed(), WT(this, e, t);
		}),
		(Bw().prototype.maximum = function (e) {
			return this.throwIfDisposed(), oC(this, e);
		}),
		(Bw().prototype.mean = function (e, t) {
			return this.throwIfDisposed(), sC(this, e, t);
		}),
		(Bw().prototype.min = function (e, t) {
			return this.throwIfDisposed(), pC(this, e, t);
		}),
		(Bw().prototype.minimum = function (e) {
			return this.throwIfDisposed(), hC(this, e);
		}),
		(Bw().prototype.mirrorPad = function (e, t) {
			return this.throwIfDisposed(), fC(this, e, t);
		}),
		(Bw().prototype.mod = function (e) {
			return this.throwIfDisposed(), dC(this, e);
		}),
		(Bw().prototype.mul = function (e) {
			return this.throwIfDisposed(), KI(this, e);
		}),
		(Bw().prototype.neg = function () {
			return this.throwIfDisposed(), zT(this);
		}),
		(Bw().prototype.norm = function (e, t, n) {
			return this.throwIfDisposed(), KE(this, e, t, n);
		}),
		(Bw().prototype.notEqual = function (e) {
			return this.throwIfDisposed(), bC(this, e);
		}),
		(Bw().prototype.oneHot = function (e, t, n) {
			return void 0 === t && (t = 1), void 0 === n && (n = 0), this.throwIfDisposed(), HN(this, e, t, n);
		}),
		(Bw().prototype.onesLike = function () {
			return this.throwIfDisposed(), xC(this);
		}),
		(Bw().prototype.pad = function (e, t) {
			return this.throwIfDisposed(), kC(this, e, t);
		}),
		(Bw().prototype.pool = function (e, t, n, r, a, i) {
			return this.throwIfDisposed(), EC(this, e, t, n, r, a, i);
		}),
		(Bw().prototype.pow = function (e) {
			return this.throwIfDisposed(), RC(this, e);
		}),
		(Bw().prototype.prelu = function (e) {
			return this.throwIfDisposed(), AC(this, e);
		}),
		(Bw().prototype.prod = function (e, t) {
			return this.throwIfDisposed(), _C(this, e, t);
		}),
		(Bw().prototype.reciprocal = function () {
			return this.throwIfDisposed(), YC(this);
		}),
		(Bw().prototype.relu = function () {
			return this.throwIfDisposed(), JC(this);
		}),
		(Bw().prototype.relu6 = function () {
			return this.throwIfDisposed(), ZC(this);
		}),
		(Bw().prototype.reshapeAs = function (e) {
			return this.throwIfDisposed(), wS(this, e.shape);
		}),
		(Bw().prototype.reshape = function (e) {
			return this.throwIfDisposed(), wS(this, e);
		}),
		(Bw().prototype.resizeBilinear = function (e, t, n) {
			return this.throwIfDisposed(), PR(this, e, t, n);
		}),
		(Bw().prototype.resizeNearestNeighbor = function (e, t, n) {
			return this.throwIfDisposed(), BR(this, e, t, n);
		}),
		(Bw().prototype.reverse = function (e) {
			return this.throwIfDisposed(), QC(this, e);
		}),
		(Bw().prototype.rfft = function () {
			return this.throwIfDisposed(), kE(this);
		}),
		(Bw().prototype.round = function () {
			return this.throwIfDisposed(), rE(this);
		}),
		(Bw().prototype.rsqrt = function () {
			return this.throwIfDisposed(), aE(this);
		}),
		(Bw().prototype.selu = function () {
			return this.throwIfDisposed(), oE(this);
		}),
		(Bw().prototype.separableConv2d = function (e, t, n, r, a, i) {
			return this.throwIfDisposed(), sE(this, e, t, n, r, a, i);
		}),
		(Bw().prototype.sigmoid = function () {
			return this.throwIfDisposed(), SS(this);
		}),
		(Bw().prototype.sign = function () {
			return this.throwIfDisposed(), cE(this);
		}),
		(Bw().prototype.sin = function () {
			return this.throwIfDisposed(), pE(this);
		}),
		(Bw().prototype.sinh = function () {
			return this.throwIfDisposed(), hE(this);
		}),
		(Bw().prototype.slice = function (e, t) {
			return this.throwIfDisposed(), TS(this, e, t);
		}),
		(Bw().prototype.softmax = function (e) {
			return this.throwIfDisposed(), vE(this, e);
		}),
		(Bw().prototype.softplus = function () {
			return this.throwIfDisposed(), PT(this);
		}),
		(Bw().prototype.spaceToBatchND = function (e, t) {
			return this.throwIfDisposed(), CC(this, e, t);
		}),
		(Bw().prototype.split = function (e, t) {
			return this.throwIfDisposed(), wE(this, e, t);
		}),
		(Bw().prototype.sqrt = function () {
			return this.throwIfDisposed(), NE(this);
		}),
		(Bw().prototype.square = function () {
			return this.throwIfDisposed(), mC(this);
		}),
		(Bw().prototype.squaredDifference = function (e) {
			return this.throwIfDisposed(), IE(this, e);
		}),
		(Bw().prototype.squeeze = function (e) {
			return this.throwIfDisposed(), SE(this, e);
		}),
		(Bw().prototype.stack = function (e, t) {
			this.throwIfDisposed();
			var n = e instanceof Pw ? [this, e] : [this].concat(e);
			return TE(n, t);
		}),
		(Bw().prototype.step = function (e) {
			return this.throwIfDisposed(), CE(this, e);
		}),
		(Bw().prototype.stridedSlice = function (e, t, n, r, a, i, o, s) {
			return this.throwIfDisposed(), EE(this, e, t, n, r, a, i, o, s);
		}),
		(Bw().prototype.sub = function (e) {
			return this.throwIfDisposed(), UT(this, e);
		}),
		(Bw().prototype.sum = function (e, t) {
			return this.throwIfDisposed(), VT(this, e, t);
		}),
		(Bw().prototype.tan = function () {
			return this.throwIfDisposed(), RE(this);
		}),
		(Bw().prototype.tanh = function () {
			return this.throwIfDisposed(), CS(this);
		}),
		(Bw().prototype.tile = function (e) {
			return this.throwIfDisposed(), gT(this, e);
		}),
		(Bw().prototype.toBool = function () {
			return this.throwIfDisposed(), NN(this, "bool");
		}),
		(Bw().prototype.toFloat = function () {
			return this.throwIfDisposed(), NN(this, "float32");
		}),
		(Bw().prototype.toInt = function () {
			return this.throwIfDisposed(), NN(this, "int32");
		}),
		(Bw().prototype.topk = function (e, t) {
			return this.throwIfDisposed(), ME(this, e, t);
		}),
		(Bw().prototype.transpose = function (e) {
			return this.throwIfDisposed(), qN(this, e);
		}),
		(Bw().prototype.unique = function (e) {
			return this.throwIfDisposed(), zE(this, e);
		}),
		(Bw().prototype.unsortedSegmentSum = function (e, t) {
			return this.throwIfDisposed(), PE(this, e, t);
		}),
		(Bw().prototype.unstack = function (e) {
			return this.throwIfDisposed(), BE(this, e);
		}),
		(Bw().prototype.where = function (e, t) {
			return this.throwIfDisposed(), oT(e, this, t);
		}),
		(Bw().prototype.zerosLike = function () {
			return this.throwIfDisposed(), sT(this);
		});
	var FF = (function (e) {
			function t(n) {
				var r;
				return (r = e.call(this, n) || this), Object.setPrototypeOf(kg(r), t.prototype), r;
			}
			return gg(t, e), t;
		})(wg(Error)),
		DF = (function (e) {
			function t(n) {
				var r;
				return (r = e.call(this, n) || this), Object.setPrototypeOf(kg(r), t.prototype), r;
			}
			return gg(t, e), t;
		})(wg(Error)),
		OF = (function (e) {
			function t(n) {
				var r;
				return (r = e.call(this, n) || this), Object.setPrototypeOf(kg(r), t.prototype), r;
			}
			return gg(t, e), t;
		})(wg(Error)),
		MF = (function (e) {
			function t(n) {
				var r;
				return (r = e.call(this, n) || this), Object.setPrototypeOf(kg(r), t.prototype), r;
			}
			return gg(t, e), t;
		})(wg(Error)),
		LF = (function (e) {
			function t(n) {
				var r;
				return (r = e.call(this, n) || this), Object.setPrototypeOf(kg(r), t.prototype), r;
			}
			return gg(t, e), t;
		})(wg(Error));
	function zF(e, t) {
		if (Array.isArray(e)) {
			for (var n = [], r = 0; r < t; r++) n = n.concat(e);
			return n;
		}
		var a = new Array(t);
		return a.fill(e), a;
	}
	function PF(e, t) {
		if (!e) throw new LF(t);
	}
	function BF(e, t) {
		for (var n, r = 0, a = Ig(e); !(n = a()).done; ) n.value === t && r++;
		return r;
	}
	function WF(e) {
		return 1 === e.length ? e[0] : e;
	}
	function UF(e) {
		return Array.isArray(e) ? e : [e];
	}
	function VF(e) {
		var t = e
			.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2")
			.replace(/([a-z])([A-Z])/g, "$1_$2")
			.toLowerCase();
		return "_" !== t[0] ? t : "private" + t;
	}
	function GF(e) {
		return e.length <= 1 || -1 === e.indexOf("_")
			? e
			: e.replace(/[_]+(\w|$)/g, function (e, t) {
					return t.toUpperCase();
			  });
	}
	Error;
	var jF = {};
	function HF(e) {
		if (null == e) return null;
		var t = {};
		return (t.className = e.getClassName()), (t.config = e.getConfig()), t;
	}
	function qF(e) {
		if (null != e && "object" == typeof e)
			if (Array.isArray(e))
				e.forEach(function (e) {
					return qF(e);
				});
			else
				for (var t = 0, n = Object.keys(e); t < n.length; t++) {
					var r = n[t],
						a = e[r];
					null != a &&
						"object" == typeof a &&
						(Array.isArray(a) || "ndarray" !== a.type || "number" != typeof a.value
							? qF(a)
							: (e[r] = a.value));
				}
	}
	function KF(e, t, n, r, a) {
		if (
			(void 0 === t && (t = {}),
			void 0 === n && (n = {}),
			void 0 === r && (r = "object"),
			void 0 === a && (a = !1),
			"string" == typeof e)
		) {
			var i,
				o = e;
			if (o in n) i = n[o];
			else if (o in jF) i = jF[o];
			else if (null == (i = t[o]))
				throw new OF(
					"Unknown " +
						r +
						": " +
						e +
						". This may be due to one of the following reasons:\n1. The " +
						r +
						" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " +
						r +
						" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."
				);
			return i;
		}
		var s = e;
		if (null == s.className || null == s.config)
			throw new OF(
				r + ": Improper config format: " + JSON.stringify(s) + ".\n'className' and 'config' must set."
			);
		var u,
			l,
			c = s.className;
		if (c in n) {
			var p = n[c];
			(u = p[0]), (l = p[1]);
		} else if (c in jF) {
			var h = jF.className;
			(u = h[0]), (l = h[1]);
		} else if (c in t) {
			var f = t[c];
			(u = f[0]), (l = f[1]);
		}
		if (null == u)
			throw new OF(
				"Unknown " +
					r +
					": " +
					c +
					". This may be due to one of the following reasons:\n1. The " +
					r +
					" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " +
					r +
					" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."
			);
		if (null != l) {
			for (var d = {}, m = 0, g = Object.keys(jF); m < g.length; m++) {
				var v = g[m];
				d[v] = jF[v];
			}
			for (var y = 0, b = Object.keys(n); y < b.length; y++) {
				var x = b[y];
				d[x] = n[x];
			}
			s.config.customObjects = d;
			for (var w = Object.assign({}, jF), k = 0, N = Object.keys(n); k < N.length; k++) {
				var I = N[k];
				jF[I] = n[I];
			}
			qF(s.config);
			var S = l(u, s.config, n, a);
			return (jF = Object.assign({}, w)), S;
		}
		for (var T = Object.assign({}, jF), C = 0, E = Object.keys(n); C < E.length; C++) {
			var R = E[C];
			jF[R] = n[R];
		}
		var A = new u(s.config);
		return (jF = Object.assign({}, T)), A;
	}
	function XF(e, t) {
		return (
			-1 *
			(function (e, t) {
				return e < t ? -1 : e > t ? 1 : 0;
			})(e, t)
		);
	}
	function YF(e) {
		if (null == e) return e;
		for (var t, n = [], r = Ig(e); !(t = r()).done; ) {
			var a = t.value;
			-1 === n.indexOf(a) && n.push(a);
		}
		return n;
	}
	function JF(e) {
		if (null == e) throw new OF("Invalid value in obj: " + JSON.stringify(e));
		for (var t in e) if (e.hasOwnProperty(t)) return !1;
		return !0;
	}
	function ZF(e, t, n) {
		if (null != n && e.indexOf(n) < 0)
			throw new OF(n + " is not a valid " + t + ".  Valid values are " + e + " or null/undefined.");
	}
	function QF(e, t, n, r) {
		return (
			void 0 === n && (n = 0),
			void 0 === r && (r = 1 / 0),
			PF(n >= 0),
			PF(r >= n),
			Array.isArray(e) &&
				e.length >= n &&
				e.length <= r &&
				e.every(function (e) {
					return typeof e === t;
				})
		);
	}
	function $F(e, t) {
		Array.isArray(e)
			? (Dg(e.length > 0, function () {
					return t + " is unexpectedly an empty array.";
			  }),
			  e.forEach(function (e, n) {
					return $F(e, "element " + (n + 1) + " of " + t);
			  }))
			: Dg(Number.isInteger(e) && e > 0, function () {
					return "Expected " + t + " to be a positive integer, but got " + eD(e) + ".";
			  });
	}
	function eD(e) {
		return null === e
			? "null"
			: Array.isArray(e)
			? "[" +
			  e
					.map(function (e) {
						return eD(e);
					})
					.join(",") +
			  "]"
			: "string" == typeof e
			? '"' + e + '"'
			: "" + e;
	}
	function tD(e) {
		return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null;
	}
	function nD(e, t) {
		return BI(function () {
			return NE(VT(KI(e, e), t, !0));
		});
	}
	var rD = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			return (
				gg(t, e),
				(t.prototype.getConfig = function () {
					return {};
				}),
				t
			);
		})(EI),
		aD = (function (e) {
			function t(t) {
				var n;
				return (
					((n = e.call(this) || this).defaultMaxValue = 2),
					(n.defaultAxis = 0),
					(n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue),
					(n.axis = null != t.axis ? t.axis : n.defaultAxis),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.apply = function (e) {
					var t = this;
					return BI(function () {
						var n = nD(e, t.axis),
							r = PS(n, 0, t.maxValue);
						return KI(e, qI(r, jI(_F(), n)));
					});
				}),
				(n.getConfig = function () {
					return { maxValue: this.maxValue, axis: this.axis };
				}),
				t
			);
		})(rD);
	(aD.className = "MaxNorm"), AI(aD);
	var iD = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this) || this).defaultAxis = 0), (n.axis = null != t.axis ? t.axis : n.defaultAxis), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.apply = function (e) {
				var t = this;
				return BI(function () {
					return qI(e, jI(_F(), nD(e, t.axis)));
				});
			}),
			(n.getConfig = function () {
				return { axis: this.axis };
			}),
			t
		);
	})(rD);
	(iD.className = "UnitNorm"), AI(iD);
	var oD = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return JC(e);
			}),
			t
		);
	})(rD);
	(oD.className = "NonNeg"), AI(oD);
	var sD = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this) || this).defaultMinValue = 0),
				(n.defaultMaxValue = 1),
				(n.defaultRate = 1),
				(n.defaultAxis = 0),
				(n.minValue = null != t.minValue ? t.minValue : n.defaultMinValue),
				(n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue),
				(n.rate = null != t.rate ? t.rate : n.defaultRate),
				(n.axis = null != t.axis ? t.axis : n.defaultAxis),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.apply = function (e) {
				var t = this;
				return BI(function () {
					var n = nD(e, t.axis),
						r = jI(KI(t.rate, PS(n, t.minValue, t.maxValue)), KI(1 - t.rate, n));
					return KI(e, qI(r, jI(_F(), n)));
				});
			}),
			(n.getConfig = function () {
				return { minValue: this.minValue, maxValue: this.maxValue, rate: this.rate, axis: this.axis };
			}),
			t
		);
	})(rD);
	(sD.className = "MinMaxNorm"), AI(sD);
	var uD = { maxNorm: "MaxNorm", minMaxNorm: "MinMaxNorm", nonNeg: "NonNeg", unitNorm: "UnitNorm" };
	function lD(e) {
		return HF(e);
	}
	function cD(e, t) {
		return void 0 === t && (t = {}), KF(e, RI.getMap().classNameMap, t, "constraint");
	}
	function pD(e) {
		return null == e
			? null
			: "string" == typeof e
			? cD({ className: e in uD ? uD[e] : e, config: {} })
			: e instanceof rD
			? e
			: cD(e);
	}
	var hD = {
			__proto__: null,
			maxNorm: function (e) {
				return new aD(e);
			},
			unitNorm: function (e) {
				return new iD(e);
			},
			nonNeg: function () {
				return new oD();
			},
			minMaxNorm: function (e) {
				return new sD(e);
			},
		},
		fD = ["channelsFirst", "channelsLast"],
		dD = ["nearest", "bilinear"],
		mD = ["valid", "same", "causal"],
		gD = ["max", "avg"],
		vD = ["sum", "mul", "concat", "ave"],
		yD = new Map();
	function bD(e) {
		ZF(fD, "DataFormat", e);
	}
	function xD(e) {
		ZF(mD, "PaddingMode", e);
	}
	function wD(e) {
		ZF(gD, "PoolMode", e);
	}
	var kD = [];
	function ND(e, t) {
		kD.push(e);
		try {
			var n = t();
			return kD.pop(), n;
		} catch (e) {
			throw (kD.pop(), e);
		}
	}
	function ID(e) {
		if (!CD(e)) throw new Error("Not a valid tensor name: '" + e + "'");
		return (0 === kD.length ? "" : kD.join("/") + "/") + e;
	}
	function SD(e) {
		if (!CD(e)) throw new Error("Not a valid tensor name: '" + e + "'");
		yD.has(e) || yD.set(e, 0);
		var t = yD.get(e);
		if ((yD.set(e, yD.get(e) + 1), t > 0)) {
			var n = e + "_" + t;
			return yD.set(n, 1), n;
		}
		return e;
	}
	var TD = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
	function CD(e) {
		return !!e.match(TD);
	}
	function ED(e, t, n) {
		null == t && (t = 0), null == n && (n = e.length);
		for (var r = 1, a = t; a < n; ++a) r *= e[a];
		return r;
	}
	function RD(e) {
		if (0 === e.length) return Number.NaN;
		for (var t = Number.POSITIVE_INFINITY, n = 0; n < e.length; n++) {
			var r = e[n];
			r < t && (t = r);
		}
		return t;
	}
	function AD(e) {
		if (0 === e.length) return Number.NaN;
		for (var t = Number.NEGATIVE_INFINITY, n = 0; n < e.length; n++) {
			var r = e[n];
			r > t && (t = r);
		}
		return t;
	}
	function _D(e, t) {
		if (t < e) throw new OF("end (" + t + ") < begin (" + e + ") is forbidden.");
		for (var n = [], r = e; r < t; ++r) n.push(r);
		return n;
	}
	function FD(e, t) {
		return NN(e, t);
	}
	function DD(e, t) {
		void 0 === t && (t = -1);
		var n = e.shape.slice();
		return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), wS(e, n);
	}
	function OD(e, t, n) {
		return BI(function () {
			switch (e.rank) {
				case 1:
					return fE(e, t, n);
				case 2:
					return dE(e, [t, 0], [n, e.shape[1]]);
				case 3:
					return mE(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);
				case 4:
					return gE(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);
				case 5:
					return TS(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);
				case 6:
					return TS(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);
				default:
					throw new OF("sliceAlongFirstAxis() received an unsupported tensor rank: " + e.rank);
			}
		});
	}
	function MD(e, t, n) {
		return BI(function () {
			switch (e.rank) {
				case 1:
					return fE(e, t, n);
				case 2:
					return dE(e, [0, t], [e.shape[0], n]);
				case 3:
					return mE(e, [0, 0, t], [e.shape[0], e.shape[1], n]);
				case 4:
					return gE(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);
				default:
					throw new OF("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank);
			}
		});
	}
	function LD(e, t, n, r) {
		return BI(function () {
			switch (e.rank) {
				case 1:
					return fE(e, t, n);
				case 2:
					switch (r) {
						case 1:
							return OD(e, t, n);
						case 2:
							return MD(e, t, n);
						default:
							throw new OF("The axis is not within the rank of the tensor " + r);
					}
				case 3:
					switch (r) {
						case 1:
							return OD(e, t, n);
						case 2:
							return mE(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);
						case 3:
							return MD(e, t, n);
						default:
							throw new OF("The axis is not within the rank of the tensor " + r);
					}
				case 4:
					switch (r) {
						case 1:
							return OD(e, t, n);
						case 2:
							return gE(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);
						case 3:
							return gE(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);
						case 4:
							return MD(e, t, n);
						default:
							throw new OF("The axis is not within the rank of the tensor " + r);
					}
				default:
					throw new OF("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank);
			}
		});
	}
	function zD(e, t) {
		var n;
		return (
			void 0 === t && (t = -1),
			t < 0 && (t = 0 !== (n = e[0].rank) ? n : 0),
			t === e[0].rank && (t = -1),
			IS(e, t)
		);
	}
	function PD(e, t) {
		switch (e.rank) {
			case 1:
				return BS([e, t]);
			case 2:
				return WS([e, t], 0);
			case 3:
				return US([e, t], 0);
			case 4:
				return VS([e, t], 0);
			default:
				throw new OF("concatAlongFirstAxis() received an unsupported tensor rank: " + e.rank);
		}
	}
	function BD(e, t) {
		if ((Array.isArray(t) || (t = [t]), e.rank !== t.length))
			throw new OF(
				"The length of input n (" +
					t.length +
					") does not match the number of dimensions in input x (" +
					e.rank +
					")"
			);
		return gT(e, t);
	}
	function WD(e, t, n, r, a) {
		return void 0 === t && (t = 0), void 0 === n && (n = 1), HC(e, t, n, r, a);
	}
	function UD(e, t, n, r) {
		if (e.rank < 2 || t.rank < 2)
			throw new MF(
				"dot requires both inputs to be rank >= 2 but got x shape = " + e.shape + " and y shape = " + t.shape
			);
		if (t.rank >= 3 && e.shape.slice(-1)[0] !== t.shape.slice(-2)[0])
			throw new MF(
				"If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = " +
					e.shape +
					" and  y shape = " +
					t.shape
			);
		if (2 === e.rank && 2 === t.rank)
			return hR({
				a: e,
				b: t,
				transposeA: !1,
				transposeB: !1,
				bias: r ? jD(e.rank, r, "channelsLast") : null,
				activation: n,
			});
		var a = e.shape.slice(),
			i = a.pop();
		e = wS(e, [-1, i]);
		var o = t.shape.slice(),
			s = o.pop(),
			u = o.pop(),
			l = [].concat(o, [s]),
			c = Array.from({ length: t.rank }, function (e, n) {
				return 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n;
			});
		t = wS(qN(t, c), [u, -1]);
		var p = [].concat(a, l);
		return wS(
			hR({
				a: e,
				b: t,
				transposeA: !1,
				transposeB: !1,
				bias: r ? jD(e.rank, r, "channelsLast") : null,
				activation: n,
			}),
			p
		);
	}
	function VD(e, t, n) {
		return BI(function () {
			return (t = Array.isArray(t) ? AE(t, "int32") : NN(t, "int32")), xT(e, t, n);
		});
	}
	function GD(e) {
		return KI(e, e);
	}
	function jD(e, t, n) {
		var r = t.shape;
		if (1 !== t.rank && t.rank !== e)
			throw new OF("Unexpected bias dimensions: " + t.rank + "; expected it to be 1 or " + e);
		if (5 === e) {
			if ("channelsFirst" === n)
				return 1 === r.length ? wS(t, [1, r[0], 1, 1, 1]) : wS(t, [1, r[3], r[0], r[1], r[2]]);
			if ("channelsLast" === n) return 1 === r.length ? wS(t, [1, 1, 1, 1, r[0]]) : wS(t, [1].concat(r));
		} else if (4 === e) {
			if ("channelsFirst" === n) return 1 === r.length ? wS(t, [1, r[0], 1, 1]) : wS(t, [1, r[2], r[0], r[1]]);
			if ("channelsLast" === n) return 1 === r.length ? wS(t, [1, 1, 1, r[0]]) : wS(t, [1].concat(r));
		} else if (3 === e) {
			if ("channelsFirst" === n) return 1 === r.length ? wS(t, [1, r[0], 1]) : wS(t, [1, r[1], r[0]]);
			if ("channelsLast" === n) return 1 === r.length ? wS(t, [1, 1, r[0]]) : wS(t, [1].concat(r));
		} else if (e < 3) return t;
		throw new OF("Unsupported input rank by biasAdd: " + t.rank);
	}
	function HD(e, t, n) {
		return BI(function () {
			return null == n && (n = "channelsLast"), bD(n), jI(e, jD(e.rank, t, n));
		});
	}
	function qD(e, t, n, r) {
		return BI(function () {
			return QE(e, t, n, r);
		});
	}
	function KD(e, t, n) {
		return void 0 === n && (n = !1), n ? e() : t();
	}
	var XD = ["fanIn", "fanOut", "fanAvg"],
		YD = ["normal", "uniform", "truncatedNormal"],
		JD = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.fromConfigUsesCustomObjects = function () {
					return !1;
				}),
				(n.getConfig = function () {
					return {};
				}),
				t
			);
		})(EI),
		ZD = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			return (
				gg(t, e),
				(t.prototype.apply = function (e, t) {
					return uC(e, t);
				}),
				t
			);
		})(JD);
	(ZD.className = "Zeros"), AI(ZD);
	var QD = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e, t) {
				return lC(e, t);
			}),
			t
		);
	})(JD);
	(QD.className = "Ones"), AI(QD);
	var $D = (function (e) {
		function t(t) {
			var n;
			if (((n = e.call(this) || this), "object" != typeof t))
				throw new OF("Expected argument of type ConstantConfig but got " + t);
			if (void 0 === t.value) throw new OF("config must have value set but got " + t);
			return (n.value = t.value), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.apply = function (e, t) {
				var n = this;
				return BI(function () {
					return KI(iE(n.value), lC(e, t));
				});
			}),
			(n.getConfig = function () {
				return { value: this.value };
			}),
			t
		);
	})(JD);
	($D.className = "Constant"), AI($D);
	var eO = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this) || this).DEFAULT_MINVAL = -0.05),
				(n.DEFAULT_MAXVAL = 0.05),
				(n.minval = t.minval || n.DEFAULT_MINVAL),
				(n.maxval = t.maxval || n.DEFAULT_MAXVAL),
				(n.seed = t.seed),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.apply = function (e, t) {
				return qC(e, this.minval, this.maxval, t);
			}),
			(n.getConfig = function () {
				return { minval: this.minval, maxval: this.maxval, seed: this.seed };
			}),
			t
		);
	})(JD);
	(eO.className = "RandomUniform"), AI(eO);
	var tO = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this) || this).DEFAULT_MEAN = 0),
				(n.DEFAULT_STDDEV = 0.05),
				(n.mean = t.mean || n.DEFAULT_MEAN),
				(n.stddev = t.stddev || n.DEFAULT_STDDEV),
				(n.seed = t.seed),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.apply = function (e, t) {
				if ("float32" !== (t = t || "float32") && "int32" !== t)
					throw new MF("randomNormal does not support dType " + t + ".");
				return WD(e, this.mean, this.stddev, t, this.seed);
			}),
			(n.getConfig = function () {
				return { mean: this.mean, stddev: this.stddev, seed: this.seed };
			}),
			t
		);
	})(JD);
	(tO.className = "RandomNormal"), AI(tO);
	var nO = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this) || this).DEFAULT_MEAN = 0),
				(n.DEFAULT_STDDEV = 0.05),
				(n.mean = t.mean || n.DEFAULT_MEAN),
				(n.stddev = t.stddev || n.DEFAULT_STDDEV),
				(n.seed = t.seed),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.apply = function (e, t) {
				if ("float32" !== (t = t || "float32") && "int32" !== t)
					throw new MF("truncatedNormal does not support dType " + t + ".");
				return LE(e, this.mean, this.stddev, t, this.seed);
			}),
			(n.getConfig = function () {
				return { mean: this.mean, stddev: this.stddev, seed: this.seed };
			}),
			t
		);
	})(JD);
	(nO.className = "TruncatedNormal"), AI(nO);
	var rO = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this) || this).gain = null != t.gain ? t.gain : 1), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.apply = function (e, t) {
				var n = this;
				return BI(function () {
					if (2 !== e.length || e[0] !== e[1])
						throw new OF("Identity matrix initializer can only be used for 2D square matrices.");
					return KI(n.gain, vT(e[0]));
				});
			}),
			(n.getConfig = function () {
				return { gain: this.gain };
			}),
			t
		);
	})(JD);
	(rO.className = "Identity"), AI(rO);
	var aO = (function (e) {
		function t(t) {
			var n, r;
			if (((n = e.call(this) || this), t.scale < 0))
				throw new OF("scale must be a positive float. Got: " + t.scale);
			return (
				(n.scale = null == t.scale ? 1 : t.scale),
				(n.mode = null == t.mode ? "fanIn" : t.mode),
				(r = n.mode),
				ZF(XD, "FanMode", r),
				(n.distribution = null == t.distribution ? "normal" : t.distribution),
				(function (e) {
					ZF(YD, "Distribution", e);
				})(n.distribution),
				(n.seed = t.seed),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.apply = function (e, t) {
				var n = (function (e, t) {
						var n, r;
						if ((void 0 === t && (t = "channelsLast"), bD(t), 2 === e.length)) (n = e[0]), (r = e[1]);
						else if (-1 !== [3, 4, 5].indexOf(e.length)) {
							if ("channelsFirst" === t) {
								var a = ED(e, 2);
								(n = e[1] * a), (r = e[0] * a);
							} else if ("channelsLast" === t) {
								var i = ED(e, 0, e.length - 2);
								(n = e[e.length - 2] * i), (r = e[e.length - 1] * i);
							}
						} else {
							var o = ED(e);
							(n = Math.sqrt(o)), (r = Math.sqrt(o));
						}
						return [n, r];
					})(e),
					r = n[0],
					a = n[1],
					i = this.scale;
				if (
					("fanIn" === this.mode
						? (i /= Math.max(1, r))
						: "fanOut" === this.mode
						? (i /= Math.max(1, a))
						: (i /= Math.max(1, (r + a) / 2)),
					"normal" === this.distribution)
				) {
					var o = Math.sqrt(i);
					if ("float32" !== (t = t || "float32") && "int32" !== t)
						throw new MF(this.getClassName() + " does not support dType " + t + ".");
					return LE(e, 0, o, t, this.seed);
				}
				var s = Math.sqrt(3 * i);
				return qC(e, -s, s, t);
			}),
			(n.getConfig = function () {
				return { scale: this.scale, mode: this.mode, distribution: this.distribution, seed: this.seed };
			}),
			t
		);
	})(JD);
	(aO.className = "VarianceScaling"), AI(aO);
	var iO = (function (e) {
		function t(t) {
			return (
				e.call(this, { scale: 1, mode: "fanAvg", distribution: "uniform", seed: null == t ? null : t.seed }) ||
				this
			);
		}
		return (
			gg(t, e),
			(t.prototype.getClassName = function () {
				return aO.className;
			}),
			t
		);
	})(aO);
	(iO.className = "GlorotUniform"), AI(iO);
	var oO = (function (e) {
		function t(t) {
			return (
				e.call(this, { scale: 1, mode: "fanAvg", distribution: "normal", seed: null == t ? null : t.seed }) ||
				this
			);
		}
		return (
			gg(t, e),
			(t.prototype.getClassName = function () {
				return aO.className;
			}),
			t
		);
	})(aO);
	(oO.className = "GlorotNormal"), AI(oO);
	var sO = (function (e) {
		function t(t) {
			return (
				e.call(this, { scale: 2, mode: "fanIn", distribution: "normal", seed: null == t ? null : t.seed }) ||
				this
			);
		}
		return (
			gg(t, e),
			(t.prototype.getClassName = function () {
				return aO.className;
			}),
			t
		);
	})(aO);
	(sO.className = "HeNormal"), AI(sO);
	var uO = (function (e) {
		function t(t) {
			return (
				e.call(this, { scale: 2, mode: "fanIn", distribution: "uniform", seed: null == t ? null : t.seed }) ||
				this
			);
		}
		return (
			gg(t, e),
			(t.prototype.getClassName = function () {
				return aO.className;
			}),
			t
		);
	})(aO);
	(uO.className = "HeUniform"), AI(uO);
	var lO = (function (e) {
		function t(t) {
			return (
				e.call(this, { scale: 1, mode: "fanIn", distribution: "normal", seed: null == t ? null : t.seed }) ||
				this
			);
		}
		return (
			gg(t, e),
			(t.prototype.getClassName = function () {
				return aO.className;
			}),
			t
		);
	})(aO);
	(lO.className = "LeCunNormal"), AI(lO);
	var cO = (function (e) {
		function t(t) {
			return (
				e.call(this, { scale: 1, mode: "fanIn", distribution: "uniform", seed: null == t ? null : t.seed }) ||
				this
			);
		}
		return (
			gg(t, e),
			(t.prototype.getClassName = function () {
				return aO.className;
			}),
			t
		);
	})(aO);
	(cO.className = "LeCunNormal"), AI(cO);
	var pO = (function (e) {
		function t(t) {
			var n;
			if (
				(((n = e.call(this) || this).DEFAULT_GAIN = 1),
				(n.gain = null == t.gain ? n.DEFAULT_GAIN : t.gain),
				(n.seed = t.seed),
				null != n.seed)
			)
				throw new MF("Random seed is not implemented for Orthogonal Initializer yet.");
			return n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.apply = function (e, t) {
				var n = this;
				return BI(function () {
					if (e.length < 2) throw new MF("Shape must be at least 2D.");
					e[0] * e[1] > 2e3 &&
						console.warn(
							"Orthogonal initializer is being called on a matrix with more than 2000 (" +
								e[0] * e[1] +
								") elements: Slowness may result."
						);
					var t = WD(e[0] > e[1] ? [e[1], e[0]] : e, 0, 1, "float32"),
						r = hA.gramSchmidt(t);
					return e[0] > e[1] && (r = qN(r)), KI(n.gain, r);
				});
			}),
			(n.getConfig = function () {
				return { gain: this.gain, seed: this.seed };
			}),
			t
		);
	})(JD);
	(pO.className = "Orthogonal"), AI(pO);
	var hO = {
		constant: "Constant",
		glorotNormal: "GlorotNormal",
		glorotUniform: "GlorotUniform",
		heNormal: "HeNormal",
		heUniform: "HeUniform",
		identity: "Identity",
		leCunNormal: "LeCunNormal",
		leCunUniform: "LeCunUniform",
		ones: "Ones",
		orthogonal: "Orthogonal",
		randomNormal: "RandomNormal",
		randomUniform: "RandomUniform",
		truncatedNormal: "TruncatedNormal",
		varianceScaling: "VarianceScaling",
		zeros: "Zeros",
	};
	function fO(e, t) {
		return void 0 === t && (t = {}), KF(e, RI.getMap().classNameMap, t, "initializer");
	}
	function dO(e) {
		return HF(e);
	}
	function mO(e) {
		if ("string" == typeof e) {
			var t = e in hO ? hO[e] : e;
			if ("GlorotNormal" === t) return new oO();
			if ("GlorotUniform" === t) return new iO();
			if ("HeNormal" === t) return new sO();
			if ("HeUniform" === t) return new uO();
			if ("LeCunNormal" === t) return new lO();
			if ("LeCunUniform" === t) return new cO();
			var n = {};
			return (n.className = t), (n.config = {}), fO(n);
		}
		return e instanceof JD ? e : fO(e);
	}
	var gO = {
			__proto__: null,
			zeros: function () {
				return new ZD();
			},
			ones: function () {
				return new QD();
			},
			constant: function (e) {
				return new $D(e);
			},
			randomUniform: function (e) {
				return new eO(e);
			},
			randomNormal: function (e) {
				return new tO(e);
			},
			truncatedNormal: function (e) {
				return new nO(e);
			},
			identity: function (e) {
				return new rO(e);
			},
			varianceScaling: function (e) {
				return new aO(e);
			},
			glorotUniform: function (e) {
				return new iO(e);
			},
			glorotNormal: function (e) {
				return new oO(e);
			},
			heNormal: function (e) {
				return new sO(e);
			},
			heUniform: function (e) {
				return new uO(e);
			},
			leCunNormal: function (e) {
				return new lO(e);
			},
			leCunUniform: function (e) {
				return new cO(e);
			},
			orthogonal: function (e) {
				return new pO(e);
			},
		},
		vO = 0;
	function yO() {
		return vO++;
	}
	var bO = {};
	function xO(e) {
		return void 0 === e && (e = ""), e in bO || (bO[e] = 0), (bO[e] += 1), e + bO[e].toString();
	}
	function wO(e) {
		return Array.isArray(e) && Array.isArray(e[0]);
	}
	function kO(e) {
		return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [e];
	}
	function NO(e) {
		var t;
		if (Array.isArray(e)) {
			if (1 !== e.length) throw new OF("Expected Tensor length to be 1; got " + e.length);
			t = e[0];
		} else t = e;
		return t;
	}
	function IO(e) {
		if (Array.isArray(e) && Array.isArray(e[0])) {
			if (1 === e.length) return (e = e)[0];
			throw new OF("Expected exactly 1 Shape; got " + e.length);
		}
		return e;
	}
	function SO(e) {
		for (var t, n = 0, r = Ig(e); !(t = r()).done; ) {
			var a = t.value;
			0 === a.shape.length
				? (n += 1)
				: (n += a.shape.reduce(function (e, t) {
						return e * t;
				  }));
		}
		return n;
	}
	var TO = "Variable",
		CO = (function () {
			function e(e, t, n, r, a) {
				void 0 === t && (t = "float32"),
					void 0 === n && (n = TO),
					void 0 === r && (r = !0),
					void 0 === a && (a = null),
					(this.dtype = null == t ? "float32" : t),
					(this.shape = e.shape),
					(this.id = yO()),
					(n = null == n ? TO : n),
					(this.originalName = ID(n)),
					(this.name = SD(this.originalName)),
					(this.trainable_ = r),
					(this.constraint = a),
					(this.val = WE(e, this.trainable_, this.name, this.dtype));
			}
			var t = e.prototype;
			return (
				(t.read = function () {
					return this.assertNotDisposed(), this.val;
				}),
				(t.write = function (e) {
					return (
						this.assertNotDisposed(),
						(function (e, t) {
							if (e.shape.toString() !== t.shape.toString())
								throw new Error(
									"Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape)
								);
						})(this.val, e),
						this.val.id !== e.id &&
							(this.val.assign(e),
							null != this.constraint && this.val.assign(this.constraint.apply(this.val))),
						this
					);
				}),
				(t.dispose = function () {
					this.assertNotDisposed(), this.val.dispose();
				}),
				(t.assertNotDisposed = function () {
					if (this.val.isDisposed) throw new Error("LayersVariable " + this.name + " is already disposed.");
				}),
				mg(e, [
					{
						key: "trainable",
						get: function () {
							return this.trainable_;
						},
						set: function (e) {
							(this.trainable_ = e), (this.val.trainable = e);
						},
					},
				]),
				e
			);
		})();
	function EO(e) {
		return e.map(function (e) {
			return e.read();
		});
	}
	function RO(e) {
		e.forEach(function (e) {
			e[0].write(e[1]);
		});
	}
	var AO = function (e) {
			(this.dtype = e.dtype),
				(this.shape = e.shape),
				null != e.shape ? (this.ndim = e.shape.length) : (this.ndim = e.ndim),
				(this.maxNDim = e.maxNDim),
				(this.minNDim = e.minNDim),
				(this.axes = e.axes || {});
		},
		_O = function (e, t, n, r, a, i, o) {
			(this.dtype = e),
				(this.shape = t),
				(this.sourceLayer = n),
				(this.inputs = r),
				(this.callArgs = a),
				(this.outputTensorIndex = o),
				(this.id = yO()),
				null != i && ((this.originalName = ID(i)), (this.name = SD(this.originalName))),
				(this.rank = t.length);
		},
		FO = 0,
		DO = (function () {
			function e(e, t) {
				(this.callArgs = t),
					(this.id = FO++),
					(this.outboundLayer = e.outboundLayer),
					(this.inboundLayers = e.inboundLayers),
					(this.nodeIndices = e.nodeIndices),
					(this.tensorIndices = e.tensorIndices),
					(this.inputTensors = e.inputTensors),
					(this.outputTensors = e.outputTensors),
					(this.inputMasks = e.inputMasks),
					(this.outputMasks = e.outputMasks),
					(this.inputShapes = e.inputShapes),
					(this.outputShapes = e.outputShapes);
				for (var n, r = Ig(e.inboundLayers); !(n = r()).done; ) {
					var a = n.value;
					null != a && a.outboundNodes.push(this);
				}
				e.outboundLayer.inboundNodes.push(this);
			}
			return (
				(e.prototype.getConfig = function () {
					for (var e, t = [], n = Ig(this.inboundLayers); !(e = n()).done; ) {
						var r = e.value;
						null != r ? t.push(r.name) : t.push(null);
					}
					return {
						outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
						inboundLayers: t,
						nodeIndices: this.nodeIndices,
						tensorIndices: this.tensorIndices,
					};
				}),
				e
			);
		})(),
		OO = 0,
		MO = (function (e) {
			function t(t) {
				var n;
				void 0 === t && (t = {}),
					((n = e.call(this) || this)._callHook = null),
					(n._addedWeightNames = []),
					(n._stateful = !1),
					(n.id = OO++),
					(n.activityRegularizer = null),
					(n.inputSpec = null),
					(n.supportsMasking = !1),
					(n._trainableWeights = []),
					(n._nonTrainableWeights = []),
					(n._losses = []),
					(n._updates = []),
					(n._built = !1),
					(n.inboundNodes = []),
					(n.outboundNodes = []);
				var r = t.name;
				if (!r) {
					var a = n.getClassName();
					r = VF(a) + "_" + xO(a);
				}
				if (
					((n.name = r),
					(n.trainable_ = null == t.trainable || t.trainable),
					null != t.inputShape || null != t.batchInputShape)
				) {
					var i;
					if (null != t.batchInputShape) i = t.batchInputShape;
					else if (null != t.inputShape) {
						var o = null;
						null != t.batchSize && (o = t.batchSize), (i = [o].concat(t.inputShape));
					}
					n.batchInputShape = i;
					var s = t.dtype;
					null == s && (s = t.inputDType), null == s && (s = "float32"), (n.dtype = s);
				}
				return (
					null != t.weights ? (n.initialWeights = t.weights) : (n.initialWeights = null),
					(n._refCount = null),
					(n.fastWeightInitDuringBuild = !1),
					n
				);
			}
			gg(t, e),
				(t.nodeKey = function (e, t) {
					return e.name + "_ib-" + t.toString();
				});
			var n = t.prototype;
			return (
				(n.getNodeAtIndex = function (e, t) {
					if (0 === this.inboundNodes.length)
						throw new DF("The layer has never been called and thus has no defined " + t + ".");
					if (this.inboundNodes.length <= e)
						throw new OF(
							"Asked to get " +
								t +
								" at node " +
								e +
								", but the layer has only " +
								this.inboundNodes.length +
								" inbound nodes."
						);
					return this.inboundNodes[e];
				}),
				(n.getInputAt = function (e) {
					return WF(this.getNodeAtIndex(e, "input").inputTensors);
				}),
				(n.getOutputAt = function (e) {
					return WF(this.getNodeAtIndex(e, "output").outputTensors);
				}),
				(n.calculateLosses = function () {
					return this.losses.map(function (e) {
						return e();
					});
				}),
				(n.resetStates = function () {
					if (!this.stateful)
						throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
				}),
				(n.assertInputCompatibility = function (e) {
					if (((e = UF(e)), null != this.inputSpec && 0 !== this.inputSpec.length)) {
						var t = UF(this.inputSpec);
						if (e.length !== t.length)
							throw new OF(
								"Layer " +
									this.name +
									" expects " +
									t.length +
									" inputs, but it received " +
									e.length +
									" input tensors. Input received: " +
									e
							);
						for (var n = 0; n < e.length; n++) {
							var r = e[n],
								a = t[n];
							if (null != a) {
								var i = r.rank;
								if (null != a.ndim && i !== a.ndim)
									throw new OF(
										"Input " +
											n +
											" is incompatible with layer " +
											this.name +
											": expected ndim=" +
											a.ndim +
											", found ndim=" +
											i
									);
								if (null != a.maxNDim && i > a.maxNDim)
									throw new OF(
										"Input " +
											n +
											" is incompatible with layer " +
											this.name +
											": expected max_ndim=" +
											a.maxNDim +
											", found ndim=" +
											i
									);
								if (null != a.minNDim && i < a.minNDim)
									throw new OF(
										"Input " +
											n +
											" is incompatible with layer " +
											this.name +
											": expected min_ndim=" +
											a.minNDim +
											", found ndim=" +
											i +
											"."
									);
								if (null != a.dtype && r.dtype !== a.dtype)
									throw new OF(
										"Input " +
											n +
											" is incompatible with layer " +
											this.name +
											" : expected dtype=" +
											a.dtype +
											", found dtype=" +
											r.dtype +
											"."
									);
								if (a.axes) {
									var o = r.shape;
									for (var s in a.axes) {
										var u = Number(s),
											l = a.axes[s],
											c = u >= 0 ? o[u] : o[o.length + u];
										if (null != l && -1 === [l, null].indexOf(c))
											throw new OF(
												"Input " +
													n +
													" is incompatible with layer " +
													this.name +
													": expected axis " +
													u +
													" of input shape to have value " +
													l +
													" but got shape " +
													o +
													"."
											);
									}
								}
								if (null != a.shape)
									for (var p = 0; p < a.shape.length; ++p) {
										var h = a.shape[p],
											f = r.shape[p];
										if (null != h && null != f && h !== f)
											throw new OF(
												"Input " +
													n +
													" is incompatible with layer " +
													this.name +
													": expected shape=" +
													a.shape +
													", found shape=" +
													r.shape +
													"."
											);
									}
							}
						}
					}
				}),
				(n.call = function (e, t) {
					return e;
				}),
				(n.invokeCallHook = function (e, t) {
					null != this._callHook && this._callHook(e, t);
				}),
				(n.setCallHook = function (e) {
					this._callHook = e;
				}),
				(n.clearCallHook = function () {
					this._callHook = null;
				}),
				(n.apply = function (e, t) {
					var n = this;
					(t = t || {}), this.assertNotDisposed();
					for (var r, a = UF(e), i = !0, o = Ig(a); !(r = o()).done; )
						if (!(r.value instanceof _O)) {
							i = !1;
							break;
						}
					for (var s, u = !0, l = Ig(a); !(s = l()).done; )
						if (s.value instanceof _O) {
							u = !1;
							break;
						}
					if (i === u) throw new OF("Arguments to apply() must be all SymbolicTensors or all Tensors");
					return ND(this.name, function () {
						if (!n.built) {
							n.assertInputCompatibility(e);
							for (var r, i = [], o = Ig(UF(e)); !(r = o()).done; ) {
								var s = r.value;
								i.push(s.shape);
							}
							n.build(WF(i)),
								(n.built = !0),
								n.initialWeights && n.setWeights(n.initialWeights),
								null === n._refCount && u && (n._refCount = 1);
						}
						if ((n.assertInputCompatibility(e), u)) {
							for (var l, c = n.call(e, t), p = [], h = Ig(UF(c)); !(l = h()).done; ) {
								var f = l.value;
								-1 !== a.indexOf(f) && (f = f.clone()), p.push(f);
							}
							if (((c = WF(p)), null != n.activityRegularizer))
								throw new MF(
									"Layer invocation in the presence of activity regularizer(s) is not supported yet."
								);
							return c;
						}
						var d,
							m = (function (e) {
								for (var t, n = [], r = Ig((e = UF(e))); !(t = r()).done; ) {
									var a = t.value;
									n.push(a.shape);
								}
								return WF(n);
							})(e),
							g = n.computeOutputShape(m),
							v = "float32";
						if (
							(n.warnOnIncompatibleInputShape(Array.isArray(e) ? m[0] : m),
							(d =
								null != g && g.length > 0 && Array.isArray(g[0])
									? g.map(function (r, a) {
											return new _O(v, r, n, UF(e), t, n.name, a);
									  })
									: new _O(v, g, n, UF(e), t, n.name)),
							n.addInboundNode(e, d, null, null, m, g, t),
							n._refCount++,
							null != n.activityRegularizer)
						)
							throw new MF(
								"Layer invocation in the presence of activity regularizer(s) is not supported yet."
							);
						return d;
					});
				}),
				(n.warnOnIncompatibleInputShape = function (e) {
					if (null != this.batchInputShape)
						if (e.length !== this.batchInputShape.length)
							console.warn(
								"The rank of the input tensor provided (shape: " +
									JSON.stringify(e) +
									") does not match that of the batchInputShape (" +
									JSON.stringify(this.batchInputShape) +
									") of the layer " +
									this.name
							);
						else {
							var t = !1;
							this.batchInputShape.forEach(function (n, r) {
								null != n && null != e[r] && e[r] !== n && (t = !0);
							}),
								t &&
									console.warn(
										"The shape of the input tensor (" +
											JSON.stringify(e) +
											") does not match the expectation of layer " +
											this.name +
											": " +
											JSON.stringify(this.batchInputShape)
									);
						}
				}),
				(n.countParams = function () {
					if (!this.built)
						throw new DF(
							"You tried to call countParams() on " +
								this.name +
								", but the layer is not built yet. Build it first by calling build(batchInputShape)."
						);
					return SO(this.weights);
				}),
				(n.build = function (e) {
					this.built = !0;
				}),
				(n.getWeights = function (e) {
					return void 0 === e && (e = !1), EO(e ? this.trainableWeights : this.weights);
				}),
				(n.setWeights = function (e) {
					var t = this;
					BI(function () {
						var n = t.weights;
						if (n.length !== e.length)
							throw new OF(
								'You called setWeights(weights) on layer "' +
									t.name +
									'" with a weight list of length ' +
									e.length +
									", but the layer was expecting " +
									n.length +
									" weights. Provided weights: " +
									e +
									"..."
							);
						if (0 !== n.length) {
							for (var r = [], a = EO(n), i = 0; i < a.length; ++i) {
								var o = a[i],
									s = n[i],
									u = e[i];
								if (!Pg(o.shape, u.shape))
									throw new OF(
										"Layer weight shape " +
											o.shape +
											" not compatible with provided weight shape " +
											u.shape
									);
								r.push([s, u]);
							}
							RO(r);
						}
					});
				}),
				(n.addWeight = function (e, t, n, r, a, i, o, s) {
					if (-1 !== this._addedWeightNames.indexOf(e))
						throw new OF("Duplicate weight name " + e + " for layer " + this.name);
					this._addedWeightNames.push(e),
						null == n && (n = "float32"),
						this.fastWeightInitDuringBuild && (r = null != s ? s() : mO("zeros"));
					var u = r.apply(t, n),
						l = new CO(u, n, e, i, o);
					return (
						u.dispose(),
						null != a &&
							this.addLoss(function () {
								return a.apply(l.read());
							}),
						null == i && (i = !0),
						i ? this._trainableWeights.push(l) : this._nonTrainableWeights.push(l),
						l
					);
				}),
				(n.setFastWeightInitDuringBuild = function (e) {
					this.fastWeightInitDuringBuild = e;
				}),
				(n.addLoss = function (e) {
					var t;
					null == e ||
						(Array.isArray(e) && 0 === e.length) ||
						((e = UF(e)),
						void 0 !== this._losses && null !== this._losses && (t = this.losses).push.apply(t, e));
				}),
				(n.computeOutputShape = function (e) {
					return e;
				}),
				(n.computeMask = function (e, t) {
					var n = this;
					if (!this.supportsMasking) {
						if (null != t) {
							if (!Array.isArray(t))
								throw new TypeError(
									"Layer " + this.name + " does not support masking, but was passed an inputMask."
								);
							t.forEach(function (e) {
								if (null != e)
									throw new TypeError(
										"Layer " + n.name + " does not support masking, but was passed an inputMask."
									);
							});
						}
						return null;
					}
					return t;
				}),
				(n.addInboundNode = function (e, t, n, r, a, i, o) {
					void 0 === o && (o = null);
					var s = UF(e);
					(t = UF(t)), (n = UF(n)), (r = UF(r)), (a = kO(a)), (i = kO(i));
					for (var u, l = [], c = [], p = [], h = Ig(s); !(u = h()).done; ) {
						var f = u.value;
						l.push(f.sourceLayer), c.push(f.nodeIndex), p.push(f.tensorIndex);
					}
					new DO(
						{
							outboundLayer: this,
							inboundLayers: l,
							nodeIndices: c,
							tensorIndices: p,
							inputTensors: s,
							outputTensors: t,
							inputMasks: n,
							outputMasks: r,
							inputShapes: a,
							outputShapes: i,
						},
						o
					);
					for (var d = 0; d < t.length; d++)
						(t[d].sourceLayer = this),
							(t[d].nodeIndex = this.inboundNodes.length - 1),
							(t[d].tensorIndex = d);
				}),
				(n.getConfig = function () {
					var e = { name: this.name, trainable: this.trainable };
					return (
						null != this.batchInputShape && (e.batchInputShape = this.batchInputShape),
						null != this.dtype && (e.dtype = this.dtype),
						e
					);
				}),
				(n.disposeWeights = function () {
					return (
						this.weights.forEach(function (e) {
							return e.dispose();
						}),
						this.weights.length
					);
				}),
				(n.assertNotDisposed = function () {
					if (0 === this._refCount) throw new Error("Layer '" + this.name + "' is already disposed.");
				}),
				(n.dispose = function () {
					if (!this.built)
						throw new Error("Cannot dispose Layer " + this.name + " because it has not been built yet.");
					if (null === this._refCount)
						throw new Error("Cannot dispose Layer " + this.name + " because it has not been used yet.");
					this.assertNotDisposed();
					var e = 0;
					return (
						0 == --this._refCount && (e = this.disposeWeights()),
						{ refCountAfterDispose: this._refCount, numDisposedVariables: e }
					);
				}),
				mg(t, [
					{
						key: "input",
						get: function () {
							if (this.inboundNodes.length > 1)
								throw new FF(
									"Layer " +
										this.name +
										' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.'
								);
							if (0 === this.inboundNodes.length)
								throw new FF("Layer " + this.name + " is not connected, no input to return.");
							return WF(this.getNodeAtIndex(0, "input").inputTensors);
						},
					},
					{
						key: "output",
						get: function () {
							if (0 === this.inboundNodes.length)
								throw new FF("Layer " + this.name + " has no inbound nodes.");
							if (this.inboundNodes.length > 1)
								throw new FF(
									"Layer " +
										this.name +
										' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.'
								);
							return WF(this.getNodeAtIndex(0, "output").outputTensors);
						},
					},
					{
						key: "losses",
						get: function () {
							return this._losses;
						},
					},
					{
						key: "updates",
						get: function () {
							return this._updates;
						},
					},
					{
						key: "built",
						get: function () {
							return this._built;
						},
						set: function (e) {
							this._built = e;
						},
					},
					{
						key: "trainable",
						get: function () {
							return this.trainable_;
						},
						set: function (e) {
							this._trainableWeights.forEach(function (t) {
								return (t.trainable = e);
							}),
								(this.trainable_ = e);
						},
					},
					{
						key: "trainableWeights",
						get: function () {
							return this.trainable_
								? this._trainableWeights.filter(function (e) {
										return e.trainable;
								  })
								: [];
						},
						set: function (e) {
							this._trainableWeights = e;
						},
					},
					{
						key: "nonTrainableWeights",
						get: function () {
							return this.trainable
								? this._trainableWeights
										.filter(function (e) {
											return !e.trainable;
										})
										.concat(this._nonTrainableWeights)
								: this._trainableWeights.concat(this._nonTrainableWeights);
						},
						set: function (e) {
							this._nonTrainableWeights = e;
						},
					},
					{
						key: "weights",
						get: function () {
							return this.trainableWeights.concat(this.nonTrainableWeights);
						},
					},
					{
						key: "stateful",
						get: function () {
							return this._stateful;
						},
					},
					{
						key: "outputShape",
						get: function () {
							if (null == this.inboundNodes || 0 === this.inboundNodes.length)
								throw new FF(
									"The layer " +
										this.name +
										" has never been called and thus has no defined output shape."
								);
							for (var e, t = [], n = Ig(this.inboundNodes); !(e = n()).done; ) {
								var r = e.value,
									a = JSON.stringify(r.outputShapes);
								-1 === t.indexOf(a) && t.push(a);
							}
							if (1 === t.length) {
								var i = this.inboundNodes[0].outputShapes;
								return Array.isArray(i) && Array.isArray(i[0]) && 1 === i.length ? i[0] : i;
							}
							throw new FF(
								"The layer " +
									this.name +
									' has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.'
							);
						},
					},
				]),
				t
			);
		})(EI);
	function LO(e, t, n) {
		if (
			((null == t || (null != n && n > 0)) && ((t = e.sourceLayer), (n = e.nodeIndex)),
			0 === t.inboundNodes.length)
		)
			return [e];
		var r = t.inboundNodes[n];
		if (0 === r.inboundLayers.length) return r.inputTensors;
		for (var a = [], i = 0; i < r.inboundLayers.length; i++)
			for (var o, s = Ig(LO(r.inputTensors[i], r.inboundLayers[i], r.nodeIndices[i])); !(o = s()).done; ) {
				var u = o.value;
				-1 === a.indexOf(u) && a.push(u);
			}
		return a;
	}
	var zO,
		PO = (function (e) {
			function t(t) {
				var n;
				if (
					((n =
						e.call(this, { dtype: t.dtype, name: null != t.name ? t.name : xO("input").toString() }) ||
						this),
					null == t.batchSize && (t.batchSize = null),
					null == t.sparse && (t.sparse = !1),
					(n.trainable = !1),
					(n.built = !0),
					(n.sparse = t.sparse),
					null != t.inputShape && null != t.batchInputShape)
				)
					throw new OF(
						"Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time."
					);
				var r = t.batchInputShape;
				if (null == r) {
					if (null == t.inputShape)
						throw new OF("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
					r = [t.batchSize].concat(t.inputShape);
				} else if (null != t.batchSize)
					throw new OF(
						"Cannot specify batchSize if batchInputShape is specified when creating an InputLayer."
					);
				var a = t.dtype || "float32";
				(n.batchInputShape = r), (n.dtype = a), (n.inputSpec = [{ shape: r }]);
				var i = new _O(n.dtype, n.batchInputShape, kg(n), [], {}, n.name);
				return (
					(i.nodeIndex = 0),
					(i.tensorIndex = 0),
					new DO({
						outboundLayer: kg(n),
						inboundLayers: [],
						nodeIndices: [],
						tensorIndices: [],
						inputTensors: [i],
						outputTensors: [i],
						inputMasks: [null],
						outputMasks: [null],
						inputShapes: [r],
						outputShapes: [r],
					}),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.apply = function (e, t) {
					throw new OF(
						"Cannot pass any input to an InputLayer's apply() method. InputLayer name: " + this.name
					);
				}),
				(n.dispose = function () {
					return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
				}),
				(n.getConfig = function () {
					return {
						batchInputShape: this.batchInputShape,
						dtype: this.dtype,
						sparse: this.sparse,
						name: this.name,
					};
				}),
				t
			);
		})(MO);
	function BO(e) {
		if (null == e.batchShape && null == e.shape)
			throw new Error(
				"Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension."
			);
		if (null != e.batchShape && null != e.shape)
			throw new OF("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
		var t = e.batchShape;
		null != e.shape && null == t && (t = [null].concat(e.shape));
		var n = e.dtype;
		return (
			null == n && (n = "float32"),
			new PO({ batchInputShape: t, name: e.name, dtype: n, sparse: e.sparse }).inboundNodes[0].outputTensors[0]
		);
	}
	function WO(e) {
		return UO.apply(this, arguments);
	}
	function UO() {
		return (UO = fg(
			regeneratorRuntime.mark(function e(t) {
				var n, r, a, i, o, s, u, l;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if (null != t) {
									e.next = 2;
									break;
								}
								return e.abrupt("return");
							case 2:
								for (i in ((n = []), (r = []), (a = []), t))
									"number" != typeof (o = t[i]) && ((s = o), n.push(s.data()), r.push(i), a.push(s));
								if (!(n.length > 0)) {
									e.next = 12;
									break;
								}
								return (e.next = 9), Promise.all(n);
							case 9:
								for (u = e.sent, l = 0; l < u.length; ++l) t[r[l]] = u[l][0];
								WI(a);
							case 12:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function VO(e) {
		if (null != e)
			for (var t in e) {
				var n = e[t];
				"number" != typeof n && n.dispose();
			}
	}
	(PO.className = "InputLayer"),
		AI(PO),
		(function (e) {
			(e[(e.SILENT = 0)] = "SILENT"), (e[(e.VERBOSE = 1)] = "VERBOSE");
		})(zO || (zO = {}));
	var GO = (function () {
			function e() {
				this.validationData = null;
			}
			var t = e.prototype;
			return (
				(t.setParams = function (e) {
					this.params = e;
				}),
				(t.onEpochBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onEpochEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onBatchBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onBatchEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onTrainBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onTrainEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.setModel = function (e) {}),
				e
			);
		})(),
		jO = (function () {
			function e(e, t) {
				void 0 === t && (t = 10), null == e && (e = []), (this.callbacks = e), (this.queueLength = t);
			}
			var t = e.prototype;
			return (
				(t.append = function (e) {
					this.callbacks.push(e);
				}),
				(t.setParams = function (e) {
					for (var t, n = Ig(this.callbacks); !(t = n()).done; ) t.value.setParams(e);
				}),
				(t.setModel = function (e) {
					for (var t, n = Ig(this.callbacks); !(t = n()).done; ) t.value.setModel(e);
				}),
				(t.onEpochBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r, a, i;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												null == n && (n = {}), (r = Ig(this.callbacks));
											case 2:
												if ((a = r()).done) {
													e.next = 8;
													break;
												}
												return (i = a.value), (e.next = 6), i.onEpochBegin(t, n);
											case 6:
												e.next = 2;
												break;
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onEpochEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r, a, i;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												null == n && (n = {}), (r = Ig(this.callbacks));
											case 2:
												if ((a = r()).done) {
													e.next = 8;
													break;
												}
												return (i = a.value), (e.next = 6), i.onEpochEnd(t, n);
											case 6:
												e.next = 2;
												break;
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onBatchBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r, a, i;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												null == n && (n = {}), (r = Ig(this.callbacks));
											case 2:
												if ((a = r()).done) {
													e.next = 8;
													break;
												}
												return (i = a.value), (e.next = 6), i.onBatchBegin(t, n);
											case 6:
												e.next = 2;
												break;
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onBatchEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r, a, i;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												null == n && (n = {}), (r = Ig(this.callbacks));
											case 2:
												if ((a = r()).done) {
													e.next = 8;
													break;
												}
												return (i = a.value), (e.next = 6), i.onBatchEnd(t, n);
											case 6:
												e.next = 2;
												break;
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onTrainBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r, a;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												null == t && (t = {}), (n = Ig(this.callbacks));
											case 2:
												if ((r = n()).done) {
													e.next = 8;
													break;
												}
												return (a = r.value), (e.next = 6), a.onTrainBegin(t);
											case 6:
												e.next = 2;
												break;
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.onTrainEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r, a;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												null == t && (t = {}), (n = Ig(this.callbacks));
											case 2:
												if ((r = n()).done) {
													e.next = 8;
													break;
												}
												return (a = r.value), (e.next = 6), a.onTrainEnd(t);
											case 6:
												e.next = 2;
												break;
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				e
			);
		})(),
		HO = (function (e) {
			function t() {
				return e.call(this) || this;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.onEpochBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												(this.seen = 0), (this.totals = {});
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onBatchEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r,
								a,
								i,
								o = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												for (i in (null == n && (n = {}),
												(r = null == n.size ? 0 : n.size),
												(this.seen += r),
												(a = function (e) {
													var t = n[e];
													if ("number" == typeof t)
														o.totals.hasOwnProperty(e) || (o.totals[e] = 0),
															(o.totals[e] = o.totals[e] + t * r);
													else {
														var a;
														e in o.totals ? (a = o.totals[e]) : (o.totals[e] = 0);
														var i = BI(function () {
															return jI(o.totals[e], KI(t, r));
														});
														(o.totals[e] = i), null != a && a.dispose();
													}
												}),
												n))
													a(i);
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onEpochEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r,
								a,
								i,
								o = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (null == n) {
													e.next = 9;
													break;
												}
												(r = function () {
													var e = i.value;
													if (null == o.totals[e]) return "continue";
													"number" == typeof o.totals[e]
														? (n[e] = o.totals[e] / o.seen)
														: BI(function () {
																var t = KI(qI(1, o.seen), o.totals[e]);
																(n[e] = t), o.totals[e].dispose(), UI(n[e]);
														  });
												}),
													(a = Ig(this.params.metrics));
											case 3:
												if ((i = a()).done) {
													e.next = 9;
													break;
												}
												if ("continue" !== r()) {
													e.next = 7;
													break;
												}
												return e.abrupt("continue", 7);
											case 7:
												e.next = 3;
												break;
											case 9:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(GO),
		qO = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.onTrainBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												(this.epoch = []), (this.history = {});
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onEpochEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												for (r in (null == n && (n = {}), this.epoch.push(t), n))
													null == this.history[r] && (this.history[r] = []),
														this.history[r].push(n[r]);
											case 3:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(n.syncData = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r, a, i, o, s, u, l;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												for (a in ((t = []), (n = []), (r = []), this.history))
													for (i = this.history[a], o = 0; o < i.length; ++o)
														"number" != typeof i[o] &&
															((s = i[o]), t.push(s.data()), n.push(a), r.push(o));
												return (e.next = 6), Promise.all(t);
											case 6:
												for (u = e.sent, l = 0; l < u.length; ++l)
													this.history[n[l]][r[l]].dispose(),
														(this.history[n[l]][r[l]] = u[l][0]);
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(GO),
		KO = (function (e) {
			function t(t, n) {
				var r;
				if (
					(((r = e.call(this) || this).currentEpoch = 0),
					(r.nowFunc = t.nowFunc),
					(r.nextFrameFunc = t.nextFrameFunc || CA),
					(r.yieldEvery = n || "auto"),
					"auto" === r.yieldEvery && (r.yieldEvery = 125),
					"never" === r.yieldEvery && null != t.onYield)
				)
					throw new Error(
						"yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback"
					);
				return (
					nv(r.yieldEvery) &&
						(r.maybeWait = (function (e, t, n) {
							var r,
								a = null != n ? n() : Nw();
							return function () {
								var i = null != n ? n() : Nw();
								return i - a < t ? r : ((a = i), (r = e.apply(void 0, arguments)));
							};
						})(r.maybeWait.bind(kg(r)), r.yieldEvery, r.nowFunc)),
					(r.trainBegin = t.onTrainBegin),
					(r.trainEnd = t.onTrainEnd),
					(r.epochBegin = t.onEpochBegin),
					(r.epochEnd = t.onEpochEnd),
					(r.batchBegin = t.onBatchBegin),
					(r.batchEnd = t.onBatchEnd),
					(r.yield = t.onYield),
					r
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.maybeWait = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n, r) {
							var a;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (((a = []), null == this.yield)) {
													e.next = 5;
													break;
												}
												return (e.next = 4), WO(r);
											case 4:
												a.push(this.yield(t, n, r));
											case 5:
												return a.push(this.nextFrameFunc()), (e.next = 8), Promise.all(a);
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n, r) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onEpochBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (((this.currentEpoch = t), null == this.epochBegin)) {
													e.next = 6;
													break;
												}
												return (e.next = 4), WO(n);
											case 4:
												return (e.next = 6), this.epochBegin(t, n);
											case 6:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onEpochEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (((r = []), null == this.epochEnd)) {
													e.next = 5;
													break;
												}
												return (e.next = 4), WO(n);
											case 4:
												r.push(this.epochEnd(t, n));
											case 5:
												return (
													"epoch" === this.yieldEvery && r.push(this.nextFrameFunc()),
													(e.next = 8),
													Promise.all(r)
												);
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onBatchBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (null == this.batchBegin) {
													e.next = 5;
													break;
												}
												return (e.next = 3), WO(n);
											case 3:
												return (e.next = 5), this.batchBegin(t, n);
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onBatchEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (((r = []), null == this.batchEnd)) {
													e.next = 5;
													break;
												}
												return (e.next = 4), WO(n);
											case 4:
												r.push(this.batchEnd(t, n));
											case 5:
												return (
													"batch" === this.yieldEvery
														? r.push(this.nextFrameFunc())
														: nv(this.yieldEvery) &&
														  r.push(this.maybeWait(this.currentEpoch, t, n)),
													(e.next = 8),
													Promise.all(r)
												);
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onTrainBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (null == this.trainBegin) {
													e.next = 5;
													break;
												}
												return (e.next = 3), WO(t);
											case 3:
												return (e.next = 5), this.trainBegin(t);
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onTrainEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (null == this.trainEnd) {
													e.next = 5;
													break;
												}
												return (e.next = 3), WO(t);
											case 3:
												return (e.next = 5), this.trainEnd(t);
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(GO);
	function XO(e, t) {
		return (
			null == e && (e = {}),
			e instanceof GO
				? [e]
				: Array.isArray(e) && e[0] instanceof GO
				? e
				: UF(e).map(function (e) {
						return new KO(e, t);
				  })
		);
	}
	var YO = (function () {
		function e() {}
		return (
			(e.registerCallbackConstructor = function (t, n) {
				Dg(t >= 0 && Number.isInteger(t), function () {
					return "Verbosity level is expected to be an integer >= 0, but got " + t;
				}),
					e.checkForDuplicate(n),
					null == e.constructors[t] && (e.constructors[t] = []),
					e.constructors[t].push(n);
			}),
			(e.checkForDuplicate = function (t) {
				for (var n in e.constructors)
					e.constructors[+n].forEach(function (e) {
						if (e === t) throw new OF("Duplicate callback constructor.");
					});
			}),
			(e.clear = function () {
				e.constructors = {};
			}),
			(e.createCallbacks = function (t) {
				var n = [];
				for (var r in e.constructors) {
					var a = +r;
					t >= a && n.push.apply(n, e.constructors[a]);
				}
				return n.map(function (e) {
					return new e();
				});
			}),
			e
		);
	})();
	function JO(e, t, n, r, a, i, o, s, u) {
		var l = new qO(),
			c = [new HO()].concat(YO.createCallbacks(t));
		null != e && c.push.apply(c, e), c.push(l);
		var p = new jO(c);
		return (
			p.setParams({
				epochs: n,
				initialEpoch: r,
				samples: a,
				steps: i,
				batchSize: o,
				verbose: t,
				doValidation: s,
				metrics: u,
			}),
			{ callbackList: p, history: l }
		);
	}
	function ZO(e, t, n) {
		return void 0 === t && (t = {}), void 0 === n && (n = !1), KF(e, RI.getMap().classNameMap, t, "layer", n);
	}
	function QO(e, t) {
		return BI(function () {
			"float32" !== e.dtype && (e = NN(e, "float32"));
			var n = VT(GD(e), t, !0),
				r = yT(n.shape, _F()),
				a = NE(oC(n, r));
			return qI(e, a);
		});
	}
	function $O(e, t) {
		return BI(function () {
			return sC(GD(UT(t, e)), -1);
		});
	}
	function eM(e, t) {
		return BI(function () {
			return sC(XI(UT(t, e)), -1);
		});
	}
	function tM(e, t) {
		return BI(function () {
			var n = UT(e, t),
				r = PS(XI(e), _F(), Number.MAX_VALUE),
				a = XI(qI(n, r));
			return KI(100, sC(a, -1));
		});
	}
	function nM(e, t, n) {
		return (
			void 0 === n && (n = !1),
			BI(function () {
				if (n) t = vE(t);
				else {
					var r = VT(t, t.shape.length - 1, !0);
					t = qI(t, r);
				}
				return (t = PS(t, _F(), 1 - _F())), zT(VT(KI(NN(e, "float32"), FT(t)), t.shape.length - 1));
			})
		);
	}
	function rM(e, t, n) {
		return (
			void 0 === n && (n = !1),
			BI(function () {
				var r,
					a,
					i = NN(bT(((a = [ED((r = e).shape)]), wS(r, a))), "int32"),
					o = (t = PS(t, _F(), 1 - _F())).shape;
				return nM(wS(HN(i, o[o.length - 1]), o), t, n);
			})
		);
	}
	function aM(e, t) {
		return BI(function () {
			var n;
			return (
				(n = PS(t, _F(), 1 - _F())),
				(n = FT(qI(n, UT(1, n)))),
				sC(
					(function (e, t) {
						if (!Pg(e.shape, t.shape))
							throw new OF(
								"logits and labels must have the same shape, but got shapes " +
									JSON.stringify(e.shape) +
									" and " +
									JSON.stringify(t.shape)
							);
						return BI(function () {
							var n = JC(t),
								r = zT(XI(t));
							return jI(UT(n, KI(t, e)), DT(fT(r)));
						});
					})(e, n),
					-1
				)
			);
		});
	}
	function iM(e, t) {
		return BI(function () {
			var n = QO(e, -1),
				r = QO(t, -1),
				a = KI(n, r);
			return zT(VT(a, -1));
		});
	}
	YO.constructors = {};
	var oM = {
		meanSquaredError: $O,
		meanAbsoluteError: eM,
		meanAbsolutePercentageError: tM,
		meanSquaredLogarithmicError: function (e, t) {
			return BI(function () {
				var n = PS(t, _F(), Number.MAX_VALUE),
					r = FT(jI(1, n)),
					a = PS(e, _F(), Number.MAX_VALUE),
					i = FT(jI(1, a));
				return sC(GD(UT(r, i)), -1);
			});
		},
		squaredHinge: function (e, t) {
			return BI(function () {
				var n = oC(0, UT(1, KI(e, t)));
				return sC(GD(n), -1);
			});
		},
		hinge: function (e, t) {
			return BI(function () {
				var n = oC(0, UT(1, KI(e, t)));
				return sC(n, -1);
			});
		},
		categoricalHinge: function (e, t) {
			return BI(function () {
				var n = VT(KI(e, t), -1),
					r = WT(KI(UT(1, e), t), -1);
				return oC(0, jI(1, UT(r, n)));
			});
		},
		logcosh: function (e, t) {
			return BI(function () {
				var n = Math.log(2),
					r = UT(t, e),
					a = UT(jI(r, PT(KI(-2, r))), n);
				return sC(a, -1);
			});
		},
		categoricalCrossentropy: nM,
		sparseCategoricalCrossentropy: rM,
		binaryCrossentropy: aM,
		kullbackLeiblerDivergence: function (e, t) {
			return BI(function () {
				var n = PS(e, _F(), 1),
					r = PS(t, _F(), 1);
				return VT(KI(e, FT(qI(n, r))), -1);
			});
		},
		poisson: function (e, t) {
			return BI(function () {
				var n = FT(jI(_F(), t));
				return sC(UT(t, KI(e, n)), -1);
			});
		},
		cosineProximity: iM,
	};
	function sM(e) {
		if ("string" == typeof e) {
			if (e in oM) return oM[e];
			var t = "Unknown loss " + e;
			throw (
				(e.toLowerCase().includes("softmaxcrossentropy") &&
					(t =
						"Unknown loss " +
						e +
						'. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),
				new OF(t))
			);
		}
		return e;
	}
	function uM(e, t) {
		return BI(function () {
			var n = KI(0.5, xC(t)),
				r = FD(wT(t, n), e.dtype);
			return sC(iT(e, r), -1);
		});
	}
	function lM(e, t) {
		return BI(function () {
			return FD(iT(eS(e, -1), eS(t, -1)), "float32");
		});
	}
	function cM(e, t) {
		return BI(function () {
			return NN(VT($T(iT(e, 1), iT(t, 1))), "float32");
		});
	}
	function pM(e, t) {
		return BI(function () {
			var n = cM(e, t),
				r = (function (e, t) {
					return BI(function () {
						return NN(VT($T(iT(e, 0), iT(t, 1))), "float32");
					});
				})(e, t),
				a = jI(n, r);
			return NN(oT(wT(a, 0), qI(n, a), 0), "float32");
		});
	}
	function hM(e, t) {
		return aM(e, t);
	}
	function fM(e, t) {
		return (
			e.rank === t.rank && (e = SE(e, [e.rank - 1])),
			(t = eS(t, -1)).dtype !== e.dtype && (t = NN(t, e.dtype)),
			NN(iT(e, t), "float32")
		);
	}
	var dM = nM,
		mM = rM,
		gM = {
			binaryAccuracy: uM,
			categoricalAccuracy: lM,
			precision: pM,
			categoricalCrossentropy: dM,
			sparseCategoricalCrossentropy: mM,
			mse: $O,
			MSE: $O,
			mae: eM,
			MAE: eM,
			mape: tM,
			MAPE: tM,
			cosine: iM,
		};
	function vM(e) {
		if ("string" == typeof e && e in gM) return gM[e];
		if ("string" != typeof e && null != e) return e;
		throw new OF("Unknown metric " + e);
	}
	function yM(e) {
		if ((PF(null !== e, "Unknown LossOrMetricFn " + e), "string" == typeof e)) return e;
		for (var t, n = 0, r = Object.keys(oM); n < r.length; n++) {
			var a = r[n];
			if (oM[a] === e) {
				t = a;
				break;
			}
		}
		if (void 0 !== t) return t;
		for (var i = 0, o = Object.keys(gM); i < o.length; i++) {
			var s = o[i];
			if (gM[s] === e) {
				t = s;
				break;
			}
		}
		return void 0 !== t ? t : e.name;
	}
	function bM(e, t, n) {
		if (
			(void 0 === n && (n = !1),
			null == e || "object" != typeof e || Object.getPrototypeOf(e) !== Object.prototype || !xM(e))
		)
			throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
		if (n) {
			var r = JSON.stringify(e);
			r.length > 1048576 &&
				console.warn(
					'User-defined metadata of model "' +
						t +
						'" is too large in size (length=' +
						r.length +
						" when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576."
				);
		}
	}
	function xM(e) {
		if (null === e) return !0;
		if ("object" == typeof e) {
			if (Object.getPrototypeOf(e) === Object.prototype) {
				for (var t = 0, n = Object.keys(e); t < n.length; t++) {
					var r = n[t];
					if ("string" != typeof r) return !1;
					if (!xM(e[r])) return !1;
				}
				return !0;
			}
			if (Array.isArray(e)) {
				for (var a, i = Ig(e); !(a = i()).done; ) if (!xM(a.value)) return !1;
				return !0;
			}
			return !1;
		}
		var o = typeof e;
		return "string" === o || "number" === o || "boolean" === o;
	}
	function wM(e, t, n) {
		void 0 === n && (n = console.log);
		for (var r = "", a = 0; a < e.length; ++a)
			a > 0 && (r = r.slice(0, r.length - 1) + " "),
				(r = (r += e[a]).slice(0, t[a])),
				(r += " ".repeat(t[a] - r.length));
		n(r);
	}
	function kM(e, t, n) {
		var r, a;
		try {
			a = e.inboundNodes
				.map(function (e) {
					return JSON.stringify(e.inputShapes);
				})
				.join(",");
		} catch (e) {
			a = "multiple";
		}
		try {
			r = JSON.stringify(e.outputShape);
		} catch (e) {
			r = "multiple";
		}
		wM([e.name + " (" + e.getClassName() + ")", a, r, e.countParams().toString()], t, n);
	}
	function NM(e, t, n, r) {
		var a, i;
		try {
			i = e.inboundNodes
				.map(function (e) {
					return JSON.stringify(e.inputShapes);
				})
				.join(",");
		} catch (e) {
			i = "multiple";
		}
		try {
			a = JSON.stringify(e.outputShape);
		} catch (e) {
			a = "multiple";
		}
		for (var o, s = [], u = Ig(e.inboundNodes); !(o = u()).done; ) {
			var l = o.value;
			if (!(null != n && n.length > 0 && -1 === n.indexOf(l)))
				for (var c = 0; c < l.inboundLayers.length; ++c) {
					var p = l.inboundLayers[c].name,
						h = l.nodeIndices[c],
						f = l.tensorIndices[c];
					s.push(p + "[" + h + "][" + f + "]");
				}
		}
		var d = e.name,
			m = e.getClassName(),
			g = 0 === s.length ? "" : s[0];
		wM([d + " (" + m + ")", i, a, e.countParams().toString(), g], t, r);
		for (var v = 1; v < s.length; ++v) wM(["", "", "", "", s[v]], t, r);
	}
	function IM(e, t, n) {
		return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n;
	}
	function SM(e, t) {
		if (null === e) return null;
		if ("string" == typeof e) return GF(e);
		if ("number" == typeof e || "boolean" == typeof e) return e;
		if (e instanceof Array) {
			for (var n = [], r = e.length, a = 0; a < r; ++a) {
				var i = e[a];
				IM(t, a, i) ? n.push(i) : n.push(SM(i, t));
			}
			return n;
		}
		for (var o = {}, s = 0, u = Object.keys(e); s < u.length; s++) {
			var l = u[s],
				c = e[l];
			if ("name" === l && "string" == typeof c) o[l] = c;
			else {
				var p = GF(l);
				o[p] = SM(c, p);
			}
		}
		return o;
	}
	function TM(e, t) {
		if (null == e) return null;
		if ("string" == typeof e) return VF(e);
		if ("number" == typeof e || "boolean" == typeof e) return e;
		if (e instanceof Array) {
			for (var n = [], r = e.length, a = 0; a < r; ++a) {
				var i = e[a];
				IM(t, a, i) ? n.push(i) : n.push(TM(i, t));
			}
			return n;
		}
		for (var o = {}, s = 0, u = Object.keys(e); s < u.length; s++) {
			var l = u[s],
				c = e[l];
			o[VF(l)] = ("name" !== l && "className" !== l) || "string" != typeof c ? TM(c, l) : c;
		}
		return o;
	}
	var CM = "3.15.0",
		EM = (function () {
			function e(t) {
				if (((this.id2Value = {}), (this.id2Mask = {}), (this.name2Id = {}), t instanceof e))
					for (var n in t.id2Value)
						(this.id2Value[n] = t.id2Value[n]), n in t.id2Mask && (this.id2Mask[n] = t.id2Mask[n]);
				else {
					if (null == t) return;
					for (var r, a = Ig(t); !(r = a()).done; ) {
						var i = r.value;
						this.add(i.key, i.value);
					}
				}
			}
			var t = e.prototype;
			return (
				(t.add = function (e, t, n) {
					if (null != this.id2Value[e.id]) throw new OF("Duplicate key: name=" + e.name + ", id=" + e.id);
					return (
						(this.id2Value[e.id] = (function (e, t) {
							if (null == e.dtype || e.dtype === t.dtype) return t;
							try {
								return NN(t, e.dtype);
							} catch (n) {
								throw new OF(
									"The dtype of the feed (" +
										t.dtype +
										") can not be cast to the dtype of the key '" +
										e.name +
										"' (" +
										e.dtype +
										")."
								);
							}
						})(e, t)),
						(this.name2Id[e.name] = e.id),
						null != n && (this.id2Mask[e.id] = n),
						this
					);
				}),
				(t.addFeed = function (e) {
					this.add(e.key, e.value);
				}),
				(t.hasKey = function (e) {
					return null != this.id2Value[e.id];
				}),
				(t.names = function () {
					return Object.keys(this.name2Id);
				}),
				(t.getValue = function (e) {
					if (e instanceof _O) {
						if (null == this.id2Value[e.id]) throw new OF("Nonexistent key: " + e.name);
						return this.id2Value[e.id];
					}
					var t = this.name2Id[e];
					if (null == t) throw new OF("Feed dict has no SymbolicTensor name: " + e);
					return this.id2Value[t];
				}),
				(t.getMask = function (e) {
					if (e instanceof _O) {
						if (null == this.id2Value[e.id]) throw new OF("Nonexistent key: " + e.name);
						return this.id2Mask[e.id];
					}
					var t = this.name2Id[e];
					if (null == t) throw new OF("Feed dict has no SymbolicTensor name: " + e);
					return this.id2Mask[t];
				}),
				(t.disposeMasks = function () {
					null != this.id2Mask && WI(this.id2Mask);
				}),
				e
			);
		})(),
		RM = {},
		AM = {};
	function _M(e, t, n, r) {
		for (
			var a,
				i = null != n && n.training,
				o = Array.isArray(e),
				s = o ? e : [e],
				u = s.map(function (e) {
					return e.name;
				}),
				l = [],
				c = t.names(),
				p = Ig(u);
			!(a = p()).done;

		) {
			var h = a.value;
			-1 !== c.indexOf(h) ? l.push(t.getValue(h)) : l.push(null);
		}
		null != r && ((r.maxNumTensors = -1 / 0), (r.minNumTensors = 1 / 0));
		var f,
			d,
			m = u.join(",") + "|" + t.names().join(",");
		if (null == RM[m]) {
			var g = (function (e, t) {
				Dg(null != e && e.length > 0, function () {
					return "Expected at least one fetch, got none";
				});
				var n = [],
					r = {};
				if (1 === e.length) {
					var a = DM(e[0], t);
					(n = a.sorted), (r = a.recipientMap);
				} else
					for (var i, o = new Set(), s = Ig(e); !(i = s()).done; ) {
						for (
							var u, l = DM(i.value, t), c = l.sorted, p = l.recipientMap, h = Ig(c);
							!(u = h()).done;

						) {
							var f = u.value;
							o.has(f.name) || (n.push(f), o.add(f.name));
						}
						var d = function (e) {
							null == r[e] && (r[e] = new Set()),
								p[e].forEach(function (t) {
									return r[e].add(t);
								});
						};
						for (var m in p) d(m);
					}
				return { sorted: n, recipientCounts: FM(r) };
			})(s, t);
			(f = g.sorted), (d = g.recipientCounts), (RM[m] = f), (AM[m] = d);
		}
		(f = RM[m]), (d = {}), i || Object.assign(d, AM[m]);
		for (var v = new EM(t), y = 0; y < f.length; ++y) {
			if (null != r) {
				var b = PI().numTensors;
				b > r.maxNumTensors && (r.maxNumTensors = b), b < r.minNumTensors && (r.minNumTensors = b);
			}
			var x = f[y],
				w = x.sourceLayer;
			if (!(w instanceof PO)) {
				for (var k, N = [], I = [], S = [], T = !1, C = Ig(x.inputs); !(k = C()).done; ) {
					var E = k.value,
						R = v.getValue(E),
						A = v.getMask(E);
					N.push(R),
						I.push(A),
						null != A && (T = !0),
						i ||
							(d[E.name]--,
							0 !== d[E.name] ||
								t.hasKey(E) ||
								-1 !== u.indexOf(E.name) ||
								R.isDisposed ||
								!0 === E.sourceLayer.stateful ||
								S.push(R));
				}
				T && ((n = n || {}).mask = I[0]);
				var _ = UF(w.apply(N, n)),
					F = null;
				w.supportsMasking && (F = w.computeMask(N, I));
				for (var D = OM(x), O = Array.isArray(D) ? D : [D], M = 0; M < O.length; ++M) {
					v.hasKey(O[M]) || v.add(O[M], _[M], Array.isArray(F) ? F[0] : F);
					var L = u.indexOf(O[M].name);
					-1 !== L && (l[L] = _[M]);
				}
				i || WI(S);
			}
		}
		return v.disposeMasks(), o ? l : l[0];
	}
	function FM(e) {
		var t = {};
		for (var n in e) t[n] = e[n].size;
		return t;
	}
	function DM(e, t) {
		for (var n, r = new Set(), a = [], i = {}, o = Ig(t.names()); !(n = o()).done; ) {
			var s = n.value;
			r.add(s);
		}
		var u = [],
			l = [];
		for (u.push(e); u.length > 0; ) {
			var c = u[u.length - 1];
			if (r.has(c.name)) u.pop();
			else {
				var p = l[l.length - 1] === u.length - 1;
				if (0 === c.inputs.length || p) u.pop(), a.push(c), r.add(c.name), p && l.pop();
				else {
					l.push(u.length - 1);
					for (var h, f = Ig(c.inputs); !(h = f()).done; ) {
						var d = h.value;
						null == i[d.name] && (i[d.name] = new Set()), i[d.name].add(c.name), r.has(d.name) || u.push(d);
					}
				}
			}
		}
		return { sorted: a, recipientMap: i };
	}
	function OM(e) {
		var t;
		if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;
		else {
			for (var n = null, r = 0; r < e.sourceLayer.inboundNodes.length; ++r)
				for (var a, i = Ig(e.sourceLayer.inboundNodes[r].outputTensors); !(a = i()).done; )
					if (a.value.id === e.id) {
						n = r;
						break;
					}
			t = e.sourceLayer.getOutputAt(n);
		}
		return t;
	}
	function MM(e, t) {
		return (function (e, t, n) {
			var r = t.length;
			if (null == e || (Array.isArray(e) && 0 === e.length))
				return t.map(function (e) {
					return null;
				});
			if (1 === r)
				return Array.isArray(e) && 1 === e.length ? e : "object" == typeof e && t[0] in e ? [e[t[0]]] : [e];
			if (Array.isArray(e)) {
				if (e.length !== r)
					throw new Error(
						"Provided " +
							n +
							" is an array of " +
							e.length +
							" element(s), but the model has " +
							r +
							" outputs. Make sure a set of weights is provided for each model output."
					);
				return e;
			}
			if ("object" == typeof e && Object.keys(e).length > 0 && "object" == typeof e[Object.keys(e)[0]]) {
				var a = [];
				return (
					t.forEach(function (t) {
						t in e ? a.push(e[t]) : a.push(null);
					}),
					a
				);
			}
			throw new Error(
				"The model has multiple (" +
					r +
					") outputs, so " +
					n +
					" must be either an array with " +
					r +
					" elements or an object with " +
					t +
					" keys. Provided " +
					n +
					" not understood: " +
					JSON.stringify(e)
			);
		})(e, t, "classWeight");
	}
	function LM(e, t, n, r) {
		return zM.apply(this, arguments);
	}
	function zM() {
		return (zM = fg(
			regeneratorRuntime.mark(function e(t, n, r, a) {
				var i, o, s;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if (null == n && null == a) {
									e.next = 2;
									break;
								}
								throw new Error("Support sampleWeight is not implemented yet");
							case 2:
								if (null == r) {
									e.next = 15;
									break;
								}
								return (
									(i = BI(function () {
										if (1 === t.shape.length) return IN(t);
										if (2 === t.shape.length) {
											if (t.shape[1] > 1) return eS(t, 1);
											if (1 === t.shape[1]) return wS(t, [t.shape[0]]);
											throw new Error(
												"Encountered unexpected last-dimension size (" +
													t.shape[1] +
													") during handling of class weights. The size is expected to be >= 1."
											);
										}
										throw new Error(
											"Unexpected rank of target (y) tensor (" +
												t.rank +
												") during handling of class weights. The rank is expected to be 1 or 2."
										);
									})),
									(e.t0 = Array),
									(e.next = 7),
									i.data()
								);
							case 7:
								return (
									(e.t1 = e.sent),
									(o = e.t0.from.call(e.t0, e.t1)),
									WI(i),
									(s = []),
									o.forEach(function (e) {
										if (null == r[e])
											throw new Error(
												"classWeight must contain all classes in the training data. The class " +
													e +
													" exists in the data but not in classWeight"
											);
										s.push(r[e]);
									}),
									e.abrupt("return", AE(s, "float32"))
								);
							case 15:
								return e.abrupt("return", null);
							case 16:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function PM(e, t) {
		return KI(e, t);
	}
	function BM(e, t) {
		var n,
			r,
			a = t;
		(n = a.xs),
			(r = a.ys),
			Dg(null != n && null != r, function () {
				return (
					"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " +
					t
				);
			});
		var i = WM("input", e.inputNames, n),
			o = WM("output", e.outputNames, r),
			s = i[0].shape[0];
		Dg(i.length === e.inputs.length, function () {
			return (
				"LayersModel has " +
				e.inputs.length +
				" inputs, but the dataset provides " +
				i.length +
				" inputs.  (Expected input keys: " +
				JSON.stringify(e.inputNames) +
				")"
			);
		}),
			Dg(o.length === e.outputs.length, function () {
				return (
					"LayersModel has " +
					e.outputs.length +
					" outputs, but the dataset provides " +
					o.length +
					" outputs.  (Expected output keys: " +
					JSON.stringify(e.outputNames) +
					")"
				);
			});
		for (
			var u = function (t) {
					Dg(i[t].shape[0] === s, function () {
						return (
							"Batch size mismatch: input " +
							e.inputNames[t] +
							" has " +
							i[t].shape[0] +
							"; expected  " +
							s +
							" based on input " +
							e.inputNames[0] +
							"."
						);
					});
				},
				l = 0;
			l < i.length;
			l++
		)
			u(l);
		for (
			var c = function (t) {
					Dg(o[t].shape[0] === s, function () {
						return (
							"Batch size mismatch: output " +
							e.outputNames[t] +
							" has " +
							o[t].shape[0] +
							"; expected  " +
							s +
							" based on input " +
							e.inputNames[0] +
							"."
						);
					});
				},
				p = 0;
			p < o.length;
			p++
		)
			c(p);
		return { xs: i, ys: o };
	}
	function WM(e, t, n) {
		if (n instanceof Pw) return [n];
		if (Array.isArray(n))
			return (
				Dg(n.length === t.length, function () {
					return (
						"Received an array of " +
						n.length +
						" Tensors, but expected " +
						t.length +
						" to match the " +
						e +
						" keys " +
						t +
						"."
					);
				}),
				n
			);
		for (var r, a = [], i = Ig(t); !(r = i()).done; ) {
			var o = r.value;
			if (null == n[o])
				throw new OF("The feature data generated by the dataset lacks the required " + e + " key '" + o + "'.");
			a.push(n[o]);
		}
		return a;
	}
	function UM(e) {
		if (3 === e.length) throw new MF("Validation with sample weights is not implemented yet.");
		return { xs: e[0], ys: e[1] };
	}
	function VM(e, t, n) {
		return GM.apply(this, arguments);
	}
	function GM() {
		return (GM = fg(
			regeneratorRuntime.mark(function e(t, n, r) {
				var a, i, o, s, u, l, c, p, h, f, d, m, g, v, y, b, x, w, k, N, I, S, T, C, E, R, A, _, F, D, O, M, L;
				return regeneratorRuntime.wrap(
					function (e) {
						for (;;)
							switch ((e.prev = e.next)) {
								case 0:
									if (
										((a = null != r.batchesPerEpoch),
										Dg(null != t.optimizer, function () {
											return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).";
										}),
										Dg(null != r, function () {
											return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.";
										}),
										Dg(null != r.epochs && r.epochs > 0 && Number.isInteger(r.epochs), function () {
											return (
												"For fitDataset(), config.epochs is expected to be a positive integer, but got " +
												r.epochs
											);
										}),
										Dg(
											!a || (r.batchesPerEpoch > 0 && Number.isInteger(r.batchesPerEpoch)),
											function () {
												return (
													"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got " +
													r.batchesPerEpoch
												);
											}
										),
										Dg(null == r.validationSplit, function () {
											return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.";
										}),
										!t.isTraining)
									) {
										e.next = 8;
										break;
									}
									throw new Error("Cannot start training because another fit() call is ongoing.");
								case 8:
									return (
										(t.isTraining = !0),
										(e.prev = 9),
										(i = null != r.validationData) &&
											(HM(r.validationData)
												? Dg(
														null == r.validationBatches ||
															(r.validationBatches > 0 &&
																Number.isInteger(r.validationBatches)),
														function () {
															return (
																"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got " +
																r.validationBatches
															);
														}
												  )
												: ((u = UM(r.validationData)), (o = u.xs), (s = u.ys))),
										(l = t.makeTrainFunction()),
										(c = t.getDedupedMetricsNames()),
										(p = i
											? c.slice().concat(
													c.map(function (e) {
														return "val_" + e;
													})
											  )
											: c.slice()),
										(h = XO(r.callbacks, r.yieldEvery)),
										(f = null == r.verbose ? 1 : r.verbose),
										(d = JO(h, f, r.epochs, null, null, jM(n, r), null, i, p)),
										(m = d.callbackList),
										(g = d.history),
										m.setModel(t),
										(t.history = g),
										(e.next = 22),
										m.onTrainBegin()
									);
								case 22:
									return (
										(t.stopTraining_ = !1),
										(v = null == r.initialEpoch ? 0 : r.initialEpoch),
										(e.next = 26),
										n.iterator()
									);
								case 26:
									y = e.sent;
								case 27:
									if (!(v < r.epochs)) {
										e.next = 98;
										break;
									}
									return (b = {}), (e.next = 31), m.onEpochBegin(v);
								case 31:
									if (((x = 0), (w = 0), a)) {
										e.next = 37;
										break;
									}
									return (e.next = 36), n.iterator();
								case 36:
									y = e.sent;
								case 37:
									if (a && !(x < r.batchesPerEpoch)) {
										e.next = 91;
										break;
									}
									return (e.next = 40), y.next();
								case 40:
									if (((k = e.sent), !a || !k.done)) {
										e.next = 44;
										break;
									}
									return (
										console.warn(
											"You provided `batchesPerEpoch` as " +
												r.batchesPerEpoch +
												", but your dataset iterator ran out of data after " +
												x +
												" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " +
												r.batchesPerEpoch * r.epochs +
												" batches). You may need to use the repeat() function when building your dataset."
										),
										e.abrupt("break", 91)
									);
								case 44:
									if (null == k.value) {
										e.next = 73;
										break;
									}
									return (
										(N = BM(t, k.value)),
										(I = N.xs),
										(S = N.ys),
										((T = {}).batch = w),
										(T.size = I[0].shape[0]),
										(e.next = 51),
										m.onBatchBegin(w, T)
									);
								case 51:
									if (((C = []), null == r.classWeight)) {
										e.next = 64;
										break;
									}
									(E = MM(r.classWeight, t.outputNames)), (R = 0);
								case 55:
									if (!(R < E.length)) {
										e.next = 64;
										break;
									}
									return (e.t0 = C), (e.next = 59), LM(S[R], null, E[R]);
								case 59:
									(e.t1 = e.sent), e.t0.push.call(e.t0, e.t1);
								case 61:
									++R, (e.next = 55);
									break;
								case 64:
									for (A = I.concat(S).concat(C), _ = l(A), WI(A), F = 0; F < c.length; ++F)
										(D = c[F]), (O = _[F]), (T[D] = O), UI(O);
									return (e.next = 70), m.onBatchEnd(w, T);
								case 70:
									VO(T), w++, x++;
								case 73:
									if (!(a ? x >= r.batchesPerEpoch : k.done)) {
										e.next = 87;
										break;
									}
									if (!i) {
										e.next = 86;
										break;
									}
									if (((M = void 0), !HM(r.validationData))) {
										e.next = 84;
										break;
									}
									return (
										(e.t2 = UF),
										(e.next = 80),
										t.evaluateDataset(r.validationData, { batches: r.validationBatches })
									);
								case 80:
									(e.t3 = e.sent), (M = (0, e.t2)(e.t3)), (e.next = 85);
									break;
								case 84:
									M = UF(
										t.evaluate(o, s, {
											batchSize: null == r.validationBatchSize ? 32 : r.validationBatchSize,
											verbose: 0,
										})
									);
								case 85:
									for (L = 0; L < t.metricsNames.length; ++L) b["val_" + t.metricsNames[L]] = M[L];
								case 86:
									return e.abrupt("break", 91);
								case 87:
									if (!t.stopTraining_) {
										e.next = 89;
										break;
									}
									return e.abrupt("break", 91);
								case 89:
									e.next = 37;
									break;
								case 91:
									return (e.next = 93), m.onEpochEnd(v, b);
								case 93:
									if ((v++, !t.stopTraining_)) {
										e.next = 96;
										break;
									}
									return e.abrupt("break", 98);
								case 96:
									e.next = 27;
									break;
								case 98:
									return (e.next = 100), m.onTrainEnd();
								case 100:
									return (e.next = 102), t.history.syncData();
								case 102:
									return e.abrupt("return", t.history);
								case 103:
									return (e.prev = 103), (t.isTraining = !1), e.finish(103);
								case 106:
								case "end":
									return e.stop();
							}
					},
					e,
					null,
					[[9, , 103, 106]]
				);
			})
		)).apply(this, arguments);
	}
	function jM(e, t) {
		var n = null;
		return null != t.batchesPerEpoch ? (n = t.batchesPerEpoch) : Number.isFinite(e.size) && (n = e.size), n;
	}
	function HM(e) {
		return "function" == typeof e.iterator;
	}
	function qM(e) {
		return "function" == typeof e.next;
	}
	function KM(e, t, n) {
		return XM.apply(this, arguments);
	}
	function XM() {
		return (XM = fg(
			regeneratorRuntime.mark(function e(t, n, r) {
				var a, i, o, s, u, l, c, p, h;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if (
									((a = null != (r = r || {}).batches),
									(i = t.testFunction),
									(o = []),
									!(r.verbose > 0))
								) {
									e.next = 6;
									break;
								}
								throw new MF("Verbose mode is not implemented yet.");
							case 6:
								if (
									(Dg(!a || (r.batches > 0 && Number.isInteger(r.batches)), function () {
										return (
											"Test loop expects `batches` to be a positive integer, but received " +
											JSON.stringify(r.batches)
										);
									}),
									!qM(n))
								) {
									e.next = 11;
									break;
								}
								(e.t0 = n), (e.next = 14);
								break;
							case 11:
								return (e.next = 13), n.iterator();
							case 13:
								e.t0 = e.sent;
							case 14:
								(s = e.t0),
									(u = 0),
									(l = 0),
									(c = regeneratorRuntime.mark(function e() {
										var n;
										return regeneratorRuntime.wrap(function (e) {
											for (;;)
												switch ((e.prev = e.next)) {
													case 0:
														return (e.next = 2), s.next();
													case 2:
														if (
															((n = e.sent),
															(o = BI(function () {
																return (
																	n.value &&
																		(function () {
																			var e = BM(t, n.value),
																				r = e.xs,
																				a = e.ys,
																				s = r.concat(a),
																				c = BI(function () {
																					return i(s);
																				});
																			if ((WI(s), 0 === l))
																				for (var p = 0; p < c.length; ++p)
																					o.push(iE(0));
																			for (
																				var h = s[0].shape[0],
																					f = function (e) {
																						var t = c[e],
																							n = o[e];
																						(o[e] = BI(function () {
																							return jI(o[e], KI(h, t));
																						})),
																							l > 0 && WI(n);
																					},
																					d = 0;
																				d < c.length;
																				++d
																			)
																				f(d);
																			WI(c), (u += h), ++l;
																		})(),
																	o
																);
															})),
															!n.done)
														) {
															e.next = 7;
															break;
														}
														return (
															a &&
																console.warn(
																	"Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, " +
																		r.batches +
																		" batches). You may need to use the repeat() function when building your dataset."
																),
															e.abrupt("return", "break")
														);
													case 7:
													case "end":
														return e.stop();
												}
										}, e);
									}));
							case 18:
								if (a && !(l < r.batches)) {
									e.next = 25;
									break;
								}
								return e.delegateYield(c(), "t1", 20);
							case 20:
								if ("break" !== e.t1) {
									e.next = 23;
									break;
								}
								return e.abrupt("break", 25);
							case 23:
								e.next = 18;
								break;
							case 25:
								for (p = 0; p < o.length; ++p) (h = o[p]), (o[p] = qI(o[p], u)), WI(h);
								return e.abrupt("return", WF(o));
							case 27:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function YM(e) {
		Dg(e > 0 && Number.isInteger(e), function () {
			return "batchSize is required to be a positive integer, but got " + e;
		});
	}
	function JM(e, t, n) {
		return null == e
			? [null]
			: Array.isArray(e)
			? e.map(function (e) {
					return OD(e, t, n - t);
			  })
			: OD(e, t, n - t);
	}
	function ZM(e, t) {
		return BI(function () {
			return null == e
				? null
				: Array.isArray(e)
				? e.map(function (e) {
						return ZM(e, t);
				  })
				: VD(e, "int32" === t.dtype ? t : NN(t, "int32"));
		});
	}
	function QM(e, t) {
		for (var n = [], r = 0, a = null; r < e; ) (a = r + t) >= e && (a = e), n.push([r, a]), (r = a);
		return n;
	}
	function $M(e, t, n, r, a, i, o, s, u, l, c, p, h, f, d) {
		return eL.apply(this, arguments);
	}
	function eL() {
		return (eL = fg(
			regeneratorRuntime.mark(function e(t, n, r, a, i, o, s, u, l, c, p, h, f, d, m) {
				var g, v, y, b, x, w, k, N;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if (
									(null == i && (i = 32),
									null == o && (o = 1),
									null == p && (p = !0),
									null == f && (f = 0),
									(g = !1),
									null != l && null != c && (g = !0),
									null == m)
								) {
									e.next = 10;
									break;
								}
								if (((g = !0), null != d)) {
									e.next = 10;
									break;
								}
								throw new OF(
									"Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set."
								);
							case 10:
								return (
									null != (v = t.checkNumSamples(r, i, d, "steps_per_epoch")) && (y = _D(0, v)),
									null == s && (s = 1),
									(b = JO(u, s, o, f, v, d, i, g, h)),
									(x = b.callbackList),
									(w = b.history),
									x.setModel(t),
									(t.history = w),
									(e.next = 18),
									x.onTrainBegin()
								);
							case 18:
								(t.stopTraining_ = !1),
									(k = regeneratorRuntime.mark(function e(o) {
										var s;
										return regeneratorRuntime.wrap(function (e) {
											for (;;)
												switch ((e.prev = e.next)) {
													case 0:
														return (e.next = 2), x.onEpochBegin(o);
													case 2:
														if (((s = {}), null == d)) {
															e.next = 7;
															break;
														}
														throw new MF("stepsPerEpoch mode is not implemented yet.");
													case 7:
														return e.delegateYield(
															regeneratorRuntime.mark(function e() {
																var o, u, h, f;
																return regeneratorRuntime.wrap(function (e) {
																	for (;;)
																		switch ((e.prev = e.next)) {
																			case 0:
																				if ("batch" !== p) {
																					e.next = 4;
																					break;
																				}
																				throw new MF(
																					"batch shuffling is not implemneted yet"
																				);
																			case 4:
																				p && Eg(y);
																			case 5:
																				(o = AE(y)),
																					(u = QM(v, i)),
																					(h = regeneratorRuntime.mark(
																						function e(p) {
																							var h;
																							return regeneratorRuntime.wrap(
																								function (e) {
																									for (;;)
																										switch (
																											(e.prev =
																												e.next)
																										) {
																											case 0:
																												return (
																													(h =
																														{}),
																													(e.next = 3),
																													x.onBatchBegin(
																														p,
																														h
																													)
																												);
																											case 3:
																												return (
																													BI(
																														function () {
																															var e =
																																	u[
																																		p
																																	][0],
																																f =
																																	u[
																																		p
																																	][1],
																																d =
																																	OD(
																																		o,
																																		e,
																																		f -
																																			e
																																	);
																															(h.batch =
																																p),
																																(h.size =
																																	f -
																																	e);
																															for (
																																var m =
																																		ZM(
																																			r,
																																			d
																																		),
																																	v =
																																		n(
																																			m
																																		),
																																	y = 0;
																																y <
																																a.length;
																																++y
																															) {
																																var b =
																																		a[
																																			y
																																		],
																																	x =
																																		v[
																																			y
																																		];
																																(h[
																																	b
																																] =
																																	x),
																																	UI(
																																		x
																																	);
																															}
																															if (
																																p ===
																																	u.length -
																																		1 &&
																																g
																															)
																																for (
																																	var w =
																																			t.testLoop(
																																				l,
																																				c,
																																				i
																																			),
																																		k = 0;
																																	k <
																																	a.length;
																																	++k
																																) {
																																	var N =
																																			a[
																																				k
																																			],
																																		I =
																																			w[
																																				k
																																			];
																																	UI(
																																		I
																																	),
																																		(s[
																																			"val_" +
																																				N
																																		] =
																																			I);
																																}
																														}
																													),
																													(e.next = 6),
																													x.onBatchEnd(
																														p,
																														h
																													)
																												);
																											case 6:
																												if (
																													(VO(
																														h
																													),
																													!t.stopTraining_)
																												) {
																													e.next = 9;
																													break;
																												}
																												return e.abrupt(
																													"return",
																													"break"
																												);
																											case 9:
																											case "end":
																												return e.stop();
																										}
																								},
																								e
																							);
																						}
																					)),
																					(f = 0);
																			case 9:
																				if (!(f < u.length)) {
																					e.next = 17;
																					break;
																				}
																				return e.delegateYield(h(f), "t0", 11);
																			case 11:
																				if ("break" !== e.t0) {
																					e.next = 14;
																					break;
																				}
																				return e.abrupt("break", 17);
																			case 14:
																				++f, (e.next = 9);
																				break;
																			case 17:
																				o.dispose();
																			case 18:
																			case "end":
																				return e.stop();
																		}
																}, e);
															})(),
															"t0",
															8
														);
													case 8:
														return (e.next = 10), x.onEpochEnd(o, s);
													case 10:
														if (!t.stopTraining_) {
															e.next = 12;
															break;
														}
														return e.abrupt("return", "break");
													case 12:
													case "end":
														return e.stop();
												}
										}, e);
									})),
									(N = f);
							case 21:
								if (!(N < o)) {
									e.next = 29;
									break;
								}
								return e.delegateYield(k(N), "t0", 23);
							case 23:
								if ("break" !== e.t0) {
									e.next = 26;
									break;
								}
								return e.abrupt("break", 29);
							case 26:
								++N, (e.next = 21);
								break;
							case 29:
								return (e.next = 31), x.onTrainEnd();
							case 31:
								return (e.next = 33), t.history.syncData();
							case 33:
								return e.abrupt("return", t.history);
							case 34:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function tL(e, t, n, r) {
		return nL.apply(this, arguments);
	}
	function nL() {
		return (nL = fg(
			regeneratorRuntime.mark(function e(t, n, r, a) {
				var i, o, s, u, l, c, p, h, f, d, m, g, v, y, b, x, w, k, N, I, S, T, C;
				return regeneratorRuntime.wrap(
					function (e) {
						for (;;)
							switch ((e.prev = e.next)) {
								case 0:
									if ((void 0 === a && (a = {}), !t.isTraining)) {
										e.next = 3;
										break;
									}
									throw new Error("Cannot start training because another fit() call is ongoing.");
								case 3:
									return (
										(t.isTraining = !0),
										(e.prev = 4),
										YM((d = null == a.batchSize ? 32 : a.batchSize)),
										(e.next = 10),
										t.standardizeUserData(n, r, a.sampleWeight, a.classWeight, !1, d)
									);
								case 10:
									if (
										((m = e.sent),
										(i = m[0]),
										(o = m[1]),
										(f = m[2]),
										(g = !1),
										!(null != a.validationData && a.validationData.length > 0))
									) {
										e.next = 36;
										break;
									}
									if (((g = !0), 2 !== a.validationData.length)) {
										e.next = 22;
										break;
									}
									(l = a.validationData[0]), (c = a.validationData[1]), (e.next = 27);
									break;
								case 22:
									if (3 !== a.validationData.length) {
										e.next = 26;
										break;
									}
									throw new MF("validationData including sample weights is not supported yet.");
								case 26:
									throw new OF(
										"When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " +
											a.validationData +
											" is invalid."
									);
								case 27:
									return (e.next = 30), t.standardizeUserData(l, c, null, null, !0, d);
								case 30:
									(y = e.sent), (p = y[0]), (h = y[1]), (v = p.concat(h)), (e.next = 37);
									break;
								case 36:
									null != a.validationSplit && a.validationSplit > 0 && a.validationSplit < 1
										? ((g = !0),
										  (b = Math.floor(i[0].shape[0] * (1 - a.validationSplit))),
										  (x = i[0].shape[0]),
										  (p = JM(i, b, x)),
										  (s = i),
										  (i = JM(i, 0, b)),
										  (h = JM(o, b, x)),
										  (u = o),
										  (o = JM(o, 0, b)),
										  (v = p.concat(h)))
										: null != a.validationSteps && (g = !0);
								case 37:
									return (
										(w = i.concat(o).concat(f)),
										t.checkTrainableWeightsConsistency(),
										(k = t.makeTrainFunction()),
										(N = t.getDedupedMetricsNames()),
										g
											? (t.makeTestFunction(),
											  (I = t.testFunction),
											  (S = N.slice().concat(
													N.map(function (e) {
														return "val_" + e;
													})
											  )))
											: ((I = null), (v = []), (S = N.slice())),
										(T = XO(a.callbacks, a.yieldEvery)),
										(e.next = 45),
										$M(
											t,
											k,
											w,
											N,
											d,
											a.epochs,
											a.verbose,
											T,
											I,
											v,
											a.shuffle,
											S,
											a.initialEpoch,
											null,
											null
										)
									);
								case 45:
									return (C = e.sent), e.abrupt("return", C);
								case 47:
									return (
										(e.prev = 47),
										(t.isTraining = !1),
										aL(i, n),
										aL(o, r),
										aL(s, n),
										aL(u, r),
										aL(p, l),
										aL(h, c),
										null != f && WI(f),
										e.finish(47)
									);
								case 57:
								case "end":
									return e.stop();
							}
					},
					e,
					null,
					[[4, , 47, 57]]
				);
			})
		)).apply(this, arguments);
	}
	function rL(e) {
		var t = [];
		e instanceof Pw && (e = [e]);
		for (var n = 0; n < e.length; ++n) {
			var r = e[n];
			if (1 === r.rank) t.push(DD(r, 1));
			else {
				if (0 === r.rank)
					throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
				t.push(r);
			}
		}
		return t;
	}
	function aL(e, t) {
		if (null != e) {
			var n = [];
			if (t instanceof Pw) n.push(t.id);
			else if (Array.isArray(t))
				t.forEach(function (e) {
					return n.push(e.id);
				});
			else if (null != t)
				for (var r in t) {
					var a = t[r];
					n.push(a.id);
				}
			var i = [];
			if (e instanceof Pw) -1 === n.indexOf(e.id) && i.push(e);
			else if (Array.isArray(e))
				e.forEach(function (e) {
					-1 === n.indexOf(e.id) && i.push(e);
				});
			else if (null != e)
				for (var o in e) {
					var s = e[o];
					-1 === n.indexOf(s.id) && i.push(s);
				}
			i.forEach(function (e) {
				e.isDisposed || e.dispose();
			});
		}
	}
	function iL(e) {
		return Array.isArray(e);
	}
	function oL(e) {
		return (
			!(function (e) {
				return e instanceof Pw;
			})(e) && !iL(e)
		);
	}
	function sL(e, t, n, r, a) {
		if ((void 0 === r && (r = !0), void 0 === a && (a = ""), null == t || 0 === t.length)) {
			if (null != e) {
				var i = !1;
				if (iL(e) && e.length > 0) i = !0;
				else if (oL(e)) {
					for (var o in e)
						if (e.hasOwnProperty(o)) {
							i = !0;
							break;
						}
				} else i = !0;
				if (i) throw new OF("Error when checking model " + a + " expected no data, but got " + e);
			}
			return [];
		}
		if (null == e)
			return t.map(function (e) {
				return null;
			});
		var s;
		if (oL(e)) {
			(e = e), (s = []);
			for (var u, l = Ig(t); !(u = l()).done; ) {
				var c = u.value;
				if (null == e[c]) throw new OF('No data provided for "' + c + '". Need data for each key in: ' + t);
				s.push(e[c]);
			}
		} else if (iL(e)) {
			if ((e = e).length !== t.length)
				throw new OF(
					"Error when checking model " +
						a +
						": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see " +
						t.length +
						" Tensor(s), but instead got the following list of Tensor(s): " +
						e
				);
			s = e;
		} else {
			if (((e = e), t.length > 1))
				throw new OF(
					"The model " +
						a +
						" expects " +
						t.length +
						" Tensor(s), but only received one Tensor. Found: Tensor with shape " +
						e.shape
				);
			s = [e];
		}
		if (((s = rL(s)), null != n))
			for (var p = 0; p < t.length; ++p)
				if (null != n[p]) {
					var h = s[p];
					if (h.shape.length !== n[p].length)
						throw new OF(
							"Error when checking " +
								a +
								": expected " +
								t[p] +
								" to have " +
								n[p].length +
								" dimension(s). but got array with shape " +
								h.shape
						);
					for (var f = 0; f < n[p].length; ++f)
						if (0 !== f || r) {
							var d = h.shape[f],
								m = n[p][f];
							if (null != m && m >= 0 && d !== m)
								throw new OF(
									a +
										" expected a batch of elements where each example has shape [" +
										n[p].slice(1, n[p].length) +
										"] (i.e.,tensor shape [*," +
										n[p].slice(1, n[p].length) +
										"]) but the " +
										a +
										" received an input with " +
										h.shape[0] +
										" examples, each with shape [" +
										h.shape.slice(1, h.shape.length) +
										"] (tensor shape [" +
										h.shape +
										"])"
								);
						}
				}
		return s;
	}
	function uL(e, t, n, r, a) {
		var i;
		if ((void 0 === r && (r = !0), void 0 === a && (a = ""), Array.isArray(e))) {
			if (e.length !== t.length)
				throw new OF(
					"Error when checking model " +
						a +
						": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see " +
						t.length +
						" Tensor(s), but instead got " +
						e.length +
						" Tensors(s)."
				);
			i = e;
		} else {
			if (t.length > 1)
				throw new OF(
					"The model expects " +
						t.length +
						" " +
						a +
						" Tensors, but only received one Tensor. Found: array with shape " +
						JSON.stringify(e.shape) +
						"."
				);
			i = [e];
		}
		if (null != n)
			for (var o = 0; o < t.length; ++o)
				if (null != n[o]) {
					var s = i[o];
					if (s.shape.length !== n[o].length)
						throw new OF(
							"Error when checking " +
								a +
								": expected " +
								t[o] +
								" to have " +
								n[o].length +
								" dimension(s), but got array with shape " +
								JSON.stringify(s.shape)
						);
					for (var u = 0; u < n[o].length; ++u)
						if (0 !== u || r) {
							var l = s.shape[u],
								c = n[o][u];
							if (null != c && c !== l)
								throw new OF(
									"Error when checking " +
										a +
										": expected " +
										t[o] +
										" to have shape " +
										JSON.stringify(n[o]) +
										" but got array with shape " +
										JSON.stringify(s.shape) +
										"."
								);
						}
				}
	}
	var lL = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this, t) || this).isTraining = !1), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.summary = function (e, t, n) {
				if ((void 0 === n && (n = console.log), !this.built))
					throw new OF(
						"This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data)."
					);
				!(function (e, t, n, r) {
					void 0 === r && (r = console.log);
					var a,
						i = (function (e) {
							var t = !0,
								n = [],
								r = [];
							for (var a in e.nodesByDepth) n.push(e.nodesByDepth[a]);
							for (var i = 0, o = n; i < o.length; i++) {
								var s = o[i];
								if (s.length > 1 || (1 === s.length && s[0].inboundLayers.length > 1)) {
									t = !1;
									break;
								}
								r.push.apply(r, s);
							}
							if (t)
								for (var u, l = Ig(e.layers); !(u = l()).done; ) {
									for (var c, p = !1, h = Ig(u.value.inboundNodes); !(c = h()).done; ) {
										var f = c.value;
										if (-1 !== r.indexOf(f)) {
											if (p) {
												t = !1;
												break;
											}
											p = !0;
										}
									}
									if (!t) break;
								}
							return t;
						})(e),
						o = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
					if (
						(i
							? ((t = t || 90), (n = n || [0.32, 0.61, 0.89, 1]))
							: ((t = t || 115), (n = n || [0.24, 0.48, 0.7, 0.8, 1])),
						n[n.length - 1] <= 1 &&
							(n = n.map(function (e) {
								return Math.floor(t * e);
							})),
						!i)
					)
						for (var s in (o.push("Receives inputs"), (a = []), e.nodesByDepth)) {
							var u;
							(u = a).push.apply(u, e.nodesByDepth[s]);
						}
					r("_".repeat(t)), wM(o, n, r), r("=".repeat(t));
					for (var l = e.layers, c = 0; c < l.length; ++c)
						i ? kM(l[c], n, r) : NM(l[c], n, a, r), r((c === l.length - 1 ? "=" : "_").repeat(t));
					e.checkTrainableWeightsConsistency();
					var p = (function (e) {
							return null != e.collectedTrainableWeights
								? SO(e.collectedTrainableWeights)
								: SO(e.trainableWeights);
						})(e),
						h = SO(e.nonTrainableWeights);
					r("Total params: " + (p + h)),
						r("Trainable params: " + p),
						r("Non-trainable params: " + h),
						r("_".repeat(t));
				})(this, e, t, n);
			}),
			(n.compile = function (e) {
				var t = this;
				if ((null == e.loss && (e.loss = []), (this.loss = e.loss), "string" == typeof e.optimizer))
					(this.optimizer_ = (function (e) {
						var t = {
							Adagrad: function () {
								return SA.adagrad(0.01);
							},
							Adadelta: function () {
								return SA.adadelta(1, 0.95, _F());
							},
							Adam: function () {
								return SA.adam(0.001, 0.9, 0.999, _F());
							},
							Adamax: function () {
								return SA.adamax(0.002, 0.9, 0.999, _F(), 0);
							},
							RMSProp: function () {
								return SA.rmsprop(0.001, 0.9, 0, _F());
							},
							SGD: function () {
								return SA.sgd(0.01);
							},
						};
						if (
							((t.adagrad = t.Adagrad),
							(t.adadelta = t.Adadelta),
							(t.adam = t.Adam),
							(t.adamax = t.Adamax),
							(t.rmsprop = t.RMSProp),
							(t.sgd = t.SGD),
							e in t)
						)
							return t[e]();
						throw new OF("Unknown Optimizer " + e);
					})(e.optimizer)),
						(this.isOptimizerOwned = !0);
				else {
					if (!(e.optimizer instanceof gA))
						throw new OF("User-defined optimizer must be an instance of tf.Optimizer.");
					(this.optimizer_ = e.optimizer), (this.isOptimizerOwned = !1);
				}
				var n = [];
				if (Array.isArray(e.loss) || "string" == typeof e.loss || "function" == typeof e.loss)
					if (Array.isArray(e.loss)) {
						if (e.loss.length !== this.outputs.length)
							throw new OF(
								"When passing an Array as loss, it should have one entry per model output. The model has " +
									this.outputs.length +
									" output(s), but you passed loss=" +
									e.loss +
									"."
							);
						var r = e.loss;
						n = r.map(function (e) {
							return sM(e);
						});
					} else {
						var a = sM(e.loss);
						this.outputs.forEach(function (e) {
							n.push(a);
						});
					}
				else {
					for (var i in ((e.loss = e.loss), e.loss))
						if (-1 === this.outputNames.indexOf(i))
							throw new OF(
								'Unknown entry in loss dictionary: "' +
									i +
									'". Only expected the following keys: ' +
									this.outputNames
							);
					for (var o, s = Ig(this.outputNames); !(o = s()).done; ) {
						var u = o.value;
						null == e.loss[u] &&
							console.warn(
								'Output "' +
									u +
									'" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ' +
									u +
									" during training"
							),
							n.push(sM(e.loss[u]));
					}
				}
				(this.lossFunctions = n),
					(this.feedOutputNames = []),
					(this.feedOutputShapes = []),
					(this.feedLossFns = []);
				for (var l = 0; l < this.outputs.length; ++l) {
					var c = this.internalOutputShapes[l],
						p = this.outputNames[l];
					this.feedOutputNames.push(p),
						this.feedOutputShapes.push(c),
						this.feedLossFns.push(this.lossFunctions[l]);
				}
				var h = [];
				(this.metrics = e.metrics),
					(this.metricsNames = ["loss"]),
					(this.metricsTensors = []),
					ND("loss", function () {
						for (var e = 0; e < t.outputs.length; ++e)
							if (-1 === h.indexOf(e)) {
								var n = t.lossFunctions[e];
								t.outputs.length > 1 &&
									(t.metricsTensors.push([n, e]), t.metricsNames.push(t.outputNames[e] + "_loss"));
							}
					});
				var f = (function (e, t) {
						if (null == e || (Array.isArray(e) && 0 === e.length))
							return t.map(function (e) {
								return [];
							});
						var n;
						if ("string" == typeof e || "function" == typeof e) n = [e];
						else {
							if (!Array.isArray(e) && "object" != typeof e)
								throw new TypeError(
									"Type of metrics argument not understood. Expected an string,function, Array, or Object, found: " +
										e
								);
							n = e;
						}
						if (Array.isArray(n))
							return t.map(function (e) {
								return n;
							});
						for (var r, a = [], i = Ig(t); !(r = i()).done; ) {
							var o = r.value,
								s = n.hasOwnProperty(o) ? n[o] : [];
							Array.isArray(s) || (s = [s]), a.push(s);
						}
						return a;
					})(e.metrics, this.outputNames),
					d = function (e, n, r) {
						t.outputNames.length > 1 && (n = t.outputNames[e] + "_" + n),
							t.metricsNames.push(n),
							t.metricsTensors.push([r, e]);
					};
				ND("metric", function () {
					for (
						var e = function (e) {
								if (-1 !== h.indexOf(e)) return "continue";
								!(function (n) {
									for (var r, a, i, o, s = Ig(n); !(o = s()).done; ) {
										var u = o.value;
										if (
											"string" == typeof u &&
											-1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(u)
										) {
											var l = t.internalOutputShapes[e];
											1 === l[l.length - 1] || t.lossFunctions[e] === aM
												? -1 !== ["accuracy", "acc"].indexOf(u)
													? (a = uM)
													: -1 !== ["crossentropy", "ce"].indexOf(u) && (a = hM)
												: t.lossFunctions[e] === rM
												? -1 !== ["accuracy", "acc"].indexOf(u)
													? (a = fM)
													: -1 !== ["crossentropy", "ce"].indexOf(u) && (a = mM)
												: -1 !== ["accuracy", "acc"].indexOf(u)
												? (a = lM)
												: -1 !== ["crossentropy", "ce"].indexOf(u) && (a = dM);
											var c = void 0;
											-1 !== ["accuracy", "acc"].indexOf(u)
												? (c = "acc")
												: -1 !== ["crossentropy", "ce"].indexOf(u) && (c = "ce"),
												(i = a),
												(r = "" + c);
										} else {
											var p = vM(u);
											(i = p), (r = "" + yM(u));
										}
										var h = void 0;
										ND(r, function () {
											h = i;
										}),
											d(e, r, h);
									}
								})(f[e]);
							},
							n = 0;
						n < t.outputs.length;
						++n
					)
						e(n);
				}),
					(this.collectedTrainableWeights = this.trainableWeights);
			}),
			(n.checkTrainableWeightsConsistency = function () {
				null != this.collectedTrainableWeights &&
					this.trainableWeights.length !== this.collectedTrainableWeights.length &&
					console.warn(
						"Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?"
					);
			}),
			(n.evaluate = function (e, t, n) {
				void 0 === n && (n = {});
				var r = null == n.batchSize ? 32 : n.batchSize;
				YM(r);
				var a = this.standardizeUserDataXY(e, t, !0, r);
				try {
					var i = a[0].concat(a[1]);
					this.makeTestFunction();
					var o = this.testFunction;
					return WF(this.testLoop(o, i, r, n.verbose, n.steps));
				} finally {
					aL(a[0], e), aL(a[1], t);
				}
			}),
			(n.evaluateDataset = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return this.makeTestFunction(), e.abrupt("return", KM(this, t, n));
										case 2:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n) {
					return e.apply(this, arguments);
				};
			})()),
			(n.checkNumSamples = function (e, t, n, r) {
				var a;
				if ((void 0 === r && (r = "steps"), null != n)) {
					if (((a = null), null != t))
						throw new OF("If " + r + " is set, batchSize must be null or undefined.Got batchSize = " + t);
				} else {
					if (null == e)
						throw new OF(
							"Either the input data should have a defined shape, or " + r + " shoud be specified."
						);
					a = Array.isArray(e) ? e[0].shape[0] : e.shape[0];
				}
				return a;
			}),
			(n.execute = function (e, t) {
				if (Array.isArray(t) && 0 === t.length)
					throw new OF("`outputs` is an empty Array, which is not allowed.");
				var n = Array.isArray(t),
					r = n ? t : [t],
					a = this.retrieveSymbolicTensors(r),
					i = new EM();
				if ((e instanceof Pw && (e = [e]), Array.isArray(e))) {
					if (e.length !== this.inputs.length)
						throw new OF(
							"The number of inputs provided (" +
								e.length +
								") does not match the number of inputs of this model (" +
								this.inputs.length +
								")."
						);
					for (var o = 0; o < this.inputs.length; ++o) i.add(this.inputs[o], e[o]);
				} else
					for (var s, u = Ig(this.inputs); !(s = u()).done; ) {
						var l = s.value,
							c = e[l.name];
						if (null == c) throw new OF("No value is provided for the model's input " + l.name);
						i.add(l, c);
					}
				var p = _M(a, i);
				return n ? p : p[0];
			}),
			(n.retrieveSymbolicTensors = function (e) {
				for (var t, n = zF(null, e.length), r = e.length, a = Ig(this.layers); !(t = a()).done; ) {
					for (
						var i = t.value,
							o = Array.isArray(i.output) ? i.output : [i.output],
							s = o.map(function (e) {
								return e.name;
							}),
							u = 0;
						u < e.length;
						++u
					) {
						var l = s.indexOf(e[u]);
						if ((-1 !== l && ((n[u] = o[l]), r--), 0 === r)) break;
					}
					if (0 === r) break;
				}
				if (r > 0) {
					var c = [];
					throw (
						(n.forEach(function (t, n) {
							null == t && c.push(e[n]);
						}),
						new OF("Cannot find SymbolicTensors for output name(s): " + JSON.stringify(c)))
					);
				}
				return n;
			}),
			(n.predictLoop = function (e, t, n) {
				var r = this;
				return (
					void 0 === t && (t = 32),
					void 0 === n && (n = !1),
					BI(function () {
						var a = r.checkNumSamples(e);
						if (n) throw new MF("Verbose predictLoop() is not implemented yet.");
						for (
							var i = QM(a, t),
								o = r.outputs.map(function (e) {
									return [];
								}),
								s = function (t) {
									BI(function () {
										var n = i[t][0],
											a = i[t][1],
											o = JM(e, n, a),
											s = [];
										if (Array.isArray(o))
											for (var u = 0; u < o.length; ++u)
												s.push({ key: r.inputs[u], value: o[u] });
										else s.push({ key: r.inputs[0], value: o });
										var l = new EM(s);
										return _M(r.outputs, l);
									}).forEach(function (e, t) {
										return o[t].push(e);
									});
								},
								u = 0;
							u < i.length;
							++u
						)
							s(u);
						return WF(
							o.map(function (e) {
								return IS(e, 0);
							})
						);
					})
				);
			}),
			(n.predict = function (e, t) {
				void 0 === t && (t = {});
				var n = rL(e);
				uL(n, this.inputNames, this.feedInputShapes, !1);
				try {
					var r = null == t.batchSize ? 32 : t.batchSize;
					return YM(r), this.predictLoop(n, r);
				} finally {
					aL(n, e);
				}
			}),
			(n.predictOnBatch = function (e) {
				uL(e, this.inputNames, this.feedInputShapes, !0);
				var t = (Array.isArray(e) ? e[0] : e).shape[0];
				return this.predictLoop(e, t);
			}),
			(n.standardizeUserDataXY = function (e, t, n, r) {
				if ((void 0 === n && (n = !0), null == this.optimizer_))
					throw new DF(
						"You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs)."
					);
				for (var a = [], i = 0; i < this.feedOutputShapes.length; ++i) {
					var o = this.feedOutputShapes[i];
					this.feedLossFns[i] === rM ? a.push(o.slice(0, o.length - 1).concat([1])) : a.push(o);
				}
				if (
					((function (e, t, n) {
						var r = YF(
							e.map(function (e) {
								return e.shape[0];
							})
						);
						r.sort();
						var a = YF(
							t.map(function (e) {
								return e.shape[0];
							})
						);
						if ((a.sort(), r.length > 1))
							throw new OF(
								"All input Tensors (x) should have the same number of samples. Got array shapes: " +
									JSON.stringify(
										e.map(function (e) {
											return e.shape;
										})
									)
							);
						if (a.length > 1)
							throw new OF(
								"All target Tensors (y) should have the same number of samples. Got array shapes: " +
									JSON.stringify(
										t.map(function (e) {
											return e.shape;
										})
									)
							);
						if (r.length > 0 && a.length > 0 && !Pg(r, a))
							throw new OF(
								"Input Tensors should have the same number of samples as target Tensors. Found " +
									r[0] +
									" input sample(s) and " +
									a[0] +
									" target sample(s)."
							);
					})(
						(e = sL(e, this.feedInputNames, this.feedInputShapes, !1, "input")),
						(t = sL(t, this.feedOutputNames, a, !1, "target"))
					),
					(function (e, t, n) {
						for (var r = [$O, aM, nM], a = 0; a < e.length; ++a) {
							var i = e[a],
								o = t[a],
								s = n[a];
							if (null != o) {
								if (o === nM && 1 === i.shape[i.shape.length - 1])
									throw new OF(
										"You are passing a target array of shape " +
											i.shape +
											" while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes]."
									);
								if (-1 !== r.indexOf(o))
									for (var u = i.shape.slice(1), l = s.slice(1), c = 0; c < u.length; ++c) {
										var p = u[c],
											h = l[c];
										if (null != h && p !== h)
											throw new OF(
												"A target Tensor with shape " +
													i.shape +
													" was passed for an output of shape " +
													s +
													", while using a loss function that expects targets to have the same shape as the output."
											);
									}
							}
						}
					})(t, this.feedLossFns, this.feedOutputShapes),
					this.stateful && null != r && r > 0 && e[0].shape[0] % r != 0)
				)
					throw new OF(
						"In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " +
							r +
							". Found: " +
							e[0].shape[0] +
							" sample(s)."
					);
				return [e, t];
			}),
			(n.standardizeUserData = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n, r, a, i, o) {
						var s, u, l, c, p, h;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if (
												(void 0 === i && (i = !0),
												(s = this.standardizeUserDataXY(t, n, i, o)),
												(u = s[0]),
												(l = s[1]),
												null == r)
											) {
												e.next = 4;
												break;
											}
											throw new Error("sample weight is not supported yet.");
										case 4:
											if (((c = null), null == a)) {
												e.next = 18;
												break;
											}
											(p = MM(a, this.outputNames)), (c = []), (h = 0);
										case 9:
											if (!(h < p.length)) {
												e.next = 18;
												break;
											}
											return (e.t0 = c), (e.next = 13), LM(l[h], null, p[h]);
										case 13:
											(e.t1 = e.sent), e.t0.push.call(e.t0, e.t1);
										case 15:
											++h, (e.next = 9);
											break;
										case 18:
											return e.abrupt("return", [u, l, c]);
										case 19:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n, r, a, i, o) {
					return e.apply(this, arguments);
				};
			})()),
			(n.testLoop = function (e, t, n, r, a) {
				var i = this;
				return (
					void 0 === r && (r = 0),
					BI(function () {
						var o = i.checkNumSamples(t, n, a, "steps"),
							s = [];
						if (r > 0) throw new MF("Verbose mode is not implemented yet.");
						if (null != a) throw new MF("steps mode in testLoop() is not implemented yet");
						for (var u = QM(o, n), l = AE(_D(0, o)), c = 0; c < u.length; ++c) {
							var p = u[c][0],
								h = u[c][1],
								f = OD(l, p, h - p),
								d = ZM(t, f),
								m = e(d);
							if (0 === c) for (var g = 0; g < m.length; ++g) s.push(iE(0));
							for (var v = 0; v < m.length; ++v) {
								var y = m[v];
								s[v] = jI(s[v], KI(h - p, y));
							}
						}
						for (var b = 0; b < s.length; ++b) s[b] = qI(s[b], o);
						return s;
					})
				);
			}),
			(n.getDedupedMetricsNames = function () {
				for (var e = this.metricsNames, t = [], n = 0; n < e.length; ++n) {
					var r = e[n],
						a = r;
					BF(e, r) > 1 && (a += "_" + BF(e.slice(0, n), r)), t.push(a);
				}
				return t;
			}),
			(n.makeTrainFunction = function () {
				var e = this;
				return function (t) {
					var n = [],
						r = t.slice(0, e.inputs.length),
						a = t.slice(e.inputs.length, e.inputs.length + e.outputs.length),
						i = t.slice(e.inputs.length + e.outputs.length, e.inputs.length + 2 * e.outputs.length),
						o = [],
						s = e.collectedTrainableWeights.map(function (e) {
							return e.read();
						});
					return [
						e.optimizer_.minimize(
							function () {
								for (var t = [], s = 0; s < e.inputs.length; ++s)
									t.push({ key: e.inputs[s], value: r[s] });
								for (
									var u, l = new EM(t), c = _M(e.outputs, l, { training: !0 }), p = 0;
									p < e.lossFunctions.length;
									++p
								) {
									var h = (0, e.lossFunctions[p])(a[p], c[p]);
									null != i[p] && (h = PM(h, i[p]));
									var f = sC(h);
									n.push(f), (u = 0 === p ? h : jI(u, h));
								}
								for (var d = 0; d < e.metricsTensors.length; ++d) {
									var m = void 0;
									if (e.outputs.length > 1 && d < e.outputs.length) m = n[d];
									else {
										var g = e.metricsTensors[d][0],
											v = e.metricsTensors[d][1];
										m = sC(g(a[v], c[v]));
									}
									UI(m), o.push(m);
								}
								return (
									(u = sC(u)),
									e.calculateLosses().forEach(function (e) {
										u = jI(u, e);
									}),
									u
								);
							},
							!0,
							s
						),
					].concat(o);
				};
			}),
			(n.makeTestFunction = function () {
				var e = this;
				this.testFunction = function (t) {
					return BI(function () {
						for (
							var n,
								r = [],
								a = t.slice(0, e.inputs.length),
								i = t.slice(e.inputs.length, e.inputs.length + e.outputs.length),
								o = [],
								s = 0;
							s < e.inputs.length;
							++s
						)
							o.push({ key: e.inputs[s], value: a[s] });
						for (var u = new EM(o), l = _M(e.outputs, u), c = 0; c < e.lossFunctions.length; ++c) {
							var p = e.lossFunctions[c],
								h = sC(p(i[c], l[c]));
							(n = 0 === c ? h : jI(n, h)), r.push(n);
						}
						for (var f = 0; f < e.metricsTensors.length; ++f) {
							var d = e.metricsTensors[f][0],
								m = e.metricsTensors[f][1],
								g = sC(d(i[m], l[m]));
							r.push(g);
						}
						return r;
					});
				};
			}),
			(n.fit = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n, r) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return void 0 === r && (r = {}), e.abrupt("return", tL(this, t, n, r));
										case 2:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n, r) {
					return e.apply(this, arguments);
				};
			})()),
			(n.fitDataset = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return e.abrupt("return", VM(this, t, n));
										case 1:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n) {
					return e.apply(this, arguments);
				};
			})()),
			(n.trainOnBatch = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n) {
						var r, a, i, o, s, u, l, c, p, h;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (e.next = 2), this.standardizeUserData(t, n);
										case 2:
											(r = e.sent),
												(a = r[0]),
												(i = r[1]),
												(o = this.makeTrainFunction()),
												(s = o(a.concat(i))),
												(u = []),
												(l = Ig(s));
										case 9:
											if ((c = l()).done) {
												e.next = 17;
												break;
											}
											return (p = c.value), (e.next = 13), p.data();
										case 13:
											(h = e.sent), u.push(h[0]);
										case 15:
											e.next = 9;
											break;
										case 17:
											return WI(s), aL(r[0], t), aL(r[1], n), e.abrupt("return", WF(u));
										case 21:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n) {
					return e.apply(this, arguments);
				};
			})()),
			(n.getNamedWeights = function (e) {
				for (
					var t = [],
						n = null != e && e.trainableOnly,
						r = n ? this.trainableWeights : this.weights,
						a = this.getWeights(n),
						i = 0;
					i < r.length;
					++i
				)
					(n && !r[i].trainable) || t.push({ name: r[i].originalName, tensor: a[i] });
				return t;
			}),
			(n.dispose = function () {
				var t = e.prototype.dispose.call(this);
				if (0 === t.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
					var n = PI().numTensors;
					this.optimizer_.dispose(), (t.numDisposedVariables += n - PI().numTensors);
				}
				return t;
			}),
			(n.getLossIdentifiers = function () {
				var e;
				if ("string" == typeof this.loss) e = VF(this.loss);
				else if (Array.isArray(this.loss)) {
					for (var t, n = Ig(this.loss); !(t = n()).done; )
						if ("string" != typeof t.value)
							throw new Error("Serialization of non-string loss is not supported.");
					e = this.loss.map(function (e) {
						return VF(e);
					});
				} else {
					var r = Object.keys(this.loss);
					e = {};
					for (var a = this.loss, i = 0, o = r; i < o.length; i++) {
						var s = o[i];
						if ("string" != typeof a[s])
							throw new Error("Serialization of non-string loss is not supported.");
						e[s] = VF(a[s]);
					}
				}
				return e;
			}),
			(n.getMetricIdentifiers = function () {
				if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [VF(yM(this.metrics))];
				if (Array.isArray(this.metrics))
					return this.metrics.map(function (e) {
						return VF(yM(e));
					});
				var e = {};
				for (var t in this.metrics) e[t] = VF(yM(this.metrics[t]));
				return e;
			}),
			(n.getTrainingConfig = function () {
				return {
					loss: this.getLossIdentifiers(),
					metrics: this.getMetricIdentifiers(),
					optimizer_config: { class_name: this.optimizer.getClassName(), config: this.optimizer.getConfig() },
				};
			}),
			(n.loadTrainingConfig = function (e) {
				if (null != e.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
				if (null != e.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
				if (null != e.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
				var t,
					n,
					r = ZO(SM(e.optimizer_config));
				if ("string" == typeof e.loss) t = GF(e.loss);
				else if (Array.isArray(e.loss))
					t = e.loss.map(function (e) {
						return GF(e);
					});
				else if (null != e.loss) for (var a in ((t = {}), e.loss)) t[a] = GF(e.loss[a]);
				if (Array.isArray(e.metrics))
					n = e.metrics.map(function (e) {
						return GF(e);
					});
				else if (null != e.metrics) for (var i in ((n = {}), e.metrics)) n[i] = GF(e.metrics[i]);
				this.compile({ loss: t, metrics: n, optimizer: r });
			}),
			(n.save = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n) {
						var r, a, i, o, s, u, l, c, p;
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if ("string" != typeof t) {
												e.next = 9;
												break;
											}
											if (0 !== (r = Bk(t)).length) {
												e.next = 6;
												break;
											}
											throw new OF("Cannot find any save handlers for URL '" + t + "'");
										case 6:
											if (!(r.length > 1)) {
												e.next = 8;
												break;
											}
											throw new OF(
												"Found more than one (" +
													r.length +
													") save handlers for URL '" +
													t +
													"'"
											);
										case 8:
											t = r[0];
										case 9:
											if (null != t.save) {
												e.next = 11;
												break;
											}
											throw new OF(
												"LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined."
											);
										case 11:
											return (e.next = 13), Nk(this.getNamedWeights(n));
										case 13:
											if (
												((a = e.sent),
												(i = this.toJSON(null, !1)),
												(o = {
													modelTopology: i,
													format: "layers-model",
													generatedBy: "TensorFlow.js tfjs-layers v3.15.0",
													convertedBy: null,
												}),
												null == n || !n.includeOptimizer || null == this.optimizer)
											) {
												e.next = 34;
												break;
											}
											return (
												(o.trainingConfig = this.getTrainingConfig()),
												(u = "optimizer"),
												(e.t0 = GN),
												(e.next = 25),
												this.optimizer.getWeights()
											);
										case 25:
											return (
												(e.t1 = e.sent),
												(e.t2 = u),
												(e.next = 29),
												e.t0.encodeWeights.call(e.t0, e.t1, e.t2)
											);
										case 29:
											(l = e.sent),
												(c = l.data),
												(p = l.specs),
												(s = a.specs).push.apply(s, p),
												(a.data = _k([a.data, c]));
										case 34:
											return (
												null != this.userDefinedMetadata &&
													(bM(this.userDefinedMetadata, this.name, !0),
													(o.userDefinedMetadata = this.userDefinedMetadata)),
												(o.weightData = a.data),
												(o.weightSpecs = a.specs),
												e.abrupt("return", t.save(o))
											);
										case 38:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n) {
					return e.apply(this, arguments);
				};
			})()),
			(n.setUserDefinedMetadata = function (e) {
				bM(e, this.name), (this.userDefinedMetadata = e);
			}),
			(n.getUserDefinedMetadata = function () {
				return this.userDefinedMetadata;
			}),
			mg(t, [
				{
					key: "stopTraining",
					get: function () {
						return this.stopTraining_;
					},
					set: function (e) {
						this.stopTraining_ = e;
					},
				},
				{
					key: "optimizer",
					get: function () {
						return this.optimizer_;
					},
					set: function (e) {
						this.optimizer_ !== e && ((this.optimizer_ = e), (this.isOptimizerOwned = !1));
					},
				},
			]),
			t
		);
	})(
		(function (e) {
			function t(n) {
				var r;
				if ((((r = e.call(this, {}) || this).containerNodes = new Set()), (r.name = n.name), null == r.name)) {
					var a = r.getClassName().toLowerCase();
					r.name = xO(a);
				}
				if (
					((r.supportsMasking = !1),
					(r.trainable_ = !0),
					Array.isArray(n.inputs) ? (r.inputs = n.inputs.slice()) : (r.inputs = [n.inputs]),
					Array.isArray(n.outputs) ? (r.outputs = n.outputs.slice()) : (r.outputs = [n.outputs]),
					YF(r.inputs).length !== r.inputs.length)
				)
					throw new OF(
						"The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " +
							r.inputs.map(function (e) {
								return e.name;
							})
					);
				YF(r.outputs).length !== r.outputs.length &&
					console.warn(
						"The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " +
							r.outputs.map(function (e) {
								return e.name;
							})
					),
					(r.inputLayers = []),
					(r.inputLayersNodeIndices = []),
					(r.inputLayersTensorIndices = []),
					(r.outputLayers = []),
					(r.outputLayersNodeIndices = []),
					(r.outputLayersTensorIndices = []),
					(r.layers = []),
					(r.internalContainerRefs = []);
				for (var i, o = Ig(r.outputs); !(i = o()).done; ) {
					var s = i.value,
						u = s.sourceLayer,
						l = s.nodeIndex,
						c = s.tensorIndex;
					r.outputLayers.push(u), r.outputLayersNodeIndices.push(l), r.outputLayersTensorIndices.push(c);
				}
				for (var p, h = Ig(r.inputs); !(p = h()).done; ) {
					var f = p.value,
						d = f.sourceLayer,
						m = f.nodeIndex,
						g = f.tensorIndex;
					PF(0 === m, "input layer has >1 nodes"),
						PF(0 === g, "input layer has >1 tensors"),
						r.inputLayers.push(d),
						r.inputLayersNodeIndices.push(m),
						r.inputLayersTensorIndices.push(g);
				}
				(r.inputNames = []),
					(r.outputNames = []),
					(r.feedInputShapes = []),
					(r.feedInputNames = []),
					(r.feedOutputNames = []);
				for (var v = 0; v < r.inputLayers.length; v++) {
					var y = r.inputLayers[v];
					if (!(y instanceof PO))
						throw new TypeError(
							"Input layers to a LayersModel must be InputLayer objects. Received inputs: " +
								n.inputs +
								". Input " +
								v +
								" (0-based) originates from layer type " +
								y.getClassName() +
								"."
						);
					r.inputNames.push(y.name), r.feedInputShapes.push(y.batchInputShape), r.feedInputNames.push(y.name);
				}
				for (var b, x = Ig(r.outputLayers); !(b = x()).done; ) {
					var w = b.value;
					r.outputNames.push(w.name);
				}
				(r.internalInputShapes = r.inputs.map(function (e) {
					return e.shape;
				})),
					(r.internalOutputShapes = r.outputs.map(function (e) {
						return e.shape;
					}));
				for (
					var k,
						N = {},
						I = {},
						S = {},
						T = {},
						C = {},
						E = [],
						R = function e(n, a, i, o, s, u) {
							(null != o && null != s && null != u) ||
								((o = n.sourceLayer), (s = n.nodeIndex), (u = n.tensorIndex));
							var l = o.inboundNodes[s];
							if (-1 !== i.indexOf(l))
								throw new DF("The tensor " + n.name + ' at layer "' + o.name + '" is part of a cycle.');
							if (-1 === a.indexOf(l)) {
								r.containerNodes.add(t.nodeKey(o, s)),
									(o.id in C) || (C[o.id] = Object.keys(C).length),
									-1 === i.indexOf(l) && i.push(l);
								for (var c = l.inboundLayers.length, p = 0; p < c; p++)
									e(
										l.inputTensors[p],
										a,
										i,
										l.inboundLayers[p],
										l.nodeIndices[p],
										l.tensorIndices[p]
									);
								for (a.push(l); i.indexOf(l) >= 0; ) i.splice(i.indexOf(l), 1);
								E.push(l);
							}
						},
						A = [],
						_ = [],
						F = Ig(r.outputs);
					!(k = F()).done;

				)
					R(k.value, A, _);
				for (var D, O = Ig(E.slice().reverse()); !(D = O()).done; ) {
					var M = D.value;
					(I[M.id] = M), M.id in N || (N[M.id] = 0);
					var L = N[M.id],
						z = null == S[M.outboundLayer.id] ? 0 : S[M.outboundLayer.id];
					(L = Math.max(L, z)),
						(S[M.outboundLayer.id] = L),
						(T[M.outboundLayer.id] = M.outboundLayer),
						(N[M.id] = L);
					for (var P = 0; P < M.inboundLayers.length; P++) {
						var B = M.inboundLayers[P],
							W = M.nodeIndices[P],
							U = B.inboundNodes[W],
							V = null == N[U.id] ? 0 : N[U.id];
						(N[U.id] = Math.max(L + 1, V)), (I[U.id] = U);
					}
				}
				var G = {};
				for (var j in N) {
					var H = N[j];
					H in G || (G[H] = []), G[H].push(I[j]);
				}
				var q = {};
				for (var K in S) {
					var X = S[K];
					X in q || (q[X] = []), q[X].push(T[K]);
				}
				var Y = Object.keys(q)
					.map(function (e) {
						return parseInt(e, 10);
					})
					.sort(XF);
				r.layers = [];
				for (var J, Z = Ig(Y); !(J = Z()).done; ) {
					var Q = q[J.value];
					Q.sort(function (e, t) {
						var n = C[e.id],
							r = C[t.id];
						return n < r ? -1 : n > r ? 1 : 0;
					});
					for (var $, ee = Ig(Q); !($ = ee()).done; ) {
						var te = $.value;
						te instanceof t && r.internalContainerRefs.push(te), r.layers.push(te);
					}
				}
				(r.layersByDepth = q),
					(Y = Object.keys(G)
						.map(function (e) {
							return parseInt(e, 10);
						})
						.sort(XF));
				for (var ne, re = r.inputs.slice(), ae = [], ie = Ig(Y); !(ne = ie()).done; )
					for (var oe, se = Ig(G[ne.value]); !(oe = se()).done; ) {
						var ue = oe.value,
							le = ue.outboundLayer;
						if (null != le) {
							for (var ce, pe = Ig(ue.inputTensors); !(ce = pe()).done; ) {
								var he = ce.value;
								if (-1 === re.indexOf(he))
									throw new DF(
										"Graph disconnected: cannot obtain value for tensor " +
											he +
											' at layer "' +
											le.name +
											'". The following previous layers were accessed without issue: ' +
											ae
									);
							}
							for (var fe, de = Ig(ue.outputTensors); !(fe = de()).done; ) {
								var me = fe.value;
								re.push(me);
							}
							ae.push(le.name);
						}
					}
				r.nodesByDepth = G;
				for (
					var ge,
						ve = r.layers.map(function (e) {
							return e.name;
						}),
						ye = function () {
							var e = ge.value,
								t = ve.filter(function (t) {
									return t === e;
								}).length;
							if (1 !== t)
								throw new DF(
									'The name "' +
										e +
										'" is used ' +
										t +
										" times in the model. All layer names should be unique. Layer names: " +
										JSON.stringify(ve)
								);
						},
						be = Ig(ve);
					!(ge = be()).done;

				)
					ye();
				return (
					(r.outboundNodes = []),
					(r.inboundNodes = []),
					new DO({
						outboundLayer: kg(r),
						inboundLayers: [],
						nodeIndices: [],
						tensorIndices: [],
						inputTensors: r.inputs,
						outputTensors: r.outputs,
						inputMasks: r.inputs.map(function (e) {
							return null;
						}),
						outputMasks: r.outputs.map(function (e) {
							return null;
						}),
						inputShapes: r.inputs.map(function (e) {
							return e.shape;
						}),
						outputShapes: r.outputs.map(function (e) {
							return e.shape;
						}),
					}),
					(r.built = !0),
					(r._refCount = 1),
					r
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.assertNotDisposed = function () {
					if (0 === this._refCount) throw new Error("Container '" + this.name + "' is already disposed.");
				}),
				(n.dispose = function () {
					this.assertNotDisposed();
					var e = { refCountAfterDispose: null, numDisposedVariables: 0 };
					if (0 == --this._refCount) {
						for (var t, n = Ig(this.layers); !(t = n()).done; ) {
							var r = t.value;
							e.numDisposedVariables += r.dispose().numDisposedVariables;
						}
						for (var a, i = Ig(this.internalContainerRefs); !(a = i()).done; ) {
							var o = a.value;
							e.numDisposedVariables += o.dispose().numDisposedVariables;
						}
					}
					return (e.refCountAfterDispose = this._refCount), e;
				}),
				(n.loadWeights = function (e, t) {
					void 0 === t && (t = !0);
					for (var n, r = {}, a = 0, i = Ig(this.layers); !(n = i()).done; )
						for (var o, s = Ig(n.value.weights); !(o = s()).done; ) {
							var u = o.value;
							if (null != r[u.originalName]) throw new OF("Duplicate weight name: " + u.originalName);
							(r[u.originalName] = u), a++;
						}
					var l = [];
					for (var c in e) {
						var p = c;
						if (null == r[c]) {
							var h = c.split("/");
							p = h
								.slice(0, -2)
								.concat([h[h.length - 1]])
								.join("/");
						}
						if (null != r[p]) l.push([r[p], e[c]]);
						else if (t) throw new OF("Provided weight data has no target variable: " + c);
						delete r[p];
					}
					if (t) {
						var f = [];
						for (var d in r) f.push(d);
						if (f.length > 0) throw new OF(f.length + " of " + a + " weights are not set: " + f);
					}
					RO(l);
				}),
				(n.updatedConfig = function () {
					var e = this.getConfig(),
						t = {};
					return (
						(t.className = this.getClassName()),
						(t.config = e),
						(t.kerasVersion = "tfjs-layers 3.15.0"),
						(t.backend = "TensorFlow.js"),
						t
					);
				}),
				(n.toJSON = function (e, t) {
					void 0 === t && (t = !0);
					var n = TM(this.updatedConfig());
					return t ? JSON.stringify(n) : n;
				}),
				(n.call = function (e, t) {
					var n = this;
					return BI(function () {
						e = UF(e);
						for (var r = new EM(), a = 0; a < n.inputs.length; ++a) r.add(n.inputs[a], e[a]);
						return _M(n.outputs, r, t);
					});
				}),
				(n.computeMask = function (e, t) {
					var n = this;
					return BI(function () {
						var r;
						return (e = UF(e)), (r = null == t ? zF(null, e.length) : UF(t)), n.runInternalGraph(e, r)[1];
					});
				}),
				(n.computeOutputShape = function (e) {
					var t = kO(e);
					if (t.length !== this.inputLayers.length)
						throw new OF(
							"Invalid inputShape argument " +
								e +
								": model has " +
								this.inputLayers.length +
								" tensor inputs."
						);
					for (var n = {}, r = 0; r < t.length; r++) {
						var a = this.inputLayers[r],
							i = t[r];
						n[a.name + "_0_0"] = i;
					}
					var o = Object.keys(this.nodesByDepth)
						.map(function (e) {
							return parseInt(e, 10);
						})
						.sort(XF);
					if (o.length > 1)
						for (var s, u = Ig(o); !(s = u()).done; )
							for (var l, c = s.value, p = Ig(this.nodesByDepth[c]); !(l = p()).done; ) {
								var h = l.value,
									f = h.outboundLayer;
								if (
									-1 ===
									this.inputLayers
										.map(function (e) {
											return e.id;
										})
										.indexOf(f.id)
								) {
									for (var d = [], m = 0; m < h.inboundLayers.length; m++) {
										var g = h.inboundLayers[m],
											v = h.nodeIndices[m],
											y = h.tensorIndices[m],
											b = n[g.name + "_" + v + "_" + y];
										d.push(b);
									}
									for (
										var x = kO(f.computeOutputShape(WF(d))), w = f.inboundNodes.indexOf(h), k = 0;
										k < x.length;
										k++
									)
										n[f.name + "_" + w + "_" + k] = x[k];
								}
							}
					for (var N = [], I = [], S = 0; S < this.outputLayers.length; S++) {
						var T = this.outputLayers[S],
							C = this.outputLayersNodeIndices[S],
							E = this.outputLayersTensorIndices[S],
							R = T.name + "_" + C + "_" + E;
						I.push(R);
					}
					for (var A = 0; A < I.length; A++) {
						var _ = I[A];
						PF(_ in n), N.push(n[_]);
					}
					return WF(N);
				}),
				(n.runInternalGraph = function (e, t) {
					null == t && (t = zF(null, e.length));
					for (var n = {}, r = 0; r < this.inputs.length; ++r) {
						var a = this.inputs[r],
							i = e[r],
							o = t[r];
						n[a.id] = [i, o];
					}
					for (
						var s,
							u = Ig(
								Object.keys(this.nodesByDepth)
									.map(function (e) {
										return parseInt(e, 10);
									})
									.sort(XF)
							);
						!(s = u()).done;

					)
						for (var l, c = s.value, p = Ig(this.nodesByDepth[c]); !(l = p()).done; ) {
							for (
								var h,
									f = l.value,
									d = f.outboundLayer,
									m = f.inputTensors,
									g = f.outputTensors,
									v = new Array(),
									y = Ig(m);
								!(h = y()).done;

							) {
								var b = h.value;
								b.id in n && v.push(n[b.id]);
							}
							if (v.length === m.length) {
								var x = {},
									w = void 0,
									k = void 0,
									N = void 0,
									I = void 0;
								if ((null != f.callArgs && (x = f.callArgs), 1 === v.length)) {
									var S = v[0],
										T = S[0],
										C = S[1];
									null == x.mask && (x.mask = C),
										(N = UF(d.call(T, x))),
										(I = UF(d.computeMask(T, C))),
										(w = [T]),
										(k = [C]);
								} else
									(w = v.map(function (e) {
										return e[0];
									})),
										(k = v.map(function (e) {
											return e[1];
										})),
										null == x.mask && (x.mask = k),
										(N = UF(d.call(w, x))),
										(I = UF(d.computeMask(w, k)));
								if (d.activityRegularizer)
									throw new MF(
										"LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet."
									);
								for (var E = 0; E < g.length; ++E) {
									var R = g[E],
										A = N[E],
										_ = I[E];
									n[R.id] = [A, _];
								}
							}
						}
					for (var F, D = [], O = [], M = [], L = Ig(this.outputs); !(F = L()).done; ) {
						var z = F.value;
						PF(z.id in n, "Could not compute output " + z.name + " : " + z.id);
						var P = n[z.id],
							B = P[0],
							W = P[1];
						M.push(B.shape), D.push(B), O.push(W);
					}
					return [D, O, M];
				}),
				(n.buildNodeConversionMap = function (e) {
					for (var n, r, a = {}, i = Ig(this.layers); !(r = i()).done; ) {
						var o = r.value;
						n = o instanceof t ? 1 : 0;
						for (var s = 0; s < o.inboundNodes.length; s++) {
							var u = t.nodeKey(o, s);
							this.containerNodes.has(u) && ((a[u] = n), (n += 1));
						}
					}
					return a;
				}),
				(n.getLayer = function (e, t) {
					if (null != t) {
						if (this.layers.length <= t)
							throw new OF(
								"Was asked to retrieve layer at index " +
									t +
									", but model only has " +
									this.layers.length +
									" layer(s)."
							);
						return this.layers[t];
					}
					if (null == e) throw new OF("Provide either a layer name or layer index");
					for (var n, r = Ig(this.layers); !(n = r()).done; ) {
						var a = n.value;
						if (a.name === e) return a;
					}
					throw new OF("No such layer: " + e);
				}),
				(n.calculateLosses = function () {
					var e = this;
					return BI(function () {
						for (var n, r = [], a = Ig(e.layers); !(n = a()).done; )
							for (var i = n.value, o = 0; o < i.inboundNodes.length; ++o) {
								var s = t.nodeKey(i, o);
								e.containerNodes.has(s) && r.push.apply(r, i.calculateLosses());
							}
						return r;
					});
				}),
				(n.getConfig = function () {
					for (
						var e,
							n = { name: this.name },
							r = this.buildNodeConversionMap(this.layers),
							a = [],
							i = Ig(this.layers);
						!(e = i()).done;

					) {
						for (
							var o = e.value, s = o.getClassName(), u = o.getConfig(), l = [], c = 0;
							c < o.inboundNodes.length;
							c++
						) {
							var p = o.inboundNodes[c],
								h = t.nodeKey(o, c),
								f = {};
							if (this.containerNodes.has(h)) {
								if (p.callArgs)
									try {
										JSON.stringify(p.callArgs), (f = p.callArgs);
									} catch (e) {
										console.warn(
											"Layer " +
												o.name +
												" was passed non-serializable keyword arguments: " +
												p.callArgs +
												". They will not be included in the serialized model (and thus will be missing at deserialization time)."
										),
											(f = {});
									}
								if (p.inboundLayers.length > 0) {
									for (var d = [], m = 0; m < p.inboundLayers.length; m++) {
										var g = p.inboundLayers[m],
											v = p.nodeIndices[m],
											y = p.tensorIndices[m],
											b = r[t.nodeKey(g, v)];
										null == b && (b = 0), d.push([g.name, b, y, f]);
									}
									l.push(d);
								}
							}
						}
						var x = {};
						(x.name = o.name), (x.className = s), (x.config = u), (x.inboundNodes = l), a.push(x);
					}
					n.layers = a;
					for (var w = [], k = 0; k < this.inputLayers.length; k++) {
						var N = this.inputLayers[k],
							I = this.inputLayersNodeIndices[k],
							S = t.nodeKey(N, I);
						if (this.containerNodes.has(S)) {
							var T = r[S];
							null == T && (T = 0);
							var C = this.inputLayersTensorIndices[k];
							w.push([N.name, T, C]);
						}
					}
					n.inputLayers = w;
					for (var E = [], R = 0; R < this.outputLayers.length; R++) {
						var A = this.outputLayers[R],
							_ = this.outputLayersNodeIndices[R],
							F = t.nodeKey(A, _);
						if (this.containerNodes.has(F)) {
							var D = r[F];
							null == D && (D = 0);
							var O = this.outputLayersTensorIndices[R];
							E.push([A.name, D, O]);
						}
					}
					return (n.outputLayers = E), n;
				}),
				(t.fromConfig = function (e, t, n, r) {
					void 0 === n && (n = {}), void 0 === r && (r = !1);
					var a = {},
						i = {};
					function o(e, t) {
						e.name in i ? i[e.name].push(t) : (i[e.name] = [t]);
					}
					function s(e, t) {
						for (var n, r, i = [], s = Ig(t); !(r = s()).done; ) {
							var u = r.value,
								l = u[0],
								c = u[1],
								p = u[2];
							if (((n = null == u[3] ? {} : u[3]), !(l in a))) return void o(e, t);
							var h = a[l];
							if (h.inboundNodes.length <= c) return void o(e, t);
							var f = h.inboundNodes[c];
							i.push(f.outputTensors[p]);
						}
						i.length > 0 && e.apply(WF(i), n);
					}
					function u(e) {
						var n = e.name,
							i = ZO(e, null != t.customObjects ? t.customObjects : {});
						i.setFastWeightInitDuringBuild(r),
							(a[n] = i),
							e.inboundNodes.forEach(function (e) {
								if (!(e instanceof Array))
									throw new OF("Corrupted configuration, expected array for nodeData: " + e);
								o(i, e);
							});
					}
					for (var l, c = t.name, p = t.layers, h = Ig(p); !(l = h()).done; ) u(l.value);
					for (; !JF(i); )
						for (var f, d = Ig(p); !(f = d()).done; ) {
							var m = f.value,
								g = a[m.name];
							if (g.name in i) {
								var v = i[g.name];
								delete i[g.name];
								for (var y, b = Ig(v); !(y = b()).done; ) s(g, y.value);
							}
						}
					for (var x, w = [], k = [], N = Ig(t.inputLayers); !(x = N()).done; ) {
						var I = x.value,
							S = I[0],
							T = I[1],
							C = I[2];
						PF(S in a);
						var E = a[S].inboundNodes[T].outputTensors;
						w.push(E[C]);
					}
					for (var R, A = Ig(t.outputLayers); !(R = A()).done; ) {
						var _ = R.value,
							F = _[0],
							D = _[1],
							O = _[2];
						PF(F in a);
						var M = a[F].inboundNodes[D].outputTensors;
						k.push(M[O]);
					}
					return new e({ inputs: w, outputs: k, name: c });
				}),
				(n.resetStates = function () {
					var e = this;
					BI(function () {
						e.layers.forEach(function (e) {
							e.stateful && e.resetStates();
						});
					});
				}),
				mg(t, [
					{
						key: "trainable",
						get: function () {
							return this.trainable_;
						},
						set: function (e) {
							this.layers.forEach(function (t) {
								t._trainableWeights.forEach(function (t) {
									return (t.trainable = e);
								});
							}),
								(this.trainable_ = e);
						},
					},
					{
						key: "trainableWeights",
						get: function () {
							if (this._trainableWeights.length > 0)
								throw new OF(
									"Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array."
								);
							if (!this.trainable) return [];
							for (var e, t = [], n = Ig(this.layers); !(e = n()).done; ) {
								var r = e.value;
								t = t.concat(r.trainableWeights);
							}
							return t;
						},
					},
					{
						key: "nonTrainableWeights",
						get: function () {
							for (var e, t = [], n = Ig(this.layers); !(e = n()).done; ) {
								var r = e.value;
								t.push.apply(t, r.nonTrainableWeights);
							}
							if (!this.trainable) {
								for (var a, i = [], o = Ig(this.layers); !(a = o()).done; ) {
									var s = a.value;
									i.push.apply(i, s.trainableWeights);
								}
								return i.concat(t);
							}
							return t;
						},
					},
					{
						key: "weights",
						get: function () {
							return this.trainableWeights.concat(this.nonTrainableWeights);
						},
					},
					{
						key: "stateful",
						get: function () {
							if (this._stateful)
								throw new OF(
									"Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false."
								);
							for (var e, t = Ig(this.layers); !(e = t()).done; ) if (e.value.stateful) return !0;
							return !1;
						},
					},
				]),
				t
			);
		})(MO)
	);
	(lL.className = "Model"), AI(lL);
	var cL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return gg(t, e), t;
	})(lL);
	function pL() {
		return (pL = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r, a, i, o, s, u, l, c;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if (
									("modelTopology" in t || (t = { modelTopology: t }),
									null != (r = (t = t).modelTopology).model_config && (r = r.model_config),
									(a = SM(r)),
									(i = ZO(a, n)),
									null == t.weightsManifest)
								) {
									e.next = 14;
									break;
								}
								return (
									(e.next = 9),
									FN(
										t.weightsManifest,
										t.pathPrefix,
										i.weights.map(function (e) {
											return e.originalName;
										})
									)
								);
							case 9:
								for (o = e.sent, s = {}, u = Ig(i.weights); !(l = u()).done; )
									(c = l.value), (s[c.originalName] = o[c.originalName]);
								i.loadWeights(s), WI(o);
							case 14:
								return e.abrupt("return", i);
							case 15:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function hL() {
		return (hL = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if ((null == n && (n = {}), "string" != typeof t)) {
									e.next = 10;
									break;
								}
								if (0 !== (r = Wk(t, n)).length) {
									e.next = 7;
									break;
								}
								r.push(WN(t, n)), (e.next = 9);
								break;
							case 7:
								if (!(r.length > 1)) {
									e.next = 9;
									break;
								}
								throw new OF(
									"Found more than one (" + r.length + ") load handlers for URL '" + t + "'"
								);
							case 9:
								t = r[0];
							case 10:
								return e.abrupt("return", fL(t, void 0, n));
							case 11:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function fL(e, t, n) {
		return dL.apply(this, arguments);
	}
	function dL() {
		return (dL = fg(
			regeneratorRuntime.mark(function e(t, n, r) {
				var a, i, o, s, u, l, c, p, h;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if ((null == r && (r = {}), null != t.load)) {
									e.next = 3;
									break;
								}
								throw new OF(
									"Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented."
								);
							case 3:
								return (e.next = 5), t.load();
							case 5:
								if (
									((a = e.sent),
									null != (i = a.modelTopology).model_config && (i = i.model_config),
									(o = null == r.strict || r.strict),
									(s = null != a.weightData && null != a.weightSpecs && o),
									(u = ZO(SM(i), n, s)),
									null != (l = a.trainingConfig) && u.loadTrainingConfig(l),
									null != a.userDefinedMetadata && u.setUserDefinedMetadata(a.userDefinedMetadata),
									null == a.weightData)
								) {
									e.next = 24;
									break;
								}
								if (null != a.weightSpecs) {
									e.next = 17;
									break;
								}
								throw new OF(
									"LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed."
								);
							case 17:
								if (
									((c = mL(a.weightData, a.weightSpecs)),
									(p = c.modelWeights),
									(h = c.optimizerWeights),
									u.loadWeights(p, o),
									!(null != u.optimizer && h.length > 0))
								) {
									e.next = 22;
									break;
								}
								return (e.next = 22), u.optimizer.setWeights(h);
							case 22:
								WI(p),
									WI(
										h.map(function (e) {
											return e.tensor;
										})
									);
							case 24:
								return e.abrupt("return", u);
							case 25:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function mL(e, t) {
		var n = Sk(e, t),
			r = {},
			a = [];
		return (
			t.forEach(function (e) {
				"optimizer" === e.group ? a.push({ name: e.name, tensor: n[e.name] }) : (r[e.name] = n[e.name]);
			}),
			{ modelWeights: r, optimizerWeights: a }
		);
	}
	(cL.className = "Functional"), AI(cL);
	var gL = (function (e) {
		function t(t) {
			var n;
			if (
				((t = t || {}),
				((n = e.call(this, { inputs: [], outputs: [] }) || this).trainable = !0),
				(n.built = !1),
				(n.name = null != t.name ? t.name : xO("sequential_")),
				null != t.layers)
			)
				for (var r, a = Ig(t.layers); !(r = a()).done; ) {
					var i = r.value;
					n.add(i);
				}
			return n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.checkShape = function (e) {
				if (
					e.inboundNodes[0].outputTensors[0].shape.some(function (e) {
						return e < 0;
					})
				)
					throw new OF(
						"Negative dimension size caused by adding layer " +
							e.name +
							" with input shape [" +
							e.inboundNodes[0].inputTensors[0].shape +
							"]"
					);
			}),
			(n.add = function (e) {
				var n,
					r = e instanceof t || e instanceof lL;
				if (r) {
					if (1 !== (n = e).outputs.length)
						throw new OF(
							"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API."
						);
					if (1 !== n.inputs.length)
						throw new OF(
							"All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API."
						);
				}
				if (0 === this.outputs.length) {
					if (0 === e.inboundNodes.length) {
						if (null == e.batchInputShape)
							throw new OF(
								"The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument."
							);
						var a = BO({ batchShape: e.batchInputShape, dtype: e.dtype, name: e.name + "_input" });
						e.apply(a);
					}
					if (r) (this.outputs = n.outputs), (this.inputs = n.inputs);
					else {
						if (1 !== e.inboundNodes.length)
							throw new OF(
								"A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer " +
									e.name +
									" which has " +
									e.inboundNodes.length +
									" pre-existing inbound connections."
							);
						if (1 !== e.inboundNodes[0].outputTensors.length)
							throw new OF(
								"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API."
							);
						this.checkShape(e),
							(this.outputs = [e.inboundNodes[0].outputTensors[0]]),
							(this.inputs = LO(this.outputs[0]));
					}
					(this.inboundNodes = []),
						new DO({
							outboundLayer: this,
							inboundLayers: [],
							nodeIndices: [],
							tensorIndices: [],
							inputTensors: this.inputs,
							outputTensors: this.outputs,
							inputMasks: zF(null, this.inputs.length),
							outputMasks: [null],
							inputShapes: this.inputs.map(function (e) {
								return e.shape;
							}),
							outputShapes: this.outputs[0].shape,
						});
				} else {
					var i = e.apply(this.outputs[0]);
					if (Array.isArray(i))
						throw new TypeError(
							"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API."
						);
					this.checkShape(e),
						(this.outputs = [i]),
						(this.inboundNodes[0].outputTensors = this.outputs),
						(this.inboundNodes[0].outputShapes = [this.outputs[0].shape]);
				}
				this.layers.push(e), (this.built = !1);
			}),
			(n.pop = function () {
				if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
				if ((this.layers.pop(), 0 === this.layers.length))
					(this.outputs = []), (this.inboundNodes = []), (this.outboundNodes = []);
				else {
					var e = this.layers.length - 1;
					(this.layers[e].outboundNodes = []),
						(this.outputs = [this.layers[e].output]),
						(this.inboundNodes[0].outputTensors = this.outputs),
						(this.inboundNodes[0].outputShapes = [this.outputs[0].shape]);
				}
			}),
			(n.call = function (e, t) {
				return null == this.model && this.build(), this.model.call(e, t);
			}),
			(n.build = function (e) {
				if ((IO(e), 0 === this.inputs.length || 0 === this.outputs.length))
					throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
				(this.model = new lL({ inputs: this.inputs, outputs: this.outputs[0], name: this.name + "_model" })),
					(this.model.trainable = this.trainable),
					(this.supportsMasking = this.model.supportsMasking),
					(this.inputLayers = this.model.inputLayers),
					(this.inputLayersNodeIndices = this.model.inputLayersNodeIndices),
					(this.inputLayersTensorIndices = this.model.inputLayersTensorIndices),
					(this.outputLayers = this.model.outputLayers),
					(this.outputLayersNodeIndices = this.model.outputLayersNodeIndices),
					(this.outputLayersTensorIndices = this.model.outputLayersTensorIndices),
					(this.nodesByDepth = this.model.nodesByDepth),
					(this.containerNodes = this.model.containerNodes),
					(this.outputNames = this.model.outputNames),
					(this.inputNames = this.model.inputNames),
					(this.built = !0);
			}),
			(n.countParams = function () {
				return this.built || this.build(), e.prototype.countParams.call(this);
			}),
			(n.summary = function (t, n, r) {
				void 0 === r && (r = console.log), this.built || this.build(), e.prototype.summary.call(this, t, n, r);
			}),
			(n.setWeights = function (e) {
				null == this.model && this.build(), this.model.setWeights(e);
			}),
			(n.evaluate = function (e, t, n) {
				if ((void 0 === n && (n = {}), !this.built))
					throw new DF("The model needs to be compiled before being used.");
				return this.model.evaluate(e, t, n);
			}),
			(n.evaluateDataset = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if (this.built) {
												e.next = 2;
												break;
											}
											throw new DF("The model needs to be compiled before being used.");
										case 2:
											return e.abrupt("return", this.model.evaluateDataset(t, n));
										case 3:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n) {
					return e.apply(this, arguments);
				};
			})()),
			(n.predict = function (e, t) {
				return void 0 === t && (t = {}), null == this.model && this.build(), this.model.predict(e, t);
			}),
			(n.predictOnBatch = function (e) {
				return null == this.model && this.build(), this.model.predictOnBatch(e);
			}),
			(n.compile = function (e) {
				this.build(),
					this.model.compile(e),
					(this.optimizer_ = this.model.optimizer),
					(this.isOptimizerOwned = this.model.isOptimizerOwned),
					(this.loss = this.model.loss),
					(this.metrics = this.model.metrics),
					(this.metricsTensors = this.model.metricsTensors),
					(this.metricsNames = this.model.metricsNames);
			}),
			(n.fit = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n, r) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if ((void 0 === r && (r = {}), this.built)) {
												e.next = 3;
												break;
											}
											throw new DF("The model needs to be compiled before being used.");
										case 3:
											return e.abrupt("return", this.model.fit(t, n, r));
										case 4:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n, r) {
					return e.apply(this, arguments);
				};
			})()),
			(n.fitDataset = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if (this.built) {
												e.next = 2;
												break;
											}
											throw new DF("The model needs to be compiled before being used.");
										case 2:
											return e.abrupt("return", this.model.fitDataset(t, n));
										case 3:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n) {
					return e.apply(this, arguments);
				};
			})()),
			(n.trainOnBatch = (function () {
				var e = fg(
					regeneratorRuntime.mark(function e(t, n) {
						return regeneratorRuntime.wrap(
							function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return e.abrupt("return", this.model.trainOnBatch(t, n));
										case 1:
										case "end":
											return e.stop();
									}
							},
							e,
							this
						);
					})
				);
				return function (t, n) {
					return e.apply(this, arguments);
				};
			})()),
			(t.fromConfig = function (e, n, r, a) {
				var i;
				void 0 === r && (r = {}), void 0 === a && (a = !1);
				var o = {};
				if (n instanceof Array) {
					if (null == n[0].className || "Merge" === n[0].className)
						throw new OF("Legacy serialization format not supported yet.");
					i = n;
				} else
					Dg(null != n.layers, function () {
						return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.";
					}),
						(i = n.layers),
						delete n.layers,
						(o = n);
				var s = new e(o);
				if (!(s instanceof t)) throw new MF("Sequential.fromConfig called on non-Sequential input: " + s);
				for (var u, l = Ig(i); !(u = l()).done; ) {
					var c = ZO(u.value, void 0, a);
					a && c.setFastWeightInitDuringBuild(!0), s.add(c);
				}
				return s;
			}),
			(n.getConfig = function () {
				for (var e, t = [], n = Ig(this.layers); !(e = n()).done; ) {
					var r = e.value,
						a = {};
					(a.className = r.getClassName()), (a.config = r.getConfig()), t.push(a);
				}
				return { name: this.name, layers: t };
			}),
			mg(t, [
				{
					key: "optimizer",
					get: function () {
						return null == this.model ? void 0 : this.model.optimizer;
					},
					set: function (e) {
						this.model.optimizer = e;
					},
				},
				{
					key: "stopTraining",
					get: function () {
						if (null == this.model)
							throw new OF(
								"Cannot get the stopTraining property of a sequential model before it is compiled."
							);
						return this.model.stopTraining;
					},
					set: function (e) {
						if (null == this.model)
							throw new OF(
								"Cannot set the stopTraining property of a sequential model before it is compiled."
							);
						this.model.stopTraining = e;
					},
				},
			]),
			t
		);
	})(lL);
	function vL(e) {
		return BO(e);
	}
	(gL.className = "Sequential"), AI(gL);
	var yL = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			return (
				gg(t, e),
				(t.prototype.getConfig = function () {
					return {};
				}),
				t
			);
		})(EI),
		bL = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			return (
				gg(t, e),
				(t.prototype.apply = function (e, t) {
					return (
						void 0 === t && (t = 1),
						(function (e, t) {
							if ((void 0 === t && (t = 1), 1 !== t))
								throw new MF(
									"Support for alpha values other than 1 (" + t + ") is not implemented yet."
								);
							return pT(e);
						})(e, t)
					);
				}),
				t
			);
		})(yL);
	(bL.className = "elu"), AI(bL);
	var xL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return oE(e);
			}),
			t
		);
	})(yL);
	(xL.className = "selu"), AI(xL);
	var wL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return JC(e);
			}),
			t
		);
	})(yL);
	(wL.className = "relu"), AI(wL);
	var kL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return BI(function () {
					return hC(6, JC(e));
				});
			}),
			t
		);
	})(yL);
	(kL.className = "relu6"), AI(kL);
	var NL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return e;
			}),
			t
		);
	})(yL);
	(NL.className = "linear"), AI(NL);
	var IL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return SS(e);
			}),
			t
		);
	})(yL);
	(IL.className = "sigmoid"), AI(IL);
	var SL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return (function (e) {
					return BI(function () {
						var t = jI(0.5, KI(0.2, e));
						return PS(t, 0, 1);
					});
				})(e);
			}),
			t
		);
	})(yL);
	(SL.className = "hardSigmoid"), AI(SL);
	var TL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return PT(e);
			}),
			t
		);
	})(yL);
	(TL.className = "softplus"), AI(TL);
	var CL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return (function (e) {
					return BI(function () {
						return qI(e, jI(XI(e), 1));
					});
				})(e);
			}),
			t
		);
	})(yL);
	(CL.className = "softsign"), AI(CL);
	var EL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return CS(e);
			}),
			t
		);
	})(yL);
	(EL.className = "tanh"), AI(EL);
	var RL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e, t) {
				return void 0 === t && (t = -1), vE(e, t);
			}),
			t
		);
	})(yL);
	(RL.className = "softmax"), AI(RL);
	var AL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e, t) {
				return void 0 === t && (t = -1), GT(e, t);
			}),
			t
		);
	})(yL);
	(AL.className = "logSoftmax"), AI(AL);
	var _L = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e, t) {
				return (
					void 0 === t && (t = 1),
					BI(function () {
						return KI(SS(KI(e, t)), e);
					})
				);
			}),
			t
		);
	})(yL);
	(_L.className = "swish"), AI(_L);
	var FL = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.apply = function (e) {
				return BI(function () {
					return KI(e, CS(PT(e)));
				});
			}),
			t
		);
	})(yL);
	function DL(e) {
		return e.getClassName();
	}
	function OL(e, t) {
		return void 0 === t && (t = {}), KF(e, RI.getMap().classNameMap, t, "activation");
	}
	function ML(e) {
		if (null == e) {
			return OL({ className: "linear", config: {} });
		}
		if ("string" == typeof e) {
			var t = {};
			return (t.className = e), (t.config = {}), OL(t);
		}
		return e instanceof yL ? e : OL(e);
	}
	function LL(e) {
		if (null != e && "object" != typeof e)
			throw new Error(
				"Argument to L1L2 regularizer's constructor is expected to be an object, but received: " + e
			);
	}
	(FL.className = "mish"), AI(FL);
	var zL = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			return gg(t, e), t;
		})(EI),
		PL = (function (e) {
			function t(t) {
				var n;
				return (
					(n = e.call(this) || this),
					LL(t),
					(n.l1 = null == t || null == t.l1 ? 0.01 : t.l1),
					(n.l2 = null == t || null == t.l2 ? 0.01 : t.l2),
					(n.hasL1 = 0 !== n.l1),
					(n.hasL2 = 0 !== n.l2),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.apply = function (e) {
					var t = this;
					return BI(function () {
						var n = uC([1]);
						return (
							t.hasL1 && (n = jI(n, VT(KI(t.l1, XI(e))))),
							t.hasL2 && (n = jI(n, VT(KI(t.l2, GD(e))))),
							wS(n, [])
						);
					});
				}),
				(n.getConfig = function () {
					return { l1: this.l1, l2: this.l2 };
				}),
				(t.fromConfig = function (e, t) {
					return new e({ l1: t.l1, l2: t.l2 });
				}),
				t
			);
		})(zL);
	(PL.className = "L1L2"), AI(PL);
	var BL = { l1l2: "L1L2" };
	function WL(e) {
		return HF(e);
	}
	function UL(e, t) {
		return void 0 === t && (t = {}), KF(e, RI.getMap().classNameMap, t, "regularizer");
	}
	function VL(e) {
		return null == e
			? null
			: "string" == typeof e
			? UL({ className: e in BL ? BL[e] : e, config: {} })
			: e instanceof zL
			? e
			: UL(e);
	}
	var GL = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, null == t ? {} : t) || this).supportsMasking = !0),
				null != t && (n.maxValue = t.maxValue),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.call = function (e, t) {
				e = NO(e);
				var n = JC(e);
				return null != this.maxValue && (n = PS(n, 0, this.maxValue)), n;
			}),
			(n.computeOutputShape = function (e) {
				return e;
			}),
			(n.getConfig = function () {
				var t = { maxValue: this.maxValue },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(GL.className = "ReLU"), AI(GL);
	var jL = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, null == t ? {} : t) || this).DEFAULT_ALPHA = 0.3),
				null == t && (t = {}),
				(n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.call = function (e, t) {
				var n = NO(e);
				return CT(n, this.alpha);
			}),
			(n.computeOutputShape = function (e) {
				return e;
			}),
			(n.getConfig = function () {
				var t = { alpha: this.alpha },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(jL.className = "LeakyReLU"), AI(jL);
	var HL = (function (e) {
		function t(t) {
			var n;
			if (
				(((n = e.call(this, null == t ? {} : t) || this).DEFAULT_ALPHA_INITIALIZER = "zeros"),
				null == t && (t = {}),
				(n.supportsMasking = !0),
				(n.alphaInitializer = mO(t.alphaInitializer || n.DEFAULT_ALPHA_INITIALIZER)),
				(n.alphaRegularizer = VL(t.alphaRegularizer)),
				(n.alphaConstraint = pD(t.alphaConstraint)),
				null == t.sharedAxes)
			)
				n.sharedAxes = null;
			else if (Array.isArray(t.sharedAxes)) n.sharedAxes = t.sharedAxes;
			else {
				if ("number" != typeof t.sharedAxes)
					throw new OF("Expected sharedAxes to be a number or an array of numbers, but got " + t.sharedAxes);
				n.sharedAxes = [t.sharedAxes];
			}
			return n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t = (e = IO(e)).slice(1);
				if (null != this.sharedAxes) for (var n, r = Ig(this.sharedAxes); !(n = r()).done; ) t[n.value - 1] = 1;
				this.alpha = this.addWeight(
					"alpha",
					t,
					"float32",
					this.alphaInitializer,
					this.alphaRegularizer,
					!0,
					this.alphaConstraint
				);
				var a = {};
				if (null != this.sharedAxes) for (var i = 1; i < e.length; ++i) a[i] = e[i];
				(this.inputSpec = [new AO({ ndim: e.length, axes: a })]), (this.built = !0);
			}),
			(n.call = function (e, t) {
				return (e = NO(e)), AC(e, this.alpha.read());
			}),
			(n.getConfig = function () {
				var t = {
						alphaInitializer: dO(this.alphaInitializer),
						alphaRegularizer: WL(this.alphaRegularizer),
						alphaConstraint: lD(this.alphaConstraint),
						sharedAxes: this.sharedAxes,
					},
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(HL.className = "PReLU"), AI(HL);
	var qL = (function (e) {
		function t(t) {
			var n;
			if (
				(((n = e.call(this, null == t ? {} : t) || this).DEFAULT_ALPHA = 1),
				null == t && (t = {}),
				null != t.alpha && t.alpha !== n.DEFAULT_ALPHA)
			)
				throw new MF("Non-default alpha value (" + t.alpha + ") is not supported by the ELU layer yet.");
			return (n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.call = function (e, t) {
				var n = NO(e);
				return pT(n);
			}),
			(n.computeOutputShape = function (e) {
				return e;
			}),
			(n.getConfig = function () {
				var t = { alpha: this.alpha },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(qL.className = "ELU"), AI(qL);
	var KL = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, null == t ? {} : t) || this).DEFAULT_THETA = 1),
				null == t && (t = {}),
				(n.theta = null == t.theta ? n.DEFAULT_THETA : t.theta),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.call = function (e, t) {
				var n = NO(e);
				return KI(n, NN(wT(n, this.theta), "float32"));
			}),
			(n.computeOutputShape = function (e) {
				return e;
			}),
			(n.getConfig = function () {
				var t = { theta: this.theta },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(KL.className = "ThresholdedReLU"), AI(KL);
	var XL = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, null == t ? {} : t) || this).DEFAULT_AXIS = 1),
				null == t && (t = {}),
				(n.softmax = new RL().apply),
				(n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.call = function (e, t) {
				var n = NO(e);
				return this.softmax(n, this.axis);
			}),
			(n.computeOutputShape = function (e) {
				return e;
			}),
			(n.getConfig = function () {
				var t = { axis: this.axis },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	function YL(e, t, n) {
		if ("number" == typeof e) return zF(e, t);
		if (e.length !== t)
			throw new OF(
				"The " +
					n +
					" argument must be an integer or tuple of " +
					t +
					" integers. Received: " +
					e.length +
					" elements."
			);
		for (var r = 0; r < t; ++r) {
			var a = e[r];
			if ((i = a) !== parseInt(i.toString(), 10))
				throw new OF(
					"The " +
						n +
						" argument must be an integer or tuple of " +
						t +
						" integers. Received: " +
						JSON.stringify(e) +
						" including a non-integer number " +
						a
				);
		}
		return e;
		var i;
	}
	function JL(e, t, n, r, a) {
		return (
			void 0 === a && (a = 1),
			null == e ? e : ((i = "same" === n ? e : e - (t + (t - 1) * (a - 1)) + 1), Math.floor((i + r - 1) / r))
		);
		var i;
	}
	function ZL(e, t, n, r) {
		if (null == e) return null;
		if ("valid" === r) e = e * t + AD([n - t, 0]);
		else {
			if ("same" !== r) throw new OF("Unsupport padding mode: " + r + ".");
			e *= t;
		}
		return e;
	}
	function QL(e, t) {
		return BI(function () {
			return bD(t), "channelsFirst" === t ? qN(e, [0, 2, 3, 1]) : e;
		});
	}
	function $L(e, t) {
		return BI(function () {
			return bD(t), "channelsFirst" === t ? qN(e, [0, 2, 3, 4, 1]) : e;
		});
	}
	function ez(e, t, n, r, a, i, o, s) {
		return (
			void 0 === r && (r = [1, 1]),
			void 0 === a && (a = "valid"),
			void 0 === s && (s = null),
			BI(function () {
				if ((null == i && (i = "channelsLast"), bD(i), 3 !== e.rank && 4 !== e.rank))
					throw new OF(
						"conv2dWithBiasActivation expects input to be of rank 3 or 4, but received " + e.rank + "."
					);
				if (3 !== t.rank && 4 !== t.rank)
					throw new OF(
						"conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received " + e.rank + "."
					);
				var u = QL(e, i);
				if ("causal" === a)
					throw new MF("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
				return (
					(u = uR({
						x: u,
						filter: t,
						strides: r,
						pad: "same" === a ? "same" : "valid",
						dilations: o,
						dataFormat: "NHWC",
						bias: n,
						activation: s,
					})),
					"channelsFirst" === i && (u = qN(u, [0, 3, 1, 2])),
					u
				);
			})
		);
	}
	(XL.className = "Softmax"), AI(XL);
	var tz = (function (e) {
			function t(n, r) {
				var a;
				if (
					(((a = e.call(this, r) || this).bias = null),
					(a.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
					(a.DEFAULT_BIAS_INITIALIZER = "zeros"),
					t.verifyArgs(r),
					(a.rank = n),
					$F(a.rank, "rank"),
					1 !== a.rank && 2 !== a.rank && 3 !== a.rank)
				)
					throw new MF(
						"Convolution layer for rank other than 1, 2, or 3 (" + a.rank + ") is not implemented yet."
					);
				if (
					((a.kernelSize = YL(r.kernelSize, n, "kernelSize")),
					(a.strides = YL(null == r.strides ? 1 : r.strides, n, "strides")),
					(a.padding = null == r.padding ? "valid" : r.padding),
					xD(a.padding),
					(a.dataFormat = null == r.dataFormat ? "channelsLast" : r.dataFormat),
					bD(a.dataFormat),
					(a.activation = ML(r.activation)),
					(a.useBias = null == r.useBias || r.useBias),
					(a.biasInitializer = mO(r.biasInitializer || a.DEFAULT_BIAS_INITIALIZER)),
					(a.biasConstraint = pD(r.biasConstraint)),
					(a.biasRegularizer = VL(r.biasRegularizer)),
					(a.activityRegularizer = VL(r.activityRegularizer)),
					(a.dilationRate = YL(null == r.dilationRate ? 1 : r.dilationRate, n, "dilationRate")),
					1 === a.rank && Array.isArray(a.dilationRate) && 1 !== a.dilationRate.length)
				)
					throw new OF(
						"dilationRate must be a number or an array of a single number for 1D convolution, but received " +
							JSON.stringify(a.dilationRate)
					);
				if (2 === a.rank) {
					if ("number" == typeof a.dilationRate) a.dilationRate = [a.dilationRate, a.dilationRate];
					else if (2 !== a.dilationRate.length)
						throw new OF(
							"dilationRate must be a number or array of two numbers for 2D convolution, but received " +
								JSON.stringify(a.dilationRate)
						);
				} else if (3 === a.rank)
					if ("number" == typeof a.dilationRate)
						a.dilationRate = [a.dilationRate, a.dilationRate, a.dilationRate];
					else if (3 !== a.dilationRate.length)
						throw new OF(
							"dilationRate must be a number or array of three numbers for 3D convolution, but received " +
								JSON.stringify(a.dilationRate)
						);
				return a;
			}
			return (
				gg(t, e),
				(t.verifyArgs = function (e) {
					if (
						(PF("kernelSize" in e, "required key 'kernelSize' not in config"),
						"number" != typeof e.kernelSize && !QF(e.kernelSize, "number", 1, 3))
					)
						throw new OF(
							"BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received " +
								JSON.stringify(e.kernelSize) +
								"."
						);
				}),
				(t.prototype.getConfig = function () {
					var t = {
							kernelSize: this.kernelSize,
							strides: this.strides,
							padding: this.padding,
							dataFormat: this.dataFormat,
							dilationRate: this.dilationRate,
							activation: DL(this.activation),
							useBias: this.useBias,
							biasInitializer: dO(this.biasInitializer),
							biasRegularizer: WL(this.biasRegularizer),
							activityRegularizer: WL(this.activityRegularizer),
							biasConstraint: lD(this.biasConstraint),
						},
						n = e.prototype.getConfig.call(this);
					return Object.assign(t, n), t;
				}),
				t
			);
		})(MO),
		nz = (function (e) {
			function t(n, r) {
				var a;
				return (
					((a = e.call(this, n, r) || this).kernel = null),
					t.verifyArgs(r),
					(a.filters = r.filters),
					$F(a.filters, "filters"),
					(a.kernelInitializer = mO(r.kernelInitializer || a.DEFAULT_KERNEL_INITIALIZER)),
					(a.kernelConstraint = pD(r.kernelConstraint)),
					(a.kernelRegularizer = VL(r.kernelRegularizer)),
					a
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.build = function (e) {
					var t;
					e = IO(e);
					var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
					if (null == e[n])
						throw new OF("The channel dimension of the input should be defined. Found " + e[n]);
					var r = e[n],
						a = this.kernelSize.concat([r, this.filters]);
					(this.kernel = this.addWeight(
						"kernel",
						a,
						null,
						this.kernelInitializer,
						this.kernelRegularizer,
						!0,
						this.kernelConstraint
					)),
						this.useBias &&
							(this.bias = this.addWeight(
								"bias",
								[this.filters],
								null,
								this.biasInitializer,
								this.biasRegularizer,
								!0,
								this.biasConstraint
							)),
						(this.inputSpec = [{ ndim: this.rank + 2, axes: ((t = {}), (t[n] = r), t) }]),
						(this.built = !0);
				}),
				(n.call = function (e, t) {
					var n = this;
					return BI(function () {
						var t;
						e = NO(e);
						var r = null == n.bias ? null : n.bias.read(),
							a = tD(n.activation.getClassName());
						if (null != a && 2 === n.rank)
							t = ez(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate, a);
						else {
							if (1 === n.rank)
								t = (function (e, t, n, r, a, i, o) {
									return (
										void 0 === r && (r = 1),
										void 0 === a && (a = "valid"),
										void 0 === o && (o = 1),
										BI(function () {
											if ((null == i && (i = "channelsLast"), bD(i), 3 !== e.shape.length))
												throw new OF(
													"The input of a conv1dWithBias operation should be 3, but is " +
														e.shape.length +
														" instead."
												);
											if (3 !== t.shape.length)
												throw new OF(
													"The kernel for a conv1dWithBias operation should be 3, but is " +
														t.shape.length +
														" instead"
												);
											if (null != n && 1 !== n.shape.length)
												throw new OF(
													"The bias for a conv1dWithBias operation should be 1, but is " +
														t.shape.length +
														" instead"
												);
											if (("channelsFirst" === i && (e = qN(e, [0, 2, 1])), "causal" === a))
												throw new MF(
													"The support for CAUSAL padding mode in conv1dWithBias is not implemented yet."
												);
											var s = jS(e, t, r, "same" === a ? "same" : "valid", "NWC", o);
											return null != n && (s = HD(s, n)), s;
										})
									);
								})(e, n.kernel.read(), r, n.strides[0], n.padding, n.dataFormat, n.dilationRate[0]);
							else if (2 === n.rank)
								t = ez(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
							else {
								if (3 !== n.rank) throw new MF("convolutions greater than 3D are not implemented yet.");
								t = (function (e, t, n, r, a, i, o) {
									return (
										void 0 === r && (r = [1, 1, 1]),
										void 0 === a && (a = "valid"),
										BI(function () {
											if (
												(null == i && (i = "channelsLast"), bD(i), 4 !== e.rank && 5 !== e.rank)
											)
												throw new OF(
													"conv3dWithBias expects input to be of rank 4 or 5, but received " +
														e.rank +
														"."
												);
											if (4 !== t.rank && 5 !== t.rank)
												throw new OF(
													"conv3dWithBias expects kernel to be of rank 4 or 5, but received " +
														e.rank +
														"."
												);
											var s = $L(e, i);
											if ("causal" === a)
												throw new MF(
													"The support for CAUSAL padding mode in conv3dWithBias is not implemented yet."
												);
											return (
												(s = KS(s, t, r, "same" === a ? "same" : "valid", "NDHWC", o)),
												null != n && (s = HD(s, n)),
												"channelsFirst" === i && (s = qN(s, [0, 4, 1, 2, 3])),
												s
											);
										})
									);
								})(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
							}
							null != n.activation && (t = n.activation.apply(t));
						}
						return t;
					});
				}),
				(n.computeOutputShape = function (e) {
					e = IO(e);
					for (
						var t = [],
							n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2),
							r = 0;
						r < n.length;
						++r
					) {
						var a = JL(
							n[r],
							this.kernelSize[r],
							this.padding,
							this.strides[r],
							"number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r]
						);
						t.push(a);
					}
					var i = [e[0]];
					return (
						"channelsLast" === this.dataFormat
							? (i = i.concat(t)).push(this.filters)
							: (i.push(this.filters), (i = i.concat(t))),
						i
					);
				}),
				(n.getConfig = function () {
					var t = {
							filters: this.filters,
							kernelInitializer: dO(this.kernelInitializer),
							kernelRegularizer: WL(this.kernelRegularizer),
							kernelConstraint: lD(this.kernelConstraint),
						},
						n = e.prototype.getConfig.call(this);
					return Object.assign(t, n), t;
				}),
				(t.verifyArgs = function (e) {
					if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1)
						throw new OF(
							"Convolution layer expected config.filters to be a 'number' > 0 but got " +
								JSON.stringify(e.filters)
						);
				}),
				t
			);
		})(tz),
		rz = (function (e) {
			function t(n) {
				var r;
				return (r = e.call(this, 2, n) || this), t.verifyArgs(n), r;
			}
			return (
				gg(t, e),
				(t.prototype.getConfig = function () {
					var t = e.prototype.getConfig.call(this);
					return delete t.rank, t;
				}),
				(t.verifyArgs = function (e) {
					if ("number" != typeof e.kernelSize && !QF(e.kernelSize, "number", 1, 2))
						throw new OF(
							"Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received " +
								JSON.stringify(e.kernelSize) +
								"."
						);
				}),
				t
			);
		})(nz);
	(rz.className = "Conv2D"), AI(rz);
	var az = (function (e) {
		function t(n) {
			var r;
			return (r = e.call(this, 3, n) || this), t.verifyArgs(n), r;
		}
		return (
			gg(t, e),
			(t.prototype.getConfig = function () {
				var t = e.prototype.getConfig.call(this);
				return delete t.rank, t;
			}),
			(t.verifyArgs = function (e) {
				if (
					"number" != typeof e.kernelSize &&
					(!Array.isArray(e.kernelSize) || (1 !== e.kernelSize.length && 3 !== e.kernelSize.length))
				)
					throw new OF(
						"Conv3D expects config.kernelSize to be number or [number, number, number], but received " +
							JSON.stringify(e.kernelSize) +
							"."
					);
			}),
			t
		);
	})(nz);
	(az.className = "Conv3D"), AI(az);
	var iz = (function (e) {
		function t(t) {
			var n;
			if (
				(((n = e.call(this, t) || this).inputSpec = [new AO({ ndim: 4 })]),
				"same" !== n.padding && "valid" !== n.padding)
			)
				throw new OF(
					"Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " +
						n.padding
				);
			return n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t;
				if (4 !== (e = IO(e)).length)
					throw new OF("Input should have rank 4; Received input shape: " + JSON.stringify(e));
				var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
				if (null == e[n]) throw new OF("The channel dimension of the inputs should be defined. Found `None`.");
				var r = e[n],
					a = this.kernelSize.concat([this.filters, r]);
				(this.kernel = this.addWeight(
					"kernel",
					a,
					"float32",
					this.kernelInitializer,
					this.kernelRegularizer,
					!0,
					this.kernelConstraint
				)),
					this.useBias &&
						(this.bias = this.addWeight(
							"bias",
							[this.filters],
							"float32",
							this.biasInitializer,
							this.biasRegularizer,
							!0,
							this.biasConstraint
						)),
					(this.inputSpec = [new AO({ ndim: 4, axes: ((t = {}), (t[n] = r), t) })]),
					(this.built = !0);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					var t = NO(e);
					if (4 !== t.shape.length)
						throw new OF(
							"Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" +
								t.shape.length
						);
					var r,
						a,
						i = t.shape,
						o = i[0];
					"channelsFirst" === n.dataFormat ? ((r = 2), (a = 3)) : ((r = 1), (a = 2));
					var s = i[r],
						u = i[a],
						l = n.kernelSize[0],
						c = n.kernelSize[1],
						p = n.strides[0],
						h = n.strides[1],
						f = [o, ZL(s, p, l, n.padding), ZL(u, h, c, n.padding), n.filters];
					"channelsLast" !== n.dataFormat && (t = qN(t, [0, 2, 3, 1]));
					var d = qS(t, n.kernel.read(), f, n.strides, n.padding);
					return (
						"channelsLast" !== n.dataFormat && (d = qN(d, [0, 3, 1, 2])),
						null != n.bias && (d = HD(d, n.bias.read(), n.dataFormat)),
						null != n.activation && (d = n.activation.apply(d)),
						d
					);
				});
			}),
			(n.computeOutputShape = function (e) {
				var t,
					n,
					r,
					a = (e = IO(e)).slice();
				"channelsFirst" === this.dataFormat ? ((t = 1), (n = 2), (r = 3)) : ((t = 3), (n = 1), (r = 2));
				var i = this.kernelSize[0],
					o = this.kernelSize[1],
					s = this.strides[0],
					u = this.strides[1];
				return (
					(a[t] = this.filters),
					(a[n] = ZL(a[n], s, i, this.padding)),
					(a[r] = ZL(a[r], u, o, this.padding)),
					a
				);
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this);
				return delete t.dilationRate, t;
			}),
			t
		);
	})(rz);
	(iz.className = "Conv2DTranspose"), AI(iz);
	var oz = (function (e) {
		function t(t) {
			var n;
			if (
				(((n = e.call(this, t) || this).inputSpec = [new AO({ ndim: 5 })]),
				"same" !== n.padding && "valid" !== n.padding)
			)
				throw new OF(
					"Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " +
						n.padding
				);
			return n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t;
				if (5 !== (e = IO(e)).length)
					throw new OF("Input should have rank 5; Received input shape: " + JSON.stringify(e));
				var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
				if (null == e[n]) throw new OF("The channel dimension of the inputs should be defined. Found `None`.");
				var r = e[n],
					a = this.kernelSize.concat([this.filters, r]);
				(this.kernel = this.addWeight(
					"kernel",
					a,
					"float32",
					this.kernelInitializer,
					this.kernelRegularizer,
					!0,
					this.kernelConstraint
				)),
					this.useBias &&
						(this.bias = this.addWeight(
							"bias",
							[this.filters],
							"float32",
							this.biasInitializer,
							this.biasRegularizer,
							!0,
							this.biasConstraint
						)),
					(this.inputSpec = [new AO({ ndim: 5, axes: ((t = {}), (t[n] = r), t) })]),
					(this.built = !0);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					var t = NO(e);
					if (5 !== t.shape.length)
						throw new OF(
							"Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" +
								t.shape.length
						);
					var r,
						a,
						i,
						o = t.shape,
						s = o[0];
					"channelsFirst" === n.dataFormat ? ((i = 2), (r = 3), (a = 4)) : ((i = 1), (r = 2), (a = 3));
					var u = o[i],
						l = o[r],
						c = o[a],
						p = n.kernelSize[0],
						h = n.kernelSize[1],
						f = n.kernelSize[2],
						d = n.strides[0],
						m = n.strides[1],
						g = n.strides[2],
						v = [s, ZL(u, d, p, n.padding), ZL(l, m, h, n.padding), ZL(c, g, f, n.padding), n.filters];
					"channelsLast" !== n.dataFormat && (t = qN(t, [0, 2, 3, 4, 1]));
					var y = YS(t, n.kernel.read(), v, n.strides, n.padding);
					return (
						"channelsLast" !== n.dataFormat && (y = qN(y, [0, 4, 1, 2, 3])),
						null !== n.bias && (y = HD(y, n.bias.read(), n.dataFormat)),
						null !== n.activation && (y = n.activation.apply(y)),
						y
					);
				});
			}),
			(n.computeOutputShape = function (e) {
				var t,
					n,
					r,
					a,
					i = (e = IO(e)).slice();
				"channelsFirst" === this.dataFormat
					? ((t = 1), (n = 2), (r = 3), (a = 4))
					: ((t = 4), (n = 1), (r = 2), (a = 3));
				var o = this.kernelSize[0],
					s = this.kernelSize[1],
					u = this.kernelSize[2],
					l = this.strides[0],
					c = this.strides[1],
					p = this.strides[2];
				return (
					(i[t] = this.filters),
					(i[n] = ZL(i[n], l, o, this.padding)),
					(i[r] = ZL(i[r], c, s, this.padding)),
					(i[a] = ZL(i[a], p, u, this.padding)),
					i
				);
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this);
				return delete t.dilationRate, t;
			}),
			t
		);
	})(az);
	(oz.className = "Conv3DTranspose"), AI(oz);
	var sz = (function (e) {
		function t(t, n) {
			var r;
			if (
				(((r = e.call(this, t, n) || this).DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform"),
				(r.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform"),
				(r.depthwiseKernel = null),
				(r.pointwiseKernel = null),
				null == n.filters)
			)
				throw new OF("The `filters` configuration field is required by SeparableConv, but is unspecified.");
			if (null != n.kernelInitializer || null != n.kernelRegularizer || null != n.kernelConstraint)
				throw new OF(
					"Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead."
				);
			if (null != n.padding && "same" !== n.padding && "valid" !== n.padding)
				throw new OF(
					"SeparableConv" +
						r.rank +
						"D supports only padding modes: 'same' and 'valid', but received " +
						JSON.stringify(n.padding)
				);
			return (
				(r.depthMultiplier = null == n.depthMultiplier ? 1 : n.depthMultiplier),
				(r.depthwiseInitializer = mO(n.depthwiseInitializer || r.DEFAULT_DEPTHWISE_INITIALIZER)),
				(r.depthwiseRegularizer = VL(n.depthwiseRegularizer)),
				(r.depthwiseConstraint = pD(n.depthwiseConstraint)),
				(r.pointwiseInitializer = mO(n.depthwiseInitializer || r.DEFAULT_POINTWISE_INITIALIZER)),
				(r.pointwiseRegularizer = VL(n.pointwiseRegularizer)),
				(r.pointwiseConstraint = pD(n.pointwiseConstraint)),
				r
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t;
				if ((e = IO(e)).length < this.rank + 2)
					throw new OF(
						"Inputs to SeparableConv" +
							this.rank +
							"D should have rank " +
							(this.rank + 2) +
							", but received input shape: " +
							JSON.stringify(e)
					);
				var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
				if (null == e[n] || e[n] < 0)
					throw new OF(
						"The channel dimension of the inputs should be defined, but found " + JSON.stringify(e[n])
					);
				for (
					var r = e[n], a = this.kernelSize.concat([r, this.depthMultiplier]), i = [], o = 0;
					o < this.rank;
					++o
				)
					i.push(1);
				i.push(r * this.depthMultiplier, this.filters);
				var s = !0;
				(this.depthwiseKernel = this.addWeight(
					"depthwise_kernel",
					a,
					"float32",
					this.depthwiseInitializer,
					this.depthwiseRegularizer,
					s,
					this.depthwiseConstraint
				)),
					(this.pointwiseKernel = this.addWeight(
						"pointwise_kernel",
						i,
						"float32",
						this.pointwiseInitializer,
						this.pointwiseRegularizer,
						s,
						this.pointwiseConstraint
					)),
					this.useBias
						? (this.bias = this.addWeight(
								"bias",
								[this.filters],
								"float32",
								this.biasInitializer,
								this.biasRegularizer,
								s,
								this.biasConstraint
						  ))
						: (this.bias = null),
					(this.inputSpec = [new AO({ ndim: this.rank + 2, axes: ((t = {}), (t[n] = r), t) })]),
					(this.built = !0);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					var t;
					if (((e = NO(e)), 1 === n.rank)) throw new MF("1D separable convolution is not implemented yet.");
					return (
						2 === n.rank &&
							("channelsFirst" === n.dataFormat && (e = qN(e, [0, 2, 3, 1])),
							(t = sE(
								e,
								n.depthwiseKernel.read(),
								n.pointwiseKernel.read(),
								n.strides,
								n.padding,
								n.dilationRate,
								"NHWC"
							))),
						n.useBias && (t = HD(t, n.bias.read(), n.dataFormat)),
						null != n.activation && (t = n.activation.apply(t)),
						"channelsFirst" === n.dataFormat && (t = qN(t, [0, 3, 1, 2])),
						t
					);
				});
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this);
				return (
					delete t.rank,
					delete t.kernelInitializer,
					delete t.kernelRegularizer,
					delete t.kernelConstraint,
					(t.depthwiseInitializer = dO(this.depthwiseInitializer)),
					(t.pointwiseInitializer = dO(this.pointwiseInitializer)),
					(t.depthwiseRegularizer = WL(this.depthwiseRegularizer)),
					(t.pointwiseRegularizer = WL(this.pointwiseRegularizer)),
					(t.depthwiseConstraint = lD(this.depthwiseConstraint)),
					(t.pointwiseConstraint = lD(this.pointwiseConstraint)),
					t
				);
			}),
			t
		);
	})(nz);
	sz.className = "SeparableConv";
	var uz = (function (e) {
		function t(t) {
			return e.call(this, 2, t) || this;
		}
		return gg(t, e), t;
	})(sz);
	(uz.className = "SeparableConv2D"), AI(uz);
	var lz = (function (e) {
		function t(n) {
			var r;
			return (r = e.call(this, 1, n) || this), t.verifyArgs(n), (r.inputSpec = [{ ndim: 3 }]), r;
		}
		return (
			gg(t, e),
			(t.prototype.getConfig = function () {
				var t = e.prototype.getConfig.call(this);
				return delete t.rank, delete t.dataFormat, t;
			}),
			(t.verifyArgs = function (e) {
				if ("number" != typeof e.kernelSize && !QF(e.kernelSize, "number", 1, 1))
					throw new OF(
						"Conv1D expects config.kernelSize to be number or number[] with length 1, but received " +
							JSON.stringify(e.kernelSize) +
							"."
					);
			}),
			t
		);
	})(nz);
	(lz.className = "Conv1D"), AI(lz);
	var cz = (function (e) {
		function t(t) {
			var n;
			return (
				(n = e.call(this, t) || this),
				"number" == typeof t.cropping
					? (n.cropping = [
							[t.cropping, t.cropping],
							[t.cropping, t.cropping],
					  ])
					: "number" == typeof t.cropping[0]
					? (n.cropping = [
							[t.cropping[0], t.cropping[0]],
							[t.cropping[1], t.cropping[1]],
					  ])
					: (n.cropping = t.cropping),
				(n.dataFormat = void 0 === t.dataFormat ? "channelsLast" : t.dataFormat),
				(n.inputSpec = [{ ndim: 4 }]),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.computeOutputShape = function (e) {
				return "channelsFirst" === this.dataFormat
					? [
							e[0],
							e[1],
							e[2] - this.cropping[0][0] - this.cropping[0][1],
							e[3] - this.cropping[1][0] - this.cropping[1][1],
					  ]
					: [
							e[0],
							e[1] - this.cropping[0][0] - this.cropping[0][1],
							e[2] - this.cropping[1][0] - this.cropping[1][1],
							e[3],
					  ];
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					if (((e = NO(e)), "channelsLast" === n.dataFormat)) {
						var t = LD(e, n.cropping[0][0], e.shape[1] - n.cropping[0][0] - n.cropping[0][1], 2);
						return LD(t, n.cropping[1][0], e.shape[2] - n.cropping[1][1] - n.cropping[1][0], 3);
					}
					var r = LD(e, n.cropping[0][0], e.shape[2] - n.cropping[0][0] - n.cropping[0][1], 3);
					return LD(r, n.cropping[1][0], e.shape[3] - n.cropping[1][1] - n.cropping[1][0], 4);
				});
			}),
			(n.getConfig = function () {
				var t = { cropping: this.cropping, dataFormat: this.dataFormat },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(cz.className = "Cropping2D"), AI(cz);
	var pz = (function (e) {
		function t(t) {
			var n, r;
			return (
				((n = e.call(this, t) || this).DEFAULT_SIZE = [2, 2]),
				(n.inputSpec = [{ ndim: 4 }]),
				(n.size = null == t.size ? n.DEFAULT_SIZE : t.size),
				(n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat),
				bD(n.dataFormat),
				(n.interpolation = null == t.interpolation ? "nearest" : t.interpolation),
				(r = n.interpolation),
				ZF(dD, "InterpolationFormat", r),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.computeOutputShape = function (e) {
				if ("channelsFirst" === this.dataFormat) {
					var t = null == e[2] ? null : this.size[0] * e[2],
						n = null == e[3] ? null : this.size[1] * e[3];
					return [e[0], e[1], t, n];
				}
				var r = null == e[1] ? null : this.size[0] * e[1],
					a = null == e[2] ? null : this.size[1] * e[2];
				return [e[0], r, a, e[3]];
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					var t = NO(e),
						r = t.shape;
					if ("channelsFirst" === n.dataFormat) {
						t = qN(t, [0, 2, 3, 1]);
						var a = n.size[0] * r[2],
							i = n.size[1] * r[3],
							o =
								"nearest" === n.interpolation
									? pA.resizeNearestNeighbor(t, [a, i])
									: pA.resizeBilinear(t, [a, i]);
						return qN(o, [0, 3, 1, 2]);
					}
					var s = n.size[0] * r[1],
						u = n.size[1] * r[2];
					return "nearest" === n.interpolation
						? pA.resizeNearestNeighbor(t, [s, u])
						: pA.resizeBilinear(t, [s, u]);
				});
			}),
			(n.getConfig = function () {
				var t = { size: this.size, dataFormat: this.dataFormat },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(pz.className = "UpSampling2D"), AI(pz);
	var hz = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, 2, t) || this).depthwiseKernel = null),
				(n.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier),
				(n.depthwiseInitializer = mO(t.depthwiseInitializer || n.DEFAULT_KERNEL_INITIALIZER)),
				(n.depthwiseConstraint = pD(t.depthwiseConstraint)),
				(n.depthwiseRegularizer = VL(t.depthwiseRegularizer)),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				if ((e = IO(e)).length < 4)
					throw new OF(
						"Inputs to DepthwiseConv2D should have rank 4. Received input shape: " + JSON.stringify(e) + "."
					);
				var t = "channelsFirst" === this.dataFormat ? 1 : 3;
				if (null == e[t] || e[t] < 0)
					throw new OF(
						"The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (" +
							e[t] +
							")."
					);
				var n = e[t],
					r = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
				(this.depthwiseKernel = this.addWeight(
					"depthwise_kernel",
					r,
					null,
					this.depthwiseInitializer,
					this.depthwiseRegularizer,
					!0,
					this.depthwiseConstraint
				)),
					this.useBias
						? (this.bias = this.addWeight(
								"bias",
								[n * this.depthMultiplier],
								null,
								this.biasInitializer,
								this.biasRegularizer,
								!0,
								this.biasConstraint
						  ))
						: (this.bias = null),
					(this.built = !0);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					e = NO(e);
					var t,
						r,
						a,
						i,
						o,
						s =
							((t = e),
							(r = n.depthwiseKernel.read()),
							(a = n.strides),
							(i = n.padding),
							(o = n.dataFormat),
							null,
							void 0 === a && (a = [1, 1]),
							void 0 === i && (i = "valid"),
							BI(function () {
								null == o && (o = "channelsLast"), bD(o);
								var e = QL(t, o);
								if (4 !== t.rank)
									throw new OF(
										"Input for depthwiseConv2d is required to be 4-D, but is instead " +
											t.rank +
											"-D"
									);
								if (4 !== r.rank)
									throw new OF(
										"depthwiseKernel is required to be 4-D, but is instead " + r.rank + "-D"
									);
								return (
									(e = nT(e, r, a, "same" === i ? "same" : "valid", "NHWC", null)),
									"channelsFirst" === o && (e = qN(e, [0, 3, 1, 2])),
									e
								);
							}));
					return (
						n.useBias && (s = HD(s, n.bias.read(), n.dataFormat)),
						null != n.activation && (s = n.activation.apply(s)),
						s
					);
				});
			}),
			(n.computeOutputShape = function (e) {
				e = IO(e);
				var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
					n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
					r = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier,
					a = JL(t, this.kernelSize[0], this.padding, this.strides[0]),
					i = JL(n, this.kernelSize[1], this.padding, this.strides[1]);
				return "channelsFirst" === this.dataFormat ? [e[0], r, a, i] : [e[0], a, i, r];
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this);
				return (
					(t.depthMultiplier = this.depthMultiplier),
					(t.depthwiseInitializer = dO(this.depthwiseInitializer)),
					(t.depthwiseRegularizer = WL(this.depthwiseRegularizer)),
					(t.depthwiseConstraint = lD(this.depthwiseRegularizer)),
					t
				);
			}),
			t
		);
	})(tz);
	function fz(e, t, n, r) {
		if (Array.isArray(e)) {
			if (null != t || null != n)
				throw new OF("When inputs is an array, neither initialState or constants should be provided");
			null != r && ((n = e.slice(e.length - r, e.length)), (e = e.slice(0, e.length - r))),
				e.length > 1 && (t = e.slice(1, e.length)),
				(e = e[0]);
		}
		function a(e) {
			return null == e || Array.isArray(e) ? e : [e];
		}
		return { inputs: e, initialState: (t = a(t)), constants: (n = a(n)) };
	}
	function dz(e, t, n, r, a, i, o, s) {
		return (
			void 0 === r && (r = !1),
			void 0 === o && (o = !1),
			void 0 === s && (s = !1),
			BI(function () {
				var u = t.shape.length;
				if (u < 3) throw new OF("Input should be at least 3D, but is " + u + "D.");
				var l = [1, 0].concat(_D(2, u));
				if (((t = qN(t, l)), null != i))
					throw new MF("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
				o &&
					console.warn(
						"Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."
					),
					null != a && ((a = NN(NN(a, "bool"), "float32")).rank === u - 1 && (a = dT(a, -1)), (a = qN(a, l))),
					r && ((t = QC(t, 0)), null != a && (a = QC(a, 0)));
				var c,
					p,
					h = [],
					f = n,
					d = t.shape[0],
					m = BE(t);
				null != a && (p = BE(a));
				for (
					var g,
						v = function (t) {
							var n = m[t],
								r = BI(function () {
									return e(n, f);
								});
							if (null == a) (c = r[0]), (f = r[1]);
							else {
								var i = BI(function () {
									var e = p[t],
										n = UT(xC(e), e);
									return {
										output: jI(KI(r[0], e), KI(f[0], n)),
										newStates: f.map(function (t, a) {
											return jI(KI(r[1][a], e), KI(t, n));
										}),
									};
								});
								(c = i.output), (f = i.newStates);
							}
							s && h.push(c);
						},
						y = 0;
					y < d;
					++y
				)
					v(y);
				return s && (g = TE(h, 1)), [c, g, f];
			})
		);
	}
	(hz.className = "DepthwiseConv2D"), AI(hz);
	var mz = (function (e) {
		function t(t) {
			var n, r;
			if (((n = e.call(this, t) || this), null == t.cell))
				throw new OF("cell property is missing for the constructor of RNN.");
			if (null == (r = Array.isArray(t.cell) ? new Nz({ cells: t.cell }) : t.cell).stateSize)
				throw new OF(
					"The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state)."
				);
			return (
				(n.cell = r),
				(n.returnSequences = null != t.returnSequences && t.returnSequences),
				(n.returnState = null != t.returnState && t.returnState),
				(n.goBackwards = null != t.goBackwards && t.goBackwards),
				(n._stateful = null != t.stateful && t.stateful),
				(n.unroll = null != t.unroll && t.unroll),
				(n.supportsMasking = !0),
				(n.inputSpec = [new AO({ ndim: 3 })]),
				(n.stateSpec = null),
				(n.states_ = null),
				(n.numConstants = null),
				(n.keptStates = []),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.getStates = function () {
				return null == this.states_
					? _D(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function (e) {
							return null;
					  })
					: this.states_;
			}),
			(n.setStates = function (e) {
				this.states_ = e;
			}),
			(n.computeOutputShape = function (e) {
				wO(e) && (e = e[0]), (e = e);
				var t = this.cell.stateSize;
				Array.isArray(t) || (t = [t]);
				var n,
					r = t[0];
				if (((n = this.returnSequences ? [e[0], e[1], r] : [e[0], r]), this.returnState)) {
					for (var a, i = [], o = Ig(t); !(a = o()).done; ) {
						var s = a.value;
						i.push([e[0], s]);
					}
					return [n].concat(i);
				}
				return n;
			}),
			(n.computeMask = function (e, t) {
				var n = this;
				return BI(function () {
					Array.isArray(t) && (t = t[0]);
					var e = n.returnSequences ? t : null;
					if (n.returnState) {
						var r = n.states.map(function (e) {
							return null;
						});
						return [e].concat(r);
					}
					return e;
				});
			}),
			(n.build = function (e) {
				if (null != this.numConstants) throw new MF("Constants support is not implemented in RNN yet.");
				wO(e) && (e = e[0]), (e = e);
				var t = this.stateful ? e[0] : null,
					n = e.slice(2);
				this.inputSpec[0] = new AO({ shape: [t, null].concat(n) });
				var r,
					a = [e[0]].concat(e.slice(2));
				if (
					(this.cell.build(a),
					(r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize]),
					null != this.stateSpec)
				) {
					if (
						!Pg(
							this.stateSpec.map(function (e) {
								return e.shape[e.shape.length - 1];
							}),
							r
						)
					)
						throw new OF(
							"An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=" +
								this.stateSpec +
								"; However cell.stateSize is " +
								this.cell.stateSize
						);
				} else
					this.stateSpec = r.map(function (e) {
						return new AO({ shape: [null, e] });
					});
				this.stateful && this.resetStates();
			}),
			(n.resetStates = function (e, t) {
				var n = this;
				void 0 === t && (t = !1),
					BI(function () {
						if (!n.stateful)
							throw new FF("Cannot call resetStates() on an RNN Layer that is not stateful.");
						var r = n.inputSpec[0].shape[0];
						if (null == r)
							throw new OF(
								"If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer."
							);
						if (null == n.states_)
							Array.isArray(n.cell.stateSize)
								? (n.states_ = n.cell.stateSize.map(function (e) {
										return uC([r, e]);
								  }))
								: (n.states_ = [uC([r, n.cell.stateSize])]);
						else if (null == e)
							WI(n.states_),
								null != n.keptStates && (WI(n.keptStates), (n.keptStates = [])),
								Array.isArray(n.cell.stateSize)
									? (n.states_ = n.cell.stateSize.map(function (e) {
											return uC([r, e]);
									  }))
									: (n.states_[0] = uC([r, n.cell.stateSize]));
						else {
							if ((Array.isArray(e) || (e = [e]), e.length !== n.states_.length))
								throw new OF(
									"Layer " +
										n.name +
										" expects " +
										n.states_.length +
										" state(s), but it received " +
										e.length +
										" state value(s). Input received: " +
										e
								);
							!0 === t ? n.keptStates.push(n.states_.slice()) : WI(n.states_);
							for (var a = 0; a < n.states_.length; ++a) {
								var i = e[a],
									o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize[a] : n.cell.stateSize,
									s = [r, o];
								if (!Pg(i.shape, s))
									throw new OF(
										"State " +
											a +
											" is incompatible with layer " +
											n.name +
											": expected shape=" +
											s +
											", received shape=" +
											i.shape
									);
								n.states_[a] = i;
							}
						}
						n.states_ = n.states_.map(function (e) {
							return UI(e.clone());
						});
					});
			}),
			(n.apply = function (t, n) {
				var r = null == n ? null : n.initialState,
					a = null == n ? null : n.constants;
				null == n && (n = {});
				var i = fz(t, r, a, this.numConstants);
				(t = i.inputs), (r = i.initialState), (a = i.constants);
				var o = [],
					s = [];
				if (null != r) {
					(n.initialState = r), (o = o.concat(r)), (this.stateSpec = []);
					for (var u, l = Ig(r); !(u = l()).done; ) {
						var c = u.value;
						this.stateSpec.push(new AO({ shape: c.shape }));
					}
					s = s.concat(this.stateSpec);
				}
				if (
					(null != a && ((n.constants = a), (o = o.concat(a)), (this.numConstants = a.length)),
					o[0] instanceof _O)
				) {
					var p = [t].concat(o),
						h = this.inputSpec.concat(s),
						f = this.inputSpec;
					this.inputSpec = h;
					var d = e.prototype.apply.call(this, p, n);
					return (this.inputSpec = f), d;
				}
				return e.prototype.apply.call(this, t, n);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					var r = null == t ? null : t.mask,
						a = null == t ? null : t.training,
						i = null == t ? null : t.initialState;
					(e = NO(e)), null == i && (i = n.stateful ? n.states_ : n.getInitialState(e));
					var o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize.length : 1;
					if (i.length !== o)
						throw new OF(
							"RNN Layer has " + o + " state(s) but was passed " + i.length + " initial state(s)."
						);
					n.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
					var s = { training: a },
						u = dz(
							function (e, t) {
								var r = n.cell.call([e].concat(t), s);
								return [r[0], r.slice(1)];
							},
							e,
							i,
							n.goBackwards,
							r,
							null,
							n.unroll,
							n.returnSequences
						),
						l = u[0],
						c = u[1],
						p = u[2];
					n.stateful && n.resetStates(p, a);
					var h = n.returnSequences ? c : l;
					return n.returnState ? [h].concat(p) : h;
				});
			}),
			(n.getInitialState = function (e) {
				var t = this;
				return BI(function () {
					var n = uC(e.shape);
					return (
						(n = DD((n = VT(n, [1, 2])))),
						Array.isArray(t.cell.stateSize)
							? t.cell.stateSize.map(function (e) {
									return e > 1 ? BD(n, [1, e]) : n;
							  })
							: t.cell.stateSize > 1
							? [BD(n, [1, t.cell.stateSize])]
							: [n]
					);
				});
			}),
			(n.setFastWeightInitDuringBuild = function (t) {
				e.prototype.setFastWeightInitDuringBuild.call(this, t),
					null != this.cell && this.cell.setFastWeightInitDuringBuild(t);
			}),
			(n.getConfig = function () {
				var n = e.prototype.getConfig.call(this),
					r = {
						returnSequences: this.returnSequences,
						returnState: this.returnState,
						goBackwards: this.goBackwards,
						stateful: this.stateful,
						unroll: this.unroll,
					};
				null != this.numConstants && (r.numConstants = this.numConstants);
				var a = this.cell.getConfig();
				return (
					this.getClassName() === t.className &&
						(r.cell = { className: this.cell.getClassName(), config: a }),
					Object.assign({}, a, n, r)
				);
			}),
			(t.fromConfig = function (e, t, n) {
				void 0 === n && (n = {});
				var r = ZO(t.cell, n);
				return new e(Object.assign(t, { cell: r }));
			}),
			mg(t, [
				{
					key: "states",
					get: function () {
						if (null == this.states_) {
							for (
								var e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1,
									t = [],
									n = 0;
								n < e;
								++n
							)
								t.push(null);
							return t;
						}
						return this.states_;
					},
					set: function (e) {
						this.states_ = e;
					},
				},
				{
					key: "trainableWeights",
					get: function () {
						return this.trainable ? this.cell.trainableWeights : [];
					},
				},
				{
					key: "nonTrainableWeights",
					get: function () {
						return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
					},
				},
			]),
			t
		);
	})(MO);
	(mz.className = "RNN"), AI(mz);
	var gz = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			return gg(t, e), t;
		})(MO),
		vz = (function (e) {
			function t(t) {
				var n;
				return (
					((n = e.call(this, t) || this).DEFAULT_ACTIVATION = "tanh"),
					(n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
					(n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal"),
					(n.DEFAULT_BIAS_INITIALIZER = "zeros"),
					(n.units = t.units),
					$F(n.units, "units"),
					(n.activation = ML(null == t.activation ? n.DEFAULT_ACTIVATION : t.activation)),
					(n.useBias = null == t.useBias || t.useBias),
					(n.kernelInitializer = mO(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER)),
					(n.recurrentInitializer = mO(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER)),
					(n.biasInitializer = mO(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER)),
					(n.kernelRegularizer = VL(t.kernelRegularizer)),
					(n.recurrentRegularizer = VL(t.recurrentRegularizer)),
					(n.biasRegularizer = VL(t.biasRegularizer)),
					(n.kernelConstraint = pD(t.kernelConstraint)),
					(n.recurrentConstraint = pD(t.recurrentConstraint)),
					(n.biasConstraint = pD(t.biasConstraint)),
					(n.dropout = RD([1, AD([0, null == t.dropout ? 0 : t.dropout])])),
					(n.recurrentDropout = RD([1, AD([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])])),
					(n.dropoutFunc = t.dropoutFunc),
					(n.stateSize = n.units),
					(n.dropoutMask = null),
					(n.recurrentDropoutMask = null),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.build = function (e) {
					(e = IO(e)),
						(this.kernel = this.addWeight(
							"kernel",
							[e[e.length - 1], this.units],
							null,
							this.kernelInitializer,
							this.kernelRegularizer,
							!0,
							this.kernelConstraint
						)),
						(this.recurrentKernel = this.addWeight(
							"recurrent_kernel",
							[this.units, this.units],
							null,
							this.recurrentInitializer,
							this.recurrentRegularizer,
							!0,
							this.recurrentConstraint
						)),
						this.useBias
							? (this.bias = this.addWeight(
									"bias",
									[this.units],
									null,
									this.biasInitializer,
									this.biasRegularizer,
									!0,
									this.biasConstraint
							  ))
							: (this.bias = null),
						(this.built = !0);
				}),
				(n.call = function (e, t) {
					var n = this;
					return BI(function () {
						if (2 !== (e = e).length)
							throw new OF("SimpleRNNCell expects 2 input Tensors, got " + e.length + ".");
						var r = e[1];
						e = e[0];
						var a,
							i = null != t.training && t.training;
						0 < n.dropout &&
							n.dropout < 1 &&
							null == n.dropoutMask &&
							(n.dropoutMask = Iz({
								ones: function () {
									return xC(e);
								},
								rate: n.dropout,
								training: i,
								dropoutFunc: n.dropoutFunc,
							})),
							0 < n.recurrentDropout &&
								n.recurrentDropout < 1 &&
								null == n.recurrentDropoutMask &&
								(n.recurrentDropoutMask = Iz({
									ones: function () {
										return xC(r);
									},
									rate: n.recurrentDropout,
									training: i,
									dropoutFunc: n.dropoutFunc,
								}));
						var o = n.dropoutMask,
							s = n.recurrentDropoutMask;
						(a = UD(null != o ? KI(e, o) : e, n.kernel.read())),
							null != n.bias && (a = HD(a, n.bias.read())),
							null != s && (r = KI(r, s));
						var u = jI(a, UD(r, n.recurrentKernel.read()));
						return null != n.activation && (u = n.activation.apply(u)), [u, u];
					});
				}),
				(n.getConfig = function () {
					var t = e.prototype.getConfig.call(this),
						n = {
							units: this.units,
							activation: DL(this.activation),
							useBias: this.useBias,
							kernelInitializer: dO(this.kernelInitializer),
							recurrentInitializer: dO(this.recurrentInitializer),
							biasInitializer: dO(this.biasInitializer),
							kernelRegularizer: WL(this.kernelRegularizer),
							recurrentRegularizer: WL(this.recurrentRegularizer),
							biasRegularizer: WL(this.biasRegularizer),
							activityRegularizer: WL(this.activityRegularizer),
							kernelConstraint: lD(this.kernelConstraint),
							recurrentConstraint: lD(this.recurrentConstraint),
							biasConstraint: lD(this.biasConstraint),
							dropout: this.dropout,
							recurrentDropout: this.recurrentDropout,
						};
					return Object.assign({}, t, n);
				}),
				t
			);
		})(gz);
	(vz.className = "SimpleRNNCell"), AI(vz);
	var yz = (function (e) {
		function t(t) {
			return (t.cell = new vz(t)), e.call(this, t) || this;
		}
		return (
			gg(t, e),
			(t.prototype.call = function (t, n) {
				var r = this;
				return BI(function () {
					null != r.cell.dropoutMask && (WI(r.cell.dropoutMask), (r.cell.dropoutMask = null)),
						null != r.cell.recurrentDropoutMask &&
							(WI(r.cell.recurrentDropoutMask), (r.cell.recurrentDropoutMask = null));
					var a = null == n ? null : n.mask,
						i = null == n ? null : n.training,
						o = null == n ? null : n.initialState;
					return e.prototype.call.call(r, t, { mask: a, training: i, initialState: o });
				});
			}),
			(t.fromConfig = function (e, t) {
				return new e(t);
			}),
			t
		);
	})(mz);
	(yz.className = "SimpleRNN"), AI(yz);
	var bz = (function (e) {
		function t(t) {
			var n;
			if (
				(((n = e.call(this, t) || this).DEFAULT_ACTIVATION = "tanh"),
				(n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid"),
				(n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
				(n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal"),
				(n.DEFAULT_BIAS_INITIALIZER = "zeros"),
				t.resetAfter)
			)
				throw new OF("GRUCell does not support reset_after parameter set to true.");
			return (
				(n.units = t.units),
				$F(n.units, "units"),
				(n.activation = ML(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation)),
				(n.recurrentActivation = ML(
					void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation
				)),
				(n.useBias = null == t.useBias || t.useBias),
				(n.kernelInitializer = mO(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER)),
				(n.recurrentInitializer = mO(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER)),
				(n.biasInitializer = mO(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER)),
				(n.kernelRegularizer = VL(t.kernelRegularizer)),
				(n.recurrentRegularizer = VL(t.recurrentRegularizer)),
				(n.biasRegularizer = VL(t.biasRegularizer)),
				(n.kernelConstraint = pD(t.kernelConstraint)),
				(n.recurrentConstraint = pD(t.recurrentConstraint)),
				(n.biasConstraint = pD(t.biasConstraint)),
				(n.dropout = RD([1, AD([0, null == t.dropout ? 0 : t.dropout])])),
				(n.recurrentDropout = RD([1, AD([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])])),
				(n.dropoutFunc = t.dropoutFunc),
				(n.implementation = t.implementation),
				(n.stateSize = n.units),
				(n.dropoutMask = null),
				(n.recurrentDropoutMask = null),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t = (e = IO(e))[e.length - 1];
				(this.kernel = this.addWeight(
					"kernel",
					[t, 3 * this.units],
					null,
					this.kernelInitializer,
					this.kernelRegularizer,
					!0,
					this.kernelConstraint
				)),
					(this.recurrentKernel = this.addWeight(
						"recurrent_kernel",
						[this.units, 3 * this.units],
						null,
						this.recurrentInitializer,
						this.recurrentRegularizer,
						!0,
						this.recurrentConstraint
					)),
					this.useBias
						? (this.bias = this.addWeight(
								"bias",
								[3 * this.units],
								null,
								this.biasInitializer,
								this.biasRegularizer,
								!0,
								this.biasConstraint
						  ))
						: (this.bias = null),
					(this.built = !0);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					if (2 !== (e = e).length)
						throw new OF("GRUCell expects 2 input Tensors (inputs, h, c), got " + e.length + ".");
					var r = null != t.training && t.training,
						a = e[1];
					(e = e[0]),
						0 < n.dropout &&
							n.dropout < 1 &&
							null == n.dropoutMask &&
							(n.dropoutMask = Iz({
								ones: function () {
									return xC(e);
								},
								rate: n.dropout,
								training: r,
								count: 3,
								dropoutFunc: n.dropoutFunc,
							})),
						0 < n.recurrentDropout &&
							n.recurrentDropout < 1 &&
							null == n.recurrentDropoutMask &&
							(n.recurrentDropoutMask = Iz({
								ones: function () {
									return xC(a);
								},
								rate: n.recurrentDropout,
								training: r,
								count: 3,
								dropoutFunc: n.dropoutFunc,
							}));
					var i,
						o,
						s,
						u = n.dropoutMask,
						l = n.recurrentDropoutMask;
					0 < n.dropout && n.dropout < 1 && (e = KI(e, u[0]));
					var c = UD(e, n.kernel.read());
					n.useBias && (c = HD(c, n.bias.read())),
						0 < n.recurrentDropout && n.recurrentDropout < 1 && (a = KI(a, l[0]));
					var p = n.recurrentKernel.read(),
						h = wE(p, [2 * n.units, n.units], p.rank - 1),
						f = h[0],
						d = h[1],
						m = UD(a, f),
						g = wE(c, 3, c.rank - 1),
						v = g[0],
						y = g[1],
						b = g[2],
						x = wE(m, 2, m.rank - 1),
						w = x[0],
						k = x[1];
					(i = n.recurrentActivation.apply(jI(v, w))), (o = n.recurrentActivation.apply(jI(y, k)));
					var N = UD(KI(o, a), d);
					s = n.activation.apply(jI(b, N));
					var I = jI(KI(i, a), KI(jI(1, zT(i)), s));
					return [I, I];
				});
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this),
					n = {
						units: this.units,
						activation: DL(this.activation),
						recurrentActivation: DL(this.recurrentActivation),
						useBias: this.useBias,
						kernelInitializer: dO(this.kernelInitializer),
						recurrentInitializer: dO(this.recurrentInitializer),
						biasInitializer: dO(this.biasInitializer),
						kernelRegularizer: WL(this.kernelRegularizer),
						recurrentRegularizer: WL(this.recurrentRegularizer),
						biasRegularizer: WL(this.biasRegularizer),
						activityRegularizer: WL(this.activityRegularizer),
						kernelConstraint: lD(this.kernelConstraint),
						recurrentConstraint: lD(this.recurrentConstraint),
						biasConstraint: lD(this.biasConstraint),
						dropout: this.dropout,
						recurrentDropout: this.recurrentDropout,
						implementation: this.implementation,
						resetAfter: !1,
					};
				return Object.assign({}, t, n);
			}),
			t
		);
	})(gz);
	(bz.className = "GRUCell"), AI(bz);
	var xz = (function (e) {
		function t(t) {
			return (
				0 === t.implementation &&
					console.warn(
						"`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."
					),
				(t.cell = new bz(t)),
				e.call(this, t) || this
			);
		}
		return (
			gg(t, e),
			(t.prototype.call = function (t, n) {
				var r = this;
				return BI(function () {
					null != r.cell.dropoutMask && (WI(r.cell.dropoutMask), (r.cell.dropoutMask = null)),
						null != r.cell.recurrentDropoutMask &&
							(WI(r.cell.recurrentDropoutMask), (r.cell.recurrentDropoutMask = null));
					var a = null == n ? null : n.mask,
						i = null == n ? null : n.training,
						o = null == n ? null : n.initialState;
					return e.prototype.call.call(r, t, { mask: a, training: i, initialState: o });
				});
			}),
			(t.fromConfig = function (e, t) {
				return 0 === t.implmentation && (t.implementation = 1), new e(t);
			}),
			t
		);
	})(mz);
	(xz.className = "GRU"), AI(xz);
	var wz = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, t) || this).DEFAULT_ACTIVATION = "tanh"),
				(n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid"),
				(n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
				(n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal"),
				(n.DEFAULT_BIAS_INITIALIZER = "zeros"),
				(n.units = t.units),
				$F(n.units, "units"),
				(n.activation = ML(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation)),
				(n.recurrentActivation = ML(
					void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation
				)),
				(n.useBias = null == t.useBias || t.useBias),
				(n.kernelInitializer = mO(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER)),
				(n.recurrentInitializer = mO(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER)),
				(n.biasInitializer = mO(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER)),
				(n.unitForgetBias = t.unitForgetBias),
				(n.kernelRegularizer = VL(t.kernelRegularizer)),
				(n.recurrentRegularizer = VL(t.recurrentRegularizer)),
				(n.biasRegularizer = VL(t.biasRegularizer)),
				(n.kernelConstraint = pD(t.kernelConstraint)),
				(n.recurrentConstraint = pD(t.recurrentConstraint)),
				(n.biasConstraint = pD(t.biasConstraint)),
				(n.dropout = RD([1, AD([0, null == t.dropout ? 0 : t.dropout])])),
				(n.recurrentDropout = RD([1, AD([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])])),
				(n.dropoutFunc = t.dropoutFunc),
				(n.implementation = t.implementation),
				(n.stateSize = [n.units, n.units]),
				(n.dropoutMask = null),
				(n.recurrentDropoutMask = null),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t,
					n,
					r = (e = IO(e))[e.length - 1];
				if (
					((this.kernel = this.addWeight(
						"kernel",
						[r, 4 * this.units],
						null,
						this.kernelInitializer,
						this.kernelRegularizer,
						!0,
						this.kernelConstraint
					)),
					(this.recurrentKernel = this.addWeight(
						"recurrent_kernel",
						[this.units, 4 * this.units],
						null,
						this.recurrentInitializer,
						this.recurrentRegularizer,
						!0,
						this.recurrentConstraint
					)),
					this.useBias)
				) {
					if (this.unitForgetBias) {
						var a = this.biasInitializer,
							i = this.units;
						n = new (((t = (function (e) {
							function t() {
								return e.apply(this, arguments) || this;
							}
							return (
								gg(t, e),
								(t.prototype.apply = function (e, t) {
									var n = a.apply([i]),
										r = new QD().apply([i]),
										o = a.apply([2 * i]);
									return PD(PD(n, r), o);
								}),
								t
							);
						})(JD)).className = "CustomInit"),
						t)();
					} else n = this.biasInitializer;
					this.bias = this.addWeight(
						"bias",
						[4 * this.units],
						null,
						n,
						this.biasRegularizer,
						!0,
						this.biasConstraint
					);
				} else this.bias = null;
				this.built = !0;
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					var r = null != t.training && t.training;
					if (3 !== (e = e).length)
						throw new OF("LSTMCell expects 3 input Tensors (inputs, h, c), got " + e.length + ".");
					var a = e[1],
						i = e[2];
					(e = e[0]),
						0 < n.dropout &&
							n.dropout < 1 &&
							null == n.dropoutMask &&
							(n.dropoutMask = Iz({
								ones: function () {
									return xC(e);
								},
								rate: n.dropout,
								training: r,
								count: 4,
								dropoutFunc: n.dropoutFunc,
							})),
						0 < n.recurrentDropout &&
							n.recurrentDropout < 1 &&
							null == n.recurrentDropoutMask &&
							(n.recurrentDropoutMask = Iz({
								ones: function () {
									return xC(a);
								},
								rate: n.recurrentDropout,
								training: r,
								count: 4,
								dropoutFunc: n.dropoutFunc,
							}));
					var o,
						s,
						u,
						l,
						c = n.dropoutMask,
						p = n.recurrentDropoutMask;
					0 < n.dropout && n.dropout < 1 && (e = KI(e, c[0]));
					var h = UD(e, n.kernel.read());
					0 < n.recurrentDropout && n.recurrentDropout < 1 && (a = KI(a, p[0])),
						(h = jI(h, UD(a, n.recurrentKernel.read()))),
						n.useBias && (h = HD(h, n.bias.read()));
					var f = wE(h, 4, h.rank - 1),
						d = f[0],
						m = f[1],
						g = f[2],
						v = f[3];
					(o = n.recurrentActivation.apply(d)),
						(s = n.recurrentActivation.apply(m)),
						(u = jI(KI(s, i), KI(o, n.activation.apply(g)))),
						(l = n.recurrentActivation.apply(v));
					var y = KI(l, n.activation.apply(u));
					return [y, y, u];
				});
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this),
					n = {
						units: this.units,
						activation: DL(this.activation),
						recurrentActivation: DL(this.recurrentActivation),
						useBias: this.useBias,
						kernelInitializer: dO(this.kernelInitializer),
						recurrentInitializer: dO(this.recurrentInitializer),
						biasInitializer: dO(this.biasInitializer),
						unitForgetBias: this.unitForgetBias,
						kernelRegularizer: WL(this.kernelRegularizer),
						recurrentRegularizer: WL(this.recurrentRegularizer),
						biasRegularizer: WL(this.biasRegularizer),
						activityRegularizer: WL(this.activityRegularizer),
						kernelConstraint: lD(this.kernelConstraint),
						recurrentConstraint: lD(this.recurrentConstraint),
						biasConstraint: lD(this.biasConstraint),
						dropout: this.dropout,
						recurrentDropout: this.recurrentDropout,
						implementation: this.implementation,
					};
				return Object.assign({}, t, n);
			}),
			t
		);
	})(gz);
	(wz.className = "LSTMCell"), AI(wz);
	var kz = (function (e) {
		function t(t) {
			return (
				0 === t.implementation &&
					console.warn(
						"`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."
					),
				(t.cell = new wz(t)),
				e.call(this, t) || this
			);
		}
		return (
			gg(t, e),
			(t.prototype.call = function (t, n) {
				var r = this;
				return BI(function () {
					null != r.cell.dropoutMask && (WI(r.cell.dropoutMask), (r.cell.dropoutMask = null)),
						null != r.cell.recurrentDropoutMask &&
							(WI(r.cell.recurrentDropoutMask), (r.cell.recurrentDropoutMask = null));
					var a = null == n ? null : n.mask,
						i = null == n ? null : n.training,
						o = null == n ? null : n.initialState;
					return e.prototype.call.call(r, t, { mask: a, training: i, initialState: o });
				});
			}),
			(t.fromConfig = function (e, t) {
				return 0 === t.implmentation && (t.implementation = 1), new e(t);
			}),
			t
		);
	})(mz);
	(kz.className = "LSTM"), AI(kz);
	var Nz = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this, t) || this).cells = t.cells), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					for (var r, a = (e = e).slice(1), i = [], o = Ig(n.cells.slice().reverse()); !(r = o()).done; ) {
						var s = r.value;
						Array.isArray(s.stateSize) ? i.push(a.splice(0, s.stateSize.length)) : i.push(a.splice(0, 1));
					}
					i.reverse();
					for (var u, l = [], c = 0; c < n.cells.length; ++c) {
						var p = n.cells[c];
						(a = i[c]),
							(u = 0 === c ? [e[0]].concat(a) : [u[0]].concat(a)),
							(u = p.call(u, t)),
							l.push(u.slice(1));
					}
					a = [];
					for (var h, f = Ig(l.slice().reverse()); !(h = f()).done; ) {
						var d,
							m = h.value;
						(d = a).push.apply(d, m);
					}
					return [u[0]].concat(a);
				});
			}),
			(n.build = function (e) {
				var t;
				wO(e) && (e = e[0]),
					(e = e),
					this.cells.forEach(function (n, r) {
						ND("RNNCell_" + r, function () {
							n.build(e),
								(t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize),
								(e = [e[0], t]);
						});
					}),
					(this.built = !0);
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this),
					n = {
						cells: this.cells.map(function (e) {
							return { className: e.getClassName(), config: e.getConfig() };
						}),
					};
				return Object.assign({}, t, n);
			}),
			(t.fromConfig = function (e, t, n) {
				void 0 === n && (n = {});
				for (var r, a = [], i = Ig(t.cells); !(r = i()).done; ) {
					var o = r.value;
					a.push(ZO(o, n));
				}
				return new e({ cells: a });
			}),
			(n.getWeights = function () {
				for (var e, t = [], n = Ig(this.cells); !(e = n()).done; ) {
					var r = e.value;
					t.push.apply(t, r.weights);
				}
				return EO(t);
			}),
			(n.setWeights = function (e) {
				for (var t, n = [], r = Ig(this.cells); !(t = r()).done; )
					for (var a = t.value, i = a.weights.length, o = e.splice(i), s = 0; s < a.weights.length; ++s)
						n.push([a.weights[s], o[s]]);
				RO(n);
			}),
			mg(t, [
				{
					key: "stateSize",
					get: function () {
						for (var e, t = [], n = Ig(this.cells.slice().reverse()); !(e = n()).done; ) {
							var r = e.value;
							Array.isArray(r.stateSize) ? t.push.apply(t, r.stateSize) : t.push(r.stateSize);
						}
						return t;
					},
				},
				{
					key: "trainableWeights",
					get: function () {
						if (!this.trainable) return [];
						for (var e, t = [], n = Ig(this.cells); !(e = n()).done; ) {
							var r = e.value;
							t.push.apply(t, r.trainableWeights);
						}
						return t;
					},
				},
				{
					key: "nonTrainableWeights",
					get: function () {
						for (var e, t = [], n = Ig(this.cells); !(e = n()).done; ) {
							var r = e.value;
							t.push.apply(t, r.nonTrainableWeights);
						}
						if (!this.trainable) {
							for (var a, i = [], o = Ig(this.cells); !(a = o()).done; ) {
								var s = a.value;
								i.push.apply(i, s.trainableWeights);
							}
							return i.concat(t);
						}
						return t;
					},
				},
			]),
			t
		);
	})(gz);
	function Iz(e) {
		var t = e.ones,
			n = e.rate,
			r = e.training,
			a = void 0 !== r && r,
			i = e.count,
			o = void 0 === i ? 1 : i,
			s = e.dropoutFunc,
			u = function () {
				return null != s ? s(t(), n) : qD(t(), n);
			},
			l = function () {
				return KD(u, t, a);
			};
		return !o || o <= 1
			? UI(l().clone())
			: Array(o)
					.fill(void 0)
					.map(l)
					.map(function (e) {
						return UI(e.clone());
					});
	}
	(Nz.className = "StackedRNNCells"), AI(Nz);
	var Sz = (function (e) {
		function t(t) {
			var n;
			if (t.unroll) throw new MF("Unrolling is not possible with convolutional RNNs.");
			if (Array.isArray(t.cell)) throw new MF("It is not possible at the moment to stack convolutional cells.");
			return ((n = e.call(this, t) || this).inputSpec = [new AO({ ndim: 5 })]), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.call = function (t, n) {
				var r = this;
				return BI(function () {
					if (
						(null != r.cell.dropoutMask && (WI(r.cell.dropoutMask), (r.cell.dropoutMask = null)),
						null != r.cell.recurrentDropoutMask &&
							(WI(r.cell.recurrentDropoutMask), (r.cell.recurrentDropoutMask = null)),
						n && n.constants)
					)
						throw new OF("ConvRNN2D cell does not support constants");
					var a = null == n ? null : n.mask,
						i = null == n ? null : n.training,
						o = null == n ? null : n.initialState;
					return e.prototype.call.call(r, t, { mask: a, training: i, initialState: o });
				});
			}),
			(n.computeOutputShape = function (e) {
				var t = this.computeSingleOutputShape(e);
				return (
					this.returnSequences || (t = [t[0]].concat(t.slice(2))),
					this.returnState && (t = [t].concat(Array(2).fill([e[0]].concat(t.slice(-3))))),
					t
				);
			}),
			(n.getInitialState = function (e) {
				var t = this;
				return BI(function () {
					var n = t.cell.stateSize,
						r = e.shape,
						a = t.computeSingleOutputShape(r),
						i = uC([a[0]].concat(a.slice(2)));
					return Array.isArray(n) ? Array(n.length).fill(i) : [i];
				});
			}),
			(n.resetStates = function (e, t) {
				var n = this;
				void 0 === t && (t = !1),
					BI(function () {
						if (!n.stateful)
							throw new FF("Cannot call resetStates() on an RNN Layer that is not stateful.");
						var r = n.inputSpec[0].shape,
							a = n.computeSingleOutputShape(r),
							i = [a[0]].concat(a.slice(2));
						if (null == r[0])
							throw new OF(
								"If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer."
							);
						if (null == n.getStates())
							Array.isArray(n.cell.stateSize)
								? (n.states_ = n.cell.stateSize.map(function () {
										return uC(i);
								  }))
								: (n.states_ = [uC(i)]);
						else if (null == e)
							WI(n.states_),
								null != n.keptStates && (WI(n.keptStates), (n.keptStates = [])),
								Array.isArray(n.cell.stateSize)
									? (n.states_ = n.cell.stateSize.map(function () {
											return uC(i);
									  }))
									: (n.states_[0] = uC(i));
						else {
							if ((Array.isArray(e) || (e = [e]), e.length !== n.states_.length))
								throw new OF(
									"Layer " +
										n.name +
										" expects " +
										n.states_.length +
										" state(s), but it received " +
										e.length +
										" state value(s). Input received: " +
										e
								);
							t ? n.keptStates.push(n.states_.slice()) : WI(n.states_);
							for (var o = 0; o < n.states_.length; ++o) {
								var s = e[o],
									u = i;
								if (!Pg(s.shape, u))
									throw new OF(
										"State " +
											o +
											" is incompatible with layer " +
											n.name +
											": expected shape=" +
											u +
											", received shape=" +
											s.shape
									);
								n.states_[o] = s;
							}
						}
						n.states_ = n.states_.map(function (e) {
							return UI(e.clone());
						});
					});
			}),
			(n.computeSingleOutputShape = function (e) {
				var t = this.cell,
					n = t.dataFormat,
					r = t.filters,
					a = t.kernelSize,
					i = t.padding,
					o = t.strides,
					s = t.dilationRate,
					u = "channelsFirst" === n,
					l = e[u ? 3 : 2],
					c = e[u ? 4 : 3],
					p = JL(l, a[0], i, o[0], s[0]),
					h = JL(c, a[1], i, o[1], s[1]);
				return [].concat(e.slice(0, 2), u ? [r, p, h] : [p, h, r]);
			}),
			t
		);
	})(mz);
	Sz.className = "ConvRNN2D";
	var Tz = (function (e) {
		function t(t) {
			var n,
				r = t.filters,
				a = t.kernelSize,
				i = t.strides,
				o = t.padding,
				s = t.dataFormat,
				u = t.dilationRate;
			return (
				((n = e.call(this, Object.assign({}, t, { units: r })) || this).filters = r),
				$F(n.filters, "filters"),
				(n.kernelSize = YL(a, 2, "kernelSize")),
				n.kernelSize.forEach(function (e) {
					return $F(e, "kernelSize");
				}),
				(n.strides = YL(i || 1, 2, "strides")),
				n.strides.forEach(function (e) {
					return $F(e, "strides");
				}),
				(n.padding = o || "valid"),
				xD(n.padding),
				(n.dataFormat = s || "channelsLast"),
				bD(n.dataFormat),
				(n.dilationRate = YL(u || 1, 2, "dilationRate")),
				n.dilationRate.forEach(function (e) {
					return $F(e, "dilationRate");
				}),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t;
				e = IO(e);
				var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
				if (null == e[n]) throw new OF("The channel dimension of the input should be defined. Found " + e[n]);
				var r = e[n],
					a = this.kernelSize.concat([r, 4 * this.filters]);
				this.kernel = this.addWeight(
					"kernel",
					a,
					null,
					this.kernelInitializer,
					this.kernelRegularizer,
					!0,
					this.kernelConstraint
				);
				var i = this.kernelSize.concat([this.filters, 4 * this.filters]);
				if (
					((this.recurrentKernel = this.addWeight(
						"recurrent_kernel",
						i,
						null,
						this.recurrentInitializer,
						this.recurrentRegularizer,
						!0,
						this.recurrentConstraint
					)),
					this.useBias)
				) {
					var o;
					if (this.unitForgetBias) {
						var s = this.biasInitializer,
							u = this.filters;
						o = new (((t = (function (e) {
							function t() {
								return e.apply(this, arguments) || this;
							}
							return (
								gg(t, e),
								(t.prototype.apply = function (e, t) {
									return zD([s.apply([u]), lC([u]), s.apply([2 * u])]);
								}),
								t
							);
						})(JD)).className = "CustomInit"),
						t)();
					} else o = this.biasInitializer;
					this.bias = this.addWeight(
						"bias",
						[4 * this.filters],
						null,
						o,
						this.biasRegularizer,
						!0,
						this.biasConstraint
					);
				}
				this.built = !0;
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					if (3 !== e.length)
						throw new OF("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got " + e.length + ".");
					var r = t.training || !1,
						a = e[0],
						i = e[1],
						o = e[2];
					0 < n.dropout &&
						n.dropout < 1 &&
						null == n.dropoutMask &&
						(n.dropoutMask = Iz({
							ones: function () {
								return xC(a);
							},
							rate: n.dropout,
							training: r,
							count: 4,
							dropoutFunc: n.dropoutFunc,
						}));
					var s = n.dropoutMask,
						u = function (e, t, n) {
							return t && t[n] ? KI(t[n], e) : e;
						},
						l = u(a, s, 0),
						c = u(a, s, 1),
						p = u(a, s, 2),
						h = u(a, s, 3);
					0 < n.recurrentDropout &&
						n.recurrentDropout < 1 &&
						null == n.recurrentDropoutMask &&
						(n.recurrentDropoutMask = Iz({
							ones: function () {
								return xC(i);
							},
							rate: n.recurrentDropout,
							training: r,
							count: 4,
							dropoutFunc: n.dropoutFunc,
						}));
					var f = n.recurrentDropoutMask,
						d = u(i, f, 0),
						m = u(i, f, 1),
						g = u(i, f, 2),
						v = u(i, f, 3),
						y = wE(n.kernel.read(), 4, 3),
						b = y[0],
						x = y[1],
						w = y[2],
						k = y[3],
						N = n.useBias ? wE(n.bias.read(), 4) : [null, null, null, null],
						I = N[0],
						S = N[1],
						T = N[2],
						C = N[3];
					(l = n.inputConv(l, b, I, n.padding)),
						(c = n.inputConv(c, x, S, n.padding)),
						(p = n.inputConv(p, w, T, n.padding)),
						(h = n.inputConv(h, k, C, n.padding));
					var E = wE(n.recurrentKernel.read(), 4, 3),
						R = E[0],
						A = E[1],
						_ = E[2],
						F = E[3];
					(d = n.recurrentConv(d, R)),
						(m = n.recurrentConv(m, A)),
						(g = n.recurrentConv(g, _)),
						(v = n.recurrentConv(v, F));
					var D = n.recurrentActivation.apply(jI(l, d)),
						O = n.recurrentActivation.apply(jI(c, m)),
						M = jI(KI(O, o), KI(D, n.activation.apply(jI(p, g)))),
						L = KI(n.recurrentActivation.apply(jI(h, v)), n.activation.apply(M));
					return [L, L, M];
				});
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this),
					n =
						(t.units,
						(function (e, t) {
							var n = {};
							for (var r in e)
								Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
							if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
								var a = 0;
								for (r = Object.getOwnPropertySymbols(e); a < r.length; a++)
									t.indexOf(r[a]) < 0 &&
										Object.prototype.propertyIsEnumerable.call(e, r[a]) &&
										(n[r[a]] = e[r[a]]);
							}
							return n;
						})(t, ["units"])),
					r = {
						filters: this.filters,
						kernelSize: this.kernelSize,
						padding: this.padding,
						dataFormat: this.dataFormat,
						dilationRate: this.dilationRate,
						strides: this.strides,
					};
				return Object.assign({}, n, r);
			}),
			(n.inputConv = function (e, t, n, r) {
				var a = GS(
					e,
					t,
					this.strides,
					r || "valid",
					"channelsFirst" === this.dataFormat ? "NCHW" : "NHWC",
					this.dilationRate
				);
				return n ? HD(a, n, this.dataFormat) : a;
			}),
			(n.recurrentConv = function (e, t) {
				return GS(e, t, 1, "same", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC");
			}),
			t
		);
	})(wz);
	(Tz.className = "ConvLSTM2DCell"), AI(Tz);
	var Cz = (function (e) {
		function t(t) {
			var n = new Tz(t);
			return e.call(this, Object.assign({}, t, { cell: n })) || this;
		}
		return (
			gg(t, e),
			(t.fromConfig = function (e, t) {
				return new e(t);
			}),
			t
		);
	})(Sz);
	(Cz.className = "ConvLSTM2D"), AI(Cz);
	var Ez = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, t) || this).rate = Math.max(Math.min(t.rate, 1), 0)),
				(n.noiseShape = t.noiseShape),
				(n.seed = t.seed),
				(n.supportsMasking = !0),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.getNoiseShape = function (e) {
				if (null == this.noiseShape) return this.noiseShape;
				for (var t = e.shape, n = [], r = 0; r < this.noiseShape.length; ++r)
					n.push(null == this.noiseShape[r] ? t[r] : this.noiseShape[r]);
				return n;
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					n.invokeCallHook(e, t);
					var r = NO(e);
					if (0 < n.rate && n.rate < 1) {
						var a = null != t.training && t.training,
							i = n.getNoiseShape(r);
						return KD(
							function () {
								return qD(r, n.rate, i, n.seed);
							},
							function () {
								return r;
							},
							a
						);
					}
					return e;
				});
			}),
			(n.getConfig = function () {
				var t = { rate: this.rate, noiseShape: this.noiseShape, seed: this.seed },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			(n.dispose = function () {
				return e.prototype.dispose.call(this);
			}),
			t
		);
	})(MO);
	(Ez.className = "Dropout"), AI(Ez);
	var Rz = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this, t) || this).inputSpec = [{ ndim: 3 }]), n;
		}
		return (
			gg(t, e),
			(t.prototype.getNoiseShape = function (e) {
				var t = e.shape;
				return [t[0], 1, t[2]];
			}),
			t
		);
	})(Ez);
	(Rz.className = "SpatialDropout1D"), AI(Rz);
	var Az = (function (e) {
		function t(t) {
			var n;
			if (
				(((n = e.call(this, t) || this).activation = null),
				(n.useBias = !0),
				(n.kernel = null),
				(n.bias = null),
				(n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal"),
				(n.DEFAULT_BIAS_INITIALIZER = "zeros"),
				null == t.batchInputShape && null == t.inputShape && null != t.inputDim)
			) {
				var r = null;
				null != t.batchSize && (r = t.batchSize), (n.batchInputShape = [r, t.inputDim]);
			}
			return (
				(n.units = t.units),
				$F(n.units, "units"),
				(n.activation = ML(t.activation)),
				null != t.useBias && (n.useBias = t.useBias),
				(n.kernelInitializer = mO(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER)),
				(n.biasInitializer = mO(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER)),
				(n.kernelConstraint = pD(t.kernelConstraint)),
				(n.biasConstraint = pD(t.biasConstraint)),
				(n.kernelRegularizer = VL(t.kernelRegularizer)),
				(n.biasRegularizer = VL(t.biasRegularizer)),
				(n.activityRegularizer = VL(t.activityRegularizer)),
				(n.supportsMasking = !0),
				(n.inputSpec = [{ minNDim: 2 }]),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t,
					n = (e = IO(e))[e.length - 1];
				null == this.kernel &&
					((this.kernel = this.addWeight(
						"kernel",
						[n, this.units],
						null,
						this.kernelInitializer,
						this.kernelRegularizer,
						!0,
						this.kernelConstraint
					)),
					this.useBias &&
						(this.bias = this.addWeight(
							"bias",
							[this.units],
							null,
							this.biasInitializer,
							this.biasRegularizer,
							!0,
							this.biasConstraint
						))),
					(this.inputSpec = [{ minNDim: 2, axes: ((t = {}), (t[-1] = n), t) }]),
					(this.built = !0);
			}),
			(n.computeOutputShape = function (e) {
				var t = (e = IO(e)).slice();
				return (t[t.length - 1] = this.units), t;
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					n.invokeCallHook(e, t);
					var r,
						a = NO(e),
						i = tD(n.activation.getClassName());
					return (
						null != i
							? (r = UD(a, n.kernel.read(), i, n.bias ? n.bias.read() : null))
							: ((r = UD(a, n.kernel.read())),
							  null != n.bias && (r = HD(r, n.bias.read())),
							  null != n.activation && (r = n.activation.apply(r))),
						r
					);
				});
			}),
			(n.getConfig = function () {
				var t = {
						units: this.units,
						activation: DL(this.activation),
						useBias: this.useBias,
						kernelInitializer: dO(this.kernelInitializer),
						biasInitializer: dO(this.biasInitializer),
						kernelRegularizer: WL(this.kernelRegularizer),
						biasRegularizer: WL(this.biasRegularizer),
						activityRegularizer: WL(this.activityRegularizer),
						kernelConstraint: lD(this.kernelConstraint),
						biasConstraint: lD(this.biasConstraint),
					},
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(Az.className = "Dense"), AI(Az);
	var _z = (function (e) {
		function t(t) {
			var n;
			return (
				(t = t || {}),
				((n = e.call(this, t) || this).inputSpec = [{ minNDim: 3 }]),
				(n.dataFormat = t.dataFormat),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.computeOutputShape = function (e) {
				for (var t, n = Ig((e = IO(e)).slice(1)); !(t = n()).done; )
					if (null == t.value)
						throw new OF(
							'The shape of the input to "Flatten" is not fully defined (got ' +
								e.slice(1) +
								'). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.'
						);
				return [e[0], ED(e, 1)];
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					n.invokeCallHook(e, t);
					var r = NO(e);
					if ("channelsFirst" === n.dataFormat && r.rank > 1) {
						for (var a = [0], i = 2; i < r.rank; ++i) a.push(i);
						a.push(1), (r = qN(r, a));
					}
					return (function (e) {
						if (e.rank <= 1)
							throw new OF("batchFlatten requires a minimum rank of 2. Got rank: " + e.rank + ".");
						var t = [e.shape[0], ED(e.shape, 1)];
						return wS(e, t);
					})(r);
				});
			}),
			(n.getConfig = function () {
				var t = {};
				null != this.dataFormat && (t.dataFormat = this.dataFormat);
				var n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(_z.className = "Flatten"), AI(_z);
	var Fz = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this, t) || this).supportsMasking = !0), (n.activation = ML(t.activation)), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					n.invokeCallHook(e, t);
					var r = NO(e);
					return n.activation.apply(r);
				});
			}),
			(n.getConfig = function () {
				var t = { activation: DL(this.activation) },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(Fz.className = "Activation"), AI(Fz);
	var Dz = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this, t) || this).n = t.n), (n.inputSpec = [{ ndim: 2 }]), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.computeOutputShape = function (e) {
				return [e[0], this.n, e[1]];
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					return (
						(e = NO(e)),
						(t = e),
						(r = n.n),
						BI(function () {
							if (2 !== t.shape.length)
								throw new OF(
									"repeat() expects a rank-2 tensor, but received a rank-" +
										t.shape.length +
										" tensor."
								);
							return BD(DD(t, 1), [1, r, 1]);
						})
					);
					var t, r;
				});
			}),
			(n.getConfig = function () {
				var t = { n: this.n },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(Dz.className = "RepeatVector"), AI(Dz);
	var Oz = (function (e) {
		function t(t) {
			var n;
			(n = e.call(this, t) || this).targetShape = t.targetShape;
			for (var r = 0; r < n.targetShape.length; ++r) n.isUnknown(n.targetShape[r]) && (n.targetShape[r] = null);
			return n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.isUnknown = function (e) {
				return e < 0 || null == e;
			}),
			(n.fixUnknownDimension = function (e, t) {
				for (
					var n = "Total size of new array must be unchanged.", r = t.slice(), a = 1, i = null, o = 0;
					o < r.length;
					++o
				) {
					var s = r[o];
					if (this.isUnknown(s)) {
						if (null !== i) throw new OF("Can only specifiy one unknown dimension.");
						i = o;
					} else a *= s;
				}
				var u = ED(e);
				if (null !== i) {
					if (0 === a || u % a != 0) throw new OF(n);
					r[i] = u / a;
				} else if (u !== a) throw new OF(n);
				return r;
			}),
			(n.computeOutputShape = function (e) {
				for (var t = !1, n = 0; n < e.length; ++n)
					if (this.isUnknown(e[n])) {
						t = !0;
						break;
					}
				return t
					? e.slice(0, 1).concat(this.targetShape)
					: e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					n.invokeCallHook(e, t);
					var r = NO(e),
						a = r.shape,
						i = a.slice(0, 1).concat(n.fixUnknownDimension(a.slice(1), n.targetShape));
					return wS(r, i);
				});
			}),
			(n.getConfig = function () {
				var t = { targetShape: this.targetShape },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(Oz.className = "Reshape"), AI(Oz);
	var Mz = (function (e) {
		function t(t) {
			var n;
			if (((n = e.call(this, t) || this), null == t.dims))
				throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
			if (!Array.isArray(t.dims))
				throw new Error(
					"Permute constructor requires `dims` to be an Array, but received " + t.dims + " instead."
				);
			var r = _D(1, t.dims.length + 1);
			if (!Pg(t.dims.slice().sort(), r))
				throw new Error(
					"Invalid permutation `dims`: " +
						JSON.stringify(t.dims) +
						" `dims` must contain consecutive integers starting from 1."
				);
			return (
				(n.dims = t.dims),
				(n.dimsIncludingBatch = [0].concat(n.dims)),
				(n.inputSpec = [new AO({ ndim: n.dims.length + 1 })]),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.computeOutputShape = function (e) {
				var t = (e = IO(e)).slice();
				return (
					this.dims.forEach(function (n, r) {
						t[r + 1] = e[n];
					}),
					t
				);
			}),
			(n.call = function (e, t) {
				return qN(NO(e), this.dimsIncludingBatch);
			}),
			(n.getConfig = function () {
				var t = { dims: this.dims },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(Mz.className = "Permute"), AI(Mz);
	var Lz = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, null == t ? {} : t) || this).supportsMasking = !0),
				(n.maskValue = null != t ? (null == t.maskValue ? 0 : t.maskValue) : 0),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.computeOutputShape = function (e) {
				return e;
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this),
					n = { maskValue: this.maskValue };
				return Object.assign(n, t), n;
			}),
			(n.computeMask = function (e, t) {
				var n = NO(e);
				return $I(bC(n, this.maskValue), -1);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					n.invokeCallHook(e, t);
					var r = NO(e),
						a = $I(bC(r, n.maskValue), -1, !0);
					return KI(r, NN(a, r.dtype));
				});
			}),
			t
		);
	})(MO);
	(Lz.className = "Masking"), AI(Lz);
	var zz = (function (e) {
		function t(t) {
			var n;
			if (
				(((n = e.call(this, t) || this).embeddings = null),
				(n.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform"),
				null == t.batchInputShape && null == t.inputShape)
			) {
				var r = null;
				null != t.batchSize && (r = t.batchSize),
					null == t.inputLength
						? (n.batchInputShape = [r, null])
						: (n.batchInputShape = [r].concat(UF(t.inputLength)));
			}
			return (
				(n.inputDim = t.inputDim),
				$F(n.inputDim, "inputDim"),
				(n.outputDim = t.outputDim),
				$F(n.outputDim, "outputDim"),
				(n.embeddingsInitializer = mO(t.embeddingsInitializer || n.DEFAULT_EMBEDDINGS_INITIALIZER)),
				(n.embeddingsRegularizer = VL(t.embeddingsRegularizer)),
				(n.activityRegularizer = VL(t.activityRegularizer)),
				(n.embeddingsConstraint = pD(t.embeddingsConstraint)),
				(n.maskZero = t.maskZero),
				(n.supportsMasking = t.maskZero),
				(n.inputLength = t.inputLength),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				(this.embeddings = this.addWeight(
					"embeddings",
					[this.inputDim, this.outputDim],
					this.dtype,
					this.embeddingsInitializer,
					this.embeddingsRegularizer,
					!0,
					this.embeddingsConstraint
				)),
					(this.built = !0);
			}),
			(n.warnOnIncompatibleInputShape = function (e) {}),
			(n.computeMask = function (e, t) {
				var n = this;
				return BI(function () {
					return n.maskZero ? ((e = NO(e)), bC(e, sT(e))) : null;
				});
			}),
			(n.computeOutputShape = function (e) {
				if (((e = IO(e)), null == this.inputLength)) return [].concat(e, [this.outputDim]);
				var t = UF(this.inputLength);
				if (t.length !== e.length - 1)
					throw new OF('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e);
				for (var n = 0, r = 0; r < t.length; ++r) {
					var a = t[r],
						i = e[r + 1];
					if (null != a && null != i && a !== i)
						throw new OF(
							'"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e
						);
					null == a && (t[n] = i), n++;
				}
				return [e[0]].concat(t, [this.outputDim]);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					n.invokeCallHook(e, t);
					var r = NO(e);
					"int32" !== r.dtype && (r = FD(r, "int32"));
					var a = VD(n.embeddings.read(), wS(r, [r.size]));
					return wS(a, IO(n.computeOutputShape(r.shape)));
				});
			}),
			(n.getConfig = function () {
				var t = {
						inputDim: this.inputDim,
						outputDim: this.outputDim,
						embeddingsInitializer: dO(this.embeddingsInitializer),
						embeddingsRegularizer: WL(this.embeddingsRegularizer),
						activityRegularizer: WL(this.activityRegularizer),
						embeddingsConstraint: lD(this.embeddingsConstraint),
						maskZero: this.maskZero,
						inputLength: this.inputLength,
					},
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(zz.className = "Embedding"), AI(zz);
	var Pz = (function (e) {
			function t(t) {
				var n;
				return ((n = e.call(this, t || {}) || this).supportsMasking = !0), n;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.mergeFunction = function (e) {
					throw new MF();
				}),
				(n.computeElementwiseOpOutputShape = function (e, t) {
					if (null == e || null == t) return null;
					if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
					if (0 === t.length) return e;
					for (var n = e.slice(0, e.length - t.length), r = 0; r < t.length; ++r) {
						var a = e[e.length - t.length + r],
							i = t[r];
						if (null == a || null == i || a < 0 || i < 0) n.push(null);
						else if (1 === a) n.push(i);
						else if (1 === i) n.push(a);
						else {
							if (a !== i)
								throw new OF(
									"Operands could not be broadcast together with shapes " +
										JSON.stringify(e) +
										" " +
										JSON.stringify(t)
								);
							n.push(a);
						}
					}
					return n;
				}),
				(n.build = function (e) {
					if ((Array.isArray(e) && !Array.isArray(e[0]) && (e = [IO(e)]), (e = e).length < 2))
						throw new OF(
							"A merge layer should be called on an Array of at least 2 inputs. Got " +
								e.length +
								" input(s)."
						);
					for (var t, n = [], r = Ig(e); !(t = r()).done; ) {
						var a = t.value;
						null != a && null !== a[0] && n.push(a[0]);
					}
					if ((n = YF(n)).length > 1)
						throw new OF(
							"Can not merge tensors with different batch sizes. Got tensors with shapes: " +
								JSON.stringify(e) +
								"."
						);
					for (var i = null == e[0] ? null : e[0].slice(1), o = 1; o < e.length; ++o) {
						var s = null == e[o] ? null : e[o].slice(1);
						i = this.computeElementwiseOpOutputShape(i, s);
					}
					var u = e.map(function (e) {
						return e.length;
					});
					-1 === e.indexOf(null) && 1 === YF(u).length
						? (this.reshapeRequired = !1)
						: (this.reshapeRequired = !0);
				}),
				(n.call = function (e, t) {
					var n = this;
					return BI(function () {
						if (((e = e), n.reshapeRequired)) {
							var t = [],
								r = e.map(function (e) {
									return e.rank;
								});
							if (-1 === r.indexOf(null)) {
								for (var a, i = AD(r), o = Ig(e); !(a = o()).done; ) {
									for (var s = a.value, u = s.rank, l = 0; l < i - u; ++l) s = DD(s, 1);
									t.push(s);
								}
								return n.mergeFunction(t);
							}
							for (var c, p = !1, h = Ig(e); !(c = h()).done; ) {
								var f = c.value,
									d = f.rank;
								if (null == d) {
									var m = f.shape,
										g = m[0],
										v = m.slice(1).concat([g]),
										y = wS(f, [g].concat(ED(m.slice(1))));
									(y = qN(y, [1, 0])), (y = wS(y, v)), t.push(y), (p = !0);
								} else if (d > 1) {
									var b = _D(1, d).concat([0]);
									t.push(qN(f, b)), (p = !0);
								} else t.push(f);
							}
							var x = n.mergeFunction(t),
								w = x.rank;
							if (p)
								if (null == w) {
									var k = x.shape,
										N = k[k.length - 1],
										I = [N].concat(k.slice(0, k.length - 1));
									x = wS(qN(wS(x, [-1, N]), [1, 0]), I);
								} else if (w > 1) {
									var S = [w - 1].concat(_D(0, w - 1));
									x = qN(x, S);
								}
							return x;
						}
						return n.mergeFunction(e);
					});
				}),
				(n.computeOutputShape = function (e) {
					var t;
					t = null == (e = e)[0] ? null : e[0].slice(1);
					for (var n = 1; n < e.length; ++n) {
						var r = null == e[n] ? null : e[n].slice(1);
						t = this.computeElementwiseOpOutputShape(t, r);
					}
					for (var a, i = [], o = Ig(e); !(a = o()).done; ) {
						var s = a.value;
						null != s && null !== s[0] && i.push(s[0]);
					}
					return 1 === (i = YF(i)).length ? i.concat(t) : [null].concat(t);
				}),
				(n.computeMask = function (e, t) {
					return BI(function () {
						if (null == t) return null;
						if (!Array.isArray(t)) throw new OF("`mask` should be an Array");
						if (!Array.isArray(e)) throw new OF("`inputs` should be an Array");
						if (t.length !== e.length)
							throw new OF(
								"The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (" +
									e.length +
									" vs " +
									t.length +
									")"
							);
						if (
							t.every(function (e) {
								return null == e;
							})
						)
							return null;
						for (
							var n = (t = t.map(function (e) {
									return null == e ? e : dT(e, 0);
								}))[0],
								r = 1;
							r < t.length - 1;
							++r
						)
							n = $T(n, t[r]);
						return n;
					});
				}),
				t
			);
		})(MO),
		Bz = (function (e) {
			function t(t) {
				return e.call(this, t) || this;
			}
			return (
				gg(t, e),
				(t.prototype.mergeFunction = function (e) {
					return BI(function () {
						for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = jI(t, e[n]);
						return t;
					});
				}),
				t
			);
		})(Pz);
	(Bz.className = "Add"), AI(Bz);
	var Wz = (function (e) {
		function t(t) {
			return e.call(this, t) || this;
		}
		return (
			gg(t, e),
			(t.prototype.mergeFunction = function (e) {
				return BI(function () {
					for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = KI(t, e[n]);
					return t;
				});
			}),
			t
		);
	})(Pz);
	(Wz.className = "Multiply"), AI(Wz);
	var Uz = (function (e) {
		function t(t) {
			return e.call(this, t) || this;
		}
		return (
			gg(t, e),
			(t.prototype.mergeFunction = function (e) {
				return BI(function () {
					for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = jI(t, e[n]);
					return KI(1 / e.length, t);
				});
			}),
			t
		);
	})(Pz);
	(Uz.className = "Average"), AI(Uz);
	var Vz = (function (e) {
		function t(t) {
			return e.call(this, t) || this;
		}
		return (
			gg(t, e),
			(t.prototype.mergeFunction = function (e) {
				return BI(function () {
					for (var t = e[0], n = 1; n < e.length; ++n) t = oC(t, e[n]);
					return t;
				});
			}),
			t
		);
	})(Pz);
	(Vz.className = "Maximum"), AI(Vz);
	var Gz = (function (e) {
		function t(t) {
			return e.call(this, t) || this;
		}
		return (
			gg(t, e),
			(t.prototype.mergeFunction = function (e) {
				return BI(function () {
					for (var t = e[0], n = 1; n < e.length; ++n) t = hC(t, e[n]);
					return t;
				});
			}),
			t
		);
	})(Pz);
	(Gz.className = "Minimum"), AI(Gz);
	var jz = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, t) || this).DEFAULT_AXIS = -1),
				null == t && (t = {}),
				(n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis),
				(n.supportsMasking = !0),
				(n.reshapeRequired = !1),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length)
					throw new OF("A `Concatenate` layer should be called on a list of at least 2 inputs");
				for (var t, n = !0, r = Ig((e = e)); !(t = r()).done; )
					if (null != t.value) {
						n = !1;
						break;
					}
				if (!n) {
					for (var a = [], i = 0; i < e.length; ++i) {
						var o = e[i].slice();
						o.splice(this.axis, 1);
						for (var s, u = !1, l = Ig(a); !(s = l()).done; )
							if (Pg(s.value, o)) {
								u = !0;
								break;
							}
						u || a.push(o);
					}
					if (a.length > 1)
						throw new OF(
							"A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " +
								JSON.stringify(e)
						);
				}
			}),
			(n.mergeFunction = function (e) {
				var t = this;
				return BI(function () {
					return zD(e, t.axis);
				});
			}),
			(n.computeOutputShape = function (e) {
				if (!Array.isArray(e) || !Array.isArray(e[0]))
					throw new OF("A `Concatenate` layer should be called on a list of inputs.");
				for (
					var t,
						n = e,
						r = n[0].slice(),
						a = this.axis < 0 ? r.length + this.axis : this.axis,
						i = Ig(n.slice(1));
					!(t = i()).done;

				) {
					var o = t.value;
					if (null == r[a] || null == o[a]) {
						r[a] = null;
						break;
					}
					r[a] += o[a];
				}
				return r;
			}),
			(n.computeMask = function (e, t) {
				var n = this;
				if (null == t) return null;
				if (!Array.isArray(t)) throw new OF("`mask` should be an array for Concatenate");
				if (!Array.isArray(e)) throw new OF("`inputs` should be an array for Concatenate");
				if (t.length !== e.length)
					throw new OF(
						"Mismatch in the length of mask (" + t.length + ") and the legnth of inputs (" + e.length + ")"
					);
				return BI(function () {
					var r = !0;
					if (
						(t.forEach(function (e) {
							null == e || (r = !1);
						}),
						r)
					)
						return null;
					for (var a = [], i = 0; i < e.length; ++i)
						null == t[i]
							? a.push(NN(xC(e[i]), "bool"))
							: t[i].rank < e[i].rank
							? a.push(dT(t[i], -1))
							: a.push(t[i]);
					var o = IS(a, n.axis);
					return QI(o, -1, !1);
				});
			}),
			(n.getConfig = function () {
				var t = { axis: this.axis },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(Pz);
	function Hz(e, t) {
		for (; e < 0; ) e += t;
		return e;
	}
	(jz.className = "Concatenate"), AI(jz);
	var qz = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, t) || this).axes = t.axes),
				(n.normalize = null != t.normalize && t.normalize),
				(n.supportsMasking = !0),
				(n.reshapeRequired = !1),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				Dg(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
					return "A `Dot` layer should be called on a list of exactly 2 inputs.";
				});
				var t = e[0],
					n = e[1];
				if (t.length > 3 || n.length > 3)
					throw new MF("Dot layer does not support tensors of 4D or higher rank yet.");
				var r = this.interpretAxes(t, n);
				if (t[r[0]] !== n[r[1]]) throw new OF("Dimension incompatibility: " + t[r[0]] + " !== " + n[r[1]]);
			}),
			(n.mergeFunction = function (e) {
				if (2 !== e.length)
					throw new OF(
						"A `Dot` layer must be called on exactly 2 inputs, but received " + e.length + " input(s)."
					);
				var t,
					n = e[0],
					r = e[1];
				return (
					(t = Array.isArray(this.axes)
						? this.axes.map(function (t, n) {
								return Hz(t, e[n].shape.length);
						  })
						: [Hz(this.axes, n.shape.length), Hz(this.axes, r.shape.length)]),
					this.normalize && ((n = QO(n, t[0])), (r = QO(r, t[1]))),
					(function (e, t, n) {
						if (e.shape.length > 3 || t.shape.length > 3)
							throw new MF("batchDot is not implemented for tensors of 4D or higher rank yet");
						if (
							(Dg(e.shape.length >= 2, function () {
								return "batchDot requires the rank of x to be >= 2, but got " + e.shape.length;
							}),
							Dg(e.shape.length >= 2, function () {
								return "batchDot requires the rank of y to be >= 2, but got " + t.shape.length;
							}),
							"number" == typeof n && (n = [n, n]),
							"complex64" === e.dtype || "complex64" === t.dtype)
						)
							throw new MF("batchDot is not implemented for complex64-type Tensors yet.");
						var r = e.shape.length,
							a = t.shape.length;
						null == n && (n = [r - 1, a - 2]);
						var i = n;
						return BI(function () {
							var n, o;
							if (r > a) {
								n = r - a;
								for (var s = [], u = 0; u < n; ++u) s.push(1);
								t = wS(t, t.shape.concat(s));
							} else if (a > r) {
								n = a - r;
								for (var l = [], c = 0; c < n; ++c) l.push(1);
								e = wS(e, e.shape.concat(l));
							} else n = 0;
							if (2 === e.shape.length && 2 === t.shape.length)
								o = i[0] === i[1] ? VT(KI(e, t), i[0]) : VT(KI(qN(e, [1, 0]), t), i[1]);
							else {
								var p = i[0] !== e.shape.length - 1,
									h = i[1] === t.shape.length - 1;
								o = jN(e, t, p, h);
							}
							if (n > 0) {
								for (var f, d = [], m = (f = r > a ? r + a - 3 : r - 1); m < f + n; ++m) d.push(m);
								o = SE(o, d);
							}
							return 1 === o.shape.length && (o = dT(o, 1)), o;
						});
					})(n, r, t)
				);
			}),
			(n.interpretAxes = function (e, t) {
				return Array.isArray(this.axes) ? this.axes : [Hz(this.axes, e.length), Hz(this.axes, t.length)];
			}),
			(n.computeOutputShape = function (e) {
				Dg(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
					return "A `Dot` layer should be called on a list of exactly 2 inputs.";
				});
				var t = e[0].slice(),
					n = e[1].slice();
				if (t.length > 3 || n.length > 3)
					throw new MF("Dot layer does not support tensors of 4D or higher rank yet.");
				var r = this.interpretAxes(t, n);
				t.splice(r[0], 1), n.splice(r[1], 1), n.splice(0, 1);
				var a = t.concat(n);
				return 1 === a.length && a.push(1), a;
			}),
			(n.computeMask = function (e, t) {
				return null;
			}),
			(n.getConfig = function () {
				var t = { axes: this.axes, normalize: this.normalize },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(Pz);
	(qz.className = "Dot"), AI(qz);
	var Kz = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this, t) || this).supportsMasking = !0), (n.stddev = t.stddev), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.computeOutputShape = function (e) {
				return e;
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this),
					n = { stddev: this.stddev };
				return Object.assign(n, t), n;
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					n.invokeCallHook(e, t);
					var r = NO(e);
					return KD(
						function () {
							return jI(WD(r.shape, 0, n.stddev), r);
						},
						function () {
							return r;
						},
						t.training || !1
					);
				});
			}),
			t
		);
	})(MO);
	(Kz.className = "GaussianNoise"), AI(Kz);
	var Xz = (function (e) {
		function t(t) {
			var n;
			return ((n = e.call(this, t) || this).supportsMasking = !0), (n.rate = t.rate), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.computeOutputShape = function (e) {
				return e;
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this),
					n = { rate: this.rate };
				return Object.assign(n, t), n;
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					n.invokeCallHook(e, t);
					var r = NO(e);
					return n.rate > 0 && n.rate < 1
						? KD(
								function () {
									var e = Math.sqrt(n.rate / (1 - n.rate));
									return KI(r, WD(r.shape, 1, e));
								},
								function () {
									return r;
								},
								t.training || !1
						  )
						: r;
				});
			}),
			t
		);
	})(MO);
	(Xz.className = "GaussianDropout"), AI(Xz);
	var Yz = (function (e) {
		function t(t) {
			var n;
			return (
				((n = e.call(this, t) || this).supportsMasking = !0),
				(n.rate = t.rate),
				(n.noiseShape = t.noiseShape),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n._getNoiseShape = function (e) {
				return this.noiseShape || NO(e).shape;
			}),
			(n.computeOutputShape = function (e) {
				return e;
			}),
			(n.getConfig = function () {
				var t = e.prototype.getConfig.call(this),
					n = { rate: this.rate };
				return Object.assign(n, t), n;
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					if (n.rate < 1 && n.rate > 0) {
						var r = n._getNoiseShape(e);
						return KD(
							function () {
								var t = NO(e),
									a = -1.7580993408473766,
									i = kT(qC(r), n.rate);
								i = FD(i, "float32");
								var o = Math.pow((1 - n.rate) * (1 + n.rate * Math.pow(a, 2)), -0.5),
									s = -o * a * n.rate,
									u = jI(KI(t, i), KI(jI(i, -1), a));
								return jI(KI(u, o), s);
							},
							function () {
								return NO(e);
							},
							t.training || !1
						);
					}
					return e;
				});
			}),
			t
		);
	})(MO);
	function Jz(e, t, n, r, a, i) {
		var o;
		if ((void 0 === i && (i = 0.001), 2 === e.rank)) o = _S(e, t, n, r, a, i);
		else if (3 === e.rank) o = FS(e, t, n, r, a, i);
		else {
			if (4 !== e.rank)
				throw new MF("batchNormalization is not implemented for array of rank " + e.rank + " yet");
			o = DS(e, t, n, r, a, i);
		}
		return o;
	}
	(Yz.className = "AlphaDropout"), AI(Yz);
	var Zz = (function (e) {
		function t(t) {
			var n;
			return (
				null == t && (t = {}),
				((n = e.call(this, t) || this).supportsMasking = !0),
				(n.axis = null == t.axis ? -1 : t.axis),
				(n.momentum = null == t.momentum ? 0.99 : t.momentum),
				(n.epsilon = null == t.epsilon ? 0.001 : t.epsilon),
				(n.center = null == t.center || t.center),
				(n.scale = null == t.scale || t.scale),
				(n.betaInitializer = mO(t.betaInitializer || "zeros")),
				(n.gammaInitializer = mO(t.gammaInitializer || "ones")),
				(n.movingMeanInitializer = mO(t.movingMeanInitializer || "zeros")),
				(n.movingVarianceInitializer = mO(t.movingVarianceInitializer || "ones")),
				(n.betaConstraint = pD(t.betaConstraint)),
				(n.gammaConstraint = pD(t.gammaConstraint)),
				(n.betaRegularizer = VL(t.betaRegularizer)),
				(n.gammaRegularizer = VL(t.gammaRegularizer)),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t;
				e = IO(e);
				var n = this.axis >= 0 ? this.axis : this.axis + e.length,
					r = e[n];
				if (null == r)
					throw new OF(
						"Axis " +
							n +
							" of input tensor should have a defined dimension but the layer received an input with shape " +
							JSON.stringify(e) +
							"."
					);
				this.inputSpec = [new AO({ ndim: e.length, axes: ((t = {}), (t[n] = r), t) })];
				var a = [r];
				this.scale &&
					(this.gamma = this.addWeight(
						"gamma",
						a,
						null,
						this.gammaInitializer,
						this.gammaRegularizer,
						!0,
						this.gammaConstraint
					)),
					this.center &&
						(this.beta = this.addWeight(
							"beta",
							a,
							null,
							this.betaInitializer,
							this.betaRegularizer,
							!0,
							this.betaConstraint
						)),
					(this.movingMean = this.addWeight("moving_mean", a, null, this.movingMeanInitializer, null, !1)),
					(this.movingVariance = this.addWeight(
						"moving_variance",
						a,
						null,
						this.movingVarianceInitializer,
						null,
						!1
					)),
					(this.built = !0);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					var r = null != t.training && t.training,
						a = NO(e),
						i = a.shape,
						o = i.length,
						s = _D(0, o),
						u = n.axis >= 0 ? n.axis : n.axis + o;
					s.splice(u, 1);
					var l = zF(1, o);
					l[u] = i[u];
					var c = s.slice();
					c.sort();
					var p = !Pg(c, _D(0, o).slice(0, o - 1));
					if (!r)
						return (function () {
							if (p) {
								var e = wS(n.movingMean.read(), l),
									t = wS(n.movingVariance.read(), l),
									r = n.center ? wS(n.beta.read(), l) : null,
									i = n.scale ? wS(n.gamma.read(), l) : null;
								return Jz(a, e, t, r, i, n.epsilon);
							}
							return Jz(
								a,
								n.movingMean.read(),
								n.movingVariance.read(),
								null == n.beta ? null : n.beta.read(),
								null == n.gamma ? null : n.gamma.read(),
								n.epsilon
							);
						})();
					var h = (function (e, t, n, r, a) {
							return (
								void 0 === a && (a = 0.001),
								Pg(r.slice().sort(), _D(0, e.rank - 1))
									? (function (e, t, n, r, a) {
											return (
												void 0 === a && (a = 0.001),
												BI(function () {
													var i = gC(e, r),
														o = i.mean,
														s = i.variance;
													return [Jz(e, o, s, n, t, a), o, s];
												})
											);
									  })(e, t, n, r, a)
									: (function (e, t, n, r, a) {
											return (
												void 0 === a && (a = 0.001),
												BI(function () {
													for (
														var i,
															o = gC(e, r),
															s = o.mean,
															u = o.variance,
															l = [],
															c = Ig(_D(0, e.rank));
														!(i = c()).done;

													) {
														var p = i.value;
														-1 !== r.indexOf(p) ? l.push(1) : l.push(e.shape[p]);
													}
													var h = wS(s, l),
														f = wS(u, l),
														d = null == t ? null : wS(t, l),
														m = null == n ? null : wS(n, l);
													return [Jz(e, h, f, m, d, a), s, u];
												})
											);
									  })(e, t, n, r, a)
							);
						})(a, n.gamma.read(), n.beta.read(), s, n.epsilon),
						f = h[0],
						d = h[1],
						m = h[2],
						g = function (e, t, n) {
							BI(function () {
								var r = 1 - n,
									a = e.read(),
									i = KI(UT(a, t), r);
								e.write(UT(a, i));
							});
						};
					return g(n.movingMean, d, n.momentum), g(n.movingVariance, m, n.momentum), f;
				});
			}),
			(n.getConfig = function () {
				var t = {
						axis: this.axis,
						momentum: this.momentum,
						epsilon: this.epsilon,
						center: this.center,
						scale: this.scale,
						betaInitializer: dO(this.betaInitializer),
						gammaInitializer: dO(this.gammaInitializer),
						movingMeanInitializer: dO(this.movingMeanInitializer),
						movingVarianceInitializer: dO(this.movingVarianceInitializer),
						betaRegularizer: WL(this.betaRegularizer),
						gammaRegularizer: WL(this.gammaRegularizer),
						betaConstraint: lD(this.betaConstraint),
						gammaConstraint: lD(this.gammaConstraint),
					},
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(Zz.className = "BatchNormalization"), AI(Zz);
	var Qz = (function (e) {
		function t(t) {
			var n;
			if (
				(null == t && (t = {}),
				((n = e.call(this, t) || this).axis = null == t.axis ? -1 : t.axis),
				"number" == typeof n.axis)
			) {
				if (!Number.isInteger(n.axis))
					throw new Error("Expected axis to be an integer, but received " + n.axis);
			} else {
				if (!Array.isArray(n.axis))
					throw new Error(
						"Expected axis to be an integer or an array of integers, but received " + JSON.stringify(n.axis)
					);
				for (var r, a = Ig(n.axis); !(r = a()).done; ) {
					var i = r.value;
					if (!Number.isInteger(i))
						throw new Error(
							"Expected axis to be an array of integers, but received " + JSON.stringify(n.axis)
						);
				}
			}
			return (
				(n.epsilon = null == t.epsilon ? 0.001 : t.epsilon),
				(n.center = null == t.center || t.center),
				(n.scale = null == t.scale || t.scale),
				(n.betaInitializer = mO(t.betaInitializer || "zeros")),
				(n.gammaInitializer = mO(t.gammaInitializer || "ones")),
				(n.betaRegularizer = VL(t.betaRegularizer)),
				(n.gammaRegularizer = VL(t.gammaRegularizer)),
				(n.supportsMasking = !0),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.build = function (e) {
				var t = (e = IO(e)).length;
				"number" == typeof this.axis && (this.axis = [this.axis]);
				for (var n = 0; n < this.axis.length; ++n) this.axis[n] < 0 && (this.axis[n] += t);
				for (var r, a = Ig(this.axis); !(r = a()).done; ) {
					var i = r.value;
					if (i < 0 || i >= t) throw new Error("Invalid axis: " + i);
				}
				if (this.axis.length !== YF(this.axis).length) throw new Error("Found duplicate axes in: " + this.axis);
				var o = this.axis.map(function (t) {
					return e[t];
				});
				this.scale
					? (this.gamma = this.addWeight(
							"gamma",
							o,
							"float32",
							this.gammaInitializer,
							this.gammaRegularizer,
							!0
					  ))
					: (this.gamma = null),
					this.center
						? (this.beta = this.addWeight(
								"beta",
								o,
								"float32",
								this.betaInitializer,
								this.betaRegularizer,
								!0
						  ))
						: (this.beta = null),
					(this.built = !0);
			}),
			(n.call = function (e, t) {
				var n = this,
					r = NO(e),
					a = r.shape,
					i = a.length;
				return BI(function () {
					for (
						var e, t = gC(r, n.axis, !0), o = t.mean, s = t.variance, u = zF(1, i), l = Ig(n.axis);
						!(e = l()).done;

					) {
						var c = e.value;
						u[c] = a[c];
					}
					for (
						var p = function (e) {
								return null != e && e.shape.length !== i ? wS(e, u) : e;
							},
							h = p(n.gamma.read()),
							f = p(n.beta.read()),
							d = [],
							m = [],
							g = 0;
						g < i;
						++g
					)
						-1 !== n.axis.indexOf(g) ? (d.push(a[g]), m.push(1)) : (d.push(1), m.push(a[g]));
					return (o = gT(o, d)), (s = gT(s, d)), (h = gT(h, m)), (f = gT(f, m)), Jz(r, o, s, f, h, n.epsilon);
				});
			}),
			(n.getConfig = function () {
				var t = {
						axis: this.axis,
						epsilon: this.epsilon,
						center: this.center,
						scale: this.scale,
						betaInitializer: dO(this.betaInitializer),
						gammaInitializer: dO(this.gammaInitializer),
						betaRegularizer: WL(this.betaRegularizer),
						gammaRegularizer: WL(this.gammaRegularizer),
					},
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	(Qz.className = "LayerNormalization"), AI(Qz);
	var $z = (function (e) {
		function t(t) {
			var n;
			if (
				(null == t && (t = {}),
				((n = e.call(this, t) || this).dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat),
				null == t.padding)
			)
				n.padding = [
					[1, 1],
					[1, 1],
				];
			else if ("number" == typeof t.padding)
				n.padding = [
					[t.padding, t.padding],
					[t.padding, t.padding],
				];
			else {
				if (((t.padding = t.padding), 2 !== t.padding.length))
					throw new OF(
						"ZeroPadding2D expects padding to be a length-2 array, but received a length-" +
							t.padding.length +
							" array."
					);
				var r, a;
				if ("number" == typeof t.padding[0])
					(r = [t.padding[0], t.padding[0]]), (a = [t.padding[1], t.padding[1]]);
				else {
					if (((t.padding = t.padding), 2 !== t.padding[0].length))
						throw new OF(
							"ZeroPadding2D expects height padding to be a length-2 array, but received a length-" +
								t.padding[0].length +
								" array."
						);
					if (((r = t.padding[0]), 2 !== t.padding[1].length))
						throw new OF(
							"ZeroPadding2D expects width padding to be a length-2 array, but received a length-" +
								t.padding[1].length +
								" array."
						);
					a = t.padding[1];
				}
				n.padding = [r, a];
			}
			return (n.inputSpec = [new AO({ ndim: 4 })]), n;
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.computeOutputShape = function (e) {
				var t, n;
				return (
					(e = IO(e)),
					"channelsFirst" === this.dataFormat
						? ((t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null),
						  (n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null),
						  [e[0], e[1], t, n])
						: ((t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null),
						  (n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null),
						  [e[0], t, n, e[3]])
				);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					return (
						(t = NO(e)),
						(r = n.padding),
						(a = n.dataFormat),
						BI(function () {
							if (4 !== t.rank)
								throw new OF(
									"temporalPadding expects input tensor to be 4-D, but received a " +
										t.rank +
										"-D tensor."
								);
							if (
								(null == r &&
									(r = [
										[1, 1],
										[1, 1],
									]),
								2 !== r.length || 2 !== r[0].length || 2 !== r[1].length)
							)
								throw new OF(
									"spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers."
								);
							if ((null == a && (a = "channelsLast"), "channelsLast" !== a && "channelsFirst" !== a))
								throw new OF(
									"Unknown data format: " +
										a +
										". Supported data formats are 'channelsLast' and 'channelsFirst."
								);
							var e;
							return (
								(e =
									"channelsFirst" === a
										? [[0, 0], [0, 0], r[0], r[1]]
										: [[0, 0], r[0], r[1], [0, 0]]),
								kC(t, e)
							);
						})
					);
					var t, r, a;
				});
			}),
			(n.getConfig = function () {
				var t = { padding: this.padding, dataFormat: this.dataFormat },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			t
		);
	})(MO);
	function eP(e, t, n, r, a, i) {
		return BI(function () {
			var o;
			bD(a),
				wD(i),
				xD(r),
				null == n && (n = [1, 1]),
				null == r && (r = "valid"),
				null == a && (a = "channelsLast"),
				null == i && (i = "max"),
				(e = QL(e, a));
			var s = "same" === r ? "same" : "valid";
			return (
				(o = "max" === i ? rC(e, t, n, s) : kS(e, t, n, s)),
				"channelsFirst" === a && (o = qN(o, [0, 3, 1, 2])),
				o
			);
		});
	}
	function tP(e, t, n, r, a, i) {
		return BI(function () {
			var o;
			bD(a),
				wD(i),
				xD(r),
				null == n && (n = [1, 1, 1]),
				null == r && (r = "valid"),
				null == a && (a = "channelsLast"),
				null == i && (i = "max"),
				(e = $L(e, a));
			var s = "same" === r ? "same" : "valid";
			return (
				(o = "max" === i ? aC(e, t, n, s) : NS(e, t, n, s)),
				"channelsFirst" === a && (o = qN(o, [0, 4, 1, 2, 3])),
				o
			);
		});
	}
	($z.className = "ZeroPadding2D"), AI($z);
	var nP = (function (e) {
			function t(t) {
				var n;
				if (
					(null == t.poolSize && (t.poolSize = 2),
					(n = e.call(this, t) || this),
					"number" == typeof t.poolSize)
				)
					n.poolSize = [t.poolSize];
				else {
					if (!Array.isArray(t.poolSize) || 1 !== t.poolSize.length || "number" != typeof t.poolSize[0])
						throw new OF(
							"poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " +
								JSON.stringify(t.poolSize)
						);
					n.poolSize = t.poolSize;
				}
				if (($F(n.poolSize, "poolSize"), null == t.strides)) n.strides = n.poolSize;
				else if ("number" == typeof t.strides) n.strides = [t.strides];
				else {
					if (!Array.isArray(t.strides) || 1 !== t.strides.length || "number" != typeof t.strides[0])
						throw new OF(
							"strides for 1D convolutional layer must be a number or an Array of a single number, but received " +
								JSON.stringify(t.strides)
						);
					n.strides = t.strides;
				}
				return (
					$F(n.strides, "strides"),
					(n.padding = null == t.padding ? "valid" : t.padding),
					xD(n.padding),
					(n.inputSpec = [new AO({ ndim: 3 })]),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.computeOutputShape = function (e) {
					var t = JL((e = IO(e))[1], this.poolSize[0], this.padding, this.strides[0]);
					return [e[0], t, e[2]];
				}),
				(n.call = function (e, t) {
					var n = this;
					return BI(function () {
						n.invokeCallHook(e, t), (e = DD(NO(e), 2));
						var r = n.poolingFunction(
							NO(e),
							[n.poolSize[0], 1],
							[n.strides[0], 1],
							n.padding,
							"channelsLast"
						);
						return SE(r, [2]);
					});
				}),
				(n.getConfig = function () {
					var t = { poolSize: this.poolSize, padding: this.padding, strides: this.strides },
						n = e.prototype.getConfig.call(this);
					return Object.assign(t, n), t;
				}),
				t
			);
		})(MO),
		rP = (function (e) {
			function t(t) {
				return e.call(this, t) || this;
			}
			return (
				gg(t, e),
				(t.prototype.poolingFunction = function (e, t, n, r, a) {
					return bD(a), xD(r), eP(e, t, n, r, a, "max");
				}),
				t
			);
		})(nP);
	(rP.className = "MaxPooling1D"), AI(rP);
	var aP = (function (e) {
		function t(t) {
			return e.call(this, t) || this;
		}
		return (
			gg(t, e),
			(t.prototype.poolingFunction = function (e, t, n, r, a) {
				return bD(a), xD(r), eP(e, t, n, r, a, "avg");
			}),
			t
		);
	})(nP);
	(aP.className = "AveragePooling1D"), AI(aP);
	var iP = (function (e) {
			function t(t) {
				var n;
				if (
					(null == t.poolSize && (t.poolSize = [2, 2]),
					((n = e.call(this, t) || this).poolSize = Array.isArray(t.poolSize)
						? t.poolSize
						: [t.poolSize, t.poolSize]),
					null == t.strides)
				)
					n.strides = n.poolSize;
				else if (Array.isArray(t.strides)) {
					if (2 !== t.strides.length)
						throw new OF(
							"If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " +
								t.strides.length +
								"."
						);
					n.strides = t.strides;
				} else n.strides = [t.strides, t.strides];
				return (
					$F(n.poolSize, "poolSize"),
					$F(n.strides, "strides"),
					(n.padding = null == t.padding ? "valid" : t.padding),
					(n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat),
					bD(n.dataFormat),
					xD(n.padding),
					(n.inputSpec = [new AO({ ndim: 4 })]),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.computeOutputShape = function (e) {
					e = IO(e);
					var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
						n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
					return (
						(t = JL(t, this.poolSize[0], this.padding, this.strides[0])),
						(n = JL(n, this.poolSize[1], this.padding, this.strides[1])),
						"channelsFirst" === this.dataFormat ? [e[0], e[1], t, n] : [e[0], t, n, e[3]]
					);
				}),
				(n.call = function (e, t) {
					var n = this;
					return BI(function () {
						return (
							n.invokeCallHook(e, t),
							n.poolingFunction(NO(e), n.poolSize, n.strides, n.padding, n.dataFormat)
						);
					});
				}),
				(n.getConfig = function () {
					var t = {
							poolSize: this.poolSize,
							padding: this.padding,
							strides: this.strides,
							dataFormat: this.dataFormat,
						},
						n = e.prototype.getConfig.call(this);
					return Object.assign(t, n), t;
				}),
				t
			);
		})(MO),
		oP = (function (e) {
			function t(t) {
				return e.call(this, t) || this;
			}
			return (
				gg(t, e),
				(t.prototype.poolingFunction = function (e, t, n, r, a) {
					return bD(a), xD(r), eP(e, t, n, r, a, "max");
				}),
				t
			);
		})(iP);
	(oP.className = "MaxPooling2D"), AI(oP);
	var sP = (function (e) {
		function t(t) {
			return e.call(this, t) || this;
		}
		return (
			gg(t, e),
			(t.prototype.poolingFunction = function (e, t, n, r, a) {
				return bD(a), xD(r), eP(e, t, n, r, a, "avg");
			}),
			t
		);
	})(iP);
	(sP.className = "AveragePooling2D"), AI(sP);
	var uP = (function (e) {
			function t(t) {
				var n;
				if (
					(null == t.poolSize && (t.poolSize = [2, 2, 2]),
					((n = e.call(this, t) || this).poolSize = Array.isArray(t.poolSize)
						? t.poolSize
						: [t.poolSize, t.poolSize, t.poolSize]),
					null == t.strides)
				)
					n.strides = n.poolSize;
				else if (Array.isArray(t.strides)) {
					if (3 !== t.strides.length)
						throw new OF(
							"If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " +
								t.strides.length +
								"."
						);
					n.strides = t.strides;
				} else n.strides = [t.strides, t.strides, t.strides];
				return (
					$F(n.poolSize, "poolSize"),
					$F(n.strides, "strides"),
					(n.padding = null == t.padding ? "valid" : t.padding),
					(n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat),
					bD(n.dataFormat),
					xD(n.padding),
					(n.inputSpec = [new AO({ ndim: 5 })]),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.computeOutputShape = function (e) {
					e = IO(e);
					var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
						n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
						r = "channelsFirst" === this.dataFormat ? e[4] : e[3];
					return (
						(t = JL(t, this.poolSize[0], this.padding, this.strides[0])),
						(n = JL(n, this.poolSize[1], this.padding, this.strides[1])),
						(r = JL(r, this.poolSize[2], this.padding, this.strides[2])),
						"channelsFirst" === this.dataFormat ? [e[0], e[1], t, n, r] : [e[0], t, n, r, e[4]]
					);
				}),
				(n.call = function (e, t) {
					var n = this;
					return BI(function () {
						return (
							n.invokeCallHook(e, t),
							n.poolingFunction(NO(e), n.poolSize, n.strides, n.padding, n.dataFormat)
						);
					});
				}),
				(n.getConfig = function () {
					var t = {
							poolSize: this.poolSize,
							padding: this.padding,
							strides: this.strides,
							dataFormat: this.dataFormat,
						},
						n = e.prototype.getConfig.call(this);
					return Object.assign(t, n), t;
				}),
				t
			);
		})(MO),
		lP = (function (e) {
			function t(t) {
				return e.call(this, t) || this;
			}
			return (
				gg(t, e),
				(t.prototype.poolingFunction = function (e, t, n, r, a) {
					return bD(a), xD(r), tP(e, t, n, r, a, "max");
				}),
				t
			);
		})(uP);
	(lP.className = "MaxPooling3D"), AI(lP);
	var cP = (function (e) {
		function t(t) {
			return e.call(this, t) || this;
		}
		return (
			gg(t, e),
			(t.prototype.poolingFunction = function (e, t, n, r, a) {
				return bD(a), xD(r), tP(e, t, n, r, a, "avg");
			}),
			t
		);
	})(uP);
	(cP.className = "AveragePooling3D"), AI(cP);
	var pP = (function (e) {
			function t(t) {
				var n;
				return ((n = e.call(this, t) || this).inputSpec = [new AO({ ndim: 3 })]), n;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.computeOutputShape = function (e) {
					return [e[0], e[2]];
				}),
				(n.call = function (e, t) {
					throw new MF();
				}),
				t
			);
		})(MO),
		hP = (function (e) {
			function t(t) {
				return e.call(this, t || {}) || this;
			}
			return (
				gg(t, e),
				(t.prototype.call = function (e, t) {
					return BI(function () {
						var t = NO(e);
						return sC(t, 1);
					});
				}),
				t
			);
		})(pP);
	(hP.className = "GlobalAveragePooling1D"), AI(hP);
	var fP = (function (e) {
		function t(t) {
			return e.call(this, t || {}) || this;
		}
		return (
			gg(t, e),
			(t.prototype.call = function (e, t) {
				return BI(function () {
					var t = NO(e);
					return WT(t, 1);
				});
			}),
			t
		);
	})(pP);
	(fP.className = "GlobalMaxPooling1D"), AI(fP);
	var dP = (function (e) {
			function t(t) {
				var n;
				return (
					((n = e.call(this, t) || this).dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat),
					bD(n.dataFormat),
					(n.inputSpec = [new AO({ ndim: 4 })]),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.computeOutputShape = function (e) {
					return (e = e), "channelsLast" === this.dataFormat ? [e[0], e[3]] : [e[0], e[1]];
				}),
				(n.call = function (e, t) {
					throw new MF();
				}),
				(n.getConfig = function () {
					var t = { dataFormat: this.dataFormat },
						n = e.prototype.getConfig.call(this);
					return Object.assign(t, n), t;
				}),
				t
			);
		})(MO),
		mP = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			return (
				gg(t, e),
				(t.prototype.call = function (e, t) {
					var n = this;
					return BI(function () {
						var t = NO(e);
						return "channelsLast" === n.dataFormat ? sC(t, [1, 2]) : sC(t, [2, 3]);
					});
				}),
				t
			);
		})(dP);
	(mP.className = "GlobalAveragePooling2D"), AI(mP);
	var gP = (function (e) {
		function t() {
			return e.apply(this, arguments) || this;
		}
		return (
			gg(t, e),
			(t.prototype.call = function (e, t) {
				var n = this;
				return BI(function () {
					var t = NO(e);
					return "channelsLast" === n.dataFormat ? WT(t, [1, 2]) : WT(t, [2, 3]);
				});
			}),
			t
		);
	})(dP);
	(gP.className = "GlobalMaxPooling2D"), AI(gP);
	var vP = (function (e) {
			function t(t) {
				var n;
				return ((n = e.call(this, t) || this).layer = t.layer), n;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.build = function (e) {
					this.built = !0;
				}),
				(n.getWeights = function () {
					return this.layer.getWeights();
				}),
				(n.setWeights = function (e) {
					this.layer.setWeights(e);
				}),
				(n.getConfig = function () {
					var t = { layer: { className: this.layer.getClassName(), config: this.layer.getConfig() } },
						n = e.prototype.getConfig.call(this);
					return Object.assign(t, n), t;
				}),
				(n.setFastWeightInitDuringBuild = function (t) {
					e.prototype.setFastWeightInitDuringBuild.call(this, t),
						null != this.layer && this.layer.setFastWeightInitDuringBuild(t);
				}),
				(t.fromConfig = function (e, t, n) {
					void 0 === n && (n = {});
					var r = ZO(t.layer, n);
					delete t.layer;
					var a = { layer: r };
					return Object.assign(a, t), new e(a);
				}),
				mg(t, [
					{
						key: "trainable",
						get: function () {
							return null != this.layer && this.layer.trainable;
						},
						set: function (e) {
							null != this.layer && (this.layer.trainable = e);
						},
					},
					{
						key: "trainableWeights",
						get: function () {
							return this.layer.trainableWeights;
						},
					},
					{
						key: "nonTrainableWeights",
						get: function () {
							return this.layer.nonTrainableWeights;
						},
					},
					{
						key: "updates",
						get: function () {
							return this.layer._updates;
						},
					},
					{
						key: "losses",
						get: function () {
							return this.layer.losses;
						},
					},
				]),
				t
			);
		})(MO),
		yP = (function (e) {
			function t(t) {
				var n;
				return ((n = e.call(this, t) || this).supportsMasking = !0), n;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.build = function (t) {
					if ((t = IO(t)).length < 3)
						throw new OF(
							"TimeDistributed layer expects an input shape >= 3D, but received input shape " +
								JSON.stringify(t)
						);
					this.inputSpec = [{ shape: t }];
					var n = [t[0]].concat(t.slice(2));
					this.layer.built || (this.layer.build(n), (this.layer.built = !0)), e.prototype.build.call(this, t);
				}),
				(n.computeOutputShape = function (e) {
					var t = [(e = IO(e))[0]].concat(e.slice(2)),
						n = this.layer.computeOutputShape(t),
						r = e[1];
					return [n[0], r].concat(n.slice(1));
				}),
				(n.call = function (e, t) {
					var n = this;
					return BI(function () {
						return dz(
							function (e, r) {
								return [NO(n.layer.call(e, t)), []];
							},
							(e = NO(e)),
							[],
							!1,
							null,
							null,
							!1,
							!0
						)[1];
					});
				}),
				t
			);
		})(vP);
	(yP.className = "TimeDistributed"), AI(yP);
	var bP = (function (e) {
		function t(t) {
			var n;
			n = e.call(this, t) || this;
			var r = t.layer.getConfig(),
				a = {};
			(a.className = t.layer.getClassName()),
				(a.config = r),
				(n.forwardLayer = ZO(a)),
				(r.goBackwards = !0 !== r.goBackwards);
			var i,
				o = {};
			if (
				((o.className = t.layer.getClassName()),
				(o.config = r),
				(n.backwardLayer = ZO(o)),
				(n.forwardLayer.name = "forward_" + n.forwardLayer.name),
				(n.backwardLayer.name = "backward_" + n.backwardLayer.name),
				(n.mergeMode = void 0 === t.mergeMode ? "concat" : t.mergeMode),
				(i = n.mergeMode),
				ZF(vD, "BidirectionalMergeMode", i),
				t.weights)
			)
				throw new MF("weights support is not implemented for Bidirectional layer yet.");
			return (
				(n._stateful = t.layer.stateful),
				(n.returnSequences = t.layer.returnSequences),
				(n.returnState = t.layer.returnState),
				(n.supportsMasking = !0),
				(n._trainable = !0),
				(n.inputSpec = t.layer.inputSpec),
				(n.numConstants = null),
				n
			);
		}
		gg(t, e);
		var n = t.prototype;
		return (
			(n.getWeights = function () {
				return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
			}),
			(n.setWeights = function (e) {
				var t = e.length,
					n = Math.floor(t / 2);
				this.forwardLayer.setWeights(e.slice(0, n)), this.backwardLayer.setWeights(e.slice(n));
			}),
			(n.computeOutputShape = function (e) {
				var t,
					n,
					r,
					a = this.forwardLayer.computeOutputShape(e);
				return (
					(Array.isArray(a) && Array.isArray(a[0])) || (a = [a]),
					(a = a),
					this.returnState ? ((r = a.slice(1)), (t = a[0])) : (t = a[0]),
					(t = t),
					"concat" === this.mergeMode
						? ((t[t.length - 1] *= 2), (n = [t]))
						: (n = null == this.mergeMode ? [t, t.slice()] : [t]),
					this.returnState
						? null == this.mergeMode
							? n.concat(r).concat(r.slice())
							: [t].concat(r).concat(r.slice())
						: WF(n)
				);
			}),
			(n.apply = function (t, n) {
				var r = null == n ? null : n.initialState,
					a = null == n ? null : n.constants;
				null == n && (n = {});
				var i = fz(t, r, a, this.numConstants);
				if (
					((t = i.inputs),
					(r = i.initialState),
					(a = i.constants),
					Array.isArray(t) && ((r = t.slice(1)), (t = t[0])),
					(null == r || 0 === r.length) && null == a)
				)
					return e.prototype.apply.call(this, t, n);
				var o = [],
					s = [];
				if (null != r) {
					var u = r.length;
					if (u % 2 > 0)
						throw new OF(
							"When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs."
						);
					(n.initialState = r), o.push.apply(o, r);
					var l = r.map(function (e) {
						return new AO({ shape: e.shape });
					});
					(this.forwardLayer.stateSpec = l.slice(0, u / 2)),
						(this.backwardLayer.stateSpec = l.slice(u / 2)),
						s.push.apply(s, l);
				}
				if (null != a) throw new MF("Support for constants in Bidirectional layers is not implemented yet.");
				for (var c = o[0] instanceof _O, p = 0, h = o; p < h.length; p++)
					if (h[p] instanceof _O !== c)
						throw new OF(
							"The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors"
						);
				if (c) {
					var f = [t].concat(o),
						d = this.inputSpec.concat(s),
						m = this.inputSpec;
					this.inputSpec = d;
					var g = e.prototype.apply.call(this, f, n);
					return (this.inputSpec = m), g;
				}
				return e.prototype.apply.call(this, t, n);
			}),
			(n.call = function (e, t) {
				var n = this;
				return BI(function () {
					var r,
						a,
						i,
						o,
						s = t.initialState;
					if (null == s) (r = n.forwardLayer.call(e, t)), (a = n.backwardLayer.call(e, t));
					else {
						var u = s.slice(0, s.length / 2),
							l = s.slice(s.length / 2);
						(r = n.forwardLayer.call(e, Object.assign(t, { initialState: u }))),
							(a = n.backwardLayer.call(e, Object.assign(t, { initialState: l })));
					}
					return (
						n.returnState &&
							(Array.isArray(r) && (i = r.slice(1).concat(a.slice(1))), (r = r[0]), (a = a[0])),
						n.returnSequences && (a = QC(a, 1)),
						"concat" === n.mergeMode
							? (o = zD([r, a]))
							: "sum" === n.mergeMode
							? (o = jI(r, a))
							: "ave" === n.mergeMode
							? (o = KI(0.5, jI(r, a)))
							: "mul" === n.mergeMode
							? (o = KI(r, a))
							: null == n.mergeMode && (o = [r, a]),
						n.returnState ? (null == n.mergeMode ? o.concat(i) : [o].concat(i)) : o
					);
				});
			}),
			(n.resetStates = function (e) {
				this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
			}),
			(n.build = function (e) {
				var t = this;
				ND(this.forwardLayer.name, function () {
					t.forwardLayer.build(e);
				}),
					ND(this.backwardLayer.name, function () {
						t.backwardLayer.build(e);
					}),
					(this.built = !0);
			}),
			(n.computeMask = function (e, t) {
				var n;
				if (
					(Array.isArray(t) && (t = t[0]),
					(n = this.returnSequences
						? null == this.mergeMode
							? [t, t]
							: t
						: null == this.mergeMode
						? [null, null]
						: null),
					this.returnState)
				) {
					var r = this.forwardLayer.states.map(function (e) {
						return null;
					});
					return Array.isArray(n) ? n.concat(r).concat(r) : [n].concat(r).concat(r);
				}
				return n;
			}),
			(n.setFastWeightInitDuringBuild = function (t) {
				e.prototype.setFastWeightInitDuringBuild.call(this, t),
					null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(t),
					null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(t);
			}),
			(n.getConfig = function () {
				var t = { mergeMode: this.mergeMode },
					n = e.prototype.getConfig.call(this);
				return Object.assign(t, n), t;
			}),
			(t.fromConfig = function (e, t) {
				var n = ZO(t.layer);
				if ((delete t.layer, null != t.numConstants))
					throw new MF(
						"Deserialization of a Bidirectional layer with numConstants present is not supported yet."
					);
				var r = t;
				return (r.layer = n), new e(r);
			}),
			mg(t, [
				{
					key: "trainable",
					get: function () {
						return this._trainable;
					},
					set: function (e) {
						(this._trainable = e),
							null != this.forwardLayer && (this.forwardLayer.trainable = e),
							null != this.backwardLayer && (this.backwardLayer.trainable = e);
					},
				},
				{
					key: "trainableWeights",
					get: function () {
						return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
					},
				},
				{
					key: "nonTrainableWeights",
					get: function () {
						return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
					},
				},
			]),
			t
		);
	})(vP);
	function xP(e) {
		return new aP(e);
	}
	function wP(e) {
		return new sP(e);
	}
	function kP(e) {
		return new cP(e);
	}
	function NP(e) {
		return new fP(e);
	}
	function IP(e) {
		return new gP(e);
	}
	function SP(e) {
		return new rP(e);
	}
	function TP(e) {
		return new oP(e);
	}
	(bP.className = "Bidirectional"), AI(bP);
	var CP = {
			__proto__: null,
			inputLayer: function (e) {
				return new PO(e);
			},
			elu: function (e) {
				return new qL(e);
			},
			reLU: function (e) {
				return new GL(e);
			},
			leakyReLU: function (e) {
				return new jL(e);
			},
			prelu: function (e) {
				return new HL(e);
			},
			softmax: function (e) {
				return new XL(e);
			},
			thresholdedReLU: function (e) {
				return new KL(e);
			},
			conv1d: function (e) {
				return new lz(e);
			},
			conv2d: function (e) {
				return new rz(e);
			},
			conv2dTranspose: function (e) {
				return new iz(e);
			},
			conv3d: function (e) {
				return new az(e);
			},
			conv3dTranspose: function (e) {
				return new oz(e);
			},
			separableConv2d: function (e) {
				return new uz(e);
			},
			cropping2D: function (e) {
				return new cz(e);
			},
			upSampling2d: function (e) {
				return new pz(e);
			},
			depthwiseConv2d: function (e) {
				return new hz(e);
			},
			activation: function (e) {
				return new Fz(e);
			},
			dense: function (e) {
				return new Az(e);
			},
			dropout: function (e) {
				return new Ez(e);
			},
			spatialDropout1d: function (e) {
				return new Rz(e);
			},
			flatten: function (e) {
				return new _z(e);
			},
			repeatVector: function (e) {
				return new Dz(e);
			},
			reshape: function (e) {
				return new Oz(e);
			},
			permute: function (e) {
				return new Mz(e);
			},
			embedding: function (e) {
				return new zz(e);
			},
			add: function (e) {
				return new Bz(e);
			},
			average: function (e) {
				return new Uz(e);
			},
			concatenate: function (e) {
				return new jz(e);
			},
			maximum: function (e) {
				return new Vz(e);
			},
			minimum: function (e) {
				return new Gz(e);
			},
			multiply: function (e) {
				return new Wz(e);
			},
			dot: function (e) {
				return new qz(e);
			},
			batchNormalization: function (e) {
				return new Zz(e);
			},
			layerNormalization: function (e) {
				return new Qz(e);
			},
			zeroPadding2d: function (e) {
				return new $z(e);
			},
			averagePooling1d: xP,
			avgPool1d: function (e) {
				return xP(e);
			},
			avgPooling1d: function (e) {
				return xP(e);
			},
			averagePooling2d: wP,
			avgPool2d: function (e) {
				return wP(e);
			},
			avgPooling2d: function (e) {
				return wP(e);
			},
			averagePooling3d: kP,
			avgPool3d: function (e) {
				return kP(e);
			},
			avgPooling3d: function (e) {
				return kP(e);
			},
			globalAveragePooling1d: function (e) {
				return new hP(e);
			},
			globalAveragePooling2d: function (e) {
				return new mP(e);
			},
			globalMaxPooling1d: NP,
			globalMaxPooling2d: IP,
			maxPooling1d: SP,
			maxPooling2d: TP,
			maxPooling3d: function (e) {
				return new lP(e);
			},
			gru: function (e) {
				return new xz(e);
			},
			gruCell: function (e) {
				return new bz(e);
			},
			lstm: function (e) {
				return new kz(e);
			},
			lstmCell: function (e) {
				return new wz(e);
			},
			simpleRNN: function (e) {
				return new yz(e);
			},
			simpleRNNCell: function (e) {
				return new vz(e);
			},
			convLstm2d: function (e) {
				return new Cz(e);
			},
			convLstm2dCell: function (e) {
				return new Tz(e);
			},
			rnn: function (e) {
				return new mz(e);
			},
			stackedRNNCells: function (e) {
				return new Nz(e);
			},
			bidirectional: function (e) {
				return new bP(e);
			},
			timeDistributed: function (e) {
				return new yP(e);
			},
			globalMaxPool1d: NP,
			globalMaxPool2d: IP,
			maxPool1d: SP,
			maxPool2d: TP,
			Layer: MO,
			RNN: mz,
			RNNCell: gz,
			input: vL,
			gaussianNoise: function (e) {
				return new Kz(e);
			},
			gaussianDropout: function (e) {
				return new Xz(e);
			},
			alphaDropout: function (e) {
				return new Yz(e);
			},
			masking: function (e) {
				return new Lz(e);
			},
		},
		EP = {
			__proto__: null,
			binaryAccuracy: function (e, t) {
				return uM(e, t);
			},
			binaryCrossentropy: function (e, t) {
				return hM(e, t);
			},
			sparseCategoricalAccuracy: function (e, t) {
				return fM(e, t);
			},
			categoricalAccuracy: function (e, t) {
				return lM(e, t);
			},
			categoricalCrossentropy: function (e, t) {
				return dM(e, t);
			},
			precision: function (e, t) {
				return pM(e, t);
			},
			recall: function (e, t) {
				return (function (e, t) {
					return BI(function () {
						var n = cM(e, t),
							r = (function (e, t) {
								return BI(function () {
									return NN(VT($T(iT(e, 1), iT(t, 0))), "float32");
								});
							})(e, t),
							a = jI(n, r);
						return NN(oT(wT(a, 0), qI(n, a), 0), "float32");
					});
				})(e, t);
			},
			cosineProximity: function (e, t) {
				return iM(e, t);
			},
			meanAbsoluteError: function (e, t) {
				return eM(e, t);
			},
			meanAbsolutePercentageError: function (e, t) {
				return tM(e, t);
			},
			MAPE: function (e, t) {
				return tM(e, t);
			},
			mape: function (e, t) {
				return tM(e, t);
			},
			meanSquaredError: function (e, t) {
				return $O(e, t);
			},
			MSE: function (e, t) {
				return $O(e, t);
			},
			mse: function (e, t) {
				return $O(e, t);
			},
		},
		RP = {
			__proto__: null,
			modelFromJSON: function (e, t) {
				return pL.apply(this, arguments);
			},
		},
		AP = {
			__proto__: null,
			l1l2: function (e) {
				return new PL(e);
			},
			l1: function (e) {
				return LL((t = e)), new PL({ l1: null != t ? t.l1 : null, l2: 0 });
				var t;
			},
			l2: function (e) {
				return LL((t = e)), new PL({ l2: null != t ? t.l2 : null, l1: 0 });
				var t;
			},
		},
		_P = (function (e) {
			function t() {
				var t;
				return ((t = e.apply(this, arguments) || this).model = null), t;
			}
			return (
				gg(t, e),
				(t.prototype.setModel = function (e) {
					if (!(e instanceof lL)) throw new Error("model must be a LayersModel, not some other Container");
					this.model = e;
				}),
				t
			);
		})(GO);
	function FP(e, t) {
		return e < t;
	}
	function DP(e, t) {
		return e > t;
	}
	var OP,
		MP,
		LP = (function (e) {
			function t(t) {
				var n;
				if (((n = e.call(this) || this), null == t && (t = {}), t.restoreBestWeights))
					throw new MF("restoreBestWeights = True is not implemented in EarlyStopping yet.");
				return (
					(n.monitor = t.monitor || "val_loss"),
					(n.minDelta = Math.abs(t.minDelta || 0)),
					(n.patience = t.patience || 0),
					(n.verbose = t.verbose || 0),
					(n.mode = t.mode || "auto"),
					(n.baseline = t.baseline),
					-1 === ["auto", "min", "max"].indexOf(n.mode) &&
						(console.warn("EarlyStopping mode '" + n.mode + "' is invalid. Falling back to mode 'auto'."),
						(n.mode = "auto")),
					"min" === n.mode
						? (n.monitorFunc = FP)
						: "max" === n.mode || -1 !== n.monitor.indexOf("acc")
						? (n.monitorFunc = DP)
						: (n.monitorFunc = FP),
					n.monitorFunc === FP && (n.minDelta *= -1),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.onTrainBegin = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												(this.wait = 0),
													(this.stoppedEpoch = 0),
													null != this.baseline
														? (this.best = this.baseline)
														: (this.best = this.monitorFunc === FP ? 1 / 0 : -1 / 0);
											case 3:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onEpochEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), WO(n);
											case 2:
												if (null != (r = this.getMonitorValue(n))) {
													e.next = 5;
													break;
												}
												return e.abrupt("return");
											case 5:
												this.monitorFunc(r - this.minDelta, this.best)
													? ((this.best = r), (this.wait = 0))
													: (this.wait++,
													  this.wait >= this.patience &&
															((this.stoppedEpoch = t), (this.model.stopTraining = !0)));
											case 6:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(n.onTrainEnd = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												this.stoppedEpoch > 0 &&
													this.verbose &&
													console.log("Epoch " + this.stoppedEpoch + ": early stopping.");
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.getMonitorValue = function (e) {
					null == e && (e = {});
					var t = e[this.monitor];
					return (
						null == t &&
							console.warn(
								"Metric for EarlyStopping " +
									this.monitor +
									" is not available. Available metrics are: " +
									Object.keys(e)
							),
						t
					);
				}),
				t
			);
		})(_P),
		zP = {
			earlyStopping: function (e) {
				return new LP(e);
			},
		};
	xv().registerFlag(
		"KEEP_INTERMEDIATE_TENSORS",
		function () {
			return !1;
		},
		function (e) {
			e &&
				console.warn(
					"Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance."
				);
		}
	),
		(function (e) {
			(e[(e.DT_INVALID = 0)] = "DT_INVALID"),
				(e[(e.DT_FLOAT = 1)] = "DT_FLOAT"),
				(e[(e.DT_DOUBLE = 2)] = "DT_DOUBLE"),
				(e[(e.DT_INT32 = 3)] = "DT_INT32"),
				(e[(e.DT_UINT8 = 4)] = "DT_UINT8"),
				(e[(e.DT_INT16 = 5)] = "DT_INT16"),
				(e[(e.DT_INT8 = 6)] = "DT_INT8"),
				(e[(e.DT_STRING = 7)] = "DT_STRING"),
				(e[(e.DT_COMPLEX64 = 8)] = "DT_COMPLEX64"),
				(e[(e.DT_INT64 = 9)] = "DT_INT64"),
				(e[(e.DT_BOOL = 10)] = "DT_BOOL"),
				(e[(e.DT_QINT8 = 11)] = "DT_QINT8"),
				(e[(e.DT_QUINT8 = 12)] = "DT_QUINT8"),
				(e[(e.DT_QINT32 = 13)] = "DT_QINT32"),
				(e[(e.DT_BFLOAT16 = 14)] = "DT_BFLOAT16"),
				(e[(e.DT_QINT16 = 15)] = "DT_QINT16"),
				(e[(e.DT_QUINT16 = 16)] = "DT_QUINT16"),
				(e[(e.DT_UINT16 = 17)] = "DT_UINT16"),
				(e[(e.DT_COMPLEX128 = 18)] = "DT_COMPLEX128"),
				(e[(e.DT_HALF = 19)] = "DT_HALF"),
				(e[(e.DT_RESOURCE = 20)] = "DT_RESOURCE"),
				(e[(e.DT_VARIANT = 21)] = "DT_VARIANT"),
				(e[(e.DT_UINT32 = 22)] = "DT_UINT32"),
				(e[(e.DT_UINT64 = 23)] = "DT_UINT64"),
				(e[(e.DT_FLOAT_REF = 101)] = "DT_FLOAT_REF"),
				(e[(e.DT_DOUBLE_REF = 102)] = "DT_DOUBLE_REF"),
				(e[(e.DT_INT32_REF = 103)] = "DT_INT32_REF"),
				(e[(e.DT_UINT8_REF = 104)] = "DT_UINT8_REF"),
				(e[(e.DT_INT16_REF = 105)] = "DT_INT16_REF"),
				(e[(e.DT_INT8_REF = 106)] = "DT_INT8_REF"),
				(e[(e.DT_STRING_REF = 107)] = "DT_STRING_REF"),
				(e[(e.DT_COMPLEX64_REF = 108)] = "DT_COMPLEX64_REF"),
				(e[(e.DT_INT64_REF = 109)] = "DT_INT64_REF"),
				(e[(e.DT_BOOL_REF = 110)] = "DT_BOOL_REF"),
				(e[(e.DT_QINT8_REF = 111)] = "DT_QINT8_REF"),
				(e[(e.DT_QUINT8_REF = 112)] = "DT_QUINT8_REF"),
				(e[(e.DT_QINT32_REF = 113)] = "DT_QINT32_REF"),
				(e[(e.DT_BFLOAT16_REF = 114)] = "DT_BFLOAT16_REF"),
				(e[(e.DT_QINT16_REF = 115)] = "DT_QINT16_REF"),
				(e[(e.DT_QUINT16_REF = 116)] = "DT_QUINT16_REF"),
				(e[(e.DT_UINT16_REF = 117)] = "DT_UINT16_REF"),
				(e[(e.DT_COMPLEX128_REF = 118)] = "DT_COMPLEX128_REF"),
				(e[(e.DT_HALF_REF = 119)] = "DT_HALF_REF"),
				(e[(e.DT_RESOURCE_REF = 120)] = "DT_RESOURCE_REF"),
				(e[(e.DT_VARIANT_REF = 121)] = "DT_VARIANT_REF"),
				(e[(e.DT_UINT32_REF = 122)] = "DT_UINT32_REF"),
				(e[(e.DT_UINT64_REF = 123)] = "DT_UINT64_REF");
		})(OP || (OP = {})),
		(function (e) {
			!(function (e) {
				(e[(e.LEGACY = 0)] = "LEGACY"), (e[(e.V1 = 1)] = "V1"), (e[(e.V2 = 2)] = "V2");
			})(e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}));
		})(MP || (MP = {}));
	var PP = {};
	function BP(e) {
		return PP[e];
	}
	function WP(e, t, n, r, a) {
		var i = t.inputParams[e];
		if (i && void 0 !== i.inputIndexStart) {
			var o = i.inputIndexStart,
				s = 0 === i.inputIndexEnd ? void 0 : void 0 === i.inputIndexEnd ? o + 1 : i.inputIndexEnd;
			if ("tensor" === i.type) return UP(t.inputNames[i.inputIndexStart], n, r, a);
			if ("tensors" === i.type)
				return t.inputNames.slice(o, s).map(function (e) {
					return UP(e, n, r, a);
				});
			var u = UP(t.inputNames.slice(o)[0], n, r, a),
				l = u.dataSync();
			return "number" === i.type ? l[0] : uv(u.shape, l);
		}
		var c = t.attrParams[e];
		return c && c.value;
	}
	function UP(e, t, n, r) {
		var a = jP(e),
			i = a[0],
			o = a[1];
		if (null != r) {
			var s = r.getHashTableHandleByName(i);
			if (null != s) return s;
		}
		var u = n.currentContextIds.find(function (e) {
			return !!t[GP(i, e)];
		});
		return void 0 !== u ? t[GP(i, u)][o] : void 0;
	}
	function VP(e, t) {
		var n = jP(e),
			r = n[0],
			a = n[1],
			i = n[2];
		return [GP(r, t && t.currentContextId), a, i];
	}
	function GP(e, t) {
		return t ? e + "-" + t : e;
	}
	function jP(e) {
		var t = e.split(":");
		if (1 === t.length) return [e, 0, void 0];
		var n = t[0],
			r = 3 === t.length ? t[1] : void 0;
		return [n, Number(t[t.length - 1]), r];
	}
	function HP(e, t, n) {
		var r = WP("pad", e, t, n);
		if ("explicit" === r) {
			r = WP("explicitPaddings", e, t, n);
			for (
				var a = [
						[0, 0],
						[0, 0],
						[0, 0],
						[0, 0],
					],
					i = 0;
				i < 4;
				i++
			)
				(a[i][0] = r[2 * i]), (a[i][1] = r[2 * i + 1]);
			return a;
		}
		return r;
	}
	function qP(e) {
		return e.kept ? e : IN(e);
	}
	var KP = {
			__proto__: null,
			json: [
				{
					tfOpName: "Add",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "AddV2",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "AddN",
					category: "arithmetic",
					inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }],
				},
				{
					tfOpName: "BiasAdd",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
						{ tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 },
					],
				},
				{
					tfOpName: "Sub",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "RealDiv",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Div",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "DivNoNan",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "FloorDiv",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Mul",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Maximum",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Minimum",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Pow",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "SquaredDifference",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Mod",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "FloorMod",
					category: "arithmetic",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
			],
		},
		XP = {
			__proto__: null,
			json: [
				{
					tfOpName: "Abs",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Acos",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Asin",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Atan",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Atan2",
					category: "basic_math",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "y", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Ceil",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "ClipByValue",
					category: "basic_math",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "clipValueMin", type: "number" },
						{ start: 2, name: "clipValueMax", type: "number" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Complex",
					category: "basic_math",
					inputs: [
						{ start: 0, name: "real", type: "tensor" },
						{ start: 1, name: "imag", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "ComplexAbs",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Cos",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Cosh",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Elu",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Exp",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Floor",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Log",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Imag",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
						{ tfName: "Tout", name: "outputType", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "Neg",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Real",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
						{ tfName: "Tout", name: "outputType", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "Prelu",
					category: "basic_math",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "alpha", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Relu",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Relu6",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Selu",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Sigmoid",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Sin",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Sinh",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Sqrt",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Rsqrt",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Square",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Tan",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Tanh",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Sign",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Round",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Expm1",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Log1p",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Reciprocal",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Softplus",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Asinh",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Acosh",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Atanh",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Erf",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Prod",
					category: "basic_math",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axes", type: "number[]" },
					],
					attrs: [
						{ tfName: "keep_dims", name: "keepDims", type: "bool", notSupported: !0 },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "LeakyRelu",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "alpha", name: "alpha", type: "number", defaultValue: 0.2 },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "IsNan",
					category: "basic_math",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
			],
		},
		YP = {
			__proto__: null,
			json: [
				{
					tfOpName: "EmptyTensorList",
					category: "control",
					inputs: [
						{ start: 0, name: "elementShape", type: "shape" },
						{ start: 1, name: "maxNumElements", type: "number" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{ tfOpName: "LoopCond", category: "control", inputs: [{ start: 0, name: "pred", type: "tensor" }] },
				{
					tfOpName: "Switch",
					category: "control",
					inputs: [
						{ start: 0, name: "data", type: "tensor" },
						{ start: 1, name: "pred", type: "tensor" },
					],
				},
				{
					tfOpName: "Merge",
					category: "control",
					inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }],
				},
				{
					tfOpName: "Enter",
					category: "control",
					inputs: [{ start: 0, name: "tensor", type: "tensor" }],
					attrs: [
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
						{ tfName: "frame_name", name: "frameName", type: "string" },
						{ tfName: "is_constant", name: "isConstant", type: "bool" },
					],
				},
				{
					tfOpName: "Exit",
					category: "control",
					inputs: [{ start: 0, name: "tensor", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "NextIteration",
					category: "control",
					inputs: [{ start: 0, name: "tensor", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "TensorArrayV3",
					category: "control",
					inputs: [{ start: 0, name: "size", type: "number" }],
					attrs: [
						{ tfName: "dtype", name: "dtype", type: "dtype" },
						{ tfName: "element_shape", name: "elementShape", type: "shape" },
						{ tfName: "dynamic_size", name: "dynamicSize", type: "bool" },
						{ tfName: "clear_after_read", name: "clearAfterRead", type: "bool" },
						{ tfName: "identical_element_shapes", name: "identicalElementShapes", type: "bool" },
						{ tfName: "tensor_array_name", name: "name", type: "string" },
					],
				},
				{
					tfOpName: "TensorArrayWriteV3",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorArrayId", type: "tensor" },
						{ start: 1, name: "index", type: "number" },
						{ start: 2, name: "tensor", type: "tensor" },
						{ start: 3, name: "flowIn", type: "number" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "TensorArrayReadV3",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorArrayId", type: "tensor" },
						{ start: 1, name: "index", type: "number" },
						{ start: 2, name: "flowIn", type: "number" },
					],
					attrs: [{ tfName: "dtype", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "TensorArrayGatherV3",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorArrayId", type: "tensor" },
						{ start: 1, name: "indices", type: "number[]" },
						{ start: 2, name: "flowIn", type: "number" },
					],
					attrs: [
						{ tfName: "dtype", name: "dtype", type: "dtype" },
						{ tfName: "element_shape", name: "elementShape", type: "shape" },
					],
				},
				{
					tfOpName: "TensorArrayScatterV3",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorArrayId", type: "tensor" },
						{ start: 1, name: "indices", type: "number[]" },
						{ start: 2, name: "tensor", type: "tensor" },
						{ start: 3, name: "flowIn", type: "number" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
				},
				{
					tfOpName: "TensorArrayConcatV3",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorArrayId", type: "tensor" },
						{ start: 1, name: "flowIn", type: "number" },
					],
					attrs: [
						{ tfName: "dtype", name: "dtype", type: "dtype" },
						{
							tfName: "element_shape_except0",
							name: "elementShapeExcept0",
							type: "shape",
							notSupported: !0,
						},
					],
				},
				{
					tfOpName: "TensorArraySplitV3",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorArrayId", type: "tensor" },
						{ start: 1, name: "tensor", type: "tensor" },
						{ start: 2, name: "lengths", type: "number[]" },
						{ start: 3, name: "flowIn", type: "number" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
				},
				{
					tfOpName: "TensorArraySizeV3",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorArrayId", type: "tensor" },
						{ start: 1, name: "flowIn", type: "number" },
					],
				},
				{
					tfOpName: "TensorArrayCloseV3",
					category: "control",
					inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }],
				},
				{
					tfOpName: "StatelessIf",
					category: "control",
					inputs: [
						{ start: 0, name: "cond", type: "tensor" },
						{ start: 1, end: 0, name: "args", type: "tensors" },
					],
					attrs: [
						{ tfName: "then_branch", name: "thenBranch", type: "func" },
						{ tfName: "else_branch", name: "elseBranch", type: "func" },
					],
				},
				{
					tfOpName: "If",
					category: "control",
					inputs: [
						{ start: 0, name: "cond", type: "tensor" },
						{ start: 1, end: 0, name: "args", type: "tensors" },
					],
					attrs: [
						{ tfName: "then_branch", name: "thenBranch", type: "func" },
						{ tfName: "else_branch", name: "elseBranch", type: "func" },
					],
				},
				{
					tfOpName: "StatelessWhile",
					category: "control",
					inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }],
					attrs: [
						{ tfName: "cond", name: "cond", type: "func" },
						{ tfName: "body", name: "body", type: "func" },
					],
				},
				{
					tfOpName: "While",
					category: "control",
					inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }],
					attrs: [
						{ tfName: "cond", name: "cond", type: "func" },
						{ tfName: "body", name: "body", type: "func" },
					],
				},
				{
					tfOpName: "TensorListScatter",
					category: "control",
					inputs: [
						{ start: 0, name: "tensor", type: "tensor" },
						{ start: 1, name: "indices", type: "number[]" },
						{ start: 2, name: "elementShape", type: "shape" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{
					tfOpName: "TensorListScatterV2",
					category: "control",
					inputs: [
						{ start: 0, name: "tensor", type: "tensor" },
						{ start: 1, name: "indices", type: "number[]" },
						{ start: 2, name: "elementShape", type: "shape" },
						{ start: 3, name: "numElements", type: "number" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{
					tfOpName: "TensorListGather",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorListId", type: "tensor" },
						{ start: 1, name: "indices", type: "number[]" },
						{ start: 2, name: "elementShape", type: "shape" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{
					tfOpName: "TensorListGetItem",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorListId", type: "tensor" },
						{ start: 1, name: "index", type: "number" },
						{ start: 2, name: "elementShape", type: "shape" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{
					tfOpName: "TensorListSetItem",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorListId", type: "tensor" },
						{ start: 1, name: "index", type: "number" },
						{ start: 2, name: "tensor", type: "tensor" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{
					tfOpName: "TensorListReserve",
					category: "control",
					inputs: [
						{ start: 0, name: "elementShape", type: "shape" },
						{ start: 1, name: "numElements", type: "number" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{
					tfOpName: "TensorListFromTensor",
					category: "control",
					inputs: [
						{ start: 0, name: "tensor", type: "tensor" },
						{ start: 1, name: "elementShape", type: "shape" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{
					tfOpName: "TensorListStack",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorListId", type: "tensor" },
						{ start: 1, name: "elementShape", type: "shape" },
					],
					attrs: [
						{ tfName: "element_dtype", name: "elementDType", type: "dtype" },
						{ tfName: "num_elements", name: "numElements", type: "dtype" },
					],
				},
				{
					tfOpName: "TensorListSplit",
					category: "control",
					inputs: [
						{ start: 0, name: "tensor", type: "tensor" },
						{ start: 1, name: "elementShape", type: "shape" },
						{ start: 2, name: "lengths", type: "number[]" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{
					tfOpName: "TensorListConcat",
					category: "control",
					inputs: [{ start: 0, name: "tensorListId", type: "tensor" }],
					attrs: [
						{ tfName: "element_shape", name: "elementShape", type: "shape" },
						{ tfName: "element_dtype", name: "elementDType", type: "dtype" },
					],
				},
				{
					tfOpName: "TensorListPopBack",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorListId", type: "tensor" },
						{ start: 1, name: "elementShape", type: "shape" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
				{
					tfOpName: "TensorListPushBack",
					category: "control",
					inputs: [
						{ start: 0, name: "tensorListId", type: "tensor" },
						{ start: 1, name: "tensor", type: "tensor" },
					],
					attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }],
				},
			],
		},
		JP = {
			__proto__: null,
			json: [
				{
					tfOpName: "AvgPool",
					category: "convolution",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 },
						{ tfName: "ksize", name: "kernelSize", type: "number[]" },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "MaxPool",
					category: "convolution",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 },
						{ tfName: "ksize", name: "kernelSize", type: "number[]" },
						{
							tfName: "explicit_paddings",
							name: "explicitPaddings",
							type: "number[]",
							defaultValue: [],
							notSupported: !0,
						},
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "MaxPoolWithArgmax",
					category: "convolution",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "ksize", name: "kernelSize", type: "number[]" },
						{ tfName: "include_batch_in_index", name: "includeBatchInIndex", type: "bool" },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "AvgPool3D",
					category: "convolution",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 },
						{ tfName: "ksize", name: "kernelSize", type: "number[]" },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "MaxPool3D",
					category: "convolution",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 },
						{ tfName: "ksize", name: "kernelSize", type: "number[]" },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "Conv1D",
					category: "convolution",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "filter", type: "tensor" },
					],
					attrs: [
						{ tfName: "stride", name: "stride", type: "number" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NWC" },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
						{ tfName: "dilation", name: "dilation", type: "number", defaultValue: 1 },
					],
				},
				{
					tfOpName: "Conv2D",
					category: "convolution",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "filter", type: "tensor" },
					],
					attrs: [
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool" },
						{ tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" },
						{ tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] },
						{ tfName: "dilations", name: "dilations", type: "number[]" },
					],
				},
				{
					tfOpName: "_FusedConv2D",
					category: "convolution",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "filter", type: "tensor" },
						{ start: 2, end: 0, name: "args", type: "tensors" },
					],
					attrs: [
						{ tfName: "num_args", name: "numArgs", type: "number" },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] },
						{ tfName: "use_cudnn_on_gpu", name: "useCudnnOnGpu", type: "bool", defaultValue: !0 },
						{ tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" },
						{ tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] },
						{ tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] },
						{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 },
						{ tfName: "leakyrelu_alpha", name: "leakyreluAlpha", type: "number" },
					],
				},
				{
					tfOpName: "Conv2DBackpropInput",
					category: "convolution",
					inputs: [
						{ start: 2, name: "x", type: "tensor" },
						{ start: 1, name: "filter", type: "tensor" },
						{ start: 0, name: "outputShape", type: "number[]" },
					],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 },
						{ tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] },
						{ tfName: "dilations", name: "dilations", type: "number[]", notSupported: !0 },
					],
				},
				{
					tfOpName: "DepthwiseConv2d",
					category: "convolution",
					inputs: [
						{ start: 0, name: "input", type: "tensor" },
						{ start: 1, name: "filter", type: "tensor" },
					],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" },
						{ tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] },
						{ tfName: "dilations", name: "dilations", type: "number[]" },
					],
				},
				{
					tfOpName: "DepthwiseConv2dNative",
					category: "convolution",
					inputs: [
						{ start: 0, name: "input", type: "tensor" },
						{ start: 1, name: "filter", type: "tensor" },
					],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" },
						{ tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] },
						{ tfName: "dilations", name: "dilations", type: "number[]" },
					],
				},
				{
					tfOpName: "FusedDepthwiseConv2dNative",
					category: "convolution",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "filter", type: "tensor" },
						{ start: 2, end: 0, name: "args", type: "tensors" },
					],
					attrs: [
						{ tfName: "num_args", name: "numArgs", type: "number" },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" },
						{ tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] },
						{ tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] },
						{ tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] },
					],
				},
				{
					tfOpName: "Conv3D",
					category: "convolution",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "filter", type: "tensor" },
					],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
						{ tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" },
						{ tfName: "dilations", name: "dilations", type: "number[]" },
					],
				},
				{
					tfOpName: "Dilation2D",
					category: "convolution",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "filter", type: "tensor" },
					],
					attrs: [
						{ tfName: "strides", name: "strides", type: "number[]" },
						{ tfName: "rates", name: "dilations", type: "number[]" },
						{ tfName: "padding", name: "pad", type: "string" },
					],
				},
			],
		},
		ZP = {
			__proto__: null,
			json: [
				{
					tfOpName: "Fill",
					category: "creation",
					inputs: [
						{ start: 0, name: "shape", type: "number[]" },
						{ start: 1, name: "value", type: "number" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
				},
				{
					tfOpName: "LinSpace",
					category: "creation",
					inputs: [
						{ start: 0, name: "start", type: "number" },
						{ start: 1, name: "stop", type: "number" },
						{ start: 2, name: "num", type: "number" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "OneHot",
					category: "creation",
					inputs: [
						{ start: 0, name: "indices", type: "tensor" },
						{ start: 1, name: "depth", type: "number" },
						{ start: 2, name: "onValue", type: "number", defaultValue: 1 },
						{ start: 3, name: "offValue", type: "number", defaultValue: 0 },
					],
					attrs: [
						{ tfName: "axis", name: "axis", type: "number", notSupported: !0 },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "Ones",
					category: "creation",
					inputs: [{ start: 0, name: "shape", type: "number[]" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
				},
				{
					tfOpName: "OnesLike",
					category: "creation",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }],
				},
				{
					tfOpName: "RandomUniform",
					category: "creation",
					inputs: [{ start: 0, name: "shape", type: "number[]" }],
					attrs: [
						{ tfName: "minval", name: "minval", type: "number", defaultValue: 0 },
						{ tfName: "maxval", name: "maxval", type: "number", defaultValue: 1 },
						{ tfName: "dtype", name: "dtype", type: "dtype" },
						{ tfName: "seed", name: "seed", type: "number", defaultValue: 0 },
						{ tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: !0 },
						{ tfName: "T", name: "T", type: "number", notSupported: !0 },
					],
				},
				{
					tfOpName: "Range",
					category: "creation",
					inputs: [
						{ start: 0, name: "start", type: "number" },
						{ start: 1, name: "stop", type: "number" },
						{ start: 2, name: "step", type: "number", defaultValue: 0 },
					],
					attrs: [{ tfName: "Tidx", name: "dtype", type: "dtype" }],
				},
				{
					tfOpName: "TruncatedNormal",
					category: "creation",
					inputs: [{ start: 0, name: "shape", type: "number[]" }],
					attrs: [
						{ tfName: "means", name: "mean", type: "number", defaultValue: 0 },
						{ tfName: "stddev", name: "stdDev", type: "number", defaultValue: 1 },
						{ tfName: "seed", name: "seed", type: "number" },
						{ tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: !0 },
						{ tfName: "dtype", name: "dtype", type: "dtype" },
						{ tfName: "T", name: "T", type: "number", notSupported: !0 },
					],
				},
				{
					tfOpName: "Zeros",
					category: "creation",
					inputs: [{ start: 0, name: "shape", type: "number[]" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
				},
				{
					tfOpName: "ZerosLike",
					category: "creation",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype" }],
				},
				{
					tfOpName: "Multinomial",
					category: "creation",
					inputs: [
						{ start: 0, name: "logits", type: "tensor" },
						{ start: 1, name: "numSamples", type: "number" },
					],
					attrs: [
						{ tfName: "seed", name: "seed", type: "number" },
						{ tfName: "seed2", name: "seed2", type: "number" },
						{ tfName: "T", name: "dtype", type: "dtype" },
						{ tfName: "output_dtype", name: "output_dtype", type: "dtype" },
					],
				},
			],
		},
		QP = {
			__proto__: null,
			json: [
				{
					tfOpName: "NonMaxSuppressionV2",
					category: "dynamic",
					inputs: [
						{ start: 0, name: "boxes", type: "tensor" },
						{ start: 1, name: "scores", type: "tensor" },
						{ start: 2, name: "maxOutputSize", type: "number" },
						{ start: 3, name: "iouThreshold", type: "number" },
					],
				},
				{
					tfOpName: "NonMaxSuppressionV3",
					category: "dynamic",
					inputs: [
						{ start: 0, name: "boxes", type: "tensor" },
						{ start: 1, name: "scores", type: "tensor" },
						{ start: 2, name: "maxOutputSize", type: "number" },
						{ start: 3, name: "iouThreshold", type: "number" },
						{ start: 4, name: "scoreThreshold", type: "number" },
					],
				},
				{
					tfOpName: "NonMaxSuppressionV4",
					category: "dynamic",
					inputs: [
						{ start: 0, name: "boxes", type: "tensor" },
						{ start: 1, name: "scores", type: "tensor" },
						{ start: 2, name: "maxOutputSize", type: "number" },
						{ start: 3, name: "iouThreshold", type: "number" },
						{ start: 4, name: "scoreThreshold", type: "number" },
					],
					attrs: [
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
						{ tfName: "T_threshold", name: "threshold", type: "dtype", notSupported: !0 },
						{ tfName: "pad_to_max_output_size", name: "padToMaxOutputSize", type: "bool" },
					],
				},
				{
					tfOpName: "NonMaxSuppressionV5",
					category: "dynamic",
					inputs: [
						{ start: 0, name: "boxes", type: "tensor" },
						{ start: 1, name: "scores", type: "tensor" },
						{ start: 2, name: "maxOutputSize", type: "number" },
						{ start: 3, name: "iouThreshold", type: "number" },
						{ start: 4, name: "scoreThreshold", type: "number" },
						{ start: 5, name: "softNmsSigma", type: "number" },
					],
				},
				{
					tfOpName: "Where",
					category: "dynamic",
					inputs: [{ start: 0, name: "condition", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "ListDiff",
					category: "dynamic",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "y", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
			],
		},
		$P = {
			__proto__: null,
			json: [
				{
					tfOpName: "TopKV2",
					category: "evaluation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "k", type: "number" },
					],
					attrs: [{ tfName: "sorted", name: "sorted", type: "bool" }],
				},
				{ tfOpName: "Unique", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{
					tfOpName: "UniqueV2",
					category: "evaluation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number" },
					],
				},
			],
		},
		eB = {
			__proto__: null,
			json: [
				{
					tfOpName: "PlaceholderWithDefault",
					category: "graph",
					inputs: [{ start: 0, name: "default", type: "tensor" }],
					attrs: [
						{ tfName: "shape", name: "shape", type: "shape" },
						{ tfName: "dtype", name: "dtype", type: "dtype" },
					],
				},
				{
					tfOpName: "Placeholder",
					category: "graph",
					attrs: [
						{ tfName: "shape", name: "shape", type: "shape" },
						{ tfName: "dtype", name: "dtype", type: "dtype" },
					],
				},
				{ tfOpName: "Const", category: "graph" },
				{ tfOpName: "Identity", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{
					tfOpName: "IdentityN",
					category: "graph",
					inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }],
				},
				{ tfOpName: "Snapshot", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{ tfOpName: "Rank", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{ tfOpName: "Size", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{ tfOpName: "Shape", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{ tfOpName: "ShapeN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] },
				{
					tfOpName: "Print",
					category: "graph",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "data", type: "tensors" },
					],
					attrs: [
						{ tfName: "message", name: "message", type: "string" },
						{ tfName: "first_n", name: "firstN", type: "number", notSupported: !0 },
						{ tfName: "summarize", name: "summarize", type: "number", defaultValue: 3 },
					],
				},
				{ tfOpName: "NoOp", category: "graph", inputs: [] },
				{ tfOpName: "StopGradient", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{
					tfOpName: "FakeQuantWithMinMaxVars",
					category: "graph",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "min", name: "min", type: "number" },
						{ tfName: "max", name: "max", type: "number" },
					],
				},
			],
		},
		tB = {
			__proto__: null,
			json: [
				{
					tfOpName: "HashTable",
					category: "hash_table",
					inputs: [],
					attrs: [
						{ tfName: "shared_name", name: "sharedName", type: "string" },
						{ tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" },
						{ tfName: "key_dtype", name: "keyDType", type: "dtype" },
						{ tfName: "value_dtype", name: "valueDType", type: "dtype" },
					],
				},
				{
					tfOpName: "HashTableV2",
					category: "hash_table",
					inputs: [],
					attrs: [
						{ tfName: "shared_name", name: "sharedName", type: "string" },
						{ tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" },
						{ tfName: "key_dtype", name: "keyDType", type: "dtype" },
						{ tfName: "value_dtype", name: "valueDType", type: "dtype" },
					],
				},
				{
					tfOpName: "LookupTableImport",
					category: "hash_table",
					inputs: [
						{ start: 0, name: "tableHandle", type: "tensor" },
						{ start: 1, name: "keys", type: "tensor" },
						{ start: 2, name: "values", type: "tensor" },
					],
					attrs: [
						{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: !0 },
						{ tfName: "Tout", name: "tOut", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "LookupTableImportV2",
					category: "hash_table",
					inputs: [
						{ start: 0, name: "tableHandle", type: "tensor" },
						{ start: 1, name: "keys", type: "tensor" },
						{ start: 2, name: "values", type: "tensor" },
					],
					attrs: [
						{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: !0 },
						{ tfName: "Tout", name: "tOut", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "LookupTableFind",
					category: "hash_table",
					inputs: [
						{ start: 0, name: "tableHandle", type: "tensor" },
						{ start: 1, name: "keys", type: "tensor" },
						{ start: 2, name: "defaultValue", type: "tensor" },
					],
					attrs: [
						{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: !0 },
						{ tfName: "Tout", name: "tOut", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "LookupTableFindV2",
					category: "hash_table",
					inputs: [
						{ start: 0, name: "tableHandle", type: "tensor" },
						{ start: 1, name: "keys", type: "tensor" },
						{ start: 2, name: "defaultValue", type: "tensor" },
					],
					attrs: [
						{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: !0 },
						{ tfName: "Tout", name: "tOut", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "LookupTableSize",
					category: "hash_table",
					inputs: [{ start: 0, name: "tableHandle", type: "tensor" }],
				},
				{
					tfOpName: "LookupTableSizeV2",
					category: "hash_table",
					inputs: [{ start: 0, name: "tableHandle", type: "tensor" }],
				},
			],
		},
		nB = {
			__proto__: null,
			json: [
				{
					tfOpName: "ResizeBilinear",
					category: "image",
					inputs: [
						{ start: 0, name: "images", type: "tensor" },
						{ start: 1, name: "size", type: "number[]" },
					],
					attrs: [
						{ tfName: "align_corners", name: "alignCorners", type: "bool" },
						{ tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "ResizeNearestNeighbor",
					category: "image",
					inputs: [
						{ start: 0, name: "images", type: "tensor" },
						{ start: 1, name: "size", type: "number[]" },
					],
					attrs: [
						{ tfName: "align_corners", name: "alignCorners", type: "bool" },
						{ tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "CropAndResize",
					category: "image",
					inputs: [
						{ start: 0, name: "image", type: "tensor" },
						{ start: 1, name: "boxes", type: "tensor" },
						{ start: 2, name: "boxInd", type: "tensor" },
						{ start: 3, name: "cropSize", type: "number[]" },
					],
					attrs: [
						{ tfName: "method", name: "method", type: "string" },
						{ tfName: "extrapolation_value", name: "extrapolationValue", type: "number" },
					],
				},
				{
					tfOpName: "ImageProjectiveTransformV3",
					category: "image",
					inputs: [
						{ start: 0, name: "images", type: "tensor" },
						{ start: 1, name: "transforms", type: "tensor" },
						{ start: 2, name: "outputShape", type: "number[]" },
						{ start: 3, name: "fillValue", type: "number" },
					],
					attrs: [
						{ tfName: "interpolation", name: "interpolation", type: "string" },
						{ tfName: "fill_mode", name: "fillMode", type: "string" },
					],
				},
			],
		},
		rB = {
			__proto__: null,
			json: [
				{
					tfOpName: "Equal",
					category: "logical",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "NotEqual",
					category: "logical",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Greater",
					category: "logical",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "GreaterEqual",
					category: "logical",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Less",
					category: "logical",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "LessEqual",
					category: "logical",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "LogicalAnd",
					category: "logical",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "LogicalNot",
					category: "logical",
					inputs: [{ start: 0, name: "a", type: "tensor" }],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "LogicalOr",
					category: "logical",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Select",
					category: "logical",
					inputs: [
						{ start: 0, name: "condition", type: "tensor" },
						{ start: 1, name: "a", type: "tensor" },
						{ start: 2, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "SelectV2",
					category: "logical",
					inputs: [
						{ start: 0, name: "condition", type: "tensor" },
						{ start: 1, name: "a", type: "tensor" },
						{ start: 2, name: "b", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
			],
		},
		aB = {
			__proto__: null,
			json: [
				{
					tfOpName: "_FusedMatMul",
					category: "matrices",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
						{ start: 2, end: 0, name: "args", type: "tensors" },
					],
					attrs: [
						{ tfName: "num_args", name: "numArgs", type: "number" },
						{ tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] },
						{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 },
						{ tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: !1 },
						{ tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: !1 },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "MatMul",
					category: "matrices",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [
						{ tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: !1 },
						{ tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: !1 },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "BatchMatMul",
					category: "matrices",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [
						{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: !1 },
						{ tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: !1 },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "BatchMatMulV2",
					category: "matrices",
					inputs: [
						{ start: 0, name: "a", type: "tensor" },
						{ start: 1, name: "b", type: "tensor" },
					],
					attrs: [
						{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: !1 },
						{ tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: !1 },
						{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 },
					],
				},
				{
					tfOpName: "Transpose",
					category: "matrices",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "perm", type: "number[]" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "Einsum",
					category: "matrices",
					inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }],
					attrs: [
						{ tfName: "equation", name: "equation", type: "string" },
						{ tfName: "N", name: "n", type: "number", defaultValue: 2 },
						{ tfName: "T", name: "dtype", type: "dtype" },
					],
				},
			],
		},
		iB = {
			__proto__: null,
			json: [
				{
					tfOpName: "FusedBatchNorm",
					category: "normalization",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "scale", type: "tensor" },
						{ start: 2, name: "offset", type: "tensor" },
						{ start: 3, name: "mean", type: "tensor" },
						{ start: 4, name: "variance", type: "tensor" },
					],
					attrs: [
						{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 0.001 },
						{ tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 },
					],
				},
				{
					tfOpName: "FusedBatchNormV2",
					category: "normalization",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "scale", type: "tensor" },
						{ start: 2, name: "offset", type: "tensor" },
						{ start: 3, name: "mean", type: "tensor" },
						{ start: 4, name: "variance", type: "tensor" },
					],
					attrs: [
						{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 0.001 },
						{ tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 },
					],
				},
				{
					tfOpName: "FusedBatchNormV3",
					category: "normalization",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "scale", type: "tensor" },
						{ start: 2, name: "offset", type: "tensor" },
						{ start: 3, name: "mean", type: "tensor" },
						{ start: 4, name: "variance", type: "tensor" },
					],
					attrs: [
						{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 0.001 },
						{ tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 },
					],
				},
				{
					tfOpName: "LRN",
					category: "normalization",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "depth_radius", name: "radius", type: "number", defaultValue: 5 },
						{ tfName: "bias", name: "bias", type: "number", defaultValue: 1 },
						{ tfName: "alpha", name: "alpha", type: "number", defaultValue: 1 },
						{ tfName: "beta", name: "beta", type: "number", defaultValue: 0.5 },
					],
				},
				{ tfOpName: "Softmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{
					tfOpName: "LogSoftmax",
					category: "normalization",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
				},
				{
					tfOpName: "SparseToDense",
					category: "normalization",
					inputs: [
						{ start: 0, name: "sparseIndices", type: "tensor" },
						{ start: 1, name: "outputShape", type: "number[]" },
						{ start: 2, name: "sparseValues", type: "tensor" },
						{ start: 3, name: "defaultValue", type: "tensor" },
					],
					attrs: [
						{
							tfName: "validate_indices",
							name: "validateIndices",
							type: "bool",
							defaultValue: !0,
							notSupported: !0,
						},
					],
				},
			],
		},
		oB = {
			__proto__: null,
			json: [
				{
					tfOpName: "Bincount",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "size", type: "number" },
						{ start: 2, name: "weights", type: "tensor" },
					],
				},
				{
					tfOpName: "DenseBincount",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "size", type: "number" },
						{ start: 2, name: "weights", type: "tensor" },
					],
					attrs: [{ tfName: "binary_output", name: "binaryOutput", type: "bool" }],
				},
				{
					tfOpName: "Max",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number[]" },
					],
					attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
				},
				{
					tfOpName: "Mean",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number[]" },
					],
					attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
				},
				{
					tfOpName: "Min",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number[]" },
					],
					attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
				},
				{
					tfOpName: "Sum",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number[]" },
					],
					attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
				},
				{
					tfOpName: "All",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number[]" },
					],
					attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
				},
				{
					tfOpName: "Any",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number[]" },
					],
					attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
				},
				{
					tfOpName: "ArgMax",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number" },
					],
				},
				{
					tfOpName: "ArgMin",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number" },
					],
				},
				{
					tfOpName: "Prod",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number[]" },
					],
					attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }],
				},
				{
					tfOpName: "Cumprod",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number" },
					],
					attrs: [
						{ tfName: "exclusive", name: "exclusive", type: "bool" },
						{ tfName: "reverse", name: "reverse", type: "bool" },
					],
				},
				{
					tfOpName: "Cumsum",
					category: "reduction",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number" },
					],
					attrs: [
						{ tfName: "exclusive", name: "exclusive", type: "bool" },
						{ tfName: "reverse", name: "reverse", type: "bool" },
					],
				},
			],
		},
		sB = {
			__proto__: null,
			json: [
				{
					tfOpName: "ConcatV2",
					category: "slice_join",
					inputs: [
						{ start: 0, end: -1, name: "tensors", type: "tensors" },
						{ start: -1, name: "axis", type: "number" },
					],
					attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }],
				},
				{
					tfOpName: "Concat",
					category: "slice_join",
					inputs: [
						{ start: 1, end: 0, name: "tensors", type: "tensors" },
						{ start: 0, name: "axis", type: "number" },
					],
					attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }],
				},
				{
					tfOpName: "GatherV2",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "indices", type: "tensor" },
						{ start: 2, name: "axis", type: "number", defaultValue: 0 },
					],
					attrs: [{ tfName: "batch_dims", name: "batchDims", type: "number", defaultValue: 0 }],
				},
				{
					tfOpName: "Gather",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "indices", type: "tensor" },
					],
					attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", notSupported: !0 }],
				},
				{
					tfOpName: "Reverse",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "dims", type: "bool[]" },
					],
				},
				{
					tfOpName: "ReverseV2",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number[]" },
					],
				},
				{
					tfOpName: "Slice",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "begin", type: "number[]" },
						{ start: 2, name: "size", type: "number[]" },
					],
				},
				{
					tfOpName: "StridedSlice",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "begin", type: "number[]" },
						{ start: 2, name: "end", type: "number[]" },
						{ start: 3, name: "strides", type: "number[]" },
					],
					attrs: [
						{ tfName: "begin_mask", name: "beginMask", type: "number", defaultValue: 0 },
						{ tfName: "end_mask", name: "endMask", type: "number", defaultValue: 0 },
						{ tfName: "new_axis_mask", name: "newAxisMask", type: "number", defaultValue: 0 },
						{ tfName: "ellipsis_mask", name: "ellipsisMask", type: "number", defaultValue: 0 },
						{ tfName: "shrink_axis_mask", name: "shrinkAxisMask", type: "number", defaultValue: 0 },
					],
				},
				{
					tfOpName: "Pack",
					category: "slice_join",
					inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }],
					attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }],
				},
				{
					tfOpName: "Unpack",
					category: "slice_join",
					inputs: [{ start: 0, name: "tensor", type: "tensor" }],
					attrs: [
						{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 },
						{ tfName: "num", name: "num", type: "number", defaultValue: 0, notSupported: !0 },
					],
				},
				{
					tfOpName: "Tile",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "reps", type: "number[]" },
					],
				},
				{
					tfOpName: "Split",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "axis", type: "number", defaultValue: 0 },
						{ start: 1, name: "x", type: "tensor" },
					],
					attrs: [{ tfName: "num_split", name: "numOrSizeSplits", type: "number", defaultValue: 1 }],
				},
				{
					tfOpName: "SplitV",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "numOrSizeSplits", type: "number[]" },
						{ start: 2, name: "axis", type: "number", defaultValue: 0 },
					],
				},
				{
					tfOpName: "ScatterNd",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "indices", type: "tensor" },
						{ start: 1, name: "values", type: "tensor" },
						{ start: 2, name: "shape", type: "number[]" },
					],
				},
				{
					tfOpName: "GatherNd",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "indices", type: "tensor" },
					],
				},
				{
					tfOpName: "SparseToDense",
					category: "slice_join",
					inputs: [
						{ start: 0, name: "sparseIndices", type: "tensor" },
						{ start: 1, name: "outputShape", type: "number[]" },
						{ start: 2, name: "sparseValues", type: "tensor" },
						{ start: 3, name: "defaultValue", type: "tensor" },
					],
					attrs: [
						{
							tfName: "validate_indices",
							name: "validateIndices",
							type: "bool",
							defaultValue: !1,
							notSupported: !0,
						},
					],
				},
			],
		},
		uB = {
			__proto__: null,
			json: [
				{
					tfOpName: "SparseFillEmptyRows",
					category: "sparse",
					inputs: [
						{ start: 0, name: "indices", type: "tensor" },
						{ start: 1, name: "values", type: "tensor" },
						{ start: 2, name: "denseShape", type: "tensor" },
						{ start: 3, name: "defaultValue", type: "tensor" },
					],
				},
				{
					tfOpName: "SparseReshape",
					category: "sparse",
					inputs: [
						{ start: 0, name: "inputIndices", type: "tensor" },
						{ start: 1, name: "inputShape", type: "tensor" },
						{ start: 2, name: "newShape", type: "tensor" },
					],
					attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }],
				},
				{
					tfOpName: "SparseSegmentMean",
					category: "sparse",
					inputs: [
						{ start: 0, name: "data", type: "tensor" },
						{ start: 1, name: "indices", type: "tensor" },
						{ start: 2, name: "segmentIds", type: "tensor" },
					],
				},
				{
					tfOpName: "SparseSegmentSum",
					category: "sparse",
					inputs: [
						{ start: 0, name: "data", type: "tensor" },
						{ start: 1, name: "indices", type: "tensor" },
						{ start: 2, name: "segmentIds", type: "tensor" },
					],
				},
			],
		},
		lB = {
			__proto__: null,
			json: [
				{ tfOpName: "FFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{ tfOpName: "IFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] },
				{
					tfOpName: "RFFT",
					category: "spectral",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "fft_length", type: "number", notSupported: !0 },
					],
				},
				{
					tfOpName: "IRFFT",
					category: "spectral",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "fft_length", type: "number", notSupported: !0 },
					],
				},
			],
		},
		cB = {
			__proto__: null,
			json: [
				{
					tfOpName: "StringNGrams",
					category: "string",
					inputs: [
						{ start: 0, name: "data", type: "tensor" },
						{ start: 1, name: "dataSplits", type: "tensor" },
					],
					attrs: [
						{ tfName: "separator", name: "separator", type: "string" },
						{ tfName: "ngram_widths", name: "nGramWidths", type: "number[]" },
						{ tfName: "left_pad", name: "leftPad", type: "string" },
						{ tfName: "right_pad", name: "rightPad", type: "string" },
						{ tfName: "pad_width", name: "padWidth", type: "number" },
						{ tfName: "preserve_short_sequences", name: "preserveShortSequences", type: "bool" },
					],
					outputs: ["ngrams", "ngrams_splits"],
				},
				{
					tfOpName: "StringSplit",
					category: "string",
					inputs: [
						{ start: 0, name: "input", type: "tensor" },
						{ start: 1, name: "delimiter", type: "tensor" },
					],
					attrs: [{ tfName: "skip_empty", name: "skipEmpty", type: "bool" }],
					outputs: ["indices", "values", "shape"],
				},
				{
					tfOpName: "StringToHashBucketFast",
					category: "string",
					inputs: [{ start: 0, name: "input", type: "tensor" }],
					attrs: [{ tfName: "num_buckets", name: "numBuckets", type: "number" }],
				},
			],
		},
		pB = {
			__proto__: null,
			json: [
				{
					tfOpName: "Cast",
					category: "transformation",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "SrcT", name: "sdtype", type: "dtype", notSupported: !0 },
						{ tfName: "DstT", name: "dtype", type: "dtype" },
					],
				},
				{
					tfOpName: "ExpandDims",
					category: "transformation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "axis", type: "number" },
					],
				},
				{
					tfOpName: "MirrorPad",
					category: "transformation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "padding", type: "number[]" },
					],
					attrs: [{ tfName: "mode", name: "mode", type: "string" }],
				},
				{
					tfOpName: "Pad",
					category: "transformation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "padding", type: "number[]" },
					],
					attrs: [{ tfName: "constant_value", name: "constantValue", type: "number", defaultValue: 0 }],
				},
				{
					tfOpName: "PadV2",
					category: "transformation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "padding", type: "number[]" },
						{ start: 2, name: "constantValue", type: "number", defaultValue: 0 },
					],
				},
				{
					tfOpName: "Reshape",
					category: "transformation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "shape", type: "number[]" },
					],
				},
				{
					tfOpName: "Squeeze",
					category: "transformation",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [{ tfName: "axis", tfDeprecatedName: "squeeze_dims", name: "axis", type: "number[]" }],
				},
				{
					tfOpName: "SpaceToBatchND",
					category: "transformation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "blockShape", type: "number[]" },
						{ start: 2, name: "paddings", type: "number[]" },
					],
				},
				{
					tfOpName: "BatchToSpaceND",
					category: "transformation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "blockShape", type: "number[]" },
						{ start: 2, name: "crops", type: "number[]" },
					],
				},
				{
					tfOpName: "DepthToSpace",
					category: "transformation",
					inputs: [{ start: 0, name: "x", type: "tensor" }],
					attrs: [
						{ tfName: "block_size", name: "blockSize", type: "number" },
						{ tfName: "data_format", name: "dataFormat", type: "string" },
					],
				},
				{
					tfOpName: "BroadcastTo",
					category: "transformation",
					inputs: [
						{ start: 0, name: "x", type: "tensor" },
						{ start: 1, name: "shape", type: "number[]" },
					],
					attrs: [],
				},
				{
					tfOpName: "BroadcastArgs",
					category: "transformation",
					inputs: [
						{ start: 0, name: "s0", type: "tensor" },
						{ start: 1, name: "s1", type: "tensor" },
					],
					attrs: [],
				},
			],
		},
		hB = (function () {
			function e() {
				var e,
					t = [KP, XP, YP, JP, ZP, QP, $P, eB, tB, nB, rB, aB, iB, oB, sB, uB, lB, cB, pB],
					n = (e = []).concat.apply(
						e,
						t.map(function (e) {
							return e.json;
						})
					);
				this.opMappers = n.reduce(function (e, t) {
					return (e[t.tfOpName] = t), e;
				}, {});
			}
			var t = e.prototype;
			return (
				(t.transformGraph = function (e, t) {
					var n = this;
					void 0 === t && (t = {});
					var r = e.node,
						a = [],
						i = [],
						o = [],
						s = r.reduce(function (e, t) {
							return (
								(e[t.name] = n.mapNode(t)),
								t.op.startsWith("Placeholder")
									? a.push(e[t.name])
									: "Const" === t.op
									? i.push(e[t.name])
									: (null != t.input && 0 !== t.input.length) || o.push(e[t.name]),
								e
							);
						}, {}),
						u = [],
						l = [],
						c = {},
						p = {};
					null != t && ((c = this.mapSignatureEntries(t.inputs)), (p = this.mapSignatureEntries(t.outputs)));
					var h = Object.keys(s);
					h.forEach(function (e) {
						var t = s[e];
						t.inputNames.forEach(function (e, n) {
							var r = VP(e),
								a = r[0],
								i = r[2],
								o = s[a];
							if (null != o.outputs) {
								var u = o.outputs.indexOf(i);
								if (-1 !== u) {
									var l = a + ":" + u;
									t.inputNames[n] = l;
								}
							}
							t.inputs.push(o), o.children.push(t);
						});
					}),
						0 === Object.keys(p).length
							? h.forEach(function (e) {
									var t = s[e];
									0 === t.children.length && l.push(t);
							  })
							: Object.keys(p).forEach(function (e) {
									var t = VP(e)[0],
										n = s[t];
									null != n && ((n.signatureKey = p[e]), l.push(n));
							  }),
						Object.keys(c).length > 0
							? Object.keys(c).forEach(function (e) {
									var t = VP(e)[0],
										n = s[t];
									n && ((n.signatureKey = c[e]), u.push(n));
							  })
							: (u = a);
					var f = {};
					null != e.library &&
						null != e.library.function &&
						(f = e.library.function.reduce(function (e, t) {
							return (e[t.signature.name] = n.mapFunction(t)), e;
						}, {}));
					var d = {
						nodes: s,
						inputs: u,
						outputs: l,
						weights: i,
						placeholders: a,
						signature: t,
						functions: f,
					};
					return o.length > 0 && (d.initNodes = o), d;
				}),
				(t.mapSignatureEntries = function (e) {
					return Object.keys(e || {}).reduce(function (t, n) {
						return (t[e[n].name] = n), t;
					}, {});
				}),
				(t.mapNode = function (e) {
					var t = BP(e.op) || this.opMappers[e.op] || {};
					null == e.attr && (e.attr = {});
					var n = {
						name: e.name,
						op: e.op,
						category: t.category,
						inputNames: (e.input || []).map(function (e) {
							return e.startsWith("^") ? e.substr(1) : e;
						}),
						inputs: [],
						children: [],
						inputParams: {},
						attrParams: {},
						rawAttrs: e.attr,
						outputs: t.outputs,
					};
					return (
						null != t.inputs &&
							(n.inputParams = t.inputs.reduce(function (e, t) {
								return (
									(e[t.name] = { type: t.type, inputIndexStart: t.start, inputIndexEnd: t.end }), e
								);
							}, {})),
						null != t.attrs &&
							(n.attrParams = t.attrs.reduce(function (t, n) {
								var r = n.type,
									a = void 0;
								switch (n.type) {
									case "string":
										void 0 === (a = dB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = dB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "string[]":
										void 0 === (a = IB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = IB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "number":
										void 0 === (a = gB(e.attr, n.tfName, n.defaultValue || 0)) &&
											n.tfDeprecatedName &&
											(a = gB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "number[]":
										void 0 === (a = NB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = NB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "bool":
										void 0 === (a = mB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = mB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "bool[]":
										void 0 === (a = TB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = TB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "shape":
										void 0 === (a = kB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = kB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "shape[]":
										void 0 === (a = SB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = SB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "dtype":
										void 0 === (a = bB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = bB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "dtype[]":
										void 0 === (a = xB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = xB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "func":
										void 0 === (a = yB(e.attr, n.tfName, n.defaultValue)) &&
											n.tfDeprecatedName &&
											(a = yB(e.attr, n.tfDeprecatedName, n.defaultValue));
										break;
									case "tensor":
									case "tensors":
										break;
									default:
										throw new Error("Unsupported param type: " + n.type + " for op: " + e.op);
								}
								return (t[n.name] = { value: a, type: r }), t;
							}, {})),
						n
					);
				}),
				(t.mapFunction = function (e) {
					var t = this,
						n = e.nodeDef,
						r = [],
						a = {};
					null != n &&
						(a = n.reduce(function (e, n) {
							return (e[n.name] = t.mapNode(n)), "Const" === n.op && r.push(e[n.name]), e;
						}, {}));
					var i = [],
						o = [];
					e.signature.inputArg.forEach(function (e) {
						var t = VP(e.name)[0],
							n = {
								name: t,
								op: "Placeholder",
								inputs: [],
								inputNames: [],
								category: "graph",
								inputParams: {},
								attrParams: { dtype: { value: vB(e.type), type: "dtype" } },
								children: [],
							};
						(n.signatureKey = e.name), i.push(n), (a[t] = n);
					}),
						Object.keys(a).forEach(function (e) {
							var t = a[e];
							t.inputNames.forEach(function (e, n) {
								var r = VP(e),
									i = r[0],
									o = r[2],
									s = a[i];
								if (null != s.outputs) {
									var u = s.outputs.indexOf(o);
									if (-1 !== u) {
										var l = i + ":" + u;
										t.inputNames[n] = l;
									}
								}
								t.inputs.push(s), s.children.push(t);
							});
						});
					var s = e.ret;
					e.signature.outputArg.forEach(function (e) {
						var t = VP(s[e.name]),
							n = t[0],
							r = t[1],
							i = a[n];
						null != i && ((i.defaultOutput = r), o.push(i));
					});
					var u = this.mapArgsToSignature(e);
					return { nodes: a, inputs: i, outputs: o, weights: r, placeholders: [], signature: u };
				}),
				(t.mapArgsToSignature = function (e) {
					var t = this;
					return {
						methodName: e.signature.name,
						inputs: e.signature.inputArg.reduce(function (e, n) {
							return (e[n.name] = t.mapArgToTensorInfo(n)), e;
						}, {}),
						outputs: e.signature.outputArg.reduce(function (n, r) {
							return (n[r.name] = t.mapArgToTensorInfo(r, e.ret)), n;
						}, {}),
					};
				}),
				(t.mapArgToTensorInfo = function (e, t) {
					var n = e.name;
					return null != t && (n = t[n]), { name: n, dtype: e.type };
				}),
				mg(e, null, [
					{
						key: "Instance",
						get: function () {
							return this._instance || (this._instance = new this());
						},
					},
				]),
				e
			);
		})();
	function fB(e, t) {
		var n = Array.isArray(e)
			? String.fromCharCode.apply(null, e)
			: (function (e) {
					var t = xv().global;
					if (void 0 !== t.atob) return t.atob(e);
					if ("undefined" != typeof Buffer) return new Buffer(e, "base64").toString();
					throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
			  })(e);
		return t ? n : n.toLowerCase();
	}
	function dB(e, t, n, r) {
		void 0 === r && (r = !1);
		var a = e[t];
		return null != a ? fB(a.s, r) : n;
	}
	function mB(e, t, n) {
		var r = e[t];
		return r ? r.b : n;
	}
	function gB(e, t, n) {
		var r = e[t] || {},
			a = null != r.i ? r.i : null != r.f ? r.f : n;
		return "number" == typeof a ? a : parseInt(a, 10);
	}
	function vB(e) {
		switch (("string" == typeof e && (e = OP[e]), e)) {
			case OP.DT_FLOAT:
			case OP.DT_HALF:
				return "float32";
			case OP.DT_INT32:
			case OP.DT_INT64:
			case OP.DT_INT8:
			case OP.DT_UINT8:
				return "int32";
			case OP.DT_BOOL:
				return "bool";
			case OP.DT_DOUBLE:
				return "float32";
			case OP.DT_STRING:
				return "string";
			default:
				return null;
		}
	}
	function yB(e, t, n) {
		var r = e[t];
		return r && r.func ? r.func.name : n;
	}
	function bB(e, t, n) {
		var r = e[t];
		return r && r.type ? vB(r.type) : n;
	}
	function xB(e, t, n) {
		var r = e[t];
		return r && r.list && r.list.type
			? r.list.type.map(function (e) {
					return vB(e);
			  })
			: n;
	}
	function wB(e) {
		if (!e.unknownRank)
			return null != e.dim
				? e.dim.map(function (e) {
						return "number" == typeof e.size ? e.size : parseInt(e.size, 10);
				  })
				: [];
	}
	function kB(e, t, n) {
		var r = e[t];
		return r && r.shape ? wB(r.shape) : n;
	}
	function NB(e, t, n) {
		var r = e[t];
		return r
			? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(function (e) {
					return "number" == typeof e ? e : parseInt(e, 10);
			  })
			: n;
	}
	function IB(e, t, n, r) {
		void 0 === r && (r = !1);
		var a = e[t];
		return a && a.list && a.list.s
			? a.list.s.map(function (e) {
					return fB(e, r);
			  })
			: n;
	}
	function SB(e, t, n) {
		var r = e[t];
		return r && r.list && r.list.shape
			? r.list.shape.map(function (e) {
					return wB(e);
			  })
			: n;
	}
	function TB(e, t, n) {
		var r = e[t];
		return r && r.list && r.list.b ? r.list.b : n;
	}
	var CB = (function () {
			function e(e, t, n) {
				var r = this;
				(this.node = e),
					(this.tensorMap = t),
					(this.context = n),
					(this.inputs = []),
					(this.attrs = {}),
					(this.inputs = e.inputNames.map(function (e) {
						return r.getInput(e);
					})),
					null != e.rawAttrs &&
						(this.attrs = Object.keys(e.rawAttrs).reduce(function (e, t) {
							return (e[t] = r.getAttr(t)), e;
						}, {}));
			}
			var t = e.prototype;
			return (
				(t.getInput = function (e) {
					return UP(e, this.tensorMap, this.context);
				}),
				(t.getAttr = function (e, t) {
					var n = this.node.rawAttrs[e];
					if (null != n.tensor) return UP(e, this.tensorMap, this.context);
					if (null != n.i || null != n.f) return gB(this.node.rawAttrs, e, t);
					if (null != n.s) return dB(this.node.rawAttrs, e, t);
					if (null != n.b) return mB(this.node.rawAttrs, e, t);
					if (null != n.shape) return kB(this.node.rawAttrs, e, t);
					if (null != n.type) return bB(this.node.rawAttrs, e, t);
					if (null != n.list) {
						if (null != n.list.i || null != n.list.f) return NB(this.node.rawAttrs, e, t);
						if (null != n.list.s) return IB(this.node.rawAttrs, e, t);
						if (null != n.list.shape) return SB(this.node.rawAttrs, e, t);
						if (null != n.list.b) return TB(this.node.rawAttrs, e, t);
						if (null != n.list.type) return xB(this.node.rawAttrs, e, t);
					}
					return t;
				}),
				e
			);
		})(),
		EB = {
			__proto__: null,
			abs: XI,
			acos: YI,
			acosh: JI,
			add: jI,
			addN: ZI,
			all: QI,
			any: $I,
			argMax: eS,
			argMin: tS,
			asin: nS,
			asinh: rS,
			atan: aS,
			atan2: iS,
			atanh: oS,
			avgPool: kS,
			avgPool3d: NS,
			basicLSTMCell: ES,
			batchToSpaceND: RS,
			batchNorm: AS,
			batchNorm2d: _S,
			batchNorm3d: FS,
			batchNorm4d: DS,
			bincount: OS,
			broadcastArgs: MS,
			broadcastTo: LS,
			buffer: kN,
			cast: NN,
			ceil: zS,
			clipByValue: PS,
			clone: IN,
			complex: bk,
			concat: IS,
			concat1d: BS,
			concat2d: WS,
			concat3d: US,
			concat4d: VS,
			conv1d: jS,
			conv2d: GS,
			conv2dTranspose: qS,
			conv3d: KS,
			conv3dTranspose: YS,
			cos: JS,
			cosh: ZS,
			cumprod: QS,
			cumsum: $S,
			denseBincount: eT,
			depthToSpace: tT,
			depthwiseConv2d: nT,
			diag: rT,
			dilation2d: aT,
			div: qI,
			divNoNan: uT,
			dot: lT,
			einsum: cT,
			elu: pT,
			equal: iT,
			erf: hT,
			exp: fT,
			expandDims: dT,
			expm1: mT,
			eye: vT,
			fill: yT,
			floor: bT,
			floorDiv: HI,
			gather: xT,
			greater: wT,
			greaterEqual: kT,
			imag: NT,
			isFinite: IT,
			isInf: ST,
			isNaN: TT,
			leakyRelu: CT,
			less: ET,
			lessEqual: RT,
			linspace: AT,
			localResponseNormalization: _T,
			log: FT,
			log1p: DT,
			logSigmoid: BT,
			logSoftmax: GT,
			logSumExp: QT,
			logicalAnd: $T,
			logicalNot: eC,
			logicalOr: tC,
			logicalXor: nC,
			matMul: jN,
			max: WT,
			maxPool: rC,
			maxPool3d: aC,
			maxPoolWithArgmax: iC,
			maximum: oC,
			mean: sC,
			meshgrid: cC,
			min: pC,
			minimum: hC,
			mirrorPad: fC,
			mod: dC,
			moments: gC,
			mul: KI,
			multiRNNCell: vC,
			multinomial: yC,
			neg: zT,
			notEqual: bC,
			oneHot: HN,
			ones: lC,
			onesLike: xC,
			outerProduct: wC,
			pad: kC,
			pad1d: NC,
			pad2d: IC,
			pad3d: SC,
			pad4d: TC,
			pool: EC,
			pow: RC,
			prelu: AC,
			print: SN,
			prod: _C,
			rand: FC,
			randomGamma: jC,
			randomNormal: HC,
			randomUniform: qC,
			range: KC,
			real: XC,
			reciprocal: YC,
			relu: JC,
			relu6: ZC,
			reshape: wS,
			reverse: QC,
			reverse1d: $C,
			reverse2d: eE,
			reverse3d: tE,
			reverse4d: nE,
			round: rE,
			rsqrt: aE,
			scalar: iE,
			selu: oE,
			separableConv2d: sE,
			setdiff1dAsync: lE,
			sigmoid: SS,
			sign: cE,
			sin: pE,
			sinh: hE,
			slice: TS,
			slice1d: fE,
			slice2d: dE,
			slice3d: mE,
			slice4d: gE,
			softmax: vE,
			softplus: PT,
			spaceToBatchND: CC,
			fft: yE,
			ifft: bE,
			irfft: xE,
			rfft: kE,
			split: wE,
			sqrt: NE,
			square: mC,
			squaredDifference: IE,
			squeeze: SE,
			stack: TE,
			step: CE,
			stridedSlice: EE,
			sub: UT,
			sum: VT,
			tan: RE,
			tanh: CS,
			tensor: wk,
			tensor1d: AE,
			tensor2d: _E,
			tensor3d: $N,
			tensor4d: FE,
			tensor5d: DE,
			tensor6d: OE,
			tile: gT,
			topk: ME,
			truncatedNormal: LE,
			unique: zE,
			unsortedSegmentSum: PE,
			unstack: BE,
			variable: WE,
			where: oT,
			whereAsync: GE,
			zeros: uC,
			zerosLike: sT,
			op: yk,
			OP_SCOPE_SUFFIX: vk,
			booleanMaskAsync: HE,
			transpose: qN,
			norm: KE,
			movingAverage: XE,
			scatterND: YE,
			sparseToDense: JE,
			gatherND: ZE,
			dropout: QE,
			enclosingPowerOfTwo: $E,
			cosineWindow: eR,
			inTopKAsync: nR,
			image: pA,
			linalg: hA,
			losses: fA,
			spectral: lA,
			fused: fR,
			signal: cA,
			sparse: dA,
			string: mA,
		};
	function RB(e, t, n) {
		if ((void 0 === n && (n = ""), "number" != typeof e && "number" != typeof t)) {
			Dg(e.length === t.length, function () {
				return n + " Shapes " + e + " and " + t + " must match";
			});
			for (var r = 0; r < e.length; r++) {
				var a = e[r],
					i = t[r];
				Dg(a < 0 || i < 0 || a === i, function () {
					return n + " Shapes " + e + " and " + t + " must match";
				});
			}
		}
	}
	function AB(e) {
		return (
			"number" != typeof e &&
			!e.some(function (e) {
				return e < 0;
			})
		);
	}
	function _B(e, t, n) {
		var r = FB(e, n),
			a = !AB(r);
		if (a && 0 === t.length)
			throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: " + r);
		if (
			(a &&
				t.forEach(function (e) {
					r = FB(e.shape, r);
				}),
			!AB(r))
		)
			throw new Error("Non-fully-defined elementShape: " + r);
		return r;
	}
	function FB(e, t) {
		if ("number" == typeof e) return t;
		if ("number" == typeof t) return e;
		if (e.length !== t.length) throw new Error("Incompatible ranks during merge: " + e + " vs. " + t);
		for (var n = [], r = 0; r < e.length; ++r) {
			var a = e[r],
				i = t[r];
			if (a >= 0 && i >= 0 && a !== i) throw new Error("Incompatible shape during merge: " + e + " vs. " + t);
			n[r] = a >= 0 ? a : i;
		}
		return n;
	}
	var DB = (function () {
			function e(e, t, n, r, a, i, o) {
				(this.name = e),
					(this.dtype = t),
					(this.maxSize = n),
					(this.elementShape = r),
					(this.identicalElementShapes = a),
					(this.dynamicSize = i),
					(this.clearAfterRead = o),
					(this.tensors = []),
					(this.closed_ = !1),
					(this.idTensor = iE(0)),
					UI(this.idTensor);
			}
			var t = e.prototype;
			return (
				(t.clearAndClose = function (e) {
					this.tensors.forEach(function (t) {
						(null != e && e.has(t.tensor.id)) || t.tensor.dispose();
					}),
						(this.tensors = []),
						(this.closed_ = !0),
						this.idTensor.dispose();
				}),
				(t.size = function () {
					return this.tensors.length;
				}),
				(t.read = function (e) {
					if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
					if (e < 0 || e >= this.size())
						throw new Error("Tried to read from index " + e + ", but array size is: " + this.size());
					var t = this.tensors[e];
					if (t.cleared)
						throw new Error(
							"TensorArray " +
								this.name +
								": Could not read index " +
								e +
								" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?)."
						);
					return this.clearAfterRead && (t.cleared = !0), (t.read = !0), t.tensor;
				}),
				(t.readMany = function (e) {
					var t = this;
					return e.map(function (e) {
						return t.read(e);
					});
				}),
				(t.write = function (e, t) {
					if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
					if (e < 0 || (!this.dynamicSize && e >= this.maxSize))
						throw new Error(
							"Tried to write to index " +
								e +
								", but array is not resizeable and size is: " +
								this.maxSize
						);
					var n = this.tensors[e] || {};
					if (t.dtype !== this.dtype)
						throw new Error(
							"TensorArray " +
								this.name +
								": Could not write to TensorArray index " +
								e +
								",\n          because the value dtype is " +
								t.dtype +
								", but TensorArray dtype is " +
								this.dtype +
								"."
						);
					if (
						(0 !== this.size() ||
							(null != this.elementShape && 0 !== this.elementShape.length) ||
							(this.elementShape = t.shape),
						RB(
							this.elementShape,
							t.shape,
							"TensorArray " + this.name + ": Could not write to TensorArray index " + e + "."
						),
						n.read)
					)
						throw new Error(
							"TensorArray " +
								this.name +
								": Could not write to TensorArray index " +
								e +
								", because it has already been read."
						);
					if (n.written)
						throw new Error(
							"TensorArray " +
								this.name +
								": Could not write to TensorArray index " +
								e +
								", because it has already been written."
						);
					(n.tensor = t), UI(t), (n.written = !0), (this.tensors[e] = n);
				}),
				(t.writeMany = function (e, t) {
					var n = this;
					if (e.length !== t.length)
						throw new Error(
							"TensorArray " +
								this.name +
								": could not write multiple tensors,because the index size: " +
								e.length +
								" is not the same as tensors size: " +
								t.length +
								"."
						);
					e.forEach(function (e, r) {
						return n.write(e, t[r]);
					});
				}),
				(t.gather = function (e, t) {
					if (t && t !== this.dtype)
						throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + t);
					if (e) e = e.slice(0, this.size());
					else {
						e = [];
						for (var n = 0; n < this.size(); n++) e.push(n);
					}
					if (0 === e.length) return wk([], [0].concat(this.elementShape));
					var r = this.readMany(e);
					return RB(this.elementShape, r[0].shape, "TensorArray shape mismatch: "), TE(r, 0);
				}),
				(t.concat = function (e) {
					if (e && e !== this.dtype)
						throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + e);
					if (0 === this.size()) return wk([], [0].concat(this.elementShape));
					for (var t = [], n = 0; n < this.size(); n++) t.push(n);
					var r = this.readMany(t);
					return (
						RB(
							this.elementShape,
							r[0].shape,
							"TensorArray shape mismatch: tensor array shape (" +
								this.elementShape +
								") vs first tensor shape (" +
								r[0].shape +
								")"
						),
						IS(r, 0)
					);
				}),
				(t.scatter = function (e, t) {
					if (t.dtype !== this.dtype)
						throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
					if (e.length !== t.shape[0])
						throw new Error(
							"Expected len(indices) == tensor.shape[0], but saw: " + e.length + " vs. " + t.shape[0]
						);
					var n = Math.max.apply(Math, e);
					if (!this.dynamicSize && n >= this.maxSize)
						throw new Error("Max index must be < array size (" + n + "  vs. " + this.maxSize + ")");
					this.writeMany(e, BE(t, 0));
				}),
				(t.split = function (e, t) {
					var n = this;
					if (t.dtype !== this.dtype)
						throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
					var r = 0,
						a = e.map(function (e) {
							return (r += e);
						});
					if (r !== t.shape[0])
						throw new Error(
							"Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " +
								r +
								", and tensor's shape is: " +
								t.shape
						);
					if (!this.dynamicSize && e.length !== this.maxSize)
						throw new Error(
							"TensorArray's size is not equal to the size of lengths (" +
								this.maxSize +
								" vs. " +
								e.length +
								"), and the TensorArray is not marked as dynamically resizeable"
						);
					var i = 0 === r ? 0 : t.size / r,
						o = [];
					BI(function () {
						t = wS(t, [1, r, i]);
						for (var s = 0; s < e.length; ++s) {
							var u = [0, 0 === s ? 0 : a[s - 1], 0],
								l = [1, e[s], i];
							o[s] = wS(TS(t, u, l), n.elementShape);
						}
						return o;
					});
					for (var s = [], u = 0; u < e.length; u++) s[u] = u;
					this.writeMany(s, o);
				}),
				mg(e, [
					{
						key: "id",
						get: function () {
							return this.idTensor.id;
						},
					},
					{
						key: "closed",
						get: function () {
							return this.closed_;
						},
					},
				]),
				e
			);
		})(),
		OB = (function () {
			function e(e, t, n, r) {
				void 0 === r && (r = -1),
					(this.tensors = e),
					(this.elementShape = t),
					(this.elementDtype = n),
					null != e &&
						e.forEach(function (e) {
							if (n !== e.dtype)
								throw new Error(
									"Invalid data types; op elements " + n + ", but list elements " + e.dtype
								);
							RB(t, e.shape, "TensorList shape mismatch: "), UI(e);
						}),
					(this.idTensor = iE(0)),
					(this.maxNumElements = r),
					UI(this.idTensor);
			}
			var t = e.prototype;
			return (
				(t.copy = function () {
					return new e([].concat(this.tensors), this.elementShape, this.elementDtype);
				}),
				(t.clearAndClose = function (e) {
					this.tensors.forEach(function (t) {
						(null != e && e.has(t.id)) || t.dispose();
					}),
						(this.tensors.length = 0),
						this.idTensor.dispose();
				}),
				(t.size = function () {
					return this.tensors.length;
				}),
				(t.stack = function (e, t, n) {
					var r = this;
					if ((void 0 === n && (n = -1), t !== this.elementDtype))
						throw new Error(
							"Invalid data types; op elements " + t + ", but list elements " + this.elementDtype
						);
					if (-1 !== n && this.tensors.length !== n)
						throw new Error(
							"Operation expected a list with " +
								n +
								" elements but got a list with " +
								this.tensors.length +
								" elements."
						);
					RB(e, this.elementShape, "TensorList shape mismatch: ");
					var a = _B(this.elementShape, this.tensors, e);
					return BI(function () {
						var e = r.tensors.map(function (e) {
							return wS(e, a);
						});
						return TE(e, 0);
					});
				}),
				(t.popBack = function (e, t) {
					if (t !== this.elementDtype)
						throw new Error(
							"Invalid data types; op elements " + t + ", but list elements " + this.elementDtype
						);
					if (0 === this.size()) throw new Error("Trying to pop from an empty list.");
					var n = _B(this.elementShape, this.tensors, e),
						r = this.tensors.pop();
					return RB(r.shape, e, "TensorList shape mismatch: "), wS(r, n);
				}),
				(t.pushBack = function (e) {
					if (e.dtype !== this.elementDtype)
						throw new Error(
							"Invalid data types; op elements " + e.dtype + ", but list elements " + this.elementDtype
						);
					if (
						(RB(e.shape, this.elementShape, "TensorList shape mismatch: "),
						this.maxNumElements === this.size())
					)
						throw new Error("Trying to push element into a full list.");
					UI(e), this.tensors.push(e);
				}),
				(t.resize = function (e) {
					if (e < 0) throw new Error("TensorListResize expects size to be non-negative. Got: " + e);
					if (-1 !== this.maxNumElements && e > this.maxNumElements)
						throw new Error(
							"TensorListResize input size " +
								e +
								" is greater maxNumElement " +
								this.maxNumElements +
								"."
						);
					this.tensors.length = e;
				}),
				(t.getItem = function (e, t, n) {
					if (n !== this.elementDtype)
						throw new Error(
							"Invalid data types; op elements " + n + ", but list elements " + this.elementDtype
						);
					if (e < 0 || e > this.tensors.length)
						throw new Error(
							"Trying to access element " + e + " in a list with " + this.tensors.length + " elements."
						);
					if (null == this.tensors[e]) throw new Error("element at index " + e + " is null.");
					RB(this.tensors[e].shape, t, "TensorList shape mismatch: ");
					var r = _B(this.elementShape, this.tensors, t);
					return wS(this.tensors[e], r);
				}),
				(t.setItem = function (e, t) {
					if (t.dtype !== this.elementDtype)
						throw new Error(
							"Invalid data types; op elements " + t.dtype + ", but list elements " + this.elementDtype
						);
					if (e < 0 || (-1 !== this.maxNumElements && e >= this.maxNumElements))
						throw new Error(
							"Trying to set element " + e + " in a list with max " + this.maxNumElements + " elements."
						);
					RB(this.elementShape, t.shape, "TensorList shape mismatch: "), UI(t), (this.tensors[e] = t);
				}),
				(t.gather = function (e, t, n) {
					var r = this;
					if (t !== this.elementDtype)
						throw new Error(
							"Invalid data types; op elements " + t + ", but list elements " + this.elementDtype
						);
					RB(this.elementShape, n, "TensorList shape mismatch: "), (e = e.slice(0, this.size()));
					var a = _B(this.elementShape, this.tensors, n);
					return 0 === e.length
						? wk([], [0].concat(a))
						: BI(function () {
								var t = e.map(function (e) {
									return wS(r.tensors[e], a);
								});
								return TE(t, 0);
						  });
				}),
				(t.concat = function (e, t) {
					var n = this;
					if (e && e !== this.elementDtype)
						throw new Error(
							"TensorList dtype is " + this.elementDtype + " but concat requested dtype " + e
						);
					RB(this.elementShape, t, "TensorList shape mismatch: ");
					var r = _B(this.elementShape, this.tensors, t);
					return 0 === this.size()
						? wk([], [0].concat(r))
						: BI(function () {
								var e = n.tensors.map(function (e) {
									return wS(e, r);
								});
								return IS(e, 0);
						  });
				}),
				mg(e, [
					{
						key: "id",
						get: function () {
							return this.idTensor.id;
						},
					},
				]),
				e
			);
		})();
	function MB(e, t, n) {
		var r = e.dtype;
		if (e.shape.length < 1) throw new Error("Tensor must be at least a vector, but saw shape: " + e.shape);
		if (e.dtype !== n) throw new Error("Invalid data types; op elements " + e.dtype + ", but list elements " + n);
		RB(e.shape.slice(1), t, "TensorList shape mismatch: ");
		var a = BE(e);
		return new OB(a, t, r);
	}
	function LB(e, t, n) {
		return new OB([], e, t, n);
	}
	function zB(e, t, n, r) {
		if (t.length !== e.shape[0])
			throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + t.length + " vs. " + e.shape[0]);
		var a = Math.max.apply(Math, t);
		if (null != r && -1 !== r && a >= r)
			throw new Error("Max index must be < array size (" + a + "  vs. " + r + ")");
		var i = new OB([], n, e.dtype, r),
			o = BE(e, 0);
		return (
			t.forEach(function (e, t) {
				i.setItem(e, o[t]);
			}),
			i
		);
	}
	function PB(e, t, n) {
		var r = 0,
			a = t.map(function (e) {
				return (r += e);
			});
		if (r !== e.shape[0])
			throw new Error(
				"Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " +
					r +
					", and tensor's shape is: " +
					e.shape
			);
		for (
			var i = FB(e.shape.slice(1), n),
				o = 0 === r ? 0 : e.size / r,
				s = BI(function () {
					var n = [];
					e = wS(e, [1, r, o]);
					for (var s = 0; s < t.length; ++s) {
						var u = [0, 0 === s ? 0 : a[s - 1], 0],
							l = [1, t[s], o];
						n[s] = wS(TS(e, u, l), i);
					}
					return e.dispose(), n;
				}),
				u = new OB([], n, e.dtype, t.length),
				l = 0;
			l < s.length;
			l++
		)
			u.setItem(l, s[l]);
		return u;
	}
	var BB = (function () {
		var e = fg(
			regeneratorRuntime.mark(function e(t, n, r) {
				var a,
					i,
					o,
					s,
					u,
					l,
					c,
					p,
					h,
					f,
					d,
					m,
					g,
					v,
					y,
					b,
					x,
					w,
					k,
					N,
					I,
					S,
					T,
					C,
					E,
					R,
					A,
					_,
					F,
					D,
					O,
					M,
					L,
					z,
					P,
					B,
					W,
					U,
					V,
					G,
					j,
					H,
					q,
					K,
					X,
					Y,
					J,
					Z,
					Q,
					$,
					ee,
					te,
					ne,
					re,
					ae,
					ie,
					oe,
					se,
					ue,
					le,
					ce,
					pe,
					he,
					fe,
					de,
					me,
					ge,
					ve,
					ye,
					be,
					xe,
					we,
					ke,
					Ne,
					Ie,
					Se,
					Te,
					Ce,
					Ee,
					Re,
					Ae,
					_e,
					Fe,
					De,
					Oe,
					Me,
					Le,
					ze,
					Pe,
					Be,
					We,
					Ue,
					Ve,
					Ge,
					je,
					He;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								(e.t0 = t.op),
									(e.next =
										"If" === e.t0 || "StatelessIf" === e.t0
											? 3
											: "While" === e.t0 || "StatelessWhile" === e.t0
											? 15
											: "LoopCond" === e.t0
											? 19
											: "Switch" === e.t0
											? 21
											: "Merge" === e.t0
											? 32
											: "Enter" === e.t0
											? 37
											: "Exit" === e.t0
											? 41
											: "NextIteration" === e.t0
											? 44
											: "TensorArrayV3" === e.t0
											? 47
											: "TensorArrayWriteV3" === e.t0
											? 57
											: "TensorArrayReadV3" === e.t0
											? 63
											: "TensorArrayGatherV3" === e.t0
											? 67
											: "TensorArrayScatterV3" === e.t0
											? 72
											: "TensorArrayConcatV3" === e.t0
											? 78
											: "TensorArraySplitV3" === e.t0
											? 82
											: "TensorArraySizeV3" === e.t0
											? 88
											: "TensorArrayCloseV3" === e.t0
											? 91
											: "TensorListSetItem" === e.t0
											? 95
											: "TensorListGetItem" === e.t0
											? 101
											: "TensorListScatterV2" === e.t0 || "TensorListScatter" === e.t0
											? 107
											: "TensorListReserve" === e.t0 || "EmptyTensorList" === e.t0
											? 114
											: "TensorListGather" === e.t0
											? 121
											: "TensorListStack" === e.t0
											? 127
											: "TensorListFromTensor" === e.t0
											? 133
											: "TensorListConcat" === e.t0
											? 139
											: "TensorListPushBack" === e.t0
											? 144
											: "TensorListPopBack" === e.t0
											? 149
											: "TensorListSplit" === e.t0
											? 154
											: 160);
								break;
							case 3:
								return (
									(a = WP("thenBranch", t, n, r)),
									(i = WP("elseBranch", t, n, r)),
									(o = WP("cond", t, n, r)),
									(s = WP("args", t, n, r)),
									(e.next = 9),
									o.data()
								);
							case 9:
								if (!e.sent[0]) {
									e.next = 14;
									break;
								}
								return e.abrupt(
									"return",
									r.functionMap[a].executeFunctionAsync(s, r.tensorArrayMap, r.tensorListMap)
								);
							case 14:
								return e.abrupt(
									"return",
									r.functionMap[i].executeFunctionAsync(s, r.tensorArrayMap, r.tensorListMap)
								);
							case 15:
								return e.delegateYield(
									regeneratorRuntime.mark(function e() {
										var a, i, o, s, u, l, c, p;
										return regeneratorRuntime.wrap(function (e) {
											for (;;)
												switch ((e.prev = e.next)) {
													case 0:
														return (
															(a = WP("body", t, n, r)),
															(i = WP("cond", t, n, r)),
															(o = WP("args", t, n, r)),
															(e.next = 5),
															r.functionMap[i].executeFunctionAsync(
																o,
																r.tensorArrayMap,
																r.tensorListMap
															)
														);
													case 5:
														return (
															(s = e.sent),
															(u = o.map(function (e) {
																return e.id;
															})),
															(e.next = 9),
															s[0].data()
														);
													case 9:
														(l = e.sent),
															s.forEach(function (e) {
																e.kept || -1 !== u.indexOf(e.id) || e.dispose();
															}),
															(c = o),
															(p = regeneratorRuntime.mark(function e() {
																var t, n, o;
																return regeneratorRuntime.wrap(function (e) {
																	for (;;)
																		switch ((e.prev = e.next)) {
																			case 0:
																				return (
																					(t = c),
																					(e.next = 3),
																					r.functionMap[
																						a
																					].executeFunctionAsync(
																						c,
																						r.tensorArrayMap,
																						r.tensorListMap
																					)
																				);
																			case 3:
																				return (
																					(c = e.sent),
																					(n = c.map(function (e) {
																						return e.id;
																					})),
																					t.forEach(function (e) {
																						e.kept ||
																							-1 !== u.indexOf(e.id) ||
																							-1 !== n.indexOf(e.id) ||
																							e.dispose();
																					}),
																					(e.next = 8),
																					r.functionMap[
																						i
																					].executeFunctionAsync(
																						c,
																						r.tensorArrayMap,
																						r.tensorListMap
																					)
																				);
																			case 8:
																				return (
																					(o = e.sent),
																					(e.next = 11),
																					o[0].data()
																				);
																			case 11:
																				(l = e.sent),
																					o.forEach(function (e) {
																						e.kept ||
																							-1 !== u.indexOf(e.id) ||
																							-1 !== n.indexOf(e.id) ||
																							e.dispose();
																					});
																			case 13:
																			case "end":
																				return e.stop();
																		}
																}, e);
															}));
													case 13:
														if (!l[0]) {
															e.next = 17;
															break;
														}
														return e.delegateYield(p(), "t0", 15);
													case 15:
														e.next = 13;
														break;
													case 17:
														return e.abrupt("return", { v: c });
													case 18:
													case "end":
														return e.stop();
												}
										}, e);
									})(),
									"t1",
									16
								);
							case 16:
								if ("object" != typeof (u = e.t1)) {
									e.next = 19;
									break;
								}
								return e.abrupt("return", u.v);
							case 19:
								return (l = WP("pred", t, n, r)), e.abrupt("return", [qP(l)]);
							case 21:
								return (
									(c = WP("pred", t, n, r)),
									(p = WP("data", t, n, r)).kept || (p = qP(p)),
									(e.next = 26),
									c.data()
								);
							case 26:
								if (!e.sent[0]) {
									e.next = 30;
									break;
								}
								(e.t2 = [void 0, p]), (e.next = 31);
								break;
							case 30:
								e.t2 = [p, void 0];
							case 31:
								return e.abrupt("return", e.t2);
							case 32:
								if (
									!(h = t.inputNames.find(function (e) {
										return void 0 !== UP(e, n, r);
									}))
								) {
									e.next = 36;
									break;
								}
								return (f = UP(h, n, r)), e.abrupt("return", [qP(f)]);
							case 36:
								return e.abrupt("return", void 0);
							case 37:
								return (
									(d = WP("frameName", t, n, r)),
									(m = WP("tensor", t, n, r)),
									r.enterFrame(d),
									e.abrupt("return", [qP(m)])
								);
							case 41:
								return (g = WP("tensor", t, n, r)), r.exitFrame(), e.abrupt("return", [qP(g)]);
							case 44:
								return (v = WP("tensor", t, n, r)), r.nextIteration(), e.abrupt("return", [qP(v)]);
							case 47:
								return (
									(y = WP("size", t, n, r)),
									(b = WP("dtype", t, n, r)),
									(x = WP("elementShape", t, n, r)),
									(w = WP("dynamicSize", t, n, r)),
									(k = WP("clearAfterRead", t, n, r)),
									(N = WP("identicalElementShapes", t, n, r)),
									(I = WP("name", t, n, r)),
									(S = new DB(I, b, y, x, N, w, k)),
									r.addTensorArray(S),
									e.abrupt("return", [S.idTensor, iE(1)])
								);
							case 57:
								return (
									(T = WP("tensorArrayId", t, n, r)),
									(C = WP("index", t, n, r)),
									(E = WP("tensor", t, n, r)),
									(R = r.getTensorArray(T.id)).write(C, E),
									e.abrupt("return", [R.idTensor])
								);
							case 63:
								return (
									(A = WP("tensorArrayId", t, n, r)),
									(_ = WP("index", t, n, r)),
									(F = r.getTensorArray(A.id)),
									e.abrupt("return", [F.read(_)])
								);
							case 67:
								return (
									(D = WP("tensorArrayId", t, n, r)),
									(O = WP("indices", t, n, r)),
									(M = WP("dtype", t, n, r)),
									(L = r.getTensorArray(D.id)),
									e.abrupt("return", [L.gather(O, M)])
								);
							case 72:
								return (
									(z = WP("tensorArrayId", t, n, r)),
									(P = WP("indices", t, n, r)),
									(B = WP("tensor", t, n, r)),
									(W = r.getTensorArray(z.id)).scatter(P, B),
									e.abrupt("return", [W.idTensor])
								);
							case 78:
								return (
									(U = WP("tensorArrayId", t, n, r)),
									(V = r.getTensorArray(U.id)),
									(G = WP("dtype", t, n, r)),
									e.abrupt("return", [V.concat(G)])
								);
							case 82:
								return (
									(j = WP("tensorArrayId", t, n, r)),
									(H = WP("tensor", t, n, r)),
									(q = WP("lengths", t, n, r)),
									(K = r.getTensorArray(j.id)).split(q, H),
									e.abrupt("return", [K.idTensor])
								);
							case 88:
								return (
									(X = WP("tensorArrayId", t, n, r)),
									(Y = r.getTensorArray(X.id)),
									e.abrupt("return", [iE(Y.size(), "int32")])
								);
							case 91:
								return (
									(J = WP("tensorArrayId", t, n, r)),
									(Z = r.getTensorArray(J.id)).clearAndClose(),
									e.abrupt("return", [Z.idTensor])
								);
							case 95:
								return (
									(Q = WP("tensorListId", t, n, r)),
									($ = WP("index", t, n, r)),
									(ee = WP("tensor", t, n, r)),
									(te = r.getTensorList(Q.id)).setItem($, ee),
									e.abrupt("return", [te.idTensor])
								);
							case 101:
								return (
									(ne = WP("tensorListId", t, n, r)),
									(re = WP("index", t, n, r)),
									(ae = WP("elementShape", t, n, r)),
									(ie = WP("elementDType", t, n, r)),
									(oe = r.getTensorList(ne.id)),
									e.abrupt("return", [oe.getItem(re, ae, ie)])
								);
							case 107:
								return (
									(se = WP("indices", t, n, r)),
									(ue = WP("tensor", t, n, r)),
									(le = WP("elementShape", t, n, r)),
									(ce = WP("numElements", t, n, r)),
									(pe = zB(ue, se, le, ce)),
									r.addTensorList(pe),
									e.abrupt("return", [pe.idTensor])
								);
							case 114:
								return (
									(he = WP("elementShape", t, n, r)),
									(fe = WP("elementDType", t, n, r)),
									(de = "TensorListReserve" === t.op ? "numElements" : "maxNumElements"),
									(me = WP(de, t, n, r)),
									(ge = LB(he, fe, me)),
									r.addTensorList(ge),
									e.abrupt("return", [ge.idTensor])
								);
							case 121:
								return (
									(ve = WP("tensorListId", t, n, r)),
									(ye = WP("indices", t, n, r)),
									(be = WP("elementShape", t, n, r)),
									(xe = WP("elementDType", t, n, r)),
									(we = r.getTensorList(ve.id)),
									e.abrupt("return", [we.gather(ye, xe, be)])
								);
							case 127:
								return (
									(ke = WP("tensorListId", t, n, r)),
									(Ne = WP("elementShape", t, n, r)),
									(Ie = WP("elementDType", t, n, r)),
									(Se = WP("numElements", t, n, r)),
									(Te = r.getTensorList(ke.id)),
									e.abrupt("return", [Te.stack(Ne, Ie, Se)])
								);
							case 133:
								return (
									(Ce = WP("tensor", t, n, r)),
									(Ee = WP("elementShape", t, n, r)),
									(Re = WP("elementDType", t, n, r)),
									(Ae = MB(Ce, Ee, Re)),
									r.addTensorList(Ae),
									e.abrupt("return", [Ae.idTensor])
								);
							case 139:
								return (
									(_e = WP("tensorListId", t, n, r)),
									(Fe = r.getTensorList(_e.id)),
									(De = WP("dtype", t, n, r)),
									(Oe = WP("elementShape", t, n, r)),
									e.abrupt("return", [Fe.concat(De, Oe)])
								);
							case 144:
								return (
									(Me = WP("tensorListId", t, n, r)),
									(Le = WP("tensor", t, n, r)),
									(ze = r.getTensorList(Me.id)).pushBack(Le),
									e.abrupt("return", [ze.idTensor])
								);
							case 149:
								return (
									(Pe = WP("tensorListId", t, n, r)),
									(Be = WP("elementShape", t, n, r)),
									(We = WP("elementDType", t, n, r)),
									(Ue = r.getTensorList(Pe.id)),
									e.abrupt("return", [Ue.popBack(Be, We)])
								);
							case 154:
								return (
									(Ve = WP("tensor", t, n, r)),
									(Ge = WP("elementShape", t, n, r)),
									(je = WP("lengths", t, n, r)),
									(He = PB(Ve, je, Ge)),
									r.addTensorList(He),
									e.abrupt("return", [He.idTensor])
								);
							case 160:
								throw TypeError("Node type " + t.op + " is not implemented");
							case 161:
							case "end":
								return e.stop();
						}
				}, e);
			})
		);
		return function (t, n, r) {
			return e.apply(this, arguments);
		};
	})();
	function WB(e, t, n) {
		var r = WP("fusedOps", e, t, n),
			a = r[0],
			i = r[1],
			o = "biasadd" === a,
			s = !o,
			u = "prelu" === i,
			l = "fusedbatchnorm" === a,
			c = WP("numArgs", e, t, n);
		if (o) {
			if (u && 2 !== c)
				throw new Error(
					"FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha."
				);
			if (!u && o && 1 !== c)
				throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
		}
		if (l) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
		var p = WP("strides", e, t, n),
			h = HP(e, t, n),
			f = WP("dataFormat", e, t, n).toUpperCase(),
			d = WP("dilations", e, t, n),
			m = WP("args", e, t, n),
			g = m[0],
			v = m[1];
		return (
			s && ((v = g), (g = void 0)),
			{
				stride: p,
				pad: h,
				dataFormat: f,
				dilations: d,
				biasArg: g,
				preluArg: v,
				activationFunc: i,
				leakyreluAlpha: WP("leakyreluAlpha", e, t, n),
			}
		);
	}
	function UB(e, t, n) {
		return {
			boxes: WP("boxes", e, t, n),
			scores: WP("scores", e, t, n),
			maxOutputSize: WP("maxOutputSize", e, t, n),
			iouThreshold: WP("iouThreshold", e, t, n),
			scoreThreshold: WP("scoreThreshold", e, t, n),
			softNmsSigma: WP("softNmsSigma", e, t, n),
		};
	}
	var VB = (function () {
			var e = fg(
				regeneratorRuntime.mark(function e(t, n, r) {
					var a, i, o, s, u, l, c, p, h, f, d, m, g, v, y, b, x, w, k, N, I, S, T, C;
					return regeneratorRuntime.wrap(function (e) {
						for (;;)
							switch ((e.prev = e.next)) {
								case 0:
									(e.t0 = t.op),
										(e.next =
											"NonMaxSuppressionV5" === e.t0
												? 3
												: "NonMaxSuppressionV4" === e.t0
												? 8
												: "NonMaxSuppressionV3" === e.t0 || "NonMaxSuppressionV2" === e.t0
												? 14
												: "Where" === e.t0
												? 19
												: "ListDiff" === e.t0
												? 26
												: 27);
									break;
								case 3:
									return (
										(a = UB(t, n, r)),
										(i = a.boxes),
										(o = a.scores),
										(s = a.maxOutputSize),
										(u = a.iouThreshold),
										(l = a.scoreThreshold),
										(c = a.softNmsSigma),
										(e.next = 6),
										pA.nonMaxSuppressionWithScoreAsync(i, o, s, u, l, c)
									);
								case 6:
									return (p = e.sent), e.abrupt("return", [p.selectedIndices, p.selectedScores]);
								case 8:
									return (
										(h = UB(t, n, r)),
										(f = h.boxes),
										(d = h.scores),
										(m = h.maxOutputSize),
										(g = h.iouThreshold),
										(v = h.scoreThreshold),
										(y = WP("padToMaxOutputSize", t, n, r)),
										(e.next = 12),
										pA.nonMaxSuppressionPaddedAsync(f, d, m, g, v, y)
									);
								case 12:
									return (b = e.sent), e.abrupt("return", [b.selectedIndices, b.validOutputs]);
								case 14:
									return (
										(x = UB(t, n, r)),
										(w = x.boxes),
										(k = x.scores),
										(N = x.maxOutputSize),
										(I = x.iouThreshold),
										(S = x.scoreThreshold),
										(e.next = 17),
										pA.nonMaxSuppressionAsync(w, k, N, I, S)
									);
								case 17:
									return (e.t1 = e.sent), e.abrupt("return", [e.t1]);
								case 19:
									return (T = NN(WP("condition", t, n, r), "bool")), (e.next = 22), GE(T);
								case 22:
									return (e.t2 = e.sent), (C = [e.t2]), T.dispose(), e.abrupt("return", C);
								case 26:
									return e.abrupt("return", lE(WP("x", t, n, r), WP("y", t, n, r)));
								case 27:
									throw TypeError("Node type " + t.op + " is not implemented");
								case 28:
								case "end":
									return e.stop();
							}
					}, e);
				})
			);
			return function (t, n, r) {
				return e.apply(this, arguments);
			};
		})(),
		GB = (function () {
			function e(e, t) {
				(this.keyDType = e),
					(this.valueDType = t),
					(this.handle = iE(0)),
					(this.tensorMap = new Map()),
					UI(this.handle);
			}
			var t = e.prototype;
			return (
				(t.clearAndClose = function () {
					this.tensorMap.forEach(function (e) {
						return e.dispose();
					}),
						this.tensorMap.clear(),
						this.handle.dispose();
				}),
				(t.size = function () {
					return this.tensorMap.size;
				}),
				(t.tensorSize = function () {
					return iE(this.size(), "int32");
				}),
				(t.import = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r,
								a = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return this.checkKeyAndValueTensor(t, n), (e.next = 3), t.data();
											case 3:
												return (
													(r = e.sent),
													this.tensorMap.forEach(function (e) {
														return e.dispose();
													}),
													this.tensorMap.clear(),
													e.abrupt(
														"return",
														BI(function () {
															var e = BE(n),
																t = r.length,
																i = e.length;
															Dg(t === i, function () {
																return (
																	"The number of elements doesn't match, keys has " +
																	t +
																	" elements, the values has " +
																	i +
																	" elements."
																);
															});
															for (var o = 0; o < t; o++) {
																var s = r[o],
																	u = e[o];
																UI(u), a.tensorMap.set(s, u);
															}
															return a.handle;
														})
													)
												);
											case 7:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.find = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r,
								a = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return this.checkKeyAndValueTensor(t, n), (e.next = 3), t.data();
											case 3:
												return (
													(r = e.sent),
													e.abrupt(
														"return",
														BI(function () {
															for (var e = [], t = 0; t < r.length; t++) {
																var i = r[t],
																	o = a.findWithDefault(i, n);
																e.push(o);
															}
															return TE(e);
														})
													)
												);
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.findWithDefault = function (e, t) {
					var n = this.tensorMap.get(e);
					return null != n ? n : t;
				}),
				(t.checkKeyAndValueTensor = function (e, t) {
					if (e.dtype !== this.keyDType)
						throw new Error("Expect key dtype " + this.keyDType + ", but got " + e.dtype);
					if (t.dtype !== this.valueDType)
						throw new Error("Expect value dtype " + this.valueDType + ", but got " + t.dtype);
				}),
				mg(e, [
					{
						key: "id",
						get: function () {
							return this.handle.id;
						},
					},
				]),
				e
			);
		})(),
		jB = (function () {
			var e = fg(
				regeneratorRuntime.mark(function e(t, n, r, a) {
					var i, o, s, u, l, c, p, h, f, d, m, g, v;
					return regeneratorRuntime.wrap(function (e) {
						for (;;)
							switch ((e.prev = e.next)) {
								case 0:
									(e.t0 = t.op),
										(e.next =
											"HashTable" === e.t0 || "HashTableV2" === e.t0
												? 3
												: "LookupTableImport" === e.t0 || "LookupTableImportV2" === e.t0
												? 8
												: "LookupTableFind" === e.t0 || "LookupTableFindV2" === e.t0
												? 16
												: "LookupTableSize" === e.t0 || "LookupTableSizeV2" === e.t0
												? 24
												: 27);
									break;
								case 3:
									return (
										(i = WP("keyDType", t, n, r)),
										(o = WP("valueDType", t, n, r)),
										(s = new GB(i, o)),
										a.addHashTable(t.name, s),
										e.abrupt("return", [s.handle])
									);
								case 8:
									return (
										(u = WP("tableHandle", t, n, r, a)),
										(l = WP("keys", t, n, r)),
										(c = WP("values", t, n, r)),
										(p = a.getHashTableById(u.id)),
										(e.next = 14),
										p.import(l, c)
									);
								case 14:
									return (e.t1 = e.sent), e.abrupt("return", [e.t1]);
								case 16:
									return (
										(h = WP("tableHandle", t, n, r, a)),
										(f = WP("keys", t, n, r)),
										(d = WP("defaultValue", t, n, r)),
										(m = a.getHashTableById(h.id)),
										(e.next = 22),
										m.find(f, d)
									);
								case 22:
									return (e.t2 = e.sent), e.abrupt("return", [e.t2]);
								case 24:
									return (
										(g = WP("tableHandle", t, n, r, a)),
										(v = a.getHashTableById(g.id)),
										e.abrupt("return", [v.tensorSize()])
									);
								case 27:
									throw TypeError("Node type " + t.op + " is not implemented");
								case 28:
								case "end":
									return e.stop();
							}
					}, e);
				})
			);
			return function (t, n, r, a) {
				return e.apply(this, arguments);
			};
		})();
	function HB(e, t, n, r) {
		var a = (function (e, t, n) {
			switch (e.category) {
				case "arithmetic":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "BiasAdd":
								case "AddV2":
								case "Add":
									return [jI(WP("a", e, t, n), WP("b", e, t, n))];
								case "AddN":
									return [ZI(WP("tensors", e, t, n))];
								case "FloorMod":
								case "Mod":
									return [dC(WP("a", e, t, n), WP("b", e, t, n))];
								case "Mul":
									return [KI(WP("a", e, t, n), WP("b", e, t, n))];
								case "RealDiv":
								case "Div":
									return [qI(WP("a", e, t, n), WP("b", e, t, n))];
								case "DivNoNan":
									return [uT(WP("a", e, t, n), WP("b", e, t, n))];
								case "FloorDiv":
									return [HI(WP("a", e, t, n), WP("b", e, t, n))];
								case "Sub":
									return [UT(WP("a", e, t, n), WP("b", e, t, n))];
								case "Minimum":
									return [hC(WP("a", e, t, n), WP("b", e, t, n))];
								case "Maximum":
									return [oC(WP("a", e, t, n), WP("b", e, t, n))];
								case "Pow":
									return [RC(WP("a", e, t, n), WP("b", e, t, n))];
								case "SquaredDifference":
									return [IE(WP("a", e, t, n), WP("b", e, t, n))];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "basic_math":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "Abs":
								case "ComplexAbs":
									return [XI(WP("x", e, t, n))];
								case "Acos":
									return [YI(WP("x", e, t, n))];
								case "Acosh":
									return [JI(WP("x", e, t, n))];
								case "Asin":
									return [nS(WP("x", e, t, n))];
								case "Asinh":
									return [rS(WP("x", e, t, n))];
								case "Atan":
									return [aS(WP("x", e, t, n))];
								case "Atan2":
									return [iS(WP("x", e, t, n), WP("y", e, t, n))];
								case "Atanh":
									return [oS(WP("x", e, t, n))];
								case "Ceil":
									return [zS(WP("x", e, t, n))];
								case "Complex":
									return [bk(WP("real", e, t, n), WP("imag", e, t, n))];
								case "Cos":
									return [JS(WP("x", e, t, n))];
								case "Cosh":
									return [ZS(WP("x", e, t, n))];
								case "Elu":
									return [pT(WP("x", e, t, n))];
								case "Erf":
									return [hT(WP("x", e, t, n))];
								case "Exp":
									return [fT(WP("x", e, t, n))];
								case "Expm1":
									return [mT(WP("x", e, t, n))];
								case "Floor":
									return [bT(WP("x", e, t, n))];
								case "Log":
									return [FT(WP("x", e, t, n))];
								case "Log1p":
									return [DT(WP("x", e, t, n))];
								case "Imag":
									return [NT(WP("x", e, t, n))];
								case "Neg":
									return [zT(WP("x", e, t, n))];
								case "Reciprocal":
									return [YC(WP("x", e, t, n))];
								case "Real":
									return [XC(WP("x", e, t, n))];
								case "Relu":
									return [JC(WP("x", e, t, n))];
								case "Round":
									return [rE(WP("x", e, t, n))];
								case "Selu":
									return [oE(WP("x", e, t, n))];
								case "Sigmoid":
									return [SS(WP("x", e, t, n))];
								case "Sin":
									return [pE(WP("x", e, t, n))];
								case "Sign":
									return [cE(WP("x", e, t, n))];
								case "Sinh":
									return [hE(WP("x", e, t, n))];
								case "Softplus":
									return [PT(WP("x", e, t, n))];
								case "Sqrt":
									return [NE(WP("x", e, t, n))];
								case "Square":
									return [mC(WP("x", e, t, n))];
								case "Tanh":
									return [CS(WP("x", e, t, n))];
								case "Tan":
									return [RE(WP("x", e, t, n))];
								case "ClipByValue":
									return [
										PS(WP("x", e, t, n), WP("clipValueMin", e, t, n), WP("clipValueMax", e, t, n)),
									];
								case "Relu6":
									return [ZC(WP("x", e, t, n))];
								case "Rsqrt":
									return [aE(UP(e.inputNames[0], t, n))];
								case "Prod":
									return [_C(WP("x", e, t, n), WP("axes", e, t, n))];
								case "LeakyRelu":
									return [CT(WP("x", e, t, n), WP("alpha", e, t, n))];
								case "Prelu":
									return [AC(WP("x", e, t, n), WP("alpha", e, t, n))];
								case "IsNan":
									return [TT(UP(e.inputNames[0], t, n))];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "control":
					return BB(e, t, n);
				case "convolution":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "Conv1D":
									var r = WP("stride", e, t, n),
										a = WP("pad", e, t, n),
										i = WP("dataFormat", e, t, n).toUpperCase(),
										o = WP("dilation", e, t, n);
									return [jS(WP("x", e, t, n), WP("filter", e, t, n), r, a, i, o)];
								case "Conv2D":
									var s = WP("strides", e, t, n),
										u = HP(e, t, n),
										l = WP("dataFormat", e, t, n).toUpperCase(),
										c = WP("dilations", e, t, n);
									return [
										GS(WP("x", e, t, n), WP("filter", e, t, n), [s[1], s[2]], u, l, [c[1], c[2]]),
									];
								case "_FusedConv2D":
									var p = WB(e, t, n),
										h = p.stride,
										f = p.pad,
										d = p.dataFormat,
										m = p.dilations,
										g = p.biasArg,
										v = p.preluArg,
										y = p.activationFunc,
										b = p.leakyreluAlpha;
									return [
										uR({
											x: WP("x", e, t, n),
											filter: WP("filter", e, t, n),
											strides: [h[1], h[2]],
											pad: f,
											dataFormat: d,
											dilations: [m[1], m[2]],
											bias: g,
											activation: y,
											preluActivationWeights: v,
											leakyreluAlpha: b,
										}),
									];
								case "FusedDepthwiseConv2dNative":
									var x = WB(e, t, n),
										w = x.stride,
										k = x.pad,
										N = x.dataFormat,
										I = x.dilations,
										S = x.biasArg,
										T = x.preluArg,
										C = x.activationFunc,
										E = x.leakyreluAlpha;
									return [
										pR({
											x: WP("x", e, t, n),
											filter: WP("filter", e, t, n),
											strides: [w[1], w[2]],
											pad: k,
											dataFormat: N,
											dilations: [I[1], I[2]],
											bias: S,
											activation: C,
											preluActivationWeights: T,
											leakyreluAlpha: E,
										}),
									];
								case "Conv2DBackpropInput":
								case "Conv2dTranspose":
									var R = WP("outputShape", e, t, n),
										A = WP("strides", e, t, n),
										_ = HP(e, t, n);
									return [qS(WP("x", e, t, n), WP("filter", e, t, n), R, [A[1], A[2]], _)];
								case "DepthwiseConv2dNative":
								case "DepthwiseConv2d":
									var F = WP("strides", e, t, n),
										D = HP(e, t, n),
										O = WP("dilations", e, t, n),
										M = WP("dataFormat", e, t, n).toUpperCase();
									return [
										nT(WP("input", e, t, n), WP("filter", e, t, n), [F[1], F[2]], D, M, [
											O[1],
											O[2],
										]),
									];
								case "Conv3D":
									var L = WP("strides", e, t, n),
										z = WP("pad", e, t, n),
										P = WP("dataFormat", e, t, n).toUpperCase(),
										B = WP("dilations", e, t, n);
									return [
										KS(WP("x", e, t, n), WP("filter", e, t, n), [L[1], L[2], L[3]], z, P, [
											B[1],
											B[2],
											B[3],
										]),
									];
								case "AvgPool":
									var W = WP("strides", e, t, n),
										U = WP("pad", e, t, n),
										V = WP("kernelSize", e, t, n);
									return [kS(WP("x", e, t, n), [V[1], V[2]], [W[1], W[2]], U)];
								case "MaxPool":
									var G = WP("strides", e, t, n),
										j = WP("pad", e, t, n),
										H = WP("kernelSize", e, t, n);
									return [rC(WP("x", e, t, n), [H[1], H[2]], [G[1], G[2]], j)];
								case "MaxPoolWithArgmax":
									var q = WP("strides", e, t, n),
										K = WP("pad", e, t, n),
										X = WP("kernelSize", e, t, n),
										Y = WP("includeBatchInIndex", e, t, n),
										J = iC(WP("x", e, t, n), [X[1], X[2]], [q[1], q[2]], K, Y);
									return [J.result, J.indexes];
								case "AvgPool3D":
									var Z = WP("strides", e, t, n),
										Q = WP("pad", e, t, n),
										$ = WP("kernelSize", e, t, n);
									return [NS(WP("x", e, t, n), [$[1], $[2], $[3]], [Z[1], Z[2], Z[3]], Q)];
								case "MaxPool3D":
									var ee = WP("strides", e, t, n),
										te = WP("pad", e, t, n),
										ne = WP("kernelSize", e, t, n);
									return [aC(WP("x", e, t, n), [ne[1], ne[2], ne[3]], [ee[1], ee[2], ee[3]], te)];
								case "Dilation2D":
									var re = WP("strides", e, t, n),
										ae = WP("pad", e, t, n),
										ie = WP("dilations", e, t, n),
										oe = re[1],
										se = re[2],
										ue = ie[1],
										le = ie[2];
									return [
										aT(WP("x", e, t, n), WP("filter", e, t, n), [oe, se], ae, [ue, le], "NHWC"),
									];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "creation":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "Fill":
									var r = WP("shape", e, t, n),
										a = WP("dtype", e, t, n);
									return [yT(r, WP("value", e, t, n), a)];
								case "LinSpace":
									return [AT(WP("start", e, t, n), WP("stop", e, t, n), WP("num", e, t, n))];
								case "Multinomial":
									var i = WP("logits", e, t, n),
										o = WP("numSamples", e, t, n),
										s = WP("seed", e, t, n);
									return [yC(i, o, s)];
								case "OneHot":
									var u = WP("indices", e, t, n),
										l = WP("depth", e, t, n),
										c = WP("onValue", e, t, n),
										p = WP("offValue", e, t, n);
									return [HN(u, l, c, p)];
								case "Ones":
									return [lC(WP("shape", e, t, n), WP("dtype", e, t, n))];
								case "OnesLike":
									return [xC(WP("x", e, t, n))];
								case "RandomUniform":
									return [
										qC(
											WP("shape", e, t, n),
											WP("minval", e, t, n),
											WP("maxval", e, t, n),
											WP("dtype", e, t, n)
										),
									];
								case "Range":
									return [
										KC(
											WP("start", e, t, n),
											WP("stop", e, t, n),
											WP("step", e, t, n),
											WP("dtype", e, t, n)
										),
									];
								case "TruncatedNormal":
									var h = WP("shape", e, t, n),
										f = WP("mean", e, t, n),
										d = WP("stdDev", e, t, n),
										m = WP("seed", e, t, n);
									return [LE(h, f, d, WP("dtype", e, t, n), m)];
								case "Zeros":
									return [uC(WP("shape", e, t, n), WP("dtype", e, t, n))];
								case "ZerosLike":
									return [sT(WP("x", e, t, n))];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "dynamic":
					return VB(e, t, n);
				case "evaluation":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "TopKV2":
									var r = WP("x", e, t, n),
										a = WP("k", e, t, n),
										i = WP("sorted", e, t, n),
										o = ME(r, a, i);
									return [o.values, o.indices];
								case "Unique":
									var s = WP("x", e, t, n),
										u = zE(s);
									return [u.values, u.indices];
								case "UniqueV2":
									var l = WP("x", e, t, n),
										c = WP("axis", e, t, n),
										p = zE(l, c);
									return [p.values, p.indices];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "image":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "ResizeBilinear":
									var r = WP("images", e, t, n),
										a = WP("size", e, t, n),
										i = WP("alignCorners", e, t, n),
										o = WP("halfPixelCenters", e, t, n);
									return [pA.resizeBilinear(r, [a[0], a[1]], i, o)];
								case "ResizeNearestNeighbor":
									var s = WP("images", e, t, n),
										u = WP("size", e, t, n),
										l = WP("alignCorners", e, t, n),
										c = WP("halfPixelCenters", e, t, n);
									return [pA.resizeNearestNeighbor(s, [u[0], u[1]], l, c)];
								case "CropAndResize":
									var p = WP("image", e, t, n),
										h = WP("boxes", e, t, n),
										f = WP("boxInd", e, t, n),
										d = WP("cropSize", e, t, n),
										m = WP("method", e, t, n),
										g = WP("extrapolationValue", e, t, n);
									return [pA.cropAndResize(p, h, f, d, m, g)];
								case "ImageProjectiveTransformV3":
									var v = WP("images", e, t, n),
										y = WP("transforms", e, t, n),
										b = WP("outputShape", e, t, n),
										x = WP("fillValue", e, t, n),
										w = WP("interpolation", e, t, n),
										k = WP("fillMode", e, t, n);
									return [pA.transform(v, y, w.toLowerCase(), k.toLowerCase(), x, b)];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "graph":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "Const":
									return t[e.name];
								case "PlaceholderWithDefault":
									var r = WP("default", e, t, n);
									return [UP(e.name, t, n) || r];
								case "Placeholder":
									return [UP(e.name, t, n)];
								case "Identity":
								case "StopGradient":
								case "FakeQuantWithMinMaxVars":
								case "Snapshot":
									return [qP(WP("x", e, t, n))];
								case "IdentityN":
									return WP("x", e, t, n).map(function (e) {
										return qP(e);
									});
								case "Shape":
									return [AE(WP("x", e, t, n).shape, "int32")];
								case "ShapeN":
									return WP("x", e, t, n).map(function (e) {
										return AE(e.shape);
									});
								case "Size":
									return [iE(WP("x", e, t, n).size, "int32")];
								case "Rank":
									return [iE(WP("x", e, t, n).rank, "int32")];
								case "NoOp":
									return [iE(1)];
								case "Print":
									var a = WP("x", e, t, n),
										i = WP("data", e, t, n),
										o = WP("message", e, t, n),
										s = WP("summarize", e, t, n);
									console.warn(
										"The graph has a tf.print() operation,usually used for debugging, which slows down performance."
									),
										console.log(o);
									for (var u = 0; u < i.length; u++)
										console.log(Array.prototype.slice.call(i[u].dataSync()).slice(0, s));
									return [a];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "logical":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "Equal":
									return [iT(WP("a", e, t, n), WP("b", e, t, n))];
								case "NotEqual":
									return [bC(WP("a", e, t, n), WP("b", e, t, n))];
								case "Greater":
									return [wT(WP("a", e, t, n), WP("b", e, t, n))];
								case "GreaterEqual":
									return [kT(WP("a", e, t, n), WP("b", e, t, n))];
								case "Less":
									return [ET(WP("a", e, t, n), WP("b", e, t, n))];
								case "LessEqual":
									return [RT(WP("a", e, t, n), WP("b", e, t, n))];
								case "LogicalAnd":
									return [$T(WP("a", e, t, n), WP("b", e, t, n))];
								case "LogicalNot":
									return [eC(WP("a", e, t, n))];
								case "LogicalOr":
									return [tC(WP("a", e, t, n), WP("b", e, t, n))];
								case "Select":
								case "SelectV2":
									return [oT(WP("condition", e, t, n), WP("a", e, t, n), WP("b", e, t, n))];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "matrices":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "BatchMatMul":
								case "BatchMatMulV2":
								case "MatMul":
									return [
										jN(
											WP("a", e, t, n),
											WP("b", e, t, n),
											WP("transposeA", e, t, n),
											WP("transposeB", e, t, n)
										),
									];
								case "Einsum":
									return [cT.apply(EB, [WP("equation", e, t, n)].concat(WP("tensors", e, t, n)))];
								case "Transpose":
									return [qN(WP("x", e, t, n), WP("perm", e, t, n))];
								case "_FusedMatMul":
									var r = WP("fusedOps", e, t, n),
										a = r[0],
										i = r[1],
										o = "biasadd" === a,
										s = "prelu" === i,
										u = WP("numArgs", e, t, n),
										l = WP("leakyreluAlpha", e, t, n);
									if (o) {
										if (s && 2 !== u)
											throw new Error(
												"Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha."
											);
										if (!s && 1 !== u)
											throw new Error(
												"Fused MatMul with BiasAdd must have one extra argument: bias."
											);
									}
									var c = WP("args", e, t, n),
										p = c[0],
										h = c[1];
									return [
										hR({
											a: WP("a", e, t, n),
											b: WP("b", e, t, n),
											transposeA: WP("transposeA", e, t, n),
											transposeB: WP("transposeB", e, t, n),
											bias: p,
											activation: i,
											preluActivationWeights: h,
											leakyreluAlpha: l,
										}),
									];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "normalization":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "FusedBatchNorm":
								case "FusedBatchNormV2":
								case "FusedBatchNormV3":
									return [
										AS(
											WP("x", e, t, n),
											WP("mean", e, t, n),
											WP("variance", e, t, n),
											WP("offset", e, t, n),
											WP("scale", e, t, n),
											WP("epsilon", e, t, n)
										),
									];
								case "LRN":
									return [
										_T(
											WP("x", e, t, n),
											WP("radius", e, t, n),
											WP("bias", e, t, n),
											WP("alpha", e, t, n),
											WP("beta", e, t, n)
										),
									];
								case "Softmax":
									return [vE(WP("x", e, t, n))];
								case "LogSoftmax":
									return [GT(WP("x", e, t, n))];
								case "SparseToDense":
									return [
										JE(
											WP("sparseIndices", e, t, n),
											WP("outputShape", e, t, n),
											WP("sparseValues", e, t, n),
											WP("defaultValue", e, t, n)
										),
									];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "reduction":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "Max":
									var r = WP("axis", e, t, n),
										a = WP("keepDims", e, t, n);
									return [WT(WP("x", e, t, n), r, a)];
								case "Mean":
									var i = WP("axis", e, t, n),
										o = WP("keepDims", e, t, n);
									return [sC(WP("x", e, t, n), i, o)];
								case "Min":
									var s = WP("axis", e, t, n),
										u = WP("keepDims", e, t, n);
									return [pC(WP("x", e, t, n), s, u)];
								case "Sum":
									var l = WP("axis", e, t, n),
										c = WP("keepDims", e, t, n);
									return [VT(WP("x", e, t, n), l, c)];
								case "All":
									var p = WP("axis", e, t, n),
										h = WP("keepDims", e, t, n);
									return [QI(WP("x", e, t, n), p, h)];
								case "Any":
									var f = WP("axis", e, t, n),
										d = WP("keepDims", e, t, n);
									return [$I(WP("x", e, t, n), f, d)];
								case "ArgMax":
									var m = WP("axis", e, t, n);
									return [eS(WP("x", e, t, n), m)];
								case "ArgMin":
									var g = WP("axis", e, t, n);
									return [tS(WP("x", e, t, n), g)];
								case "Prod":
									var v = WP("axis", e, t, n),
										y = WP("keepDims", e, t, n);
									return [_C(WP("x", e, t, n), v, y)];
								case "Cumprod":
									var b = WP("axis", e, t, n),
										x = WP("exclusive", e, t, n),
										w = WP("reverse", e, t, n);
									return [QS(WP("x", e, t, n), b, x, w)];
								case "Cumsum":
									var k = WP("axis", e, t, n),
										N = WP("exclusive", e, t, n),
										I = WP("reverse", e, t, n);
									return [$S(WP("x", e, t, n), k, N, I)];
								case "Bincount":
									var S = WP("x", e, t, n),
										T = WP("weights", e, t, n),
										C = WP("size", e, t, n);
									return [OS(S, T, C)];
								case "DenseBincount":
									var E = WP("x", e, t, n),
										R = WP("weights", e, t, n),
										A = WP("size", e, t, n),
										_ = WP("binaryOutput", e, t, n);
									return [eT(E, R, A, _)];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "slice_join":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "ConcatV2":
								case "Concat":
									var r = WP("n", e, t, n),
										a = WP("axis", e, t, n),
										i = WP("tensors", e, t, n);
									return (i = i.slice(0, r)), [IS(i, a)];
								case "Gather":
									var o = WP("x", e, t, n),
										s = WP("indices", e, t, n);
									return [xT(o, NN(s, "int32"), 0)];
								case "GatherV2":
									var u = WP("axis", e, t, n),
										l = WP("batchDims", e, t, n),
										c = WP("x", e, t, n),
										p = WP("indices", e, t, n);
									return [xT(c, NN(p, "int32"), u, l)];
								case "Reverse":
									for (var h = WP("dims", e, t, n), f = [], d = 0; d < h.length; d++)
										h[d] && f.push(d);
									var m = WP("x", e, t, n);
									return [QC(m, f)];
								case "ReverseV2":
									var g = WP("axis", e, t, n),
										v = WP("x", e, t, n);
									return [QC(v, g)];
								case "Slice":
									var y = WP("begin", e, t, n),
										b = WP("size", e, t, n);
									return [TS(WP("x", e, t, n), y, b)];
								case "StridedSlice":
									var x = WP("begin", e, t, n),
										w = WP("end", e, t, n),
										k = WP("strides", e, t, n),
										N = WP("beginMask", e, t, n),
										I = WP("endMask", e, t, n),
										S = WP("ellipsisMask", e, t, n),
										T = WP("newAxisMask", e, t, n),
										C = WP("shrinkAxisMask", e, t, n),
										E = WP("x", e, t, n);
									return [EE(E, x, w, k, N, I, S, T, C)];
								case "Pack":
									return BI(function () {
										var r = WP("axis", e, t, n),
											a = WP("tensors", e, t, n),
											i = a[0].shape,
											o = SE(a[0]).shape,
											s = a.map(function (e) {
												var t = Pg(e.shape, i);
												if (!t && !Pg(SE(e).shape, o))
													throw new Error("the input tensors shape does not match");
												return t ? e : wS(e, i);
											});
										return [TE(s, r)];
									});
								case "Unpack":
									var R = WP("axis", e, t, n),
										A = WP("tensor", e, t, n);
									return BE(A, R);
								case "Tile":
									var _ = WP("reps", e, t, n);
									return [gT(WP("x", e, t, n), _)];
								case "Split":
								case "SplitV":
									var F = WP("axis", e, t, n),
										D = WP("numOrSizeSplits", e, t, n),
										O = WP("x", e, t, n);
									return wE(O, D, F);
								case "ScatterNd":
									var M = WP("indices", e, t, n),
										L = WP("values", e, t, n),
										z = WP("shape", e, t, n);
									return [YE(M, L, z)];
								case "GatherNd":
									var P = WP("x", e, t, n),
										B = WP("indices", e, t, n);
									return [ZE(P, B)];
								case "SparseToDense":
									var W = WP("sparseIndices", e, t, n),
										U = WP("outputShape", e, t, n),
										V = WP("sparseValues", e, t, n),
										G = WP("defaultValue", e, t, n);
									return [JE(W, V, U, V.dtype === G.dtype ? G : NN(G, V.dtype))];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "sparse":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "SparseFillEmptyRows":
									var r = dA.sparseFillEmptyRows(
										WP("indices", e, t, n),
										WP("values", e, t, n),
										WP("denseShape", e, t, n),
										WP("defaultValue", e, t, n)
									);
									return [r.outputIndices, r.outputValues, r.emptyRowIndicator, r.reverseIndexMap];
								case "SparseReshape":
									var a = dA.sparseReshape(
										WP("inputIndices", e, t, n),
										WP("inputShape", e, t, n),
										WP("newShape", e, t, n)
									);
									return [a.outputIndices, a.outputShape];
								case "SparseSegmentMean":
									return [
										dA.sparseSegmentMean(
											WP("data", e, t, n),
											WP("indices", e, t, n),
											WP("segmentIds", e, t, n)
										),
									];
								case "SparseSegmentSum":
									return [
										dA.sparseSegmentSum(
											WP("data", e, t, n),
											WP("indices", e, t, n),
											WP("segmentIds", e, t, n)
										),
									];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "spectral":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "FFT":
									return [yE(WP("x", e, t, n))];
								case "IFFT":
									return [bE(WP("x", e, t, n))];
								case "RFFT":
									return [kE(WP("x", e, t, n))];
								case "IRFFT":
									return [xE(WP("x", e, t, n))];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "string":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "StringNGrams":
									var r = mA.stringNGrams(
										WP("data", e, t, n),
										WP("dataSplits", e, t, n),
										WP("separator", e, t, n),
										WP("nGramWidths", e, t, n),
										WP("leftPad", e, t, n),
										WP("rightPad", e, t, n),
										WP("padWidth", e, t, n),
										WP("preserveShortSequences", e, t, n)
									);
									return [r.nGrams, r.nGramsSplits];
								case "StringSplit":
									var a = mA.stringSplit(
										WP("input", e, t, n),
										WP("delimiter", e, t, n),
										WP("skipEmpty", e, t, n)
									);
									return [a.indices, a.values, a.shape];
								case "StringToHashBucketFast":
									return [mA.stringToHashBucketFast(WP("input", e, t, n), WP("numBuckets", e, t, n))];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "transformation":
					return BI(function () {
						return (function (e, t, n) {
							switch (e.op) {
								case "Cast":
									return [NN(WP("x", e, t, n), WP("dtype", e, t, n))];
								case "ExpandDims":
									var r = WP("axis", e, t, n);
									return [dT(WP("x", e, t, n), r)];
								case "Squeeze":
									var a = WP("axis", e, t, n);
									return [SE(WP("x", e, t, n), a)];
								case "Reshape":
									return [wS(WP("x", e, t, n), WP("shape", e, t, n))];
								case "MirrorPad":
									return [fC(WP("x", e, t, n), WP("padding", e, t, n), WP("mode", e, t, n))];
								case "PadV2":
								case "Pad":
									return [kC(WP("x", e, t, n), WP("padding", e, t, n), WP("constantValue", e, t, n))];
								case "SpaceToBatchND":
									var i = WP("blockShape", e, t, n),
										o = WP("paddings", e, t, n);
									return [CC(WP("x", e, t, n), i, o)];
								case "BatchToSpaceND":
									var s = WP("blockShape", e, t, n),
										u = WP("crops", e, t, n);
									return [RS(WP("x", e, t, n), s, u)];
								case "DepthToSpace":
									var l = WP("blockSize", e, t, n),
										c = WP("dataFormat", e, t, n).toUpperCase();
									return [tT(WP("x", e, t, n), l, c)];
								case "BroadcastTo":
									return [LS(WP("x", e, t, n), WP("shape", e, t, n))];
								case "BroadcastArgs":
									return [MS(WP("s0", e, t, n), WP("s1", e, t, n))];
								default:
									throw TypeError("Node type " + e.op + " is not implemented");
							}
						})(e, t, n);
					});
				case "hash_table":
					return jB(e, t, n, r);
				case "custom":
					var a = BP(e.op);
					if (a && a.customExecutor) return a.customExecutor(new CB(e, t, n));
					throw TypeError("Custom op " + e.op + " is not registered.");
				default:
					throw TypeError(
						"Unknown op '" +
							e.op +
							"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()"
					);
			}
		})(e, t, n);
		return mv(a)
			? a.then(function (e) {
					return [].concat(e);
			  })
			: [].concat(a);
	}
	var qB = (function () {
		function e(e, t, n, r) {
			void 0 === e && (e = {}),
				void 0 === t && (t = {}),
				void 0 === n && (n = {}),
				void 0 === r && (r = {}),
				(this.weightMap = e),
				(this.tensorArrayMap = t),
				(this.tensorListMap = n),
				(this.functionMap = r),
				(this.rootContext = { id: 0, frameName: "", iterationId: 0 }),
				(this.contexts = [this.rootContext]),
				(this.lastId = 0),
				this.generateCurrentContextIds();
		}
		var t = e.prototype;
		return (
			(t.newFrame = function (e, t) {
				return { id: e, frameName: t, iterationId: 0 };
			}),
			(t.generateCurrentContextIds = function () {
				for (var e = [], t = 0; t < this.contexts.length - 1; t++) {
					var n = this.contexts.slice(0, this.contexts.length - t);
					e.push(this.contextIdforContexts(n));
				}
				e.push(""), (this._currentContextIds = e);
			}),
			(t.contextIdforContexts = function (e) {
				return e
					? e
							.map(function (e) {
								return 0 === e.id && 0 === e.iterationId ? "" : e.frameName + "-" + e.iterationId;
							})
							.join("/")
					: "";
			}),
			(t.enterFrame = function (e) {
				this.contexts &&
					(this.lastId++,
					(this.contexts = this.contexts.slice()),
					this.contexts.push(this.newFrame(this.lastId, e)),
					this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
			}),
			(t.exitFrame = function () {
				if (!(this.contexts && this.contexts.length > 1))
					throw new Error("Cannot exit frame, the context is empty");
				(this.contexts = this.contexts.slice()), this.contexts.splice(-1), this.currentContextIds.shift();
			}),
			(t.nextIteration = function () {
				if (!(this.contexts && this.contexts.length > 0))
					throw new Error("Cannot increase frame iteration, the context is empty");
				(this.contexts = this.contexts.slice()), this.lastId++;
				var e = Object.assign({}, this.contexts[this.contexts.length - 1]);
				(e.iterationId += 1),
					(e.id = this.lastId),
					this.contexts.splice(-1, 1, e),
					this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
			}),
			(t.getWeight = function (e) {
				return this.weightMap[e];
			}),
			(t.addTensorArray = function (e) {
				this.tensorArrayMap[e.id] = e;
			}),
			(t.getTensorArray = function (e) {
				return this.tensorArrayMap[e];
			}),
			(t.addTensorList = function (e) {
				this.tensorListMap[e.id] = e;
			}),
			(t.getTensorList = function (e) {
				return this.tensorListMap[e];
			}),
			(t.dispose = function (e) {
				for (var t in this.tensorArrayMap) this.tensorArrayMap[t].clearAndClose(e);
				for (var n in this.tensorListMap) this.tensorListMap[n].clearAndClose(e);
			}),
			mg(e, [
				{
					key: "currentContext",
					get: function () {
						return this.contexts;
					},
					set: function (e) {
						this.contexts !== e && ((this.contexts = e), this.generateCurrentContextIds());
					},
				},
				{
					key: "currentContextId",
					get: function () {
						return this._currentContextIds[0];
					},
				},
				{
					key: "currentContextIds",
					get: function () {
						return this._currentContextIds;
					},
				},
			]),
			e
		);
	})();
	function KB(e, t, n, r) {
		var a = new Set(),
			i = [],
			o = null,
			s = null,
			u = new Set(),
			l = Object.keys(e).map(function (e) {
				return jP(e)[0];
			}),
			c = [];
		null != r &&
			(c = r.map(function (e) {
				return jP(e.name)[0];
			}));
		for (var p = [].concat(t); p.length > 0; ) {
			var h = p.pop();
			(ZB(h) || QB(h) || $B(h)) &&
				null == o &&
				(s = (o = h).children
					.map(function (e) {
						return e.name;
					})
					.filter(function (e) {
						return a.has(e);
					})),
				a.add(h.name),
				null == n[h.name] &&
					-1 === l.indexOf(h.name) &&
					-1 === c.indexOf(h.name) &&
					(0 !== h.inputs.length
						? h.inputs.forEach(function (e) {
								u.has(e.name) || (u.add(e.name), p.push(e));
						  })
						: i.push(h.name));
		}
		return { inputs: e, outputs: t, usedNodes: a, missingInputs: i, dynamicNode: o, syncInputs: s };
	}
	var XB = ["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"],
		YB = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"],
		JB = [
			"HashTable",
			"HashTableV2",
			"LookupTableImport",
			"LookupTableImportV2",
			"LookupTableFind",
			"LookupTableFindV2",
			"LookupTableSize",
			"LookupTableSizeV2",
		];
	function ZB(e) {
		return XB.indexOf(e.op) >= 0;
	}
	function QB(e) {
		return YB.indexOf(e.op) >= 0;
	}
	function $B(e) {
		return JB.indexOf(e.op) >= 0;
	}
	var eW = (function () {
			function e(t, n) {
				var r = this;
				(this.graph = t),
					(this.parent = n),
					(this.compiledMap = new Map()),
					(this._weightMap = {}),
					(this.SEPERATOR = ","),
					(this._functions = {}),
					(this._functionExecutorMap = {}),
					(this.intermediateTensors = {}),
					(this.keepTensorForDebug = !1),
					(this._outputs = t.outputs),
					(this._inputs = t.inputs),
					(this._initNodes = t.initNodes),
					(this._signature = t.signature),
					(this._functions = t.functions),
					null != t.functions &&
						Object.keys(t.functions).forEach(function (n) {
							r._functionExecutorMap[n] = new e(t.functions[n], r);
						});
			}
			var t = e.prototype;
			return (
				(t.getCompilationKey = function (e, t) {
					var n = e
							.map(function (e) {
								return e.name;
							})
							.sort(),
						r = t
							.map(function (e) {
								return e.name;
							})
							.sort();
					return n.join(this.SEPERATOR) + "--" + r.join(this.SEPERATOR);
				}),
				(t.compile = function (e, t) {
					var n = KB(e, t, this.weightMap, this._initNodes),
						r = n.missingInputs,
						a = n.dynamicNode,
						i = n.syncInputs;
					if (null != a)
						throw new Error(
							"This execution contains the node '" +
								a.name +
								"', which has the dynamic op '" +
								a.op +
								"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" +
								i +
								"]"
						);
					if (r.length > 0) {
						var o = t.map(function (e) {
								return e.name;
							}),
							s = Object.keys(e);
						throw new Error(
							"Cannot compute the outputs [" +
								o +
								"] from the provided inputs [" +
								s +
								"]. Missing the following inputs: [" +
								r +
								"]"
						);
					}
					return (function (e, t, n) {
						var r = n.usedNodes,
							a = n.inputs,
							i = [],
							o = Object.keys(a)
								.map(function (e) {
									return jP(e)[0];
								})
								.map(function (t) {
									return e.nodes[t];
								}),
							s = e.initNodes;
						o.forEach(function (e) {
							r.has(e.name) && i.push(e);
						}),
							e.weights.forEach(function (e) {
								r.has(e.name) && i.push(e);
							}),
							null != s &&
								s.forEach(function (e) {
									r.has(e.name) && i.push(e);
								});
						for (var u = new Set(), l = []; i.length > 0; ) {
							var c = i.pop();
							u.add(c.name),
								t[c.name] || l.push(c),
								c.children.forEach(function (e) {
									!u.has(e.name) &&
										r.has(e.name) &&
										e.inputs.every(function (e) {
											return u.has(e.name);
										}) &&
										i.push(e);
								});
						}
						return l;
					})(this.graph, this.weightMap, n);
				}),
				(t.execute = function (e, t) {
					var n = this;
					e = this.mapInputs(e);
					var r = Object.keys(e).sort();
					this.checkInputs(e), this.checkInputShapeAndType(e), (t = this.mapOutputs(t)), this.checkOutputs(t);
					var a = r.map(function (e) {
							return n.graph.nodes[jP(e)[0]];
						}),
						i = t.map(function (e) {
							return jP(e)[0];
						}),
						o = i.map(function (e) {
							return n.graph.nodes[e];
						});
					this.resetIntermediateTensors(), 0 === o.length && (o = this._outputs);
					var s = this.getCompilationKey(a, o),
						u = this.compiledMap.get(s);
					null == u && ((u = this.compile(e, o)), this.compiledMap.set(s, u));
					var l = {},
						c = {};
					return BI(function () {
						var r = new qB(n.weightMap, l, c, n.functionExecutorMap),
							a = Object.assign({}, n.weightMap);
						Object.keys(e).forEach(function (t) {
							var n = jP(t),
								r = n[0],
								i = [];
							(i[n[1]] = e[t]), (a[r] = i);
						});
						for (var o = n.getFrozenTensorIds(a), s = {}, p = 0; p < u.length; p++) {
							var h = u[p];
							if (!a[h.name]) {
								var f = HB(h, a, r, n._resourceManager);
								if (mv(f))
									throw new Error(
										"The execution of the op '" +
											h.op +
											"' returned a promise. Please use model.executeAsync() instead."
									);
								(a[h.name] = f), n.checkTensorForDisposal(h.name, h, a, r, o, i, s);
							}
						}
						return (
							null == n.parent && r.dispose(o),
							t.map(function (e) {
								return UP(e, a, r);
							})
						);
					});
				}),
				(t.getFrozenTensorIds = function (e) {
					var t = [].concat.apply(
						[],
						Object.keys(e)
							.map(function (t) {
								return e[t];
							})
							.map(function (e) {
								return e.map(function (e) {
									return e.id;
								});
							})
					);
					return new Set(t);
				}),
				(t.checkTensorForDisposal = function (e, t, n, r, a, i, o) {
					var s = this;
					"control" !== t.category &&
						-1 === i.indexOf(e) &&
						(n[e].forEach(function (e) {
							null != e && (o[e.id] = (o[e.id] || 0) + t.children.length);
						}),
						t.inputs.forEach(function (e) {
							if ("control" !== e.category) {
								var i = (function (e, t, n) {
									return t[GP(e, n.currentContextId)];
								})(e.name, n, r);
								null != i &&
									i.forEach(function (e) {
										if (e && !e.kept && !a.has(e.id)) {
											var n = o[e.id];
											if (1 === n) {
												if (s.keepTensorForDebug) {
													var i = VP(t.name, r),
														u = i[0],
														l = i[1];
													s.intermediateTensors[u] || (s.intermediateTensors[u] = []),
														(s.intermediateTensors[u][l] = e);
												} else e.dispose();
												delete o[e.id];
											} else null != n && o[e.id]--;
										}
									});
							}
						}));
				}),
				(t.executeAsync = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return e.abrupt("return", this._executeAsync(t, n));
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.disposeIntermediateTensors = function () {
					var e = this;
					this.intermediateTensors &&
						(Object.keys(this.intermediateTensors).forEach(function (t) {
							return e.intermediateTensors[t].forEach(function (e) {
								return e.dispose();
							});
						}),
						this.disposeTensorsMap());
				}),
				(t.disposeTensorsMap = function () {
					var e = this;
					this.tensorsMap &&
						Object.keys(this.tensorsMap).forEach(function (t) {
							e.tensorsMap[t].forEach(function (t) {
								!t || t.kept || t.isDisposed || e.keepIds.has(t.id) || t.dispose();
							});
						});
				}),
				(t.getIntermediateTensors = function () {
					return this.tensorsMap;
				}),
				(t.resetIntermediateTensors = function () {
					for (var e in this.intermediateTensors)
						this.intermediateTensors[e].forEach(function (e) {
							return e.dispose();
						}),
							delete this.intermediateTensors[e];
				}),
				(t._executeAsync = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n, r, a, i) {
							var o,
								s,
								u,
								l,
								c = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												void 0 === r && (r = !1),
													void 0 === a && (a = {}),
													void 0 === i && (i = {}),
													r ||
														((t = this.mapInputs(t)),
														this.checkInputs(t),
														this.checkInputShapeAndType(t),
														(n = this.mapOutputs(n)),
														this.checkOutputs(n));
												try {
													this.keepTensorForDebug = xv().getBool("KEEP_INTERMEDIATE_TENSORS");
												} catch (e) {
													console.warn(e.message);
												}
												return (
													this.resetIntermediateTensors(),
													(o = new qB(this.weightMap, a, i, this.functionExecutorMap)),
													(e.next = 9),
													this.executeWithControlFlow(t, o, n, r)
												);
											case 9:
												return (
													(this.tensorsMap = e.sent),
													(s = n.map(function (e) {
														return UP(e, c.tensorsMap, o);
													})),
													(u = s.map(function (e) {
														return e.id;
													})),
													(l = Object.keys(t).map(function (e) {
														return t[e].id;
													})),
													(this.keepIds = new Set([].concat(u, l, this.weightIds))),
													this.keepTensorForDebug || this.disposeTensorsMap(),
													null == this.parent && o.dispose(this.keepIds),
													e.abrupt("return", s)
												);
											case 17:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n, r, a, i) {
						return e.apply(this, arguments);
					};
				})()),
				(t.executeFunctionAsync = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n, r) {
							var a,
								i = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(a = t.reduce(function (e, t, n) {
														return (e[i.inputs[n].name] = t), e;
													}, {})),
													e.abrupt(
														"return",
														this._executeAsync(a, this.outputNodes, !0, n, r)
													)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n, r) {
						return e.apply(this, arguments);
					};
				})()),
				(t.executeWithControlFlow = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n, r, a) {
							var i,
								o,
								s,
								u,
								l,
								c,
								p,
								h,
								f,
								d,
								m,
								g,
								v,
								y,
								b,
								x,
								w,
								k = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												(i = Object.keys(t)),
													(o = i.map(function (e) {
														return k.graph.nodes[jP(e)[0]];
													})),
													(s = r.map(function (e) {
														return jP(e)[0];
													})),
													0 ===
														(u = s.map(function (e) {
															return k.graph.nodes[e];
														})).length && (u = this._outputs),
													(l = KB(t, u, this.weightMap, this._initNodes)),
													(c = l.usedNodes),
													(p = l.missingInputs),
													(h = l.dynamicNode),
													(f = l.syncInputs),
													(d = []
														.concat(o, this.graph.weights, this._initNodes || [])
														.map(function (e) {
															return { node: e, contexts: n.currentContext };
														})),
													(m = Object.assign({}, this.weightMap)),
													Object.keys(t).forEach(function (e) {
														var n = jP(e),
															r = n[0],
															a = [];
														(a[n[1]] = t[e]), (m[r] = a);
													}),
													(g = {}),
													(v = this.getFrozenTensorIds(m)),
													(y = {});
											case 12:
												if (!(d.length > 0)) {
													e.next = 18;
													break;
												}
												return (
													(b = this.processStack(o, d, n, m, y, v, s, g, c)),
													(e.next = 16),
													Promise.all(b)
												);
											case 16:
												e.next = 12;
												break;
											case 18:
												if (
													(null != h ||
														a ||
														console.warn(
															"This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."
														),
													!(
														(x = u
															.filter(function (e) {
																return !ZB(e) && !UP(e.name, m, n);
															})
															.map(function (e) {
																return e.name;
															})).length > 0
													))
												) {
													e.next = 24;
													break;
												}
												throw (
													((w = ""),
													null != h &&
														(w =
															"Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" +
															f +
															"]"),
													new Error(
														"Cannot compute the outputs [" +
															x +
															"] from the provided inputs [" +
															i +
															"]. Consider providing the following inputs: [" +
															p +
															"]. " +
															w
													))
												);
											case 24:
												return e.abrupt("return", m);
											case 25:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n, r, a) {
						return e.apply(this, arguments);
					};
				})()),
				(t.processStack = function (e, t, n, r, a, i, o, s, u) {
					for (
						var l = this,
							c = [],
							p = function () {
								var e = t.pop();
								n.currentContext = e.contexts;
								var p = "";
								if ("Enter" === e.node.op && WP("isConstant", e.node, r, n)) {
									var h = VP(e.node.name, n);
									p = h[0];
								}
								if (null == r[e.node.name]) {
									var f = HB(e.node, r, n, l._resourceManager);
									if (!p) {
										var d = VP(e.node.name, n);
										p = d[0];
									}
									var m = n.currentContext;
									mv(f)
										? c.push(
												f.then(function (c) {
													return (
														(r[p] = c),
														(n.currentContext = m),
														l.checkTensorForDisposal(p, e.node, r, n, i, o, s),
														l.processChildNodes(e.node, t, n, r, a, u),
														c
													);
												})
										  )
										: ((r[p] = f),
										  l.checkTensorForDisposal(p, e.node, r, n, i, o, s),
										  l.processChildNodes(e.node, t, n, r, a, u));
								} else l.processChildNodes(e.node, t, n, r, a, u);
							};
						t.length > 0;

					)
						p();
					return c;
				}),
				(t.processChildNodes = function (e, t, n, r, a, i) {
					e.children.forEach(function (e) {
						var o = VP(e.name, n)[0];
						!a[o] &&
							i.has(e.name) &&
							("Merge" === e.op
								? e.inputNames.some(function (e) {
										return !!UP(e, r, n);
								  }) && ((a[o] = !0), t.push({ contexts: n.currentContext, node: e }))
								: e.inputNames.every(function (e) {
										return !!UP(e, r, n);
								  }) && ((a[o] = !0), t.push({ contexts: n.currentContext, node: e })));
					});
				}),
				(t.dispose = function () {
					var e = this;
					Object.keys(this.weightMap).forEach(function (t) {
						return e.weightMap[t].forEach(function (e) {
							return e.dispose();
						});
					});
				}),
				(t.checkInputShapeAndType = function (e) {
					var t = this;
					Object.keys(e).forEach(function (n) {
						var r = e[n],
							a = jP(n)[0],
							i = t.graph.nodes[a];
						if (i.attrParams.shape && i.attrParams.shape.value) {
							var o = i.attrParams.shape.value;
							Dg(
								o.length === r.shape.length &&
									r.shape.every(function (e, t) {
										return -1 === o[t] || o[t] === e;
									}),
								function () {
									return (
										"The shape of dict['" +
										i.name +
										"'] provided in model.execute(dict) must be [" +
										o +
										"], but was [" +
										r.shape +
										"]"
									);
								}
							);
						}
						i.attrParams.dtype &&
							i.attrParams.dtype.value &&
							Dg(r.dtype === i.attrParams.dtype.value, function () {
								return (
									"The dtype of dict['" +
									i.name +
									"'] provided in model.execute(dict) must be " +
									i.attrParams.dtype.value +
									", but was " +
									r.dtype
								);
							});
					});
				}),
				(t.mapInputs = function (e) {
					var t = {};
					for (var n in e)
						null != this._signature && null != this._signature.inputs && null != this._signature.inputs[n]
							? (t[this._signature.inputs[n].name] = e[n])
							: (t[n] = e[n]);
					return t;
				}),
				(t.checkInputs = function (e) {
					var t = this,
						n = Object.keys(e).filter(function (e) {
							var n = jP(e)[0];
							return null == t.graph.nodes[n];
						});
					if (n.length > 0)
						throw new Error(
							"The dict provided in model.execute(dict) has keys: [" + n + "] that are not part of graph"
						);
				}),
				(t.mapOutputs = function (e) {
					var t = this;
					return e.map(function (e) {
						return null != t._signature && null != t._signature.outputs && null != t._signature.outputs[e]
							? t._signature.outputs[e].name
							: e;
					}, {});
				}),
				(t.checkOutputs = function (e) {
					var t = this;
					e.forEach(function (e) {
						var n = jP(e)[0];
						if (!t.graph.nodes[n]) throw new Error("The output '" + e + "' is not found in the graph");
					});
				}),
				mg(e, [
					{
						key: "weightIds",
						get: function () {
							return this.parent ? this.parent.weightIds : this._weightIds;
						},
					},
					{
						key: "functionExecutorMap",
						get: function () {
							return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
						},
					},
					{
						key: "weightMap",
						get: function () {
							return this.parent ? this.parent.weightMap : this._weightMap;
						},
						set: function (e) {
							var t,
								n = Object.keys(e).map(function (t) {
									return e[t].map(function (e) {
										return e.id;
									});
								});
							(this._weightIds = (t = []).concat.apply(t, n)), (this._weightMap = e);
						},
					},
					{
						key: "resourceManager",
						set: function (e) {
							this._resourceManager = e;
						},
					},
					{
						key: "inputs",
						get: function () {
							return this._inputs.map(function (e) {
								return {
									name: e.name,
									shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
									dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0,
								};
							});
						},
					},
					{
						key: "outputs",
						get: function () {
							return this._outputs.map(function (e) {
								return {
									name: e.name,
									shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
									dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0,
								};
							});
						},
					},
					{
						key: "inputNodes",
						get: function () {
							return this._inputs.map(function (e) {
								return e.signatureKey || e.name;
							});
						},
					},
					{
						key: "outputNodes",
						get: function () {
							return this._outputs.map(function (e) {
								var t = e.signatureKey || e.name;
								return e.defaultOutput ? t + ":" + e.defaultOutput : t;
							});
						},
					},
					{
						key: "functions",
						get: function () {
							var e = this;
							return Object.keys(this._functions).reduce(function (t, n) {
								return (t[n] = e._functions[n].signature), t;
							}, {});
						},
					},
				]),
				e
			);
		})(),
		tW = (function () {
			function e(e, t) {
				void 0 === e && (e = {}),
					void 0 === t && (t = {}),
					(this.hashTableNameToHandle = e),
					(this.hashTableMap = t);
			}
			var t = e.prototype;
			return (
				(t.addHashTable = function (e, t) {
					(this.hashTableNameToHandle[e] = t.handle), (this.hashTableMap[t.id] = t);
				}),
				(t.getHashTableHandleByName = function (e) {
					return this.hashTableNameToHandle[e];
				}),
				(t.getHashTableById = function (e) {
					return this.hashTableMap[e];
				}),
				(t.dispose = function () {
					for (var e in this.hashTableMap) this.hashTableMap[e].clearAndClose(), delete this.hashTableMap[e];
					for (var t in this.hashTableNameToHandle)
						this.hashTableNameToHandle[t].dispose(), delete this.hashTableNameToHandle[t];
				}),
				e
			);
		})(),
		nW = "?tfjs-format=file",
		rW = "model.json",
		aW = (function () {
			function e(e, t) {
				void 0 === t && (t = {}),
					(this.modelUrl = e),
					(this.loadOptions = t),
					(this.version = "n/a"),
					null == t && (this.loadOptions = {}),
					(this.resourceManager = new tW());
			}
			var t = e.prototype;
			return (
				(t.findIOHandler = function () {
					var e = this.modelUrl;
					if (null != e.load) this.handler = e;
					else if (null != this.loadOptions.requestInit) this.handler = WN(e, this.loadOptions);
					else {
						var t = Wk(e, this.loadOptions);
						if (0 === t.length) t.push(WN(e, this.loadOptions));
						else if (t.length > 1)
							throw new Error(
								"Found more than one (" + t.length + ") load handlers for URL '" + [e] + "'"
							);
						this.handler = t[0];
					}
				}),
				(t.load = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if ((this.findIOHandler(), null != this.handler.load)) {
													e.next = 3;
													break;
												}
												throw new Error(
													"Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented."
												);
											case 3:
												return (e.next = 5), this.handler.load();
											case 5:
												return (t = e.sent), e.abrupt("return", this.loadSync(t));
											case 7:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.loadSync = function (e) {
					this.artifacts = e;
					var t,
						n = this.artifacts.modelTopology;
					(t =
						null != this.artifacts.userDefinedMetadata &&
						null != this.artifacts.userDefinedMetadata.signature
							? this.artifacts.userDefinedMetadata.signature
							: this.artifacts.signature),
						(this.signature = t),
						(this.version = n.versions.producer + "." + n.versions.minConsumer);
					var r = Sk(this.artifacts.weightData, this.artifacts.weightSpecs);
					if (
						((this.executor = new eW(hB.Instance.transformGraph(n, this.signature))),
						(this.executor.weightMap = this.convertTensorMapToTensorsMap(r)),
						(this.executor.resourceManager = this.resourceManager),
						null != e.modelInitializer && null != e.modelInitializer.node)
					) {
						var a = hB.Instance.transformGraph(e.modelInitializer);
						(this.initializer = new eW(a)),
							(this.initializer.weightMap = this.executor.weightMap),
							(this.initializer.resourceManager = this.resourceManager),
							this.initializer.executeAsync({}, []);
					}
					return !0;
				}),
				(t.save = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if ("string" != typeof t) {
													e.next = 9;
													break;
												}
												if (0 !== (r = Bk(t)).length) {
													e.next = 6;
													break;
												}
												throw new Error("Cannot find any save handlers for URL '" + t + "'");
											case 6:
												if (!(r.length > 1)) {
													e.next = 8;
													break;
												}
												throw new Error(
													"Found more than one (" +
														r.length +
														") save handlers for URL '" +
														t +
														"'"
												);
											case 8:
												t = r[0];
											case 9:
												if (null != t.save) {
													e.next = 11;
													break;
												}
												throw new Error(
													"GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined."
												);
											case 11:
												return e.abrupt("return", t.save(this.artifacts));
											case 12:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.predict = function (e, t) {
					return this.execute(e, this.outputNodes);
				}),
				(t.normalizeInputs = function (e) {
					if (!(e instanceof Pw || Array.isArray(e))) return e;
					if ((e = Array.isArray(e) ? e : [e]).length !== this.inputNodes.length)
						throw new Error(
							"Input tensor count mismatch,the graph model has " +
								this.inputNodes.length +
								" placeholders, while there are " +
								e.length +
								" input tensors."
						);
					return this.inputNodes.reduce(function (t, n, r) {
						return (t[n] = e[r]), t;
					}, {});
				}),
				(t.normalizeOutputs = function (e) {
					return (e = e || this.outputNodes), Array.isArray(e) ? e : [e];
				}),
				(t.execute = function (e, t) {
					(e = this.normalizeInputs(e)), (t = this.normalizeOutputs(t));
					var n = this.executor.execute(e, t);
					return n.length > 1 ? n : n[0];
				}),
				(t.executeAsync = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t, n) {
							var r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(t = this.normalizeInputs(t)),
													(n = this.normalizeOutputs(n)),
													(e.next = 4),
													this.executor.executeAsync(t, n)
												);
											case 4:
												return (r = e.sent), e.abrupt("return", r.length > 1 ? r : r[0]);
											case 6:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(t.getIntermediateTensors = function () {
					return this.executor.getIntermediateTensors();
				}),
				(t.disposeIntermediateTensors = function () {
					this.executor.disposeIntermediateTensors();
				}),
				(t.convertTensorMapToTensorsMap = function (e) {
					return Object.keys(e).reduce(function (t, n) {
						return (t[n] = [e[n]]), t;
					}, {});
				}),
				(t.dispose = function () {
					this.executor.dispose(),
						this.initializer && this.initializer.dispose(),
						this.resourceManager.dispose();
				}),
				mg(e, [
					{
						key: "modelVersion",
						get: function () {
							return this.version;
						},
					},
					{
						key: "inputNodes",
						get: function () {
							return this.executor.inputNodes;
						},
					},
					{
						key: "outputNodes",
						get: function () {
							return this.executor.outputNodes;
						},
					},
					{
						key: "inputs",
						get: function () {
							return this.executor.inputs;
						},
					},
					{
						key: "outputs",
						get: function () {
							return this.executor.outputs;
						},
					},
					{
						key: "weights",
						get: function () {
							return this.executor.weightMap;
						},
					},
					{
						key: "metadata",
						get: function () {
							return this.artifacts.userDefinedMetadata;
						},
					},
					{
						key: "modelSignature",
						get: function () {
							return this.signature;
						},
					},
				]),
				e
			);
		})();
	function iW() {
		return (iW = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								if ((void 0 === n && (n = {}), null != t)) {
									e.next = 3;
									break;
								}
								throw new Error(
									"modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model"
								);
							case 3:
								return (
									null == n && (n = {}),
									n.fromTFHub &&
										null == t.load &&
										(t.endsWith("/") || (t += "/"), (t = "" + t + rW + nW)),
									(r = new aW(t, n)),
									(e.next = 8),
									r.load()
								);
							case 8:
								return e.abrupt("return", r);
							case 9:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var oW = "3.15.0";
	function sW(e, t, n, r) {
		if ((void 0 === n && (n = new Map()), void 0 === r && (r = new Set()), null == e)) return null;
		if ("function" == typeof Blob && e instanceof Blob) return e.slice();
		if (r.has(e)) throw new Error("Circular references are not supported.");
		if (n.has(e)) return n.get(e);
		var a = t(e);
		if (a.recurse && null !== a.value)
			throw new Error("A deep map function may not return both a value and recurse=true.");
		if (a.recurse) {
			if (fW(e)) {
				var i = Array.isArray(e) ? [] : {};
				for (var o in (r.add(e), e)) {
					var s = sW(e[o], t, n, r);
					i[o] = s;
				}
				return r.delete(e), e.__proto__ && (i.__proto__ = e.__proto__), i;
			}
			throw new Error("Can't recurse into non-iterable type: " + e);
		}
		return n.set(e, a.value), a.value;
	}
	function uW(e, t) {
		return void 0 === t && (t = cW), lW(e, t);
	}
	function lW(e, t, n) {
		void 0 === n && (n = new Set());
		var r = e[0];
		if (n.has(r)) throw new Error("Circular references are not supported.");
		var a = t(e);
		if (a.recurse && null !== a.value)
			throw new Error("A deep zip function may not return both a value and recurse=true.");
		if (a.recurse) {
			if (fW(r)) {
				var i = Array.isArray(r) ? [] : {};
				n.add(r);
				var o = function (r) {
					var a = lW(
						e.map(function (e) {
							return e[r];
						}),
						t,
						n
					);
					i[r] = a;
				};
				for (var s in r) o(s);
				return n.delete(r), i;
			}
			throw new Error("Can't recurse into non-iterable type: " + r);
		}
		return a.value;
	}
	function cW(e) {
		return null === e ? null : fW(e[0]) ? { value: null, recurse: !0 } : { value: e, recurse: !1 };
	}
	function pW(e, t) {
		return hW.apply(this, arguments);
	}
	function hW() {
		return (hW = fg(
			regeneratorRuntime.mark(function e(t, n) {
				var r, a, i, o, s, u, l;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								(r = new Map()), sW(t, n, r), (a = 0), (i = Array.from(r.keys()));
							case 3:
								if (!(a < i.length)) {
									e.next = 14;
									break;
								}
								if (((o = i[a]), !mv((s = r.get(o))))) {
									e.next = 11;
									break;
								}
								return (e.next = 9), s;
							case 9:
								(u = e.sent), r.set(o, u);
							case 11:
								a++, (e.next = 3);
								break;
							case 14:
								return (l = sW(t, n, r)), e.abrupt("return", l);
							case 16:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function fW(e) {
		var t = !1;
		return (
			(t = xv().get("IS_BROWSER")
				? e instanceof TextDecoder
				: e instanceof require("string_decoder").StringDecoder),
			null != e &&
				!ArrayBuffer.isView(e) &&
				(Array.isArray(e) || ("object" == typeof e && !(e instanceof Pw) && !(e instanceof Promise) && !t))
		);
	}
	function dW(e) {
		return (function (e, t) {
			return sW(e, t);
		})(e, mW);
	}
	function mW(e) {
		return e instanceof Pw
			? { value: e.clone(), recurse: !1 }
			: fW(e)
			? { value: null, recurse: !0 }
			: { value: e, recurse: !1 };
	}
	var gW = (function () {
			function e(e) {
				if (((this.capacity = e), (this.begin = 0), (this.end = 0), null == e))
					throw new RangeError("Can't create a ring buffer of unknown capacity.");
				if (e < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
				(this.data = new Array(e)), (this.doubledCapacity = 2 * e);
			}
			var t = e.prototype;
			return (
				(t.wrap = function (e) {
					for (; e < 0; ) e += this.doubledCapacity;
					return e % this.doubledCapacity;
				}),
				(t.get = function (e) {
					if (e < 0) throw new RangeError("Can't get item at a negative index.");
					return this.data[e % this.capacity];
				}),
				(t.set = function (e, t) {
					if (e < 0) throw new RangeError("Can't set item at a negative index.");
					this.data[e % this.capacity] = t;
				}),
				(t.length = function () {
					var e = this.end - this.begin;
					return e < 0 && (e = this.doubledCapacity + e), e;
				}),
				(t.isFull = function () {
					return this.length() === this.capacity;
				}),
				(t.isEmpty = function () {
					return 0 === this.length();
				}),
				(t.push = function (e) {
					if (this.isFull()) throw new RangeError("Ring buffer is full.");
					this.set(this.end, e), (this.end = this.wrap(this.end + 1));
				}),
				(t.pushAll = function (e) {
					for (var t, n = Ig(e); !(t = n()).done; ) {
						var r = t.value;
						this.push(r);
					}
				}),
				(t.pop = function () {
					if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
					this.end = this.wrap(this.end - 1);
					var e = this.get(this.end);
					return this.set(this.end, void 0), e;
				}),
				(t.unshift = function (e) {
					if (this.isFull()) throw new RangeError("Ring buffer is full.");
					(this.begin = this.wrap(this.begin - 1)), this.set(this.begin, e);
				}),
				(t.shift = function () {
					if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
					var e = this.get(this.begin);
					return this.set(this.begin, void 0), (this.begin = this.wrap(this.begin + 1)), e;
				}),
				(t.shuffleExcise = function (e) {
					if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
					var t = this.wrap(this.begin + e),
						n = this.get(t);
					return this.set(t, this.pop()), n;
				}),
				e
			);
		})(),
		vW = (function (e) {
			function t() {
				return e.call(this, t.INITIAL_CAPACITY) || this;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.isFull = function () {
					return !1;
				}),
				(n.push = function (t) {
					e.prototype.isFull.call(this) && this.expand(), e.prototype.push.call(this, t);
				}),
				(n.unshift = function (t) {
					e.prototype.isFull.call(this) && this.expand(), e.prototype.unshift.call(this, t);
				}),
				(n.expand = function () {
					for (var e = 2 * this.capacity, t = new Array(e), n = this.length(), r = 0; r < n; r++)
						t[r] = this.get(this.wrap(this.begin + r));
					(this.data = t),
						(this.capacity = e),
						(this.doubledCapacity = 2 * this.capacity),
						(this.begin = 0),
						(this.end = n);
				}),
				t
			);
		})(gW);
	function yW(e) {
		return new IW(e);
	}
	function bW(e) {
		return new SW(e);
	}
	function xW(e, t) {
		return new LW(e, t);
	}
	function wW(e, t) {
		return void 0 === t && (t = kW.FAIL), new zW(e, t);
	}
	vW.INITIAL_CAPACITY = 32;
	var kW,
		NW = (function () {
			function e() {}
			var t = e.prototype;
			return (
				(t.toArray = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (t = []), (e.next = 3), this.next();
											case 3:
												n = e.sent;
											case 4:
												if (n.done) {
													e.next = 11;
													break;
												}
												return t.push(n.value), (e.next = 8), this.next();
											case 8:
												(n = e.sent), (e.next = 4);
												break;
											case 11:
												return e.abrupt("return", t);
											case 12:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.toArrayForTest = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (t = this.prefetch(100)), (n = []), (e.next = 4), t.next();
											case 4:
												r = e.sent;
											case 5:
												if (r.done) {
													e.next = 12;
													break;
												}
												return n.push(r.value), (e.next = 9), t.next();
											case 9:
												(r = e.sent), (e.next = 5);
												break;
											case 12:
												return e.abrupt("return", n);
											case 13:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.resolveFully = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.next();
											case 2:
												t = e.sent;
											case 3:
												if (t.done) {
													e.next = 9;
													break;
												}
												return (e.next = 6), this.next();
											case 6:
												(t = e.sent), (e.next = 3);
												break;
											case 9:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.resolveWhile = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.next();
											case 2:
												(n = e.sent), (r = t(n.value));
											case 4:
												if (n.done || !r) {
													e.next = 11;
													break;
												}
												return (e.next = 7), this.next();
											case 7:
												(n = e.sent), (r = t(n.value)), (e.next = 4);
												break;
											case 11:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.handleErrors = function (e) {
					return new FW(this, e);
				}),
				(t.filter = function (e) {
					return new AW(this, e);
				}),
				(t.map = function (e) {
					return new _W(this, e);
				}),
				(t.mapAsync = function (e) {
					return new DW(this, e);
				}),
				(t.serialMapAsync = function (e) {
					return new DW(this, e).serial();
				}),
				(t.flatmap = function (e) {
					return new MW(this, e);
				}),
				(t.forEachAsync = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return e.abrupt("return", this.map(t).resolveFully());
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.serialForEach = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return e.abrupt(
													"return",
													this.serialMapAsync(t).resolveWhile(function (e) {
														return !0 === e;
													})
												);
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.rowMajorBatch = function (e, t) {
					return void 0 === t && (t = !0), new RW(this, e, t);
				}),
				(t.columnMajorBatch = function (e, t, n) {
					return (
						void 0 === t && (t = !0),
						void 0 === n && (n = cW),
						this.rowMajorBatch(e, t).map(function (e) {
							return uW(e, n);
						})
					);
				}),
				(t.concatenate = function (e, t) {
					return new LW(yW([this, e]), t);
				}),
				(t.take = function (e) {
					return e < 0 || null == e ? this : new EW(this, e);
				}),
				(t.skip = function (e) {
					return e < 0 || null == e ? this : new CW(this, e);
				}),
				(t.prefetch = function (e) {
					return new PW(this, e);
				}),
				(t.shuffle = function (e, t) {
					return new BW(this, e, t);
				}),
				(t.serial = function () {
					return new TW(this);
				}),
				e
			);
		})(),
		IW = (function (e) {
			function t(t) {
				var n;
				return ((n = e.call(this) || this).items = t), (n.trav = 0), n;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return "Array of " + this.items.length + " items";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (!(this.trav >= this.items.length)) {
													e.next = 2;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 2:
												return (
													(t = this.items[this.trav]),
													this.trav++,
													e.abrupt("return", { value: dW(t), done: !1 })
												);
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		SW = (function (e) {
			function t(t) {
				var n;
				return ((n = e.call(this) || this).nextFn = t), n;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return "Function call";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.prev = 0), e.abrupt("return", this.nextFn());
											case 4:
												throw (
													((e.prev = 4),
													(e.t0 = e.catch(0)),
													(e.t0.message =
														"Error thrown while iterating through a dataset: " +
														e.t0.message),
													e.t0)
												);
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this,
								[[0, 4]]
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		TW = (function (e) {
			function t(t) {
				var n;
				return (
					((n = e.call(this) || this).upstream = t),
					(n.lastRead = Promise.resolve({ value: null, done: !1 })),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> Serial";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.lastRead = this.lastRead.then(function () {
														return t.serialNext();
													})),
													e.abrupt("return", this.lastRead)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.serialNext = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return e.abrupt("return", this.upstream.next());
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		CW = (function (e) {
			function t(t, n) {
				var r;
				return (
					((r = e.call(this) || this).upstream = t),
					(r.maxCount = n),
					(r.count = 0),
					(r.lastRead = Promise.resolve({ value: null, done: !1 })),
					r
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> Skip";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.lastRead = this.lastRead.then(function () {
														return t.serialNext();
													})),
													e.abrupt("return", this.lastRead)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.serialNext = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (!(this.count++ < this.maxCount)) {
													e.next = 9;
													break;
												}
												return (e.next = 3), this.upstream.next();
											case 3:
												if (!(t = e.sent).done) {
													e.next = 6;
													break;
												}
												return e.abrupt("return", t);
											case 6:
												WI(t.value), (e.next = 0);
												break;
											case 9:
												return e.abrupt("return", this.upstream.next());
											case 10:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		EW = (function (e) {
			function t(t, n) {
				var r;
				return ((r = e.call(this) || this).upstream = t), (r.maxCount = n), (r.count = 0), r;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> Take";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (!(this.count++ >= this.maxCount)) {
													e.next = 2;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 2:
												return e.abrupt("return", this.upstream.next());
											case 3:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		RW = (function (e) {
			function t(t, n, r) {
				var a;
				return (
					void 0 === r && (r = !0),
					((a = e.call(this) || this).upstream = t),
					(a.batchSize = n),
					(a.enableSmallLastBatch = r),
					(a.lastRead = Promise.resolve({ value: null, done: !1 })),
					a
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> RowMajorBatch";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.lastRead = this.lastRead.then(function () {
														return t.serialNext();
													})),
													e.abrupt("return", this.lastRead)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.serialNext = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												t = [];
											case 1:
												if (!(t.length < this.batchSize)) {
													e.next = 12;
													break;
												}
												return (e.next = 4), this.upstream.next();
											case 4:
												if (!(n = e.sent).done) {
													e.next = 9;
													break;
												}
												if (!(this.enableSmallLastBatch && t.length > 0)) {
													e.next = 8;
													break;
												}
												return e.abrupt("return", { value: t, done: !1 });
											case 8:
												return e.abrupt("return", { value: null, done: !0 });
											case 9:
												t.push(n.value), (e.next = 1);
												break;
											case 12:
												return e.abrupt("return", { value: t, done: !1 });
											case 13:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		AW = (function (e) {
			function t(t, n) {
				var r;
				return (
					((r = e.call(this) || this).upstream = t),
					(r.predicate = n),
					(r.lastRead = Promise.resolve({ value: null, done: !1 })),
					r
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> Filter";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.lastRead = this.lastRead.then(function () {
														return t.serialNext();
													})),
													e.abrupt("return", this.lastRead)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.serialNext = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 3), this.upstream.next();
											case 3:
												if (!(t = e.sent).done && !this.predicate(t.value)) {
													e.next = 6;
													break;
												}
												return e.abrupt("return", t);
											case 6:
												WI(t.value), (e.next = 0);
												break;
											case 9:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		_W = (function (e) {
			function t(t, n) {
				var r;
				return ((r = e.call(this) || this).upstream = t), (r.transform = n), r;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> Map";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r, a, i, o, s;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.upstream.next();
											case 2:
												if (!(t = e.sent).done) {
													e.next = 5;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 5:
												for (
													n = Qw(t.value), r = this.transform(t.value), a = Qw(r), i = Ig(n);
													!(o = i()).done;

												)
													Zw((s = o.value), a) || s.dispose();
												return e.abrupt("return", { value: r, done: !1 });
											case 10:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		FW = (function (e) {
			function t(t, n) {
				var r;
				return (
					((r = e.call(this) || this).upstream = t),
					(r.handler = n),
					(r.count = 0),
					(r.lastRead = Promise.resolve({ value: null, done: !1 })),
					r
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> handleErrors";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.lastRead = this.lastRead.then(function () {
														return t.serialNext();
													})),
													e.abrupt("return", this.lastRead)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.serialNext = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.prev = 1), (e.next = 4), this.upstream.next();
											case 4:
												return e.abrupt("return", e.sent);
											case 7:
												if (((e.prev = 7), (e.t0 = e.catch(1)), this.handler(e.t0))) {
													e.next = 11;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 11:
												e.next = 0;
												break;
											case 13:
											case "end":
												return e.stop();
										}
								},
								e,
								this,
								[[1, 7]]
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		DW = (function (e) {
			function t(t, n) {
				var r;
				return ((r = e.call(this) || this).upstream = t), (r.transform = n), r;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> AsyncMap";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r, a, i, o, s;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.upstream.next();
											case 2:
												if (!(t = e.sent).done) {
													e.next = 5;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 5:
												return (n = Qw(t.value)), (e.next = 8), this.transform(t.value);
											case 8:
												for (r = e.sent, a = Qw(r), i = Ig(n); !(o = i()).done; )
													Zw((s = o.value), a) || s.dispose();
												return e.abrupt("return", { value: r, done: !1 });
											case 12:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		OW = (function (e) {
			function t() {
				var t;
				return (
					((t = e.call(this) || this).outputQueue = new vW()),
					(t.lastRead = Promise.resolve({ value: null, done: !1 })),
					t
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.lastRead = this.lastRead.then(function () {
														return t.serialNext();
													})),
													e.abrupt("return", this.lastRead)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.serialNext = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (0 !== this.outputQueue.length()) {
													e.next = 7;
													break;
												}
												return (e.next = 3), this.pump();
											case 3:
												if (e.sent) {
													e.next = 5;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 5:
												e.next = 0;
												break;
											case 7:
												return e.abrupt("return", {
													value: this.outputQueue.shift(),
													done: !1,
												});
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		MW = (function (e) {
			function t(t, n) {
				var r;
				return ((r = e.call(this) || this).upstream = t), (r.transform = n), r;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> Flatmap";
				}),
				(n.pump = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r, a, i, o, s;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.upstream.next();
											case 2:
												if (!(t = e.sent).done) {
													e.next = 5;
													break;
												}
												return e.abrupt("return", !1);
											case 5:
												for (
													n = Qw(t.value),
														r = this.transform(t.value),
														a = Qw(r),
														this.outputQueue.pushAll(r),
														i = Ig(n);
													!(o = i()).done;

												)
													Zw((s = o.value), a) || s.dispose();
												return e.abrupt("return", !0);
											case 11:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(OW),
		LW = (function (e) {
			function t(t, n) {
				var r;
				return (
					((r = e.call(this) || this).baseErrorHandler = n),
					(r.lastRead = null),
					(r.iterator = null),
					(r.moreIterators = t),
					r
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return "TODO: fill in upstream of chained summaries -> Chained";
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.lastRead = this.readFromChain(this.lastRead)),
													e.abrupt("return", this.lastRead)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.readFromChain = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), t;
											case 2:
												if (null != this.iterator) {
													e.next = 10;
													break;
												}
												return (e.next = 5), this.moreIterators.next();
											case 5:
												if (!(n = e.sent).done) {
													e.next = 8;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 8:
												(this.iterator = n.value),
													null != this.baseErrorHandler &&
														(this.iterator = this.iterator.handleErrors(
															this.baseErrorHandler
														));
											case 10:
												return (e.next = 12), this.iterator.next();
											case 12:
												if (!(r = e.sent).done) {
													e.next = 16;
													break;
												}
												return (
													(this.iterator = null), e.abrupt("return", this.readFromChain(t))
												);
											case 16:
												return e.abrupt("return", r);
											case 17:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW);
	!(function (e) {
		(e[(e.FAIL = 0)] = "FAIL"), (e[(e.SHORTEST = 1)] = "SHORTEST"), (e[(e.LONGEST = 2)] = "LONGEST");
	})(kW || (kW = {}));
	var zW = (function (e) {
			function t(t, n) {
				var r;
				return (
					void 0 === n && (n = kW.FAIL),
					((r = e.call(this) || this).iterators = t),
					(r.mismatchMode = n),
					(r.count = 0),
					(r.currentPromise = null),
					r
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return "{TODO: fill in upstream of zip summaries} -> Zip";
				}),
				(n.nextState = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r, a, i;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(a = function (e) {
														return e instanceof NW
															? {
																	value: e.next().then(function (e) {
																		return n++, e.done && r++, e.value;
																	}),
																	recurse: !1,
															  }
															: { value: null, recurse: !0 };
													}),
													(e.next = 3),
													t
												);
											case 3:
												return (n = 0), (r = 0), (e.next = 7), pW(this.iterators, a);
											case 7:
												if (((i = e.sent), n !== r)) {
													e.next = 10;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 10:
												if (!(r > 0)) {
													e.next = 16;
													break;
												}
												(e.t0 = this.mismatchMode),
													(e.next =
														e.t0 === kW.FAIL
															? 14
															: e.t0 === kW.SHORTEST
															? 15
															: (e.t0, kW.LONGEST, 16));
												break;
											case 14:
												throw new Error(
													"Zipped streams should have the same length. Mismatched at element " +
														this.count +
														"."
												);
											case 15:
												return e.abrupt("return", { value: null, done: !0 });
											case 16:
												return this.count++, e.abrupt("return", { value: i, done: !1 });
											case 18:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.currentPromise = this.nextState(this.currentPromise)),
													e.abrupt("return", this.currentPromise)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(NW),
		PW = (function (e) {
			function t(t, n) {
				var r;
				return ((r = e.call(this) || this).upstream = t), (r.bufferSize = n), (r.buffer = new gW(n)), r;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> Prefetch";
				}),
				(n.refill = function () {
					for (; !this.buffer.isFull(); ) {
						var e = this.upstream.next();
						this.buffer.push(e);
					}
				}),
				(n.next = function () {
					return this.refill(), this.buffer.shift();
				}),
				t
			);
		})(NW),
		BW = (function (e) {
			function t(t, n, r) {
				var a;
				return (
					((a = e.call(this, t, n) || this).upstream = t),
					(a.windowSize = n),
					(a.upstreamExhausted = !1),
					(a.random = WC(r || Nw().toString())),
					(a.lastRead = Promise.resolve({ value: null, done: !1 })),
					a
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(this.lastRead = this.lastRead.then(function () {
														return t.serialNext();
													})),
													e.abrupt("return", this.lastRead)
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.randomInt = function (e) {
					return Math.floor(this.random() * e);
				}),
				(n.chooseIndex = function () {
					return this.randomInt(this.buffer.length());
				}),
				(n.serialNext = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												this.upstreamExhausted || this.refill();
											case 1:
												if (this.buffer.isEmpty()) {
													e.next = 14;
													break;
												}
												return (
													(t = this.chooseIndex()), (e.next = 5), this.buffer.shuffleExcise(t)
												);
											case 5:
												if (!(n = e.sent).done) {
													e.next = 10;
													break;
												}
												(this.upstreamExhausted = !0), (e.next = 12);
												break;
											case 10:
												return this.refill(), e.abrupt("return", n);
											case 12:
												e.next = 1;
												break;
											case 14:
												return e.abrupt("return", { value: null, done: !0 });
											case 15:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(PW),
		WW = (function () {
			function e() {
				this.size = null;
			}
			var t = e.prototype;
			return (
				(t.batch = function (e, t) {
					void 0 === t && (t = !0);
					var n,
						r = this;
					return (
						Dg(e > 0, function () {
							return "batchSize needs to be positive, but it is\n      " + e;
						}),
						(n =
							this.size === 1 / 0 || null == this.size
								? this.size
								: t
								? Math.ceil(this.size / e)
								: Math.floor(this.size / e)),
						UW(
							fg(
								regeneratorRuntime.mark(function n() {
									return regeneratorRuntime.wrap(function (n) {
										for (;;)
											switch ((n.prev = n.next)) {
												case 0:
													return (n.next = 2), r.iterator();
												case 2:
													return n.abrupt("return", n.sent.columnMajorBatch(e, t, VW));
												case 3:
												case "end":
													return n.stop();
											}
									}, n);
								})
							),
							n
						)
					);
				}),
				(t.concatenate = function (e) {
					var t,
						n = this;
					return (
						(t =
							this.size === 1 / 0 || e.size === 1 / 0
								? 1 / 0
								: null != this.size && null != e.size
								? this.size + e.size
								: null),
						UW(
							fg(
								regeneratorRuntime.mark(function t() {
									return regeneratorRuntime.wrap(function (t) {
										for (;;)
											switch ((t.prev = t.next)) {
												case 0:
													return (t.next = 2), n.iterator();
												case 2:
													return (t.t0 = t.sent), (t.next = 5), e.iterator();
												case 5:
													return (
														(t.t1 = t.sent),
														t.abrupt("return", t.t0.concatenate.call(t.t0, t.t1))
													);
												case 7:
												case "end":
													return t.stop();
											}
									}, t);
								})
							),
							t
						)
					);
				}),
				(t.filter = function (e) {
					var t,
						n = this;
					return (
						(t = this.size === 1 / 0 ? 1 / 0 : null),
						UW(
							fg(
								regeneratorRuntime.mark(function t() {
									return regeneratorRuntime.wrap(function (t) {
										for (;;)
											switch ((t.prev = t.next)) {
												case 0:
													return (t.next = 2), n.iterator();
												case 2:
													return t.abrupt(
														"return",
														t.sent.filter(function (t) {
															return BI(function () {
																return e(t);
															});
														})
													);
												case 3:
												case "end":
													return t.stop();
											}
									}, t);
								})
							),
							t
						)
					);
				}),
				(t.forEachAsync = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.iterator();
											case 2:
												return e.abrupt("return", e.sent.forEachAsync(t));
											case 3:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.map = function (e) {
					var t = this;
					return UW(
						fg(
							regeneratorRuntime.mark(function n() {
								return regeneratorRuntime.wrap(function (n) {
									for (;;)
										switch ((n.prev = n.next)) {
											case 0:
												return (n.next = 2), t.iterator();
											case 2:
												return n.abrupt(
													"return",
													n.sent.map(function (t) {
														return BI(function () {
															return e(t);
														});
													})
												);
											case 3:
											case "end":
												return n.stop();
										}
								}, n);
							})
						),
						this.size
					);
				}),
				(t.mapAsync = function (e) {
					var t = this;
					return UW(
						fg(
							regeneratorRuntime.mark(function n() {
								return regeneratorRuntime.wrap(function (n) {
									for (;;)
										switch ((n.prev = n.next)) {
											case 0:
												return (n.next = 2), t.iterator();
											case 2:
												return n.abrupt("return", n.sent.mapAsync(e));
											case 3:
											case "end":
												return n.stop();
										}
								}, n);
							})
						),
						this.size
					);
				}),
				(t.prefetch = function (e) {
					if (null == e) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
					var t = this;
					return UW(
						fg(
							regeneratorRuntime.mark(function n() {
								return regeneratorRuntime.wrap(function (n) {
									for (;;)
										switch ((n.prev = n.next)) {
											case 0:
												return (n.next = 2), t.iterator();
											case 2:
												return n.abrupt("return", n.sent.prefetch(e));
											case 3:
											case "end":
												return n.stop();
										}
								}, n);
							})
						),
						this.size
					);
				}),
				(t.repeat = function (e) {
					var t,
						n = this;
					return (
						(t =
							null != this.size && e > 0
								? this.size * e
								: 0 === e
								? 0
								: null != this.size && (void 0 === e || e < 0)
								? 1 / 0
								: null),
						UW(
							fg(
								regeneratorRuntime.mark(function t() {
									var r;
									return regeneratorRuntime.wrap(function (t) {
										for (;;)
											switch ((t.prev = t.next)) {
												case 0:
													return (
														(r = bW(
															fg(
																regeneratorRuntime.mark(function e() {
																	return regeneratorRuntime.wrap(function (e) {
																		for (;;)
																			switch ((e.prev = e.next)) {
																				case 0:
																					return (e.next = 2), n.iterator();
																				case 2:
																					return (
																						(e.t0 = e.sent),
																						e.abrupt("return", {
																							value: e.t0,
																							done: !1,
																						})
																					);
																				case 4:
																				case "end":
																					return e.stop();
																			}
																	}, e);
																})
															)
														)),
														t.abrupt("return", xW(r.take(e)))
													);
												case 2:
												case "end":
													return t.stop();
											}
									}, t);
								})
							),
							t
						)
					);
				}),
				(t.skip = function (e) {
					var t,
						n = this;
					return (
						(t =
							null != this.size && e >= 0 && this.size >= e
								? this.size - e
								: null != this.size && (this.size < e || void 0 === e || e < 0)
								? 0
								: null),
						UW(
							fg(
								regeneratorRuntime.mark(function t() {
									return regeneratorRuntime.wrap(function (t) {
										for (;;)
											switch ((t.prev = t.next)) {
												case 0:
													return (t.next = 2), n.iterator();
												case 2:
													return t.abrupt("return", t.sent.skip(e));
												case 3:
												case "end":
													return t.stop();
											}
									}, t);
								})
							),
							t
						)
					);
				}),
				(t.shuffle = function (e, t, n) {
					if ((void 0 === n && (n = !0), null == e || e < 0))
						throw null == this.size
							? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.")
							: new RangeError(
									"`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (" +
										this.size +
										" elements)"
							  );
					var r = this,
						a = WC(t || Nw().toString());
					return UW(
						fg(
							regeneratorRuntime.mark(function t() {
								var i;
								return regeneratorRuntime.wrap(function (t) {
									for (;;)
										switch ((t.prev = t.next)) {
											case 0:
												return (
													(i = a.int32()), n && (i += a.int32()), (t.next = 4), r.iterator()
												);
											case 4:
												return t.abrupt("return", t.sent.shuffle(e, i.toString()));
											case 5:
											case "end":
												return t.stop();
										}
								}, t);
							})
						),
						this.size
					);
				}),
				(t.take = function (e) {
					var t,
						n = this;
					return (
						(t =
							null != this.size && this.size > e
								? e
								: null != this.size && this.size <= e
								? this.size
								: null),
						UW(
							fg(
								regeneratorRuntime.mark(function t() {
									return regeneratorRuntime.wrap(function (t) {
										for (;;)
											switch ((t.prev = t.next)) {
												case 0:
													return (t.next = 2), n.iterator();
												case 2:
													return t.abrupt("return", t.sent.take(e));
												case 3:
												case "end":
													return t.stop();
											}
									}, t);
								})
							),
							t
						)
					);
				}),
				(t.toArray = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (this.size !== 1 / 0) {
													e.next = 2;
													break;
												}
												throw new Error("Can not convert infinite data stream to array.");
											case 2:
												return (e.next = 4), this.iterator();
											case 4:
												return e.abrupt("return", e.sent.toArray());
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(t.toArrayForTest = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (this.size !== 1 / 0) {
													e.next = 2;
													break;
												}
												throw new Error("Can not convert infinite data stream to array.");
											case 2:
												return (e.next = 4), this.iterator();
											case 4:
												return e.abrupt("return", e.sent.toArrayForTest());
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				e
			);
		})();
	function UW(e, t) {
		return (
			void 0 === t && (t = null),
			new ((function (n) {
				function r() {
					var e;
					return ((e = n.apply(this, arguments) || this).size = t), e;
				}
				return (
					gg(r, n),
					(r.prototype.iterator = (function () {
						var t = fg(
							regeneratorRuntime.mark(function t() {
								return regeneratorRuntime.wrap(function (t) {
									for (;;)
										switch ((t.prev = t.next)) {
											case 0:
												return t.abrupt("return", e());
											case 1:
											case "end":
												return t.stop();
										}
								}, t);
							})
						);
						return function () {
							return t.apply(this, arguments);
						};
					})()),
					r
				);
			})(WW))()
		);
	}
	function VW(e) {
		return null === e
			? null
			: (function (e) {
					return (
						null == e ||
						null === (t = e) ||
						("object" != typeof t && "function" != typeof t) ||
						Array.isArray(e) ||
						("object" == typeof e && e instanceof Pw) ||
						Zg(e)
					);
					var t;
			  })(e[0])
			? {
					value: (function (e) {
						if (0 === e.length) throw new Error("Can't make a batch of zero elements.");
						return e[0] instanceof Pw ? TE(e) : wk(e);
					})(e),
					recurse: !1,
			  }
			: { value: null, recurse: !0 };
	}
	WW.MAX_BUFFER_SIZE = 1e4;
	var GW = (function (e) {
			function t(t) {
				var n;
				return ((n = e.call(this) || this).input = t), n;
			}
			return (
				gg(t, e),
				(t.prototype.iterator = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.input.iterator();
											case 2:
												return (
													(t = e.sent),
													(n = t.decodeUTF8()),
													(r = n.split("\n").map(function (e) {
														return e.endsWith("\r") && (e = e.slice(0, -1)), e;
													})),
													e.abrupt("return", r)
												);
											case 6:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(WW),
		jW = '"',
		HW = Symbol("out"),
		qW = Symbol("field"),
		KW = Symbol("quote"),
		XW = Symbol("quoteafterquote"),
		YW = Symbol("quoteinquote"),
		JW = (function (e) {
			function t(t, n) {
				var r;
				return (
					((r = e.call(this) || this).input = t),
					(r.hasHeader = !0),
					(r.fullColumnNames = null),
					(r.columnNamesValidated = !1),
					(r.columnConfigs = null),
					(r.configuredColumnsOnly = !1),
					(r.delimiter = ","),
					(r.delimWhitespace = !1),
					(r.base = new GW(t)),
					n || (n = {}),
					(r.hasHeader = !1 !== n.hasHeader),
					(r.fullColumnNames = n.columnNames),
					(r.columnConfigs = n.columnConfigs),
					(r.configuredColumnsOnly = n.configuredColumnsOnly),
					n.delimWhitespace
						? (Dg(null == n.delimiter, function () {
								return "Delimiter should not be provided when delimWhitespace is true.";
						  }),
						  (r.delimWhitespace = !0),
						  (r.delimiter = " "))
						: (r.delimiter = n.delimiter ? n.delimiter : ","),
					r
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.columnNames = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (this.columnNamesValidated) {
													e.next = 3;
													break;
												}
												return (e.next = 3), this.setColumnNames();
											case 3:
												return e.abrupt(
													"return",
													this.configuredColumnsOnly
														? Object.keys(this.columnConfigs)
														: this.fullColumnNames
												);
											case 4:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.setColumnNames = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t,
								n,
								r,
								a,
								i,
								o,
								s = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.maybeReadHeaderLine();
											case 2:
												if (((t = e.sent), this.fullColumnNames || t)) {
													e.next = 7;
													break;
												}
												throw new Error(
													"Column names must be provided if there is no header line."
												);
											case 7:
												this.fullColumnNames &&
													t &&
													Dg(t.length === this.fullColumnNames.length, function () {
														return (
															"The length of provided columnNames (" +
															s.fullColumnNames.length.toString() +
															") does not match the length of the header line read from file (" +
															t.length.toString() +
															")."
														);
													});
											case 8:
												if (
													(this.fullColumnNames || (this.fullColumnNames = t),
													(n = this.fullColumnNames.reduce(function (e, t) {
														return (e[t] = e[t] + 1 || 1), e;
													}, {})),
													Dg(
														0 ===
															(r = Object.keys(n).filter(function (e) {
																return n[e] > 1;
															})).length,
														function () {
															return "Duplicate column names found: " + r.toString();
														}
													),
													!this.columnConfigs)
												) {
													e.next = 22;
													break;
												}
												(a = 0), (i = Object.keys(this.columnConfigs));
											case 14:
												if (!(a < i.length)) {
													e.next = 22;
													break;
												}
												if (((o = i[a]), -1 !== this.fullColumnNames.indexOf(o))) {
													e.next = 19;
													break;
												}
												throw new Error(
													'The key "' +
														o +
														'" provided in columnConfigs does not match any of the column names (' +
														this.fullColumnNames.toString() +
														")."
												);
											case 19:
												a++, (e.next = 14);
												break;
											case 22:
												this.columnNamesValidated = !0;
											case 23:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.maybeReadHeaderLine = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r, a;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (!this.hasHeader) {
													e.next = 14;
													break;
												}
												return (e.next = 3), this.base.iterator();
											case 3:
												return (t = e.sent), (e.next = 6), t.next();
											case 6:
												if (!(n = e.sent).done) {
													e.next = 9;
													break;
												}
												throw new Error("No data was found for CSV parsing.");
											case 9:
												return (r = n.value), (a = this.parseRow(r, !1)), e.abrupt("return", a);
											case 14:
												return e.abrupt("return", null);
											case 15:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.iterator = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t,
								n = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (this.columnNamesValidated) {
													e.next = 3;
													break;
												}
												return (e.next = 3), this.setColumnNames();
											case 3:
												return (e.next = 5), this.base.iterator();
											case 5:
												return (
													(t = e.sent),
													this.hasHeader && (t = t.skip(1)),
													e.abrupt(
														"return",
														t.map(function (e) {
															return n.makeDataElement(e);
														})
													)
												);
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.makeDataElement = function (e) {
					for (var t = this.parseRow(e), n = {}, r = {}, a = 0; a < this.fullColumnNames.length; a++) {
						var i = this.fullColumnNames[a],
							o = this.columnConfigs ? this.columnConfigs[i] : null;
						if (!this.configuredColumnsOnly || o) {
							var s = t[a],
								u = null;
							if ("" === s)
								if (o && void 0 !== o.default) u = o.default;
								else {
									if (o && (o.required || o.isLabel))
										throw new Error("Required column " + i + " is empty in this line: " + e);
									u = void 0;
								}
							else {
								var l = Number(s);
								if (isNaN(l)) u = o && "bool" === o.dtype ? this.getBoolean(s) : s;
								else if (o && o.dtype)
									switch (o.dtype) {
										case "float32":
										default:
											u = l;
											break;
										case "int32":
											u = Math.floor(l);
											break;
										case "bool":
											u = this.getBoolean(s);
									}
								else u = l;
							}
							o && o.isLabel ? (r[i] = u) : (n[i] = u);
						}
					}
					return 0 === Object.keys(r).length ? n : { xs: n, ys: r };
				}),
				(n.getBoolean = function (e) {
					return "1" === e || "true" === e.toLowerCase() ? 1 : 0;
				}),
				(n.parseRow = function (e, t) {
					void 0 === t && (t = !0);
					for (var n = [], r = 0, a = e.length, i = HW, o = 0; o < a; o++)
						switch (i) {
							case HW:
								switch (e.charAt(o)) {
									case jW:
										(r = o + 1), (i = KW);
										break;
									case this.delimiter:
										if (((r = o + 1), " " === this.delimiter && this.delimWhitespace)) break;
										n.push(""), (i = HW);
										break;
									default:
										(i = qW), (r = o);
								}
								break;
							case qW:
								if (e.charAt(o) === this.delimiter) n.push(e.substring(r, o)), (i = HW), (r = o + 1);
								break;
							case KW:
								if (e.charAt(o) === jW) i = XW;
								break;
							case XW:
								switch (e.charAt(o)) {
									case this.delimiter:
										n.push(e.substring(r, o - 1)), (i = HW), (r = o + 1);
										break;
									case jW:
										i = KW;
										break;
									default:
										i = YW;
								}
								break;
							case YW:
								if (e.charAt(o) === jW) i = KW;
						}
					if (
						(i === XW ? n.push(e.substring(r, a - 1)) : n.push(e.substring(r)),
						t && n.length !== this.fullColumnNames.length)
					)
						throw new Error(
							"Invalid row in csv file. Should have " +
								this.fullColumnNames.length +
								" elements in a row, but got " +
								n
						);
					return n;
				}),
				t
			);
		})(WW),
		ZW = (function (e) {
			function t(t) {
				var n;
				((n = e.call(this) || this).microphoneConfig = t), (n.isClosed = !1), (n.fftSize = t.fftSize || 1024);
				var r = Math.log2(n.fftSize);
				if (n.fftSize < 0 || r < 4 || r > 14 || !Number.isInteger(r))
					throw new Error(
						"Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got " + n.fftSize
					);
				if (
					((n.numFrames = t.numFramesPerSpectrogram || 43),
					(n.sampleRateHz = t.sampleRateHz),
					(n.columnTruncateLength = t.columnTruncateLength || n.fftSize),
					(n.audioTrackConstraints = t.audioTrackConstraints),
					(n.smoothingTimeConstant = t.smoothingTimeConstant || 0),
					(n.includeSpectrogram = !1 !== t.includeSpectrogram),
					(n.includeWaveform = !0 === t.includeWaveform),
					!n.includeSpectrogram && !n.includeWaveform)
				)
					throw new Error(
						"Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned."
					);
				return n;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return "microphone";
				}),
				(t.create = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(n) {
							var r;
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if ((void 0 === n && (n = {}), xv().get("IS_BROWSER"))) {
												e.next = 3;
												break;
											}
											throw new Error("microphone API is only supported in browser environment.");
										case 3:
											return (r = new t(n)), (e.next = 6), r.start();
										case 6:
											return e.abrupt("return", r);
										case 7:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.start = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(e.prev = 0),
													(e.next = 3),
													navigator.mediaDevices.getUserMedia({
														audio:
															null == this.audioTrackConstraints ||
															this.audioTrackConstraints,
														video: !1,
													})
												);
											case 3:
												(this.stream = e.sent), (e.next = 9);
												break;
											case 6:
												throw (
													((e.prev = 6),
													(e.t0 = e.catch(0)),
													new Error(
														"Error thrown while initializing video stream: " + e.t0.message
													))
												);
											case 9:
												if (this.stream) {
													e.next = 11;
													break;
												}
												throw new Error("Could not obtain audio from microphone.");
											case 11:
												if (
													((t = window.AudioContext || window.webkitAudioContext),
													(this.audioContext = new t()),
													this.sampleRateHz)
												) {
													e.next = 17;
													break;
												}
												(this.sampleRateHz = this.audioContext.sampleRate), (e.next = 19);
												break;
											case 17:
												if (this.audioContext.sampleRate === this.sampleRateHz) {
													e.next = 19;
													break;
												}
												throw new Error(
													"Mismatch in sampling rate: Expected: " +
														this.sampleRateHz +
														"; Actual: " +
														this.audioContext.sampleRate
												);
											case 19:
												return (
													(n = this.audioContext.createMediaStreamSource(this.stream)),
													(this.analyser = this.audioContext.createAnalyser()),
													(this.analyser.fftSize = 2 * this.fftSize),
													(this.analyser.smoothingTimeConstant = this.smoothingTimeConstant),
													n.connect(this.analyser),
													(this.freqData = new Float32Array(this.fftSize)),
													(this.timeData = new Float32Array(this.fftSize)),
													e.abrupt("return")
												);
											case 27:
											case "end":
												return e.stop();
										}
								},
								e,
								this,
								[[0, 6]]
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r, a, i;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (!this.isClosed) {
													e.next = 2;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 2:
												return (e.next = 4), this.getAudioData();
											case 4:
												return (
													(r = e.sent),
													this.includeSpectrogram &&
														((a = this.flattenQueue(r.freqDataQueue)),
														(t = this.getTensorFromAudioDataArray(a, [
															this.numFrames,
															this.columnTruncateLength,
															1,
														]))),
													this.includeWaveform &&
														((i = this.flattenQueue(r.timeDataQueue)),
														(n = this.getTensorFromAudioDataArray(i, [
															this.numFrames * this.fftSize,
															1,
														]))),
													e.abrupt("return", {
														value: { spectrogram: t, waveform: n },
														done: !1,
													})
												);
											case 8:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.capture = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.next();
											case 2:
												return e.abrupt("return", e.sent.value);
											case 3:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.getAudioData = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t,
								n,
								r,
								a = this;
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (
												(t = []),
												(n = []),
												(r = 0),
												e.abrupt(
													"return",
													new Promise(function (e) {
														var i = setInterval(function () {
															a.includeSpectrogram &&
																(a.analyser.getFloatFrequencyData(a.freqData),
																a.freqData[0] === -1 / 0 &&
																	e({ freqDataQueue: t, timeDataQueue: n }),
																t.push(a.freqData.slice(0, a.columnTruncateLength))),
																a.includeWaveform &&
																	(a.analyser.getFloatTimeDomainData(a.timeData),
																	n.push(a.timeData.slice())),
																++r === a.numFrames &&
																	(clearInterval(i),
																	e({ freqDataQueue: t, timeDataQueue: n }));
														}, (a.fftSize / a.sampleRateHz) * 1e3);
													})
												)
											);
										case 4:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.stop = function () {
					this.isClosed ||
						((this.isClosed = !0),
						this.analyser.disconnect(),
						this.audioContext.close(),
						null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop());
				}),
				(n.toArray = function () {
					throw new Error("Can not convert infinite audio stream to array.");
				}),
				(n.getSampleRate = function () {
					return this.sampleRateHz;
				}),
				(n.flattenQueue = function (e) {
					var t = e[0].length,
						n = new Float32Array(e.length * t);
					return (
						e.forEach(function (e, r) {
							return n.set(e, r * t);
						}),
						n
					);
				}),
				(n.getTensorFromAudioDataArray = function (e, t) {
					var n = new Float32Array(zg(t));
					return n.set(e, n.length - e.length), wk(n, t);
				}),
				t
			);
		})(NW),
		QW = (function (e) {
			function t(t, n) {
				var r;
				if (
					(((r = e.call(this) || this).webcamVideoElement = t),
					(r.webcamConfig = n),
					(r.isClosed = !0),
					(r.resize = !1),
					r.needToResize())
				)
					if (
						((r.resize = !0),
						(r.cropSize = [r.webcamConfig.resizeHeight, r.webcamConfig.resizeWidth]),
						(r.cropBoxInd = AE([0], "int32")),
						r.webcamConfig.centerCrop)
					) {
						var a = (1 * r.webcamConfig.resizeWidth) / r.webcamVideoElement.width,
							i = (1 * r.webcamConfig.resizeHeight) / r.webcamVideoElement.height,
							o = (1 - a) / 2,
							s = (1 - i) / 2,
							u = o + a,
							l = i + s;
						r.cropBox = _E([s, o, l, u], [1, 4]);
					} else r.cropBox = _E([0, 0, 1, 1], [1, 4]);
				return r;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return "webcam";
				}),
				(t.create = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(n, r) {
							var a;
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if ((void 0 === r && (r = {}), xv().get("IS_BROWSER"))) {
												e.next = 3;
												break;
											}
											throw new Error("tf.data.webcam is only supported in browser environment.");
										case 3:
											if (n) {
												e.next = 9;
												break;
											}
											if (
												((n = document.createElement("video")), r.resizeWidth && r.resizeHeight)
											) {
												e.next = 7;
												break;
											}
											throw new Error(
												"Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element."
											);
										case 7:
											(n.width = r.resizeWidth), (n.height = r.resizeHeight);
										case 9:
											return (a = new t(n, r)), (e.next = 12), a.start();
										case 12:
											return e.abrupt("return", a);
										case 13:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t, n) {
						return e.apply(this, arguments);
					};
				})()),
				(n.start = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													this.webcamConfig.facingMode &&
														Dg(
															"user" === this.webcamConfig.facingMode ||
																"environment" === this.webcamConfig.facingMode,
															function () {
																return (
																	"Invalid webcam facing mode: " +
																	t.webcamConfig.facingMode +
																	". Please provide 'user' or 'environment'"
																);
															}
														),
													(e.prev = 1),
													(e.next = 4),
													navigator.mediaDevices.getUserMedia({
														video: {
															deviceId: this.webcamConfig.deviceId,
															facingMode: this.webcamConfig.facingMode
																? this.webcamConfig.facingMode
																: "user",
															width: this.webcamVideoElement.width,
															height: this.webcamVideoElement.height,
														},
													})
												);
											case 4:
												(this.stream = e.sent), (e.next = 11);
												break;
											case 7:
												throw (
													((e.prev = 7),
													(e.t0 = e.catch(1)),
													(e.t0.message =
														"Error thrown while initializing video stream: " +
														e.t0.message),
													e.t0)
												);
											case 11:
												if (this.stream) {
													e.next = 13;
													break;
												}
												throw new Error("Could not obtain video from webcam.");
											case 13:
												try {
													this.webcamVideoElement.srcObject = this.stream;
												} catch (e) {
													console.log(e),
														(this.webcamVideoElement.src = window.URL.createObjectURL(
															this.stream
														));
												}
												return (
													this.webcamVideoElement.play(),
													(this.isClosed = !1),
													e.abrupt(
														"return",
														new Promise(function (e) {
															t.webcamVideoElement.onloadedmetadata = function () {
																e();
															};
														})
													)
												);
											case 17:
											case "end":
												return e.stop();
										}
								},
								e,
								this,
								[[1, 7]]
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (!this.isClosed) {
													e.next = 2;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 2:
												(e.prev = 2), (t = aI(this.webcamVideoElement)), (e.next = 9);
												break;
											case 6:
												throw (
													((e.prev = 6),
													(e.t0 = e.catch(2)),
													new Error(
														"Error thrown converting video to pixels: " +
															JSON.stringify(e.t0)
													))
												);
											case 9:
												if (!this.resize) {
													e.next = 22;
													break;
												}
												return (
													(e.prev = 10),
													e.abrupt("return", { value: this.cropAndResizeFrame(t), done: !1 })
												);
											case 14:
												throw (
													((e.prev = 14),
													(e.t1 = e.catch(10)),
													new Error("Error thrown cropping the video: " + e.t1.message))
												);
											case 17:
												return (e.prev = 17), t.dispose(), e.finish(17);
											case 20:
												e.next = 23;
												break;
											case 22:
												return e.abrupt("return", { value: t, done: !1 });
											case 23:
											case "end":
												return e.stop();
										}
								},
								e,
								this,
								[
									[2, 6],
									[10, 14, 17, 20],
								]
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.needToResize = function () {
					return !(
						!this.webcamConfig.resizeWidth ||
						!this.webcamConfig.resizeHeight ||
						(this.webcamVideoElement.width === this.webcamConfig.resizeWidth &&
							this.webcamVideoElement.height === this.webcamConfig.resizeHeight)
					);
				}),
				(n.cropAndResizeFrame = function (e) {
					var t = this;
					return BI(function () {
						var n,
							r = dT(NN(e, "float32"), 0),
							a = (n = pA.cropAndResize(r, t.cropBox, t.cropBoxInd, t.cropSize, "bilinear")).shape;
						return wS(n, a.slice(1));
					});
				}),
				(n.capture = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.next();
											case 2:
												return e.abrupt("return", e.sent.value);
											case 3:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.stop = function () {
					this.stream.getTracks().forEach(function (e) {
						return e.stop();
					});
					try {
						this.webcamVideoElement.srcObject = null;
					} catch (e) {
						console.log(e), (this.webcamVideoElement.src = null);
					}
					this.isClosed = !0;
				}),
				(n.toArray = function () {
					throw new Error("Can not convert infinite video stream to array.");
				}),
				t
			);
		})(NW),
		$W = function () {},
		eU = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			return (
				gg(t, e),
				(t.prototype.split = function (e) {
					return new tU(this, e);
				}),
				t
			);
		})(NW),
		tU = (function (e) {
			function t(t, n) {
				var r;
				return ((r = e.call(this) || this).upstream = t), (r.impl = new nU(t, n)), r;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.impl.summary();
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return e.abrupt("return", this.impl.next());
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(eU),
		nU = (function (e) {
			function t(t, n) {
				var r;
				return ((r = e.call(this) || this).upstream = t), (r.separator = n), (r.carryover = ""), r;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> Split('" + this.separator + "')";
				}),
				(n.pump = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r, a, i;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.upstream.next();
											case 2:
												if (!(t = e.sent).done) {
													e.next = 9;
													break;
												}
												if ("" !== this.carryover) {
													e.next = 6;
													break;
												}
												return e.abrupt("return", !1);
											case 6:
												return (
													this.outputQueue.push(this.carryover),
													(this.carryover = ""),
													e.abrupt("return", !0)
												);
											case 9:
												for (
													(n = t.value.split(this.separator))[0] = this.carryover + n[0],
														r = Ig(n.slice(0, -1));
													!(a = r()).done;

												)
													(i = a.value), this.outputQueue.push(i);
												return (this.carryover = n[n.length - 1]), e.abrupt("return", !0);
											case 14:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(OW),
		rU = (function (e) {
			function t() {
				return e.apply(this, arguments) || this;
			}
			return (
				gg(t, e),
				(t.prototype.decodeUTF8 = function () {
					return new aU(this);
				}),
				t
			);
		})(NW),
		aU = (function (e) {
			function t(t) {
				var n;
				return ((n = e.call(this) || this).upstream = t), (n.impl = new iU(t)), n;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.impl.summary();
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return e.abrupt("return", this.impl.next());
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(eU),
		iU = (function (e) {
			function t(t) {
				var n;
				if ((((n = e.call(this) || this).upstream = t), xv().get("IS_BROWSER")))
					n.decoder = new TextDecoder("utf-8");
				else {
					var r = require("string_decoder").StringDecoder;
					n.decoder = new r("utf8");
				}
				return n;
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return this.upstream.summary() + " -> Utf8";
				}),
				(n.pump = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t, n, r;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (e.next = 2), this.upstream.next();
											case 2:
												if (!(t = e.sent).done) {
													e.next = 7;
													break;
												}
												return e.abrupt("return", !1);
											case 7:
												n = t.value;
											case 8:
												return (
													(r = xv().get("IS_BROWSER")
														? this.decoder.decode(n, { stream: !0 })
														: this.decoder.write(Buffer.from(n.buffer))),
													this.outputQueue.push(r),
													e.abrupt("return", !0)
												);
											case 11:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(OW),
		oU = (function (e) {
			function t(t, n) {
				var r;
				return (
					void 0 === n && (n = {}),
					((r = e.call(this) || this).file = t),
					(r.options = n),
					Dg(
						t instanceof Uint8Array ||
							(!!xv().get("IS_BROWSER") && (t instanceof File || t instanceof Blob)),
						function () {
							return "FileChunkIterator only supports File, Blob and Uint8Array right now.";
						}
					),
					(r.offset = n.offset || 0),
					(r.chunkSize = n.chunkSize || 1048576),
					r
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.summary = function () {
					return "FileChunks " + this.file;
				}),
				(n.next = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t,
								n = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (
													!(
														this.offset >=
														(this.file instanceof Uint8Array
															? this.file.byteLength
															: this.file.size)
													)
												) {
													e.next = 2;
													break;
												}
												return e.abrupt("return", { value: null, done: !0 });
											case 2:
												return (
													(t = new Promise(function (e, t) {
														var r = n.offset + n.chunkSize;
														if (n.file instanceof Uint8Array)
															e(new Uint8Array(n.file.slice(n.offset, r)));
														else {
															var a = new FileReader();
															(a.onload = function (n) {
																var r = a.result;
																if (
																	(r instanceof ArrayBuffer &&
																		(r = new Uint8Array(r)),
																	!(r instanceof Uint8Array))
																)
																	return t(
																		new TypeError(
																			"FileReader returned unknown type."
																		)
																	);
																e(r);
															}),
																(a.onabort = function (e) {
																	return t(new Error("Aborted"));
																}),
																(a.onerror = function (e) {
																	return t(new Error(e.type));
																});
															var i = n.file.slice(n.offset, r);
															a.readAsArrayBuffer(i);
														}
														n.offset = r;
													})),
													(e.next = 5),
													t
												);
											case 5:
												return (e.t0 = e.sent), e.abrupt("return", { value: e.t0, done: !1 });
											case 7:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})(rU);
	function sU(e, t, n) {
		return uU.apply(this, arguments);
	}
	function uU() {
		return (uU = fg(
			regeneratorRuntime.mark(function e(t, n, r) {
				var a, i, o, s;
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return (
									void 0 === n && (n = {}),
									"string" == typeof t ? (a = t) : ((a = t.url), (i = lU(t))),
									(e.next = 4),
									(r || Iw)(a, i)
								);
							case 4:
								if (!(o = e.sent).ok) {
									e.next = 14;
									break;
								}
								return (e.t0 = Uint8Array), (e.next = 9), o.arrayBuffer();
							case 9:
								return (e.t1 = e.sent), (s = new e.t0(e.t1)), e.abrupt("return", new oU(s, n));
							case 14:
								throw new Error(o.statusText);
							case 15:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var lU = function (e) {
		return {
			method: e.method,
			headers: e.headers,
			body: e.body,
			mode: e.mode,
			credentials: e.credentials,
			cache: e.cache,
			redirect: e.redirect,
			referrer: e.referrer,
			integrity: e.integrity,
		};
	};
	function cU(e) {
		return "string" == typeof e && "file://" === e.substr(0, 7);
	}
	var pU = (function (e) {
			function t(t, n) {
				var r;
				return void 0 === n && (n = {}), ((r = e.call(this) || this).input = t), (r.options = n), r;
			}
			return (
				gg(t, e),
				(t.prototype.iterator = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													cU(this.input) &&
														xv().get("IS_NODE") &&
														((t = require("fs")),
														(this.input = t.readFileSync(this.input.substr(7)))),
													e.abrupt("return", new oU(this.input, this.options))
												);
											case 2:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})($W),
		hU = (function (e) {
			function t(t, n) {
				var r;
				return void 0 === n && (n = {}), ((r = e.call(this) || this).url = t), (r.fileOptions = n), r;
			}
			return (
				gg(t, e),
				(t.prototype.iterator = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (!cU(this.url)) {
													e.next = 4;
													break;
												}
												return e.abrupt(
													"return",
													new pU(this.url, this.fileOptions).iterator()
												);
											case 4:
												return e.abrupt("return", sU(this.url, this.fileOptions));
											case 5:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				t
			);
		})($W);
	function fU() {
		return (fU = fg(
			regeneratorRuntime.mark(function e(t, n) {
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return e.abrupt("return", QW.create(t, n));
							case 1:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	function dU() {
		return (dU = fg(
			regeneratorRuntime.mark(function e(t) {
				return regeneratorRuntime.wrap(function (e) {
					for (;;)
						switch ((e.prev = e.next)) {
							case 0:
								return e.abrupt("return", ZW.create(t));
							case 1:
							case "end":
								return e.stop();
						}
				}, e);
			})
		)).apply(this, arguments);
	}
	var mU = "3.15.0",
		gU = {
			__proto__: null,
			array: function (e) {
				return UW(
					fg(
						regeneratorRuntime.mark(function t() {
							return regeneratorRuntime.wrap(function (t) {
								for (;;)
									switch ((t.prev = t.next)) {
										case 0:
											return t.abrupt("return", yW(e));
										case 1:
										case "end":
											return t.stop();
									}
							}, t);
						})
					),
					e.length
				);
			},
			Dataset: WW,
			zip: function (e) {
				if (!fW(e)) throw new Error("The argument to zip() must be an object or array.");
				var t;
				if (Array.isArray(e))
					for (var n = 0; n < e.length; n++) t = null == t ? e[n].size : Math.min(t, e[n].size);
				else if (e instanceof Object) for (var r in e) t = null == t ? e[r].size : Math.min(t, e[r].size);
				return UW(
					fg(
						regeneratorRuntime.mark(function t() {
							var n;
							return regeneratorRuntime.wrap(function (t) {
								for (;;)
									switch ((t.prev = t.next)) {
										case 0:
											return (
												(t.next = 2),
												pW(e, function (e) {
													if (e instanceof WW) return { value: e.iterator(), recurse: !1 };
													if (fW(e)) return { value: null, recurse: !0 };
													throw new Error(
														"Leaves of the structure passed to zip() must be Datasets, not primitives."
													);
												})
											);
										case 2:
											return (n = t.sent), t.abrupt("return", wW(n, kW.SHORTEST));
										case 4:
										case "end":
											return t.stop();
									}
							}, t);
						})
					),
					t
				);
			},
			CSVDataset: JW,
			TextLineDataset: GW,
			csv: function (e, t) {
				return void 0 === t && (t = {}), new JW(new hU(e), t);
			},
			func: function (e) {
				var t = bW(e);
				return UW(
					fg(
						regeneratorRuntime.mark(function e() {
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return e.abrupt("return", t);
										case 1:
										case "end":
											return e.stop();
									}
							}, e);
						})
					)
				);
			},
			generator: function (e) {
				return UW(
					fg(
						regeneratorRuntime.mark(function t() {
							var n;
							return regeneratorRuntime.wrap(function (t) {
								for (;;)
									switch ((t.prev = t.next)) {
										case 0:
											return (t.next = 2), e();
										case 2:
											return (
												(n = t.sent),
												t.abrupt(
													"return",
													bW(function () {
														return n.next();
													})
												)
											);
										case 4:
										case "end":
											return t.stop();
									}
							}, t);
						})
					)
				);
			},
			microphone: function (e) {
				return dU.apply(this, arguments);
			},
			webcam: function (e, t) {
				return fU.apply(this, arguments);
			},
			FileDataSource: pU,
			URLDataSource: hU,
			version_data: mU,
		};
	function vU(e, t) {
		Array.isArray(e) || (e = [e]),
			e.forEach(function (e) {
				null != e &&
					Dg("complex64" !== e.dtype, function () {
						return t + " does not support complex64 tensors in the CPU backend.";
					});
			});
	}
	var yU = UE,
		bU = (function (e) {
			function t() {
				var t;
				return (
					((t = e.call(this) || this).blockSize = 48), (t.firstUse = !0), (t.data = new Sg(kg(t), zI())), t
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.nextDataId = function () {
					return t.nextDataId++;
				}),
				(n.write = function (e, t, n) {
					this.firstUse &&
						((this.firstUse = !1),
						xv().get("IS_NODE") &&
							Ex(
								"\n============================\nHi there ð. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"
							));
					var r = { id: this.nextDataId() };
					return this.data.set(r, { values: e, dtype: n, refCount: 1 }), r;
				}),
				(n.makeTensorInfo = function (e, t, n) {
					var r;
					if ("string" === t && null != n && n.length > 0 && ev(n[0])) {
						var a = n.map(function (e) {
							return Sw(e);
						});
						r = this.write(a, e, t);
					} else r = this.write(n, e, t);
					return { dataId: r, shape: e, dtype: t };
				}),
				(n.refCount = function (e) {
					return this.data.has(e) ? this.data.get(e).refCount : 0;
				}),
				(n.incRef = function (e) {
					this.data.get(e).refCount++;
				}),
				(n.decRef = function (e) {
					this.data.has(e) && this.data.get(e).refCount--;
				}),
				(n.move = function (e, t, n, r, a) {
					this.data.set(e, { values: t, dtype: r, refCount: a });
				}),
				(n.numDataIds = function () {
					return this.data.numDataIds();
				}),
				(n.read = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return e.abrupt("return", this.readSync(t));
											case 1:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.readSync = function (e) {
					var t = this.data.get(e),
						n = t.dtype,
						r = t.complexTensorInfos;
					return "complex64" === n
						? BA(this.readSync(r.real.dataId), this.readSync(r.imag.dataId))
						: this.data.get(e).values;
				}),
				(n.bufferSync = function (e) {
					var t = this.readSync(e.dataId),
						n = t;
					if ("string" === e.dtype)
						try {
							n = t.map(function (e) {
								return Tw(e);
							});
						} catch (e) {
							throw new Error("Failed to decode encoded string bytes into utf-8");
						}
					return kN(e.shape, e.dtype, n);
				}),
				(n.makeOutput = function (e, t, n) {
					var r = this.write(e, t, n);
					return zI().makeTensorFromDataId(r, t, n, this);
				}),
				(n.disposeData = function (e, t) {
					if ((void 0 === t && (t = !1), this.data.has(e))) {
						if ((this.data.get(e).refCount--, !t && this.data.get(e).refCount > 0)) return !1;
						var n = this.data.get(e).complexTensorInfos;
						null != n && (this.disposeData(n.real.dataId, !0), this.disposeData(n.imag.dataId, !0)),
							this.data.delete(e);
					}
					return !0;
				}),
				(n.disposeIntermediateTensorInfo = function (e) {
					this.disposeData(e.dataId);
				}),
				(n.time = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r;
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											return (n = Nw()), t(), (r = Nw() - n), e.abrupt("return", { kernelMs: r });
										case 4:
										case "end":
											return e.stop();
									}
							}, e);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.memory = function () {
					return {
						unreliable: !0,
						reasons: [
							"The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.",
						],
					};
				}),
				(n.where = function (e) {
					vU([e], "where");
					var t = this.readSync(e.dataId);
					return yU(e.shape, t);
				}),
				(n.dispose = function () {}),
				(n.floatPrecision = function () {
					return 32;
				}),
				(n.epsilon = function () {
					return e.prototype.epsilon.call(this);
				}),
				t
			);
		})(Tg);
	function xU(e) {
		for (var t = new Float32Array(e.length), n = 0; n < e.length; ++n) t[n] = Math.abs(e[n]);
		return t;
	}
	bU.nextDataId = 0;
	var wU = {
		kernelName: Nv,
		backendName: "cpu",
		kernelFunc: function (e) {
			var t = e.inputs.x,
				n = e.backend;
			vU(t, "abs");
			var r = new Float32Array(zg(t.shape));
			return (r = xU(n.data.get(t.dataId).values)), n.makeOutput(r, t.shape, t.dtype);
		},
	};
	function kU(e) {
		return function (t, n, r, a, i) {
			var o = JN(t, n),
				s = o.length,
				u = ov(o),
				l = qg(i, zg(o)),
				c = t.length,
				p = n.length,
				h = ov(t),
				f = ov(n),
				d = XN(t, o),
				m = XN(n, o);
			if (d.length + m.length === 0)
				for (var g = 0; g < l.length; ++g) l[g] = e(r[g % r.length], a[g % a.length]);
			else
				for (
					var v = function (t) {
							var n = dv(t, s, u),
								i = n.slice(-c);
							d.forEach(function (e) {
								return (i[e] = 0);
							});
							var o = fv(i, c, h),
								g = n.slice(-p);
							m.forEach(function (e) {
								return (g[e] = 0);
							});
							var v = fv(g, p, f);
							l[t] = e(r[o], a[v]);
						},
						y = 0;
					y < l.length;
					++y
				)
					v(y);
			return [l, o];
		};
	}
	function NU(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.real,
			a = t.imag,
			i = n.data.get(r.dataId).values,
			o = n.data.get(a.dataId).values,
			s = n.makeTensorInfo(r.shape, "complex64");
		return (
			(n.data.get(s.dataId).complexTensorInfos = {
				real: n.makeTensorInfo(r.shape, "float32", i),
				imag: n.makeTensorInfo(a.shape, "float32", o),
			}),
			s
		);
	}
	var IU = { kernelName: Yv, backendName: "cpu", kernelFunc: NU };
	function SU(e, t, n) {
		if ((void 0 === n && (n = "float32"), "complex64" === n))
			return NU({ inputs: { real: SU(e, t, "float32"), imag: SU(e, t, "float32") }, backend: e });
		var r = cv(zg(t), n);
		return e.makeTensorInfo(t, n, r);
	}
	function TU(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.x;
		return n.incRef(r.dataId), { dataId: r.dataId, shape: r.shape, dtype: r.dtype };
	}
	var CU = { kernelName: zy, backendName: "cpu", kernelFunc: TU };
	function EU(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.input,
			a = n.data.get(r.dataId).complexTensorInfos.real,
			i = n.data.get(a.dataId).values;
		return n.makeTensorInfo(a.shape, a.dtype, i);
	}
	var RU = { kernelName: Eb, backendName: "cpu", kernelFunc: EU };
	function AU(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = r.dtype;
		if ("complex64" === i) {
			if ("complex64" === a.dtype) return TU({ inputs: { x: a }, backend: n });
			var o = SU(n, a.shape, a.dtype),
				s = AU({ inputs: { x: a }, backend: n, attrs: { dtype: "float32" } }),
				u = NU({ inputs: { real: s, imag: o }, backend: n });
			return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u;
		}
		if ("complex64" === a.dtype) {
			var l = EU({ inputs: { input: a }, backend: n }),
				c = AU({ inputs: { x: l }, backend: n, attrs: { dtype: i } });
			return n.disposeIntermediateTensorInfo(l), c;
		}
		if (!Jg(a.dtype, i)) {
			var p = TU({ inputs: { x: a }, backend: n });
			return { dataId: p.dataId, shape: p.shape, dtype: i };
		}
		if ("int32" === i) {
			var h = n.data.get(a.dataId).values,
				f = Int32Array.from(h);
			return n.makeTensorInfo(a.shape, "int32", f);
		}
		if ("bool" === i) {
			var d = n.data.get(a.dataId).values,
				m = kw([0], a.dtype),
				g = kU(function (e, t) {
					return e !== t ? 1 : 0;
				})(a.shape, [], d, m, "bool"),
				v = g[0],
				y = g[1];
			return n.makeTensorInfo(y, "bool", v);
		}
		throw new Error("Error in Cast: failed to cast " + a.dtype + " to " + i);
	}
	var _U = { kernelName: qv, backendName: "cpu", kernelFunc: AU };
	function FU(e, t, n, r) {
		return null == n
			? function (n) {
					var a = n.inputs,
						i = n.backend,
						o = a.a,
						s = a.b,
						u = i;
					vU([o, s], e);
					var l = u.data.get(o.dataId).values,
						c = u.data.get(s.dataId).values,
						p = "string" === o.dtype ? f_(l) : l,
						h = "string" === o.dtype ? f_(c) : c,
						f = r || o.dtype,
						d = t(o.shape, s.shape, p, h, f),
						m = d[0],
						g = d[1];
					return u.makeTensorInfo(g, f, m);
			  }
			: function (e) {
					var a = e.inputs,
						i = e.backend,
						o = a.a,
						s = a.b,
						u = i;
					if ("complex64" === o.dtype || "complex64" === s.dtype) {
						var l = AU({ inputs: { x: o }, backend: u, attrs: { dtype: "complex64" } }),
							c = u.data.get(l.dataId),
							p = c.complexTensorInfos.real,
							h = c.complexTensorInfos.imag,
							f = u.data.get(p.dataId).values,
							d = u.data.get(h.dataId).values,
							m = AU({ inputs: { x: s }, backend: u, attrs: { dtype: "complex64" } }),
							g = u.data.get(m.dataId),
							v = g.complexTensorInfos.real,
							y = g.complexTensorInfos.imag,
							b = u.data.get(v.dataId).values,
							x = u.data.get(y.dataId).values,
							w = n(o.shape, s.shape, f, d, b, x),
							k = w[0],
							N = w[1],
							I = w[2],
							S = u.makeTensorInfo(I, "float32", k),
							T = u.makeTensorInfo(I, "float32", N),
							C = NU({ inputs: { real: S, imag: T }, backend: u });
						return (
							u.disposeIntermediateTensorInfo(l),
							u.disposeIntermediateTensorInfo(m),
							u.disposeIntermediateTensorInfo(S),
							u.disposeIntermediateTensorInfo(T),
							C
						);
					}
					var E = u.data.get(o.dataId).values,
						R = u.data.get(s.dataId).values,
						A = r || o.dtype,
						_ = t(o.shape, s.shape, E, R, A),
						F = _[0],
						D = _[1];
					return u.makeTensorInfo(D, A, F);
			  };
	}
	function DU(e) {
		return function (t, n, r, a, i, o) {
			var s = JN(t, n),
				u = zg(s),
				l = s.length,
				c = ov(s),
				p = qg("float32", u),
				h = qg("float32", u),
				f = XN(t, s),
				d = XN(n, s),
				m = BA(r, a),
				g = BA(i, o),
				v = t.length,
				y = ov(t),
				b = n.length,
				x = ov(n);
			if (f.length + d.length === 0)
				for (var w = 0; w < p.length; w++) {
					var k = w % m.length,
						N = w % g.length,
						I = e(m[2 * k], m[2 * k + 1], g[2 * N], g[2 * N + 1]);
					(p[w] = I.real), (h[w] = I.imag);
				}
			else
				for (
					var S = function (t) {
							var n = dv(t, l, c),
								r = n.slice(-v);
							f.forEach(function (e) {
								return (r[e] = 0);
							});
							var a = fv(r, v, y),
								i = n.slice(-b);
							d.forEach(function (e) {
								return (i[e] = 0);
							});
							var o = fv(i, b, x),
								s = e(m[2 * a], m[2 * a + 1], g[2 * o], g[2 * o + 1]);
							(p[t] = s.real), (h[t] = s.imag);
						},
						T = 0;
					T < p.length;
					T++
				)
					S(T);
			return [p, h, s];
		};
	}
	var OU = kU(function (e, t) {
			return e + t;
		}),
		MU = DU(function (e, t, n, r) {
			return { real: e + n, imag: t + r };
		}),
		LU = FU(Tv, OU, MU),
		zU = { kernelName: Tv, backendName: "cpu", kernelFunc: LU };
	function PU(e, t, n, r, a) {
		for (var i = zg(r), o = cv(a, n), s = 0; s < e.length; s++) {
			var u = e[s];
			if (u < 0) throw new Error("Input x must be non-negative!");
			u >= a || (o[u] += i > 0 ? t[s] : 1);
		}
		return o;
	}
	function BU(e, t, n, r) {
		void 0 === r && (r = !1);
		for (var a = e.shape[0], i = e.shape[1], o = kN([a, n], t.dtype), s = 0; s < a; s++)
			for (var u = 0; u < i; u++) {
				var l = e.get(s, u);
				if (l < 0) throw new Error("Input x must be non-negative!");
				l >= n ||
					(r
						? o.set(1, s, l)
						: t.size > 0
						? o.set(o.get(s, l) + t.get(s, u), s, l)
						: o.set(o.get(s, l) + 1, s, l));
			}
		return o;
	}
	function WU(e) {
		return function (t, n, r) {
			for (var a = qg(n, t.length), i = 0; i < t.length; ++i) a[i] = e(t[i], r);
			return a;
		};
	}
	function UU(e, t, n) {
		return function (r) {
			var a = r.inputs,
				i = r.attrs,
				o = r.backend,
				s = a.x;
			if ((vU(s, e), "string" === s.dtype || "string" === n))
				throw new Error("unaryKernelFunc does not support string input/output");
			for (
				var u = o, l = u.data.get(s.dataId).values, c = zg(s.shape), p = n || s.dtype, h = Kg(p, c), f = 0;
				f < c;
				++f
			)
				h[f] = t(l[f], i);
			return u.makeTensorInfo(s.shape, p, h);
		};
	}
	function VU(e, t, n) {
		return function (r) {
			var a = r.inputs,
				i = r.attrs,
				o = r.backend,
				s = a.x;
			if ((vU(s, e), "string" === s.dtype || "string" === n))
				throw new Error("unaryKernelFunc does not support string input/output");
			var u = o,
				l = u.data.get(s.dataId).values,
				c = n || s.dtype,
				p = t(l, c, i);
			return u.makeTensorInfo(s.shape, c, p);
		};
	}
	var GU = WU(function (e) {
			return Math.ceil(e);
		}),
		jU = VU(Kv, GU),
		HU = { kernelName: Kv, backendName: "cpu", kernelFunc: jU };
	function qU(e, t, n, r) {
		var a = Kg(n, zg(t));
		if (r && "string" !== n) {
			var i = 0;
			e.forEach(function (e) {
				var t = zg(e.shape);
				a.set(e.vals, i), (i += t);
			});
		} else {
			var o = 0;
			e.forEach(function (e) {
				for (var r = "string" === n ? f_(e.vals) : e.vals, i = 0, s = 0; s < e.shape[0]; ++s)
					for (var u = s * t[1] + o, l = 0; l < e.shape[1]; ++l) a[u + l] = r[i++];
				o += e.shape[1];
			});
		}
		return a;
	}
	var KU = kU(function (e, t) {
			return e === t ? 1 : 0;
		}),
		XU = FU(Ny, KU, null, "bool"),
		YU = { kernelName: Ny, backendName: "cpu", kernelFunc: XU },
		JU = WU(function (e) {
			return Math.exp(e);
		}),
		ZU = VU(Iy, JU, "float32"),
		QU = { kernelName: Iy, backendName: "cpu", kernelFunc: ZU },
		$U = WU(function (e) {
			return Math.expm1(e);
		}),
		eV = VU(Ty, $U),
		tV = { kernelName: Ty, backendName: "cpu", kernelFunc: eV },
		nV = WU(function (e) {
			return Math.floor(e);
		}),
		rV = VU(Ay, nV),
		aV = { kernelName: Ay, backendName: "cpu", kernelFunc: rV };
	function iV(e, t, n, r, a, i, o, s, u) {
		for (var l = kN([r, i], n), c = 0; c < r; c++) {
			for (var p = [], h = 0, f = 0; f < a; f++) {
				var d = e[c * a + f];
				(h += d * o[f]), p.push(d);
			}
			if (h < 0 || h >= u / i) throw new Error("Invalid indices: " + p + " does not index into " + s);
			for (var m = 0; m < i; m++) l.values[c * i + m] = t.get.apply(t, t.indexToLoc(h * i + m));
		}
		return l;
	}
	function oV(e, t, n) {
		for (var r = kN(n, e.dtype), a = 0; a < r.size; ++a) {
			var i = r.indexToLoc(a).slice(),
				o = i[0],
				s = i[2],
				u = t.locToIndex([o, s]);
			i[2] = t.values[u];
			var l = e.locToIndex(i);
			0 <= l && l < e.values.length && (r.values[a] = e.values[l]);
		}
		return r;
	}
	var sV = kU(function (e, t) {
			return e > t ? 1 : 0;
		}),
		uV = FU(My, sV, null, "bool"),
		lV = { kernelName: My, backendName: "cpu", kernelFunc: uV },
		cV = kU(function (e, t) {
			return e >= t ? 1 : 0;
		}),
		pV = FU(Ly, cV, null, "bool"),
		hV = { kernelName: Ly, backendName: "cpu", kernelFunc: pV },
		fV = kU(function (e, t) {
			return e < t ? 1 : 0;
		}),
		dV = FU(jy, fV, null, "bool"),
		mV = { kernelName: jy, backendName: "cpu", kernelFunc: dV },
		gV = kU(function (e, t) {
			return e <= t ? 1 : 0;
		}),
		vV = FU(Hy, gV, null, "bool"),
		yV = { kernelName: Hy, backendName: "cpu", kernelFunc: vV };
	function bV(e, t, n) {
		var r = (t - e) / (n - 1),
			a = cv(n, "float32");
		a[0] = e;
		for (var i = 1; i < a.length; i++) a[i] = a[i - 1] + r;
		return a;
	}
	var xV = WU(function (e) {
			return Math.log(e);
		}),
		wV = VU(Ky, xV),
		kV = { kernelName: Ky, backendName: "cpu", kernelFunc: wV };
	function NV(e, t, n, r) {
		for (var a = qg(r, zg(n)), i = 0; i < a.length; ++i) {
			for (var o = i * t, s = e[o], u = 0; u < t; ++u) {
				var l = e[o + u];
				(Number.isNaN(l) || l > s) && (s = l);
			}
			a[i] = s;
		}
		return a;
	}
	var IV = kU(function (e, t) {
			return Math.max(e, t);
		}),
		SV = FU(nb, IV),
		TV = { kernelName: nb, backendName: "cpu", kernelFunc: SV },
		CV = kU(function (e, t) {
			return Math.min(e, t);
		}),
		EV = FU(cb, CV),
		RV = { kernelName: cb, backendName: "cpu", kernelFunc: EV },
		AV = kU(function (e, t) {
			return e * t;
		}),
		_V = DU(function (e, t, n, r) {
			return { real: e * n - t * r, imag: e * r + t * n };
		}),
		FV = FU(db, AV, _V),
		DV = { kernelName: db, backendName: "cpu", kernelFunc: FV };
	function OV(e, t, n) {
		var r = ww(-1, n);
		return AV([], t, r, e, n);
	}
	var MV = {
			kernelName: mb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.x;
				vU(r, "neg");
				var a = OV(n.data.get(r.dataId).values, r.shape, r.dtype),
					i = a[0],
					o = a[1];
				return n.makeTensorInfo(o, r.dtype, i);
			},
		},
		LV = kU(function (e, t) {
			return e !== t ? 1 : 0;
		}),
		zV = FU(gb, LV, null, "bool"),
		PV = { kernelName: gb, backendName: "cpu", kernelFunc: zV };
	function BV(e, t, n, r, a) {
		for (var i = t.length, o = zg(t), s = ov(t), u = ov(a), l = qg(n, zg(a)), c = 0; c < o; ++c) {
			for (var p = dv(c, i, s), h = new Array(p.length), f = 0; f < h.length; f++) h[f] = p[r[f]];
			l[fv(h, i, u)] = e[c];
		}
		return l;
	}
	function WV(e) {
		var t = e.inputs,
			n = e.attrs,
			r = e.backend,
			a = t.x,
			i = n.perm;
		vU(a, "transpose");
		for (var o = a.shape.length, s = new Array(o), u = 0; u < s.length; u++) s[u] = a.shape[i[u]];
		var l = BV(r.data.get(a.dataId).values, a.shape, a.dtype, i, s);
		return { dataId: r.write(l, s, a.dtype), shape: s, dtype: a.dtype };
	}
	var UV = { kernelName: vx, backendName: "cpu", kernelFunc: WV };
	function VV(e, t, n, r) {
		for (
			var a = qT(e, r), i = a[0], o = a[1], s = Kw(t, "int32"), u = cv(zg(i), s), l = zg(o), c = 0;
			c < u.length;
			++c
		) {
			for (var p = c * l, h = 1, f = 0; f < l; ++f) h *= n[p + f];
			u[c] = h;
		}
		return { outVals: u, outShape: i, outDtype: s };
	}
	var GV = {
		kernelName: Tb,
		backendName: "cpu",
		kernelFunc: function (e) {
			var t = e.inputs,
				n = e.backend,
				r = e.attrs,
				a = t.x,
				i = r.axis,
				o = r.keepDims;
			vU(a, "prod");
			var s = a.shape.length,
				u = jg(i, a.shape),
				l = YT(u, s),
				c = u,
				p = a,
				h = [];
			null != l &&
				((p = WV({ inputs: { x: a }, backend: n, attrs: { perm: l } })), h.push(p), (c = ZT(c.length, s)));
			var f = n.data.get(p.dataId).values,
				d = VV(p.shape, p.dtype, f, c),
				m = d.outVals,
				g = d.outShape,
				v = d.outDtype,
				y = g;
			return (
				o && (y = KT(g, u)),
				h.forEach(function (e) {
					return n.disposeIntermediateTensorInfo(e);
				}),
				n.makeTensorInfo(y, v, m)
			);
		},
	};
	function jV(e, t, n, r) {
		if (e === t || (e < t && n < 0) || (t < e && n > 1)) return cv(0, r);
		var a = cv(Math.abs(Math.ceil((t - e) / n)), r);
		t < e && 1 === n && (n = -1), (a[0] = e);
		for (var i = 1; i < a.length; i++) a[i] = a[i - 1] + n;
		return a;
	}
	var HV = WU(function (e) {
			return 1 / Math.sqrt(e);
		}),
		qV = VU(Bb, HV),
		KV = { kernelName: Bb, backendName: "cpu", kernelFunc: qV },
		XV = WU(function (e) {
			return 1 / (1 + Math.exp(-e));
		}),
		YV = UU(Kb, function (e) {
			return 1 / (1 + Math.exp(-e));
		}),
		JV = { kernelName: Kb, backendName: "cpu", kernelFunc: YV };
	function ZV(e, t, n, r, a) {
		var i = kI(r, t, n),
			o = zg(n),
			s = ov(r);
		if (i) {
			var u = NI(t, s);
			return "string" === a ? e.slice(u, u + o) : e.subarray(u, u + o);
		}
		for (var l = kN(r, a, "string" === a ? f_(e) : e), c = kN(n, a), p = 0; p < c.size; ++p) {
			var h = c.indexToLoc(p),
				f = h.map(function (e, n) {
					return e + t[n];
				});
			c.set.apply(c, [l.get.apply(l, f)].concat(h));
		}
		return "string" === a ? d_(c.values) : c.values;
	}
	function QV(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = r.begin,
			o = r.size;
		vU(a, "slice");
		var s = II(a, i, o),
			u = s[0],
			l = s[1];
		hI(a, u, l);
		var c = ZV(n.data.get(a.dataId).values, u, l, a.shape, a.dtype);
		return n.makeTensorInfo(l, a.dtype, c);
	}
	var $V = { kernelName: Gb, backendName: "cpu", kernelFunc: QV };
	function eG(e, t, n, r, a, i, o) {
		var s = t[0],
			u = i[0],
			l = new Array(u),
			c = new Array(s),
			p = t[1];
		if (0 === u) {
			if (0 !== s) throw new Error(t_(s));
			return [Kg(n, 0), [0, p], Kg(a, 0), l, c];
		}
		for (var h = !0, f = 0, d = new Array(u).fill(0), m = 0; m < s; ++m) {
			var g = e[m * p];
			if (g < 0) throw new Error(n_(m, g));
			if (g >= u) throw new Error(r_(m, g, u));
			++d[g], (h = h && g >= f), (f = g);
		}
		for (var v = !0, y = 0; y < u; ++y) {
			var b = 0 === d[y];
			(l[y] = b), (v = v && !b), (d[y] = Math.max(d[y], 1)), y > 0 && (d[y] += d[y - 1]);
		}
		if (v && h) {
			for (var x = e, w = r, k = 0; k < s; ++k) c[k] = k;
			return [x, [s, p], w, l, c];
		}
		for (var N = d[u - 1], I = Kg(n, N * p), S = Kg(a, N), T = new Array(u).fill(0), C = 0; C < s; ++C) {
			var E = e[C * p],
				R = T[E],
				A = (0 === E ? 0 : d[E - 1]) + R;
			T[E]++;
			for (var _ = 0; _ < p; ++_) I[A * p + _] = e[C * p + _];
			(S[A] = r[C]), (c[C] = A);
		}
		for (var F = 0; F < u; ++F)
			if (0 === T[F]) {
				var D = 0 === F ? 0 : d[F - 1];
				I[D * p + 0] = F;
				for (var O = 1; O < p; ++O) I[D * p + O] = 0;
				S[D] = o;
			}
		return [I, [N, p], S, l, c];
	}
	function tG(e, t, n, r, a) {
		for (var i = zg(r), o = t[0], s = a.length, u = [], l = 1, c = -1, p = 0; p < s; ++p) {
			var h = a[p];
			if (-1 === h) {
				if (-1 !== c) throw new Error(a_(c, p));
				(c = p), u.push(1);
			} else {
				if (h < 0) throw new Error(i_(p, h));
				(l *= h), u.push(h);
			}
		}
		if (-1 !== c) {
			if (l <= 0)
				throw new Error(
					"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"
				);
			var f = Math.trunc(i / l);
			if (l * f !== i) throw new Error(o_(r, u));
			u[c] = f;
		}
		if (zg(u) !== i) throw new Error(s_(r, u));
		var d = r.length,
			m = [];
		if (d > 0) {
			m[d - 1] = 1;
			for (var g = d - 2; g >= 0; --g) m[g] = m[g + 1] * r[g + 1];
		}
		var v = [];
		if (s > 0) {
			v[s - 1] = 1;
			for (var y = s - 2; y >= 0; --y) v[y] = v[y + 1] * u[y + 1];
		}
		for (var b = Kg(n, o * s), x = 0; x < o; ++x) {
			for (var w = 0, k = 0; k < d; ++k) w += e[x * d + k] * m[k];
			for (var N = 0; N < s; ++N) (b[x * s + N] = Math.trunc(w / v[N])), (w %= v[N]);
		}
		return [b, [o, s], u];
	}
	function nG(e, t, n, r, a, i, o) {
		void 0 === i && (i = !1), void 0 === o && (o = 0);
		var s = r.length,
			u = [t[0], e.length / t[0]],
			l = u[1],
			c = s > 0 ? a[s - 1] + 1 : 0;
		if (c < 0) throw new Error("segment ids must be >= 0");
		var p = t.slice();
		p[0] = c;
		var h = Kg(
			n,
			p.reduce(function (e, t) {
				return e * t;
			}, 1)
		);
		if (0 === s) return c > 0 && h.fill(o), [h, p];
		if (c <= 0) throw new Error("segment ids must be >= 0");
		for (var f = 0, d = 1, m = 0, g = a[f]; ; ) {
			var v = 0;
			if (d < s) {
				if (g === (v = a[d])) {
					++d;
					continue;
				}
				if (g >= v) throw new Error("segment ids are not increasing");
			}
			if (g < 0 || g >= c) throw new Error(u_(g, c));
			g > m && h.fill(o, m * l, g * l);
			for (var y = f; y < d; ++y) {
				var b = r[y];
				if (b < 0 || b >= u[0]) throw new Error(l_(y, r[y], u[0]));
				for (var x = 0; x < l; x++) h[g * l + x] += e[b * l + x];
			}
			if (i) for (var w = 0; w < l; w++) h[g * l + w] /= d - f;
			if (((f = d), (m = g + 1), (g = v), ++d > s)) break;
		}
		return m < c && h.fill(o, m * l, c * l), [h, p];
	}
	var rG = WU(function (e) {
			return Math.sqrt(e);
		}),
		aG = UU(Yb, function (e) {
			return Math.sqrt(e);
		}),
		iG = { kernelName: Yb, backendName: "cpu", kernelFunc: aG },
		oG = kU(function (e, t) {
			var n = e - t;
			return n * n;
		}),
		sG = FU(ix, oG),
		uG = { kernelName: ix, backendName: "cpu", kernelFunc: sG };
	function lG(e, t, n, r) {
		for (var a = kN(e, t.dtype), i = 0; i < a.size; i++) {
			for (var o = a.indexToLoc(i), s = new Array(o.length), u = 0; u < s.length; u++) s[u] = o[u] * n[u] + r[u];
			a.set.apply(a, [t.get.apply(t, s)].concat(o));
		}
		return a;
	}
	var cG = (function () {
		function e(e, t, n, r, a, i) {
			(this.separator = Sw(e)),
				(this.nGramWidths = t),
				(this.leftPad = Sw(n)),
				(this.rightPad = Sw(r)),
				(this.padWidth = a),
				(this.preserveShort = i);
		}
		var t = e.prototype;
		return (
			(t.getPadWidth = function (e) {
				return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
			}),
			(t.getNumNGrams = function (e, t) {
				var n = this.getPadWidth(t);
				return Math.max(0, e + 2 * n - t + 1);
			}),
			(t.createNGrams = function (e, t, n, r, a, i) {
				for (
					var o = this,
						s = function (s) {
							var u = o.getPadWidth(i),
								l = Math.max(0, u - s),
								c = Math.max(0, u - (a - (s + 1))),
								p = i - (l + c),
								h = t + (l > 0 ? 0 : s - u),
								f = 0;
							f += l * o.leftPad.length;
							for (var d = 0; d < p; ++d) f += e[h + d].length;
							(f += c * o.rightPad.length),
								(f += (l + c + p - 1) * o.separator.length),
								(n[r + s] = new Uint8Array(f));
							for (
								var m = n[r + s],
									g = 0,
									v = function (e) {
										return e.forEach(function (e) {
											return (m[g++] = e);
										});
									},
									y = 0;
								y < l;
								++y
							)
								v(o.leftPad), v(o.separator);
							for (var b = 0; b < p - 1; ++b) v(e[h + b]), v(o.separator);
							if (p > 0) {
								v(e[h + p - 1]);
								for (var x = 0; x < c; ++x) v(o.separator), v(o.rightPad);
							} else {
								for (var w = 0; w < c - 1; ++w) v(o.rightPad), v(o.separator);
								v(o.rightPad);
							}
						},
						u = 0;
					u < a;
					++u
				)
					s(u);
			}),
			(t.compute = function (e, t) {
				var n = this,
					r = e.length,
					a = t.length;
				if (a > 0) {
					var i = t[0];
					if (0 !== i) throw new Error("First split value must be 0, got " + i);
					for (var o = 1; o < a; ++o) {
						var s = t[o] >= i;
						if (!(s = s && t[o] <= r))
							throw new Error("Invalid split value " + t[o] + ", must be in [" + i + ", " + r + "]");
						i = t[o];
					}
					if (i !== r) throw new Error("Last split value must be data size. Expected " + r + ", got " + i);
				}
				var u = a - 1,
					l = Kg("int32", a);
				if (0 === r || 0 === a) {
					for (var c = new Array(r), p = 0; p <= u; ++p) l[p] = 0;
					return [c, l];
				}
				l[0] = 0;
				for (
					var h = function (e) {
							var r = t[e] - t[e - 1],
								a = 0;
							n.nGramWidths.forEach(function (e) {
								a += n.getNumNGrams(r, e);
							}),
								n.preserveShort && r > 0 && 0 === a && (a = 1),
								(l[e] = l[e - 1] + a);
						},
						f = 1;
					f <= u;
					++f
				)
					h(f);
				for (
					var d = new Array(l[u]),
						m = function (r) {
							var a = t[r],
								i = l[r];
							if (
								(n.nGramWidths.forEach(function (o) {
									var s = t[r + 1] - t[r],
										u = n.getNumNGrams(s, o);
									n.createNGrams(e, a, d, i, u, o), (i += u);
								}),
								n.preserveShort && i === l[r])
							) {
								var o = t[r + 1] - t[r];
								if (0 === o) return "continue";
								var s = o + 2 * n.padWidth;
								n.createNGrams(e, a, d, i, 1, s);
							}
						},
						g = 0;
					g < u;
					++g
				)
					m(g);
				return [d, l];
			}),
			e
		);
	})();
	function pG(e, t, n, r, a, i, o, s) {
		return new cG(n, r, a, i, o, s).compute(e, t);
	}
	function hG(e, t, n, r) {
		if (e.length)
			if (0 !== t.length)
				if (1 !== t.length) {
					for (var a = 0, i = 0; i < e.length + 1; i++)
						if (i === e.length || -1 !== t.indexOf(e[i])) {
							var o = e.subarray(a, i);
							(n && 0 === o.length) || r.push(o), (a = i + 1);
						}
				} else {
					for (var s = t[0], u = e.indexOf(s); -1 !== u; ) {
						var l = e.subarray(0, u);
						(n && 0 === l.length) || r.push(l), (u = (e = e.subarray(u + 1)).indexOf(s));
					}
					(n && 0 === e.length) || r.push(e);
				}
			else for (var c = 0; c < e.length; ++c) r.push(e.subarray(c, c + 1));
	}
	function fG(e, t, n) {
		for (var r = e.length, a = [], i = 0, o = 0, s = new Array(r), u = 0; u < r; ++u) {
			var l = a.length;
			hG(e[u], t, n, a);
			var c = a.length - l;
			(s[u] = c), (i += c), (o = Math.max(o, c));
		}
		for (var p = Kg("int32", 2 * i), h = new Array(i), f = [r, o], d = 0, m = 0; m < r; ++m)
			for (var g = 0; g < s[m]; ++g) (p[2 * d] = m), (p[2 * d + 1] = g), (h[d] = a[d]), ++d;
		return [p, h, f];
	}
	function dG(e, t) {
		for (var n = Kg("int32", e.length), r = 0; r < e.length; ++r) n[r] = xw(e[r]).modulo(t).getLowBitsUnsigned();
		return n;
	}
	var mG = kU(function (e, t) {
			return e - t;
		}),
		gG = DU(function (e, t, n, r) {
			return { real: e - n, imag: t - r };
		}),
		vG = FU(px, mG, gG),
		yG = { kernelName: px, backendName: "cpu", kernelFunc: vG };
	function bG(e, t) {
		for (var n = new Array(e.rank), r = 0; r < n.length; r++) n[r] = e.shape[r] * t[r];
		for (var a = kN(n, e.dtype), i = 0; i < a.values.length; ++i) {
			for (var o = a.indexToLoc(i), s = new Array(e.rank), u = 0; u < s.length; u++) s[u] = o[u] % e.shape[u];
			var l = e.locToIndex(s);
			a.values[i] = e.values[l];
		}
		return a;
	}
	var xG = function (e, t) {
		var n = t.value - e.value;
		return 0 === n ? e.index - t.index : n;
	};
	function wG(e, t, n, r) {
		for (void 0 === n && (n = 0), void 0 === r && (r = e.length - 1); r > n; ) {
			if (r - n > 600) {
				var a = r - n + 1,
					i = t - n + 1,
					o = Math.log(a),
					s = 0.5 * Math.exp((2 * o) / 3),
					u = 0.5 * Math.sqrt((o * s * (a - s)) / a) * Math.sign(i - a / 2);
				wG(
					e,
					t,
					Math.max(n, Math.floor(t - (i * s) / a + u)),
					Math.min(r, Math.floor(t + ((a - i) * s) / a + u))
				);
			}
			var l = e[t],
				c = n,
				p = r;
			for (_g(e, n, t), xG(e[r], l) > 0 && _g(e, n, r); c < p; ) {
				for (_g(e, c, p), c++, p--; xG(e[c], l) < 0; ) c += 1;
				for (; xG(e[p], l) > 0; ) p -= 1;
			}
			0 === xG(e[n], l) ? _g(e, n, p) : _g(e, (p += 1), r), p <= t && (n = p + 1), t <= p && (r = p - 1);
		}
	}
	function kG(e, t, n, r, a) {
		for (
			var i = t[t.length - 1],
				o = e.length / i,
				s = i,
				u = qg(n, o * r),
				l = qg("int32", o * r),
				c = function (t) {
					var n = t * s,
						i = e.subarray(n, n + s),
						o = new Array(i.length);
					i.forEach(function (e, t) {
						return (o[t] = { value: e, index: t });
					}),
						r < o.length && (wG(o, r), (o = o.slice(0, r))),
						a && o.sort(xG);
					for (var c = t * r, p = u.subarray(c, c + r), h = l.subarray(c, c + r), f = 0; f < r; f++)
						(p[f] = o[f].value), (h[f] = o[f].index);
				},
				p = 0;
			p < o;
			p++
		)
			c(p);
		var h = t.slice();
		return (h[h.length - 1] = r), [kN(h, n, u), kN(h, "int32", l)];
	}
	function NG(e, t, n, r) {
		for (var a = jg(t, n)[0], i = [1, n[0], 1], o = 0; o < a; o++) i[0] *= n[o];
		i[1] = n[a];
		for (var s = a + 1; s < n.length; s++) i[2] *= n[s];
		for (
			var u = {}, l = new Int32Array(n[a]), c = new Mw(i, r, e), p = [], h = 1 === i[0] && 1 === i[2], f = 0;
			f < n[a];
			f++
		) {
			var d = void 0;
			if (h) d = e[f].toString();
			else {
				for (var m = [], g = 0; g < i[0]; g++) for (var v = 0; v < i[2]; v++) m.push(c.get(g, f, v));
				d = m.join(",");
			}
			if (void 0 !== u[d]) l[f] = u[d];
			else {
				var y = Object.keys(u).length;
				(u[d] = y), (l[f] = y), p.push(f);
			}
		}
		var b = i.slice();
		b[1] = Object.keys(u).length;
		var x = new Mw(b, r);
		p.forEach(function (e, t) {
			for (var n = 0; n < i[0]; n++) for (var r = 0; r < i[2]; r++) x.set(c.get(n, e, r), n, t, r);
		});
		var w = n.slice();
		return (w[a] = b[1]), { outputValues: x.values, outputShape: w, indices: l };
	}
	VI(
		"cpu",
		function () {
			return new bU();
		},
		1
	);
	var IG = UU(xy, function (e) {
			return e >= 0 ? e : Math.exp(e) - 1;
		}),
		SG = { kernelName: xy, backendName: "cpu", kernelFunc: IG };
	function TG(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = r.alpha;
		vU([a], "leakyRelu");
		for (var o = zg(a.shape), s = n.data.get(a.dataId).values, u = qg("float32", o), l = 0; l < s.length; l++)
			u[l] = s[l] < 0 ? i * s[l] : s[l];
		return n.makeTensorInfo(a.shape, "float32", u);
	}
	var CG = { kernelName: Gy, backendName: "cpu", kernelFunc: TG },
		EG = kU(function (e, t) {
			return e < 0 ? t * e : e;
		});
	function RG(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.x,
			a = t.alpha;
		vU([r, a], "prelu");
		var i = n.data.get(r.dataId).values,
			o = n.data.get(a.dataId).values,
			s = EG(r.shape, a.shape, i, o, "float32"),
			u = s[0],
			l = s[1];
		return n.makeTensorInfo(l, "float32", u);
	}
	var AG = { kernelName: Sb, backendName: "cpu", kernelFunc: RG },
		_G = UU(Ab, function (e) {
			return Math.max(0, e);
		}),
		FG = { kernelName: Ab, backendName: "cpu", kernelFunc: _G },
		DG = UU(Lb, function (e) {
			return Math.min(Math.max(0, e), 6);
		}),
		OG = { kernelName: Lb, backendName: "cpu", kernelFunc: DG };
	function MG(e, t, n, r, a) {
		if ("linear" === n) return TU({ inputs: { x: t }, backend: e });
		if ("relu" === n) return _G({ inputs: { x: t }, backend: e });
		if ("elu" === n) return IG({ inputs: { x: t }, backend: e });
		if ("relu6" === n) return DG({ inputs: { x: t }, backend: e });
		if ("prelu" === n) return RG({ inputs: { x: t, alpha: r }, backend: e });
		if ("leakyrelu" === n) return TG({ inputs: { x: t }, backend: e, attrs: { alpha: a } });
		if ("sigmoid" === n) return YV({ inputs: { x: t }, backend: e });
		throw new Error("Activation " + n + " has not been implemented for the CPU backend.");
	}
	function LG(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = r.shape,
			o = zg(a.shape),
			s = Gg(i, o),
			u = zg(s);
		Dg(o === u, function () {
			return (
				"The new shape (" +
				s +
				") has " +
				u +
				" elements and the old shape (" +
				a.shape +
				") has " +
				o +
				" elements. The new shape and old shape must have the same number of elements."
			);
		}),
			n.incRef(a.dataId);
		var l = n.data.get(a.dataId);
		if (null != l.complexTensorInfos) {
			var c = l.complexTensorInfos.real,
				p = l.complexTensorInfos.imag;
			(c.shape = s), (p.shape = s);
		}
		return { dataId: a.dataId, shape: s, dtype: a.dtype };
	}
	var zG = { kernelName: _b, backendName: "cpu", kernelFunc: LG };
	function PG(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.a,
			i = t.b,
			o = r.transposeA,
			s = r.transposeB;
		vU([a, i], "matMul");
		var u = a.shape.length,
			l = i.shape.length,
			c = o ? a.shape[u - 2] : a.shape[u - 1],
			p = s ? i.shape[l - 1] : i.shape[l - 2],
			h = o ? a.shape[u - 1] : a.shape[u - 2],
			f = s ? i.shape[l - 2] : i.shape[l - 1],
			d = a.shape.slice(0, -2),
			m = i.shape.slice(0, -2),
			g = zg(d),
			v = zg(m),
			y = JN(a.shape.slice(0, -2), i.shape.slice(0, -2)).concat([h, f]);
		Dg(c === p, function () {
			return (
				"Error in matMul: inner shapes (" +
				c +
				") and (" +
				p +
				") of Tensors with shapes " +
				a.shape +
				" and " +
				i.shape +
				" and transposeA=" +
				o +
				" and transposeB=" +
				s +
				" must match."
			);
		});
		for (
			var b = s ? [v, f, p] : [v, p, f],
				x = LG({ inputs: { x: a }, backend: n, attrs: { shape: o ? [g, c, h] : [g, h, c] } }),
				w = LG({ inputs: { x: i }, backend: n, attrs: { shape: b } }),
				k = o ? x.shape[1] : x.shape[2],
				N = o ? x.shape[2] : x.shape[1],
				I = s ? w.shape[1] : w.shape[2],
				S = Math.max(g, v),
				T = n.data.get(x.dataId).values,
				C = n.data.get(w.dataId).values,
				E = ov(x.shape),
				R = ov(w.shape),
				A = o ? [E[0], 1, E[1]] : [E[0], E[1], 1],
				_ = A[0],
				F = A[1],
				D = A[2],
				O = s ? [1, R[1], R[0]] : [R[1], 1, R[0]],
				M = O[0],
				L = O[1],
				z = O[2],
				P = N * I,
				B = kN([S, N, I], x.dtype),
				W = B.values,
				U = n.blockSize,
				V = 0;
			V < S;
			V++
		)
			for (var G = 0; G < N; G += U)
				for (var j = 0; j < I; j += U)
					for (var H = 0; H < k; H += U)
						for (
							var q = Math.min(G + U, N), K = Math.min(j + U, I), X = Math.min(H + U, k), Y = G;
							Y < q;
							Y++
						)
							for (var J = j; J < K; J++) {
								for (var Z = 0, Q = H; Q < X; Q++) {
									var $ = Math.min(V, g - 1) * _,
										ee = Math.min(V, v - 1) * z;
									Z += T[$ + Y * F + Q * D] * C[Q * M + J * L + ee];
								}
								W[V * P + (Y * I + J)] += Z;
							}
		return (
			n.disposeIntermediateTensorInfo(x),
			n.disposeIntermediateTensorInfo(w),
			n.makeTensorInfo(y, B.dtype, B.values)
		);
	}
	var BG = { kernelName: Uv, backendName: "cpu", kernelFunc: PG },
		WG = {
			kernelName: Sx,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t,
					n,
					r,
					a = e.inputs,
					i = e.backend,
					o = e.attrs,
					s = a.a,
					u = a.b,
					l = a.bias,
					c = a.preluActivationWeights,
					p = o.transposeA,
					h = o.transposeB,
					f = o.activation,
					d = o.leakyreluAlpha,
					m = [];
				(t = PG({ inputs: { a: s, b: u }, attrs: { transposeA: p, transposeB: h }, backend: i })),
					l && ((n = LU({ inputs: { a: t, b: l }, backend: i })), m.push(t), (t = n)),
					f && ((r = MG(i, t, f, c, d)), m.push(t), (t = r));
				for (var g = 0, v = m; g < v.length; g++) {
					var y = v[g];
					i.disposeIntermediateTensorInfo(y);
				}
				return t;
			},
		},
		UG = UU(Iv, function (e) {
			return Math.acos(e);
		}),
		VG = { kernelName: Iv, backendName: "cpu", kernelFunc: UG },
		GG = UU(Sv, function (e) {
			return Math.acosh(e);
		}),
		jG = { kernelName: Sv, backendName: "cpu", kernelFunc: GG },
		HG = {
			kernelName: Cv,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t;
				vU(t, "addN");
				for (
					var a = r.map(function (e) {
							return n.data.get(e.dataId).values;
						}),
						i = kN(r[0].shape, r[0].dtype),
						o = i.values,
						s = 0;
					s < r.length;
					s++
				)
					for (var u = a[s], l = 0; l < o.length; l++) o[l] += u[l];
				return n.makeTensorInfo(i.shape, i.dtype, i.values);
			},
		},
		qG = {
			kernelName: Ev,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.keepDims;
				vU(a, "all");
				var s = jg(i, a.shape),
					u = s,
					l = YT(u, a.shape.length),
					c = a;
				null != l &&
					((c = WV({ inputs: { x: a }, backend: n, attrs: { perm: l } })),
					(u = ZT(u.length, a.shape.length))),
					XT("all", u, c.shape.length);
				for (
					var p = qT(c.shape, u),
						h = p[0],
						f = zg(p[1]),
						d = cv(zg(h), c.dtype),
						m = n.data.get(c.dataId).values,
						g = 0;
					g < d.length;
					++g
				) {
					for (var v = g * f, y = m[v], b = 0; b < f; ++b) {
						var x = m[v + b];
						y = y && x;
					}
					d[g] = y;
				}
				null != l && n.disposeIntermediateTensorInfo(c);
				var w = n.makeTensorInfo(h, c.dtype, d);
				if (o) {
					var k = LG({ inputs: { x: w }, backend: n, attrs: { shape: KT(h, s) } });
					return n.disposeIntermediateTensorInfo(w), k;
				}
				return w;
			},
		},
		KG = {
			kernelName: Rv,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.keepDims;
				vU(a, "any");
				var s = jg(i, a.shape),
					u = s,
					l = YT(u, a.shape.length),
					c = a;
				null != l &&
					((c = WV({ inputs: { x: a }, backend: n, attrs: { perm: l } })),
					(u = ZT(u.length, a.shape.length))),
					XT("any", u, c.shape.length);
				for (
					var p = qT(c.shape, u),
						h = p[0],
						f = zg(p[1]),
						d = cv(zg(h), c.dtype),
						m = n.data.get(c.dataId).values,
						g = 0;
					g < d.length;
					++g
				) {
					for (var v = g * f, y = m[v], b = 0; b < f; ++b) {
						var x = m[v + b];
						y = y || x;
					}
					d[g] = y;
				}
				null != l && n.disposeIntermediateTensorInfo(c);
				var w = n.makeTensorInfo(h, c.dtype, d);
				if (o) {
					var k = LG({ inputs: { x: w }, backend: n, attrs: { shape: KT(h, s) } });
					return n.disposeIntermediateTensorInfo(w), k;
				}
				return w;
			},
		},
		XG = {
			kernelName: Av,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis;
				vU(a, "argMax");
				var o = jg(i, a.shape),
					s = YT(o, a.shape.length),
					u = a,
					l = [];
				null != s &&
					((u = WV({ inputs: { x: a }, backend: n, attrs: { perm: s } })),
					l.push(u),
					(o = ZT(o.length, u.shape.length))),
					XT("argMax", (o = [o[0]]), u.shape.length);
				for (
					var c = qT(u.shape, o),
						p = c[0],
						h = c[1],
						f = cv(zg(p), "int32"),
						d = zg(h),
						m = n.data.get(u.dataId).values,
						g = 0;
					g < f.length;
					++g
				) {
					for (var v = g * d, y = m[v], b = 0, x = 0; x < d; ++x) {
						var w = m[v + x];
						w > y && ((y = w), (b = x));
					}
					f[g] = b;
				}
				return (
					l.forEach(function (e) {
						return n.disposeIntermediateTensorInfo(e);
					}),
					n.makeTensorInfo(p, "int32", f)
				);
			},
		},
		YG = {
			kernelName: _v,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis;
				vU(a, "argMin");
				var o = jg(i, a.shape),
					s = YT(o, a.shape.length),
					u = a,
					l = [];
				null != s &&
					((u = WV({ inputs: { x: a }, backend: n, attrs: { perm: s } })),
					l.push(u),
					(o = ZT(o.length, u.shape.length))),
					XT("argMin", (o = [o[0]]), u.shape.length);
				for (
					var c = qT(u.shape, o),
						p = c[0],
						h = c[1],
						f = cv(zg(p), "int32"),
						d = zg(h),
						m = n.data.get(u.dataId).values,
						g = 0;
					g < f.length;
					++g
				) {
					for (var v = g * d, y = m[v], b = 0, x = 0; x < d; ++x) {
						var w = m[v + x];
						w < y && ((y = w), (b = x));
					}
					f[g] = b;
				}
				return (
					l.forEach(function (e) {
						return n.disposeIntermediateTensorInfo(e);
					}),
					n.makeTensorInfo(p, "int32", f)
				);
			},
		},
		JG = UU(Fv, function (e) {
			return Math.asin(e);
		}),
		ZG = { kernelName: Fv, backendName: "cpu", kernelFunc: JG },
		QG = UU(Dv, function (e) {
			return Math.asinh(e);
		}),
		$G = { kernelName: Dv, backendName: "cpu", kernelFunc: QG },
		ej = UU(Ov, function (e) {
			return Math.atan(e);
		}),
		tj = { kernelName: Ov, backendName: "cpu", kernelFunc: ej },
		nj = kU(function (e, t) {
			return Math.atan2(e, t);
		}),
		rj = FU(Lv, nj),
		aj = { kernelName: Lv, backendName: "cpu", kernelFunc: rj },
		ij = UU(Mv, function (e) {
			return Math.atanh(e);
		}),
		oj = { kernelName: Mv, backendName: "cpu", kernelFunc: ij };
	function sj(e, t, n, r, a, i) {
		for (
			var o = a.strideHeight,
				s = a.strideWidth,
				u = a.dilationHeight,
				l = a.dilationWidth,
				c = a.effectiveFilterHeight,
				p = a.effectiveFilterWidth,
				h = a.padInfo.top,
				f = a.padInfo.left,
				d = "max" === i ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
				m = kN(a.outShape, n),
				g = m.values,
				v = a.outShape[1] * a.outShape[2] * a.outShape[3],
				y = a.outShape[2] * a.outShape[3],
				b = a.outShape[3],
				x = 0;
			x < a.batchSize;
			++x
		)
			for (var w = x * v, k = x * r[0], N = 0; N < a.inChannels; ++N)
				for (var I = 0; I < a.outHeight; ++I)
					for (
						var S = I * o - h, T = Math.max(0, S), C = Math.min(a.inHeight, c + S), E = w + I * y, R = 0;
						R < a.outWidth;
						++R
					) {
						for (
							var A = R * s - f,
								_ = Math.max(0, A),
								F = Math.min(a.inWidth, p + A),
								D = d,
								O = 0,
								M = 0,
								L = T;
							L < C;
							L += u
						) {
							for (var z = k + L * r[1], P = _; P < F; P += l) {
								var B = e[z + P * r[2] + N];
								"max" === i && B > D ? (D = B) : "avg" === i && ((O += B), M++);
							}
							if (isNaN(D)) break;
						}
						g[E + R * b + N] = "avg" === i ? O / M : D;
					}
		return m;
	}
	function uj(e, t, n, r, a, i) {
		void 0 === a && (a = !1), void 0 === i && (i = !1);
		for (
			var o = kN(r.outShape, "int32"),
				s = r.strideHeight,
				u = r.strideWidth,
				l = r.dilationHeight,
				c = r.dilationWidth,
				p = r.effectiveFilterHeight,
				h = r.effectiveFilterWidth,
				f = r.padInfo.top,
				d = r.padInfo.left,
				m = kN(t, n, e),
				g = 0;
			g < r.batchSize;
			++g
		)
			for (var v = 0; v < r.inChannels; ++v)
				for (var y = 0; y < r.outHeight; ++y) {
					for (var b = y * s - f, x = b; x < 0; ) x += l;
					for (var w = Math.min(r.inHeight, p + b), k = 0; k < r.outWidth; ++k) {
						for (var N = k * u - d, I = N; I < 0; ) I += c;
						for (
							var S = Math.min(r.inWidth, h + N), T = Number.NEGATIVE_INFINITY, C = -1, E = x;
							E < w;
							E += l
						)
							for (var R = E - b, A = I; A < S; A += c) {
								var _ = A - N,
									F = m.get(g, E, A, v);
								F > T &&
									((T = F),
									(C = a
										? i
											? ((g * r.inHeight + E) * r.inWidth + A) * r.inChannels + v
											: (E * r.inWidth + A) * r.inChannels + v
										: R * h + _));
							}
						o.set(C, g, y, k, v);
					}
				}
		return o;
	}
	function lj(e, t, n, r, a, i) {
		for (
			var o = a.strideDepth,
				s = a.strideHeight,
				u = a.strideWidth,
				l = a.dilationDepth,
				c = a.dilationHeight,
				p = a.dilationWidth,
				h = a.effectiveFilterDepth,
				f = a.effectiveFilterHeight,
				d = a.effectiveFilterWidth,
				m = a.padInfo.front,
				g = a.padInfo.top,
				v = a.padInfo.left,
				y = "max" === i ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
				b = kN(a.outShape, n),
				x = b.values,
				w = a.outShape[1] * a.outShape[2] * a.outShape[3] * a.outShape[4],
				k = a.outShape[2] * a.outShape[3] * a.outShape[4],
				N = a.outShape[3] * a.outShape[4],
				I = a.outShape[4],
				S = 0;
			S < a.batchSize;
			++S
		)
			for (var T = S * w, C = S * r[0], E = 0; E < a.inChannels; ++E)
				for (var R = 0; R < a.outDepth; ++R) {
					for (var A = R * o - m, _ = A; _ < 0; ) _ += l;
					for (var F = Math.min(a.inDepth, h + A), D = T + R * k, O = 0; O < a.outHeight; ++O) {
						for (var M = O * s - g, L = M; L < 0; ) L += c;
						for (var z = Math.min(a.inHeight, f + M), P = D + O * N, B = 0; B < a.outWidth; ++B) {
							for (var W = B * u - v, U = W; U < 0; ) U += p;
							for (
								var V = Math.min(a.inWidth, d + W), G = P + B * I, j = y, H = 0, q = 0, K = _;
								K < F;
								K += l
							) {
								for (var X = C + K * r[1], Y = L; Y < z; Y += c) {
									for (var J = X + Y * r[2], Z = U; Z < V; Z += p) {
										var Q = e[J + Z * r[3] + E];
										if (("max" === i && Q > j ? (j = Q) : "avg" === i && ((H += Q), q++), isNaN(j)))
											break;
									}
									if (isNaN(j)) break;
								}
								if (isNaN(j)) break;
							}
							x[G + E] = "avg" === i ? H / q : j;
						}
					}
				}
		return b;
	}
	var cj = {
			kernelName: zv,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x;
				vU(a, "avgPool");
				var i = r.filterSize,
					o = r.strides,
					s = r.pad,
					u = r.dimRoundingMode;
				Dg(yS(o, 1), function () {
					return (
						"Error in avgPool: Either strides or dilations must be 1. Got strides " +
						o +
						" and dilations '1'"
					);
				});
				var l,
					c = uS(a.shape, i, o, 1, s, u);
				if (1 === c.filterWidth && 1 === c.filterHeight && Pg(c.inShape, c.outShape))
					l = TU({ inputs: { x: a }, backend: n });
				else {
					var p = n.data.get(a.dataId).values,
						h = ov(a.shape),
						f = sj(p, a.shape, a.dtype, h, c, "avg");
					l = n.makeTensorInfo(c.outShape, a.dtype, f.values);
				}
				return l;
			},
		},
		pj = {
			kernelName: Bv,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.filterSize,
					o = r.strides,
					s = r.pad,
					u = r.dimRoundingMode,
					l = r.dataFormat;
				vU(a, "avgPool3d");
				var c = lS(a.shape, i, o, 1, s, u, l),
					p = lj(n.data.get(a.dataId).values, a.shape, a.dtype, ov(a.shape), c, "avg");
				return n.makeTensorInfo(p.shape, "float32", p.values);
			},
		},
		hj = {
			kernelName: Wv,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.input,
					o = r.filterSize,
					s = r.strides,
					u = r.pad,
					l = r.dimRoundingMode;
				vU([a, i], "avgPool3DGrad");
				for (
					var c = lS(i.shape, o, s, 1, u, l),
						p = c.strideDepth,
						h = c.strideHeight,
						f = c.strideWidth,
						d = c.filterDepth,
						m = c.filterHeight,
						g = c.filterWidth,
						v = c.dilationDepth,
						y = c.dilationHeight,
						b = c.dilationWidth,
						x = c.effectiveFilterDepth,
						w = c.effectiveFilterHeight,
						k = c.effectiveFilterWidth,
						N = x - 1 - c.padInfo.front,
						I = k - 1 - c.padInfo.left,
						S = w - 1 - c.padInfo.top,
						T = kN(i.shape, "float32"),
						C = 1 / (d * m * g),
						E = n.bufferSync(a),
						R = 0;
					R < c.batchSize;
					++R
				)
					for (var A = 0; A < c.inChannels; ++A)
						for (var _ = 0; _ < c.inDepth; ++_)
							for (var F = 0; F < c.inHeight; ++F)
								for (var D = 0; D < c.inWidth; ++D) {
									for (var O = _ - N, M = F - S, L = D - I, z = 0, P = 0; P < x; P += v) {
										var B = (O + P) / p;
										if (!(B < 0 || B >= c.outDepth || Math.floor(B) !== B))
											for (var W = 0; W < w; W += y) {
												var U = (M + W) / h;
												if (!(U < 0 || U >= c.outHeight || Math.floor(U) !== U))
													for (var V = 0; V < k; V += b) {
														var G = (L + V) / f;
														G < 0 ||
															G >= c.outWidth ||
															Math.floor(G) !== G ||
															(z += E.get(R, B, U, G, A));
													}
											}
									}
									T.set(z * C, R, _, F, D, A);
								}
				return n.makeTensorInfo(T.shape, T.dtype, T.values);
			},
		},
		fj = {
			kernelName: Pv,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.input,
					o = i;
				vU([a, i], "avgPoolGrad");
				for (
					var s = r.filterSize,
						u = r.strides,
						l = r.pad,
						c = uS(o.shape, s, u, 1, l),
						p = c.strideHeight,
						h = c.strideWidth,
						f = c.filterHeight,
						d = c.filterWidth,
						m = c.dilationHeight,
						g = c.dilationWidth,
						v = c.effectiveFilterHeight,
						y = c.effectiveFilterWidth,
						b = y - 1 - c.padInfo.left,
						x = v - 1 - c.padInfo.top,
						w = kN(o.shape, "float32"),
						k = 1 / (f * d),
						N = n.data.get(a.dataId).values,
						I = kN(a.shape, "float32", N),
						S = 0;
					S < c.batchSize;
					++S
				)
					for (var T = 0; T < c.inChannels; ++T)
						for (var C = 0; C < c.inHeight; ++C)
							for (var E = 0; E < c.inWidth; ++E) {
								for (var R = C - x, A = E - b, _ = 0, F = 0; F < v; F += m) {
									var D = (R + F) / p;
									if (!(D < 0 || D >= c.outHeight || Math.floor(D) !== D))
										for (var O = 0; O < y; O += g) {
											var M = (A + O) / h;
											M < 0 || M >= c.outWidth || Math.floor(M) !== M || (_ += I.get(S, D, M, T));
										}
								}
								w.set(_ * k, S, C, E, T);
							}
				return n.makeTensorInfo(w.shape, w.dtype, w.values);
			},
		},
		dj = {
			kernelName: Fy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.scale,
					o = t.offset,
					s = t.mean,
					u = t.variance;
				Dg(s.shape.length === u.shape.length, function () {
					return "Batch normalization gradient requires mean and variance to have equal ranks.";
				}),
					Dg(null == o || s.shape.length === o.shape.length, function () {
						return "Batch normalization gradient requires mean and offset to have equal ranks.";
					}),
					Dg(null == i || s.shape.length === i.shape.length, function () {
						return "Batch normalization gradient requires mean and scale to have equal ranks.";
					}),
					vU([a, s, u, i, o], "batchNorm");
				var l = r.varianceEpsilon;
				null == l && (l = 0.001);
				for (
					var c = n.data.get(a.dataId).values,
						p = n.data.get(s.dataId).values,
						h = n.data.get(u.dataId).values,
						f = i ? n.data.get(i.dataId).values : new Float32Array([1]),
						d = o ? n.data.get(o.dataId).values : new Float32Array([0]),
						m = new Float32Array(c.length),
						g = d.length,
						v = f.length,
						y = h.length,
						b = p.length,
						x = 0,
						w = 0,
						k = 0,
						N = 0,
						I = 0;
					I < c.length;
					++I
				)
					(m[I] = d[x++] + ((c[I] - p[w++]) * f[k++]) / Math.sqrt(h[N++] + l)),
						x >= g && (x = 0),
						w >= b && (w = 0),
						k >= v && (k = 0),
						N >= y && (N = 0);
				return n.makeTensorInfo(a.shape, a.dtype, m);
			},
		},
		mj = {
			kernelName: Vv,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.blockShape,
					o = r.crops;
				vU([a], "batchToSpaceND");
				var s = i.reduce(function (e, t) {
						return e * t;
					}),
					u = FA(a.shape, i, s),
					l = DA(u.length, i.length),
					c = OA(a.shape, i, s),
					p = MA(o, i.length),
					h = LA(c, o, i.length),
					f = LG({ inputs: { x: a }, backend: n, attrs: { shape: u } }),
					d = WV({ inputs: { x: f }, backend: n, attrs: { perm: l } }),
					m = LG({ inputs: { x: d }, backend: n, attrs: { shape: c } }),
					g = QV({ inputs: { x: m }, backend: n, attrs: { begin: p, size: h } });
				return (
					n.disposeIntermediateTensorInfo(f),
					n.disposeIntermediateTensorInfo(d),
					n.disposeIntermediateTensorInfo(m),
					g
				);
			},
		},
		gj = {
			kernelName: Gv,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.weights,
					o = r.size,
					s = PU(n.data.get(a.dataId).values, n.data.get(i.dataId).values, i.dtype, i.shape, o);
				return n.makeTensorInfo([o], i.dtype, s);
			},
		},
		vj = {
			kernelName: Hv,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.s0,
					a = t.s1,
					i = n.data.get(r.dataId).values,
					o = n.data.get(a.dataId).values,
					s = JN(Array.from(i), Array.from(o));
				return n.makeTensorInfo([s.length], "int32", Int32Array.from(s));
			},
		},
		yj = UU(Xv, function (e, t) {
			var n = t;
			return e > n.clipValueMax ? n.clipValueMax : e < n.clipValueMin ? n.clipValueMin : e;
		}),
		bj = { kernelName: Xv, backendName: "cpu", kernelFunc: yj },
		xj = {
			kernelName: Jv,
			backendName: "cpu",
			kernelFunc: function (e) {
				for (
					var t = e.inputs.x,
						n = e.backend,
						r = new Float32Array(zg(t.shape)),
						a = n.data.get(t.dataId),
						i = a.complexTensorInfos.real,
						o = a.complexTensorInfos.imag,
						s = n.data.get(i.dataId).values,
						u = n.data.get(o.dataId).values,
						l = 0;
					l < s.length;
					l++
				) {
					var c = s[l],
						p = u[l];
					r[l] = Math.hypot(c, p);
				}
				return n.makeOutput(r, t.shape, "float32");
			},
		};
	function wj(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.input,
			a = n.data.get(r.dataId).complexTensorInfos.imag,
			i = n.data.get(a.dataId).values;
		return n.makeTensorInfo(a.shape, a.dtype, i);
	}
	var kj = { kernelName: By, backendName: "cpu", kernelFunc: wj };
	function Nj(e) {
		var t = e.inputs,
			n = e.backend,
			r = jg(e.attrs.axis, t[0].shape)[0],
			a = RA(
				t.map(function (e) {
					return e.shape;
				}),
				r
			);
		if (0 === zg(a)) return n.makeTensorInfo(a, t[0].dtype, []);
		var i = t.filter(function (e) {
			return zg(e.shape) > 0;
		});
		if (1 === i.length) return TU({ inputs: { x: i[0] }, backend: n });
		if (
			(EA(
				i.map(function (e) {
					return e.shape;
				}),
				r
			),
			"complex64" === i[0].dtype)
		) {
			var o = i.map(function (e) {
					return EU({ inputs: { input: e }, backend: n });
				}),
				s = i.map(function (e) {
					return wj({ inputs: { input: e }, backend: n });
				}),
				u = Nj({ inputs: o, backend: n, attrs: { axis: r } }),
				l = Nj({ inputs: s, backend: n, attrs: { axis: r } }),
				c = NU({ inputs: { real: u, imag: l }, backend: n });
			return (
				o.forEach(function (e) {
					return n.disposeIntermediateTensorInfo(e);
				}),
				s.forEach(function (e) {
					return n.disposeIntermediateTensorInfo(e);
				}),
				n.disposeIntermediateTensorInfo(u),
				n.disposeIntermediateTensorInfo(l),
				c
			);
		}
		var p = i.map(function (e) {
				var t = zg(e.shape.slice(r));
				return LG({ inputs: { x: e }, backend: n, attrs: { shape: [-1, t] } });
			}),
			h = p.map(function (e) {
				return { vals: n.data.get(e.dataId).values, shape: e.shape };
			});
		a = RA(
			p.map(function (e) {
				return e.shape;
			}),
			1
		);
		var f = 1 === p[0].shape[0],
			d = qU(h, a, t[0].dtype, f),
			m = RA(
				i.map(function (e) {
					return e.shape;
				}),
				r
			),
			g = n.makeTensorInfo(m, t[0].dtype, d);
		return (
			p.forEach(function (e) {
				return n.disposeIntermediateTensorInfo(e);
			}),
			g
		);
	}
	var Ij = { kernelName: Zv, backendName: "cpu", kernelFunc: Nj };
	function Sj(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = t.filter,
			o = r.strides,
			s = r.pad,
			u = r.dataFormat,
			l = r.dilations,
			c = r.dimRoundingMode;
		vU([a, i], "conv2d");
		for (
			var p = bS(u),
				h = cS(a.shape, i.shape, o, l, s, c, !1, p),
				f = h.filterHeight,
				d = h.filterWidth,
				m = h.dilationHeight,
				g = h.dilationWidth,
				v = h.padInfo.left,
				y = h.padInfo.top,
				b = "channelsLast" === h.dataFormat,
				x = new Mw(h.outShape, a.dtype),
				w = ov(a.shape),
				k = ov(i.shape),
				N = w[0],
				I = b ? w[1] : w[2],
				S = b ? w[2] : 1,
				T = b ? 1 : w[1],
				C = x.strides[0],
				E = b ? x.strides[1] : x.strides[2],
				R = b ? x.strides[2] : 1,
				A = b ? 1 : x.strides[1],
				_ = n.data.get(a.dataId).values,
				F = n.data.get(i.dataId).values,
				D = x.values,
				O = 0;
			O < h.batchSize;
			++O
		)
			for (var M = O * N, L = O * C, z = 0; z < h.outHeight; ++z)
				for (var P = L + z * E, B = z * h.strideHeight - y, W = 0; W < f; ++W) {
					var U = B + W * m;
					if (!(U < 0 || U >= h.inHeight))
						for (var V = W * k[0], G = M + U * I, j = 0; j < h.outWidth; ++j)
							for (var H = P + j * R, q = j * h.strideWidth - v, K = 0; K < d; ++K) {
								var X = q + K * g;
								if (!(X < 0 || X >= h.inWidth))
									for (var Y = G + X * S, J = V + K * k[1], Z = 0; Z < h.inChannels; ++Z) {
										for (var Q = _[Y + Z * T], $ = 0; $ < h.outChannels; ++$)
											D[H + $ * A] += Q * F[J + $];
										J += h.outChannels;
									}
							}
				}
		return n.makeTensorInfo(x.shape, x.dtype, D);
	}
	var Tj = { kernelName: Qv, backendName: "cpu", kernelFunc: Sj },
		Cj = {
			kernelName: $v,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.dy,
					o = r.strides,
					s = r.pad,
					u = r.dataFormat,
					l = r.dimRoundingMode,
					c = r.filterShape;
				vU([a, i], "conv2dBackpropFilter");
				for (
					var p = bS(u),
						h = cS(a.shape, c, o, 1, s, l, !1, p),
						f = h.strideHeight,
						d = h.strideWidth,
						m = h.filterHeight,
						g = h.filterWidth,
						v = "channelsLast" === h.dataFormat,
						y = new Mw(h.filterShape, "float32"),
						b = h.padInfo.left,
						x = h.padInfo.top,
						w = n.data.get(a.dataId).values,
						k = n.data.get(i.dataId).values,
						N = new Mw(a.shape, a.dtype, w),
						I = new Mw(i.shape, i.dtype, k),
						S = 0;
					S < m;
					++S
				)
					for (
						var T = Math.max(0, Math.ceil((x - S) / f)),
							C = Math.min(h.outHeight, (h.inHeight + x - S) / f),
							E = 0;
						E < g;
						++E
					)
						for (
							var R = Math.max(0, Math.ceil((b - E) / d)),
								A = Math.min(h.outWidth, (h.inWidth + b - E) / d),
								_ = 0;
							_ < h.inChannels;
							++_
						)
							for (var F = 0; F < h.outChannels; ++F) {
								for (var D = 0, O = 0; O < h.batchSize; ++O)
									for (var M = T; M < C; ++M)
										for (var L = S + M * f - x, z = R; z < A; ++z) {
											var P = E + z * d - b;
											D += v
												? N.get(O, L, P, _) * I.get(O, M, z, F)
												: N.get(O, _, L, P) * I.get(O, F, M, z);
										}
								y.set(D, S, E, _, F);
							}
				return n.makeTensorInfo(y.shape, y.dtype, y.values);
			},
		},
		Ej = {
			kernelName: ey,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.filter,
					o = r.inputShape,
					s = r.strides,
					u = r.pad,
					l = r.dataFormat,
					c = r.dimRoundingMode;
				vU([a, i], "conv2dBackpropInput");
				var p = ov(i.shape),
					h = ov(a.shape),
					f = bS(l),
					d = cS(o, i.shape, s, 1, u, c, !1, f),
					m = new Mw(d.inShape, "float32"),
					g = m.values,
					v = n.data.get(a.dataId).values,
					y = n.data.get(i.dataId).values,
					b = p[0],
					x = p[1],
					w = p[2],
					k = d.batchSize,
					N = d.filterHeight,
					I = d.filterWidth,
					S = d.inChannels,
					T = d.inHeight,
					C = d.inWidth,
					E = d.outChannels,
					R = d.outHeight,
					A = d.outWidth,
					_ = d.strideHeight,
					F = d.strideWidth;
				f = d.dataFormat;
				for (
					var D = N - 1 - d.padInfo.top,
						O = I - 1 - d.padInfo.left,
						M = "channelsLast" === f,
						L = m.strides[0],
						z = M ? m.strides[1] : m.strides[2],
						P = M ? m.strides[2] : 1,
						B = M ? 1 : m.strides[1],
						W = h[0],
						U = M ? h[1] : h[2],
						V = M ? h[2] : 1,
						G = M ? 1 : h[1],
						j = 0;
					j < k;
					++j
				)
					for (var H = 0; H < S; ++H)
						for (var q = 0; q < T; ++q)
							for (
								var K = q - D, X = Math.max(0, Math.ceil(K / _)), Y = Math.min(R, (N + K) / _), J = 0;
								J < C;
								++J
							) {
								for (
									var Z = J - O,
										Q = Math.max(0, Math.ceil(Z / F)),
										$ = Math.min(A, (I + Z) / F),
										ee = 0,
										te = X;
									te < Y;
									++te
								)
									for (var ne = te * _ - K, re = Q; re < $; ++re)
										for (
											var ae = W * j + U * te + V * re,
												ie = b * (N - 1 - ne) + x * (I - 1 - (re * F - Z)) + w * H,
												oe = 0;
											oe < E;
											++oe
										)
											ee += v[ae + G * oe] * y[ie + oe];
								g[L * j + z * q + P * J + B * H] = ee;
							}
				return n.makeTensorInfo(m.shape, m.dtype, m.values);
			},
		},
		Rj = {
			kernelName: ty,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.filter,
					o = r.strides,
					s = r.pad,
					u = r.dilations;
				vU([a, i], "conv3d");
				for (
					var l = pS(a.shape, i.shape, o, u, s),
						c = l.filterDepth,
						p = l.filterHeight,
						h = l.filterWidth,
						f = l.dilationDepth,
						d = l.dilationHeight,
						m = l.dilationWidth,
						g = l.padInfo,
						v = g.front,
						y = g.left,
						b = g.top,
						x = new Mw(l.outShape, a.dtype),
						w = n.data.get(a.dataId).values,
						k = n.data.get(i.dataId).values,
						N = x.values,
						I = ov(a.shape),
						S = ov(i.shape),
						T = 0;
					T < l.batchSize;
					++T
				)
					for (var C = T * I[0], E = T * x.strides[0], R = 0; R < l.outDepth; ++R)
						for (var A = E + R * x.strides[1], _ = R * l.strideDepth - v, F = 0; F < c; ++F) {
							var D = _ + F * f;
							if (!(D < 0 || D >= l.inDepth))
								for (var O = F * S[0], M = C + D * I[1], L = 0; L < l.outHeight; ++L)
									for (var z = A + L * x.strides[2], P = L * l.strideHeight - b, B = 0; B < p; ++B) {
										var W = P + B * d;
										if (!(W < 0 || W >= l.inHeight))
											for (var U = O + B * S[1], V = M + W * I[2], G = 0; G < l.outWidth; ++G)
												for (
													var j = z + G * l.outChannels, H = G * l.strideWidth - y, q = 0;
													q < h;
													++q
												) {
													var K = H + q * m;
													if (!(K < 0 || K >= l.inWidth))
														for (
															var X = U + q * S[2],
																Y = V + K * l.inChannels,
																J = X,
																Z = 0;
															Z < l.inChannels;
															++Z
														) {
															for (var Q = w[Y + Z], $ = 0; $ < l.outChannels; ++$)
																N[j + $] += Q * k[J + $];
															J += l.outChannels;
														}
												}
									}
						}
				return n.makeTensorInfo(x.shape, x.dtype, x.values);
			},
		},
		Aj = {
			kernelName: ny,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.dy,
					o = r.strides,
					s = r.pad,
					u = r.filterShape;
				vU([a, i], "conv3dBackpropFilterV2");
				for (
					var l = ov(a.shape),
						c = ov(i.shape),
						p = pS(a.shape, u, o, 1, s),
						h = p.strideDepth,
						f = p.strideHeight,
						d = p.strideWidth,
						m = p.filterDepth,
						g = p.filterHeight,
						v = p.filterWidth,
						y = new Mw(p.filterShape, "float32"),
						b = y.values,
						x = y.strides,
						w = x[0],
						k = x[1],
						N = x[2],
						I = x[3],
						S = n.data.get(i.dataId).values,
						T = c[0],
						C = c[1],
						E = c[2],
						R = c[3],
						A = n.data.get(a.dataId).values,
						_ = l[0],
						F = l[1],
						D = l[2],
						O = l[3],
						M = p.padInfo.front,
						L = p.padInfo.left,
						z = p.padInfo.top,
						P = 0;
					P < m;
					++P
				)
					for (
						var B = Math.max(0, Math.ceil((M - P) / h)),
							W = Math.min(p.outDepth, (p.inDepth + M - P) / h),
							U = P * w,
							V = 0;
						V < g;
						++V
					)
						for (
							var G = Math.max(0, Math.ceil((z - V) / f)),
								j = Math.min(p.outHeight, (p.inHeight + z - V) / f),
								H = V * k + U,
								q = 0;
							q < v;
							++q
						)
							for (
								var K = Math.max(0, Math.ceil((L - q) / d)),
									X = Math.min(p.outWidth, (p.inWidth + L - q) / d),
									Y = q * N + H,
									J = 0;
								J < p.inChannels;
								++J
							)
								for (var Z = J * I + Y, Q = 0; Q < p.outChannels; ++Q) {
									for (var $ = 0, ee = 0; ee < p.batchSize; ++ee)
										for (var te = ee * _, ne = ee * T, re = B; re < W; ++re)
											for (
												var ae = (P + re * h - M) * F + te, ie = re * C + ne, oe = G;
												oe < j;
												++oe
											)
												for (
													var se = (V + oe * f - z) * D + ae, ue = oe * E + ie, le = K;
													le < X;
													++le
												) {
													var ce = le * R + ue;
													$ += A[(q + le * d - L) * O + se + J] * S[ce + Q];
												}
									b[Z + Q] = $;
								}
				return n.makeTensorInfo(y.shape, y.dtype, y.values);
			},
		},
		_j = {
			kernelName: ry,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.filter,
					o = r.pad,
					s = r.strides,
					u = r.inputShape;
				vU([a], "conv3dBackpropInputV2");
				for (
					var l = ov(a.shape),
						c = ov(i.shape),
						p = pS(u, i.shape, s, 1, o),
						h = new Mw(p.inShape, "float32"),
						f = h.values,
						d = h.strides,
						m = d[0],
						g = d[1],
						v = d[2],
						y = d[3],
						b = n.data.get(a.dataId).values,
						x = l[0],
						w = l[1],
						k = l[2],
						N = l[3],
						I = n.data.get(i.dataId).values,
						S = c[0],
						T = c[1],
						C = c[2],
						E = c[3],
						R = p.batchSize,
						A = p.filterDepth,
						_ = p.filterHeight,
						F = p.filterWidth,
						D = p.inChannels,
						O = p.inDepth,
						M = p.inHeight,
						L = p.inWidth,
						z = p.outChannels,
						P = p.outDepth,
						B = p.outHeight,
						W = p.outWidth,
						U = p.strideDepth,
						V = p.strideHeight,
						G = p.strideWidth,
						j = A - 1 - p.padInfo.front,
						H = _ - 1 - p.padInfo.top,
						q = F - 1 - p.padInfo.left,
						K = 0;
					K < R;
					++K
				)
					for (var X = 0; X < D; ++X)
						for (var Y = 0; Y < O; ++Y)
							for (
								var J = Y - j, Z = Math.max(0, Math.ceil(J / U)), Q = Math.min(P, (A + J) / U), $ = 0;
								$ < M;
								++$
							)
								for (
									var ee = $ - H,
										te = Math.max(0, Math.ceil(ee / V)),
										ne = Math.min(B, (_ + ee) / V),
										re = 0;
									re < L;
									++re
								) {
									for (
										var ae = re - q,
											ie = Math.max(0, Math.ceil(ae / G)),
											oe = Math.min(W, (F + ae) / G),
											se = 0,
											ue = Z;
										ue < Q;
										++ue
									)
										for (var le = ue * U - J, ce = te; ce < ne; ++ce)
											for (var pe = ce * V - ee, he = ie; he < oe; ++he)
												for (
													var fe = x * K + w * ue + k * ce + N * he,
														de =
															S * (A - 1 - le) +
															T * (_ - 1 - pe) +
															C * (F - 1 - (he * G - ae)) +
															E * X,
														me = 0;
													me < z;
													++me
												)
													se += b[fe + me] * I[de + me];
									f[m * K + g * Y + v * $ + y * re + X] = se;
								}
				return n.makeTensorInfo(h.shape, h.dtype, h.values);
			},
		},
		Fj = UU(ay, function (e) {
			return Math.cos(e);
		}),
		Dj = { kernelName: ay, backendName: "cpu", kernelFunc: Fj },
		Oj = UU(iy, function (e) {
			return Math.cosh(e);
		}),
		Mj = { kernelName: iy, backendName: "cpu", kernelFunc: Oj },
		Lj = {
			kernelName: uy,
			backendName: "cpu",
			kernelFunc: function (e) {
				for (
					var t = e.inputs,
						n = e.backend,
						r = e.attrs,
						a = t.image,
						i = t.boxes,
						o = t.boxInd,
						s = r.cropSize,
						u = r.method,
						l = r.extrapolationValue,
						c = a.shape,
						p = c[0],
						h = c[1],
						f = c[2],
						d = c[3],
						m = i.shape[0],
						g = s[0],
						v = s[1],
						y = kN([m, g, v, d], "float32"),
						b = n.data.get(i.dataId).values,
						x = n.data.get(o.dataId).values,
						w = n.data.get(a.dataId).values,
						k = ov(a.shape),
						N = ov(y.shape),
						I = 0;
					I < m;
					I++
				) {
					var S = 4 * I,
						T = b[S],
						C = b[S + 1],
						E = b[S + 2],
						R = b[S + 3],
						A = x[I];
					if (!(A >= p))
						for (
							var _ = g > 1 ? ((E - T) * (h - 1)) / (g - 1) : 0,
								F = v > 1 ? ((R - C) * (f - 1)) / (v - 1) : 0,
								D = 0;
							D < g;
							D++
						) {
							var O = g > 1 ? T * (h - 1) + D * _ : 0.5 * (T + E) * (h - 1);
							if (O < 0 || O > h - 1)
								for (var M = 0; M < v; M++)
									for (var L = 0; L < d; L++) {
										var z = L + M * N[2] + D * N[1] + I * N[0];
										y.values[z] = l;
									}
							else if ("bilinear" === u)
								for (var P = Math.floor(O), B = Math.ceil(O), W = O - P, U = 0; U < v; U++) {
									var V = v > 1 ? C * (f - 1) + U * F : 0.5 * (C + R) * (f - 1);
									if (V < 0 || V > f - 1)
										for (var G = 0; G < d; G++) {
											var j = G + U * N[2] + D * N[1] + I * N[0];
											y.values[j] = l;
										}
									else
										for (var H = Math.floor(V), q = Math.ceil(V), K = V - H, X = 0; X < d; X++) {
											var Y = X + H * k[2] + P * k[1] + A * k[0],
												J = w[Y],
												Z = w[(Y = X + q * k[2] + P * k[1] + A * k[0])],
												Q = w[(Y = X + H * k[2] + B * k[1] + A * k[0])],
												$ = J + (Z - J) * K,
												ee = Q + (w[(Y = X + q * k[2] + B * k[1] + A * k[0])] - Q) * K;
											(Y = X + U * N[2] + D * N[1] + I * N[0]), (y.values[Y] = $ + (ee - $) * W);
										}
								}
							else
								for (var te = 0; te < v; ++te) {
									var ne = v > 1 ? C * (f - 1) + te * F : 0.5 * (C + R) * (f - 1);
									if (ne < 0 || ne > f - 1)
										for (var re = 0; re < d; re++) {
											var ae = re + te * N[2] + D * N[1] + I * N[0];
											y.values[ae] = l;
										}
									else
										for (var ie = Math.round(ne), oe = Math.round(O), se = 0; se < d; se++) {
											var ue = se + ie * k[2] + oe * k[1] + A * k[0],
												le = se + te * N[2] + D * N[1] + I * N[0];
											y.values[le] = w[ue];
										}
								}
						}
				}
				return n.makeTensorInfo(y.shape, y.dtype, y.values);
			},
		},
		zj = {
			kernelName: oy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.exclusive,
					s = r.reverse;
				vU(a, "cumprod");
				var u = YT([i], a.shape.length),
					l = a;
				null != u && (l = WV({ inputs: { x: a }, backend: n, attrs: { perm: u } }));
				var c = ZT(1, a.shape.length)[0];
				if (c !== l.shape.length - 1)
					throw new Error(
						"backend.cumprod in CPU expects an inner-most axis=" +
							(l.shape.length - 1) +
							" but got axis=" +
							c
					);
				for (
					var p = Kw(l.dtype, "int32"),
						h = lv(zg(l.shape), p),
						f = n.data.get(l.dataId).values,
						d = l.shape[l.shape.length - 1],
						m = s
							? function (e, t) {
									return e + d - t - 1;
							  }
							: function (e, t) {
									return e + t;
							  },
						g = 0;
					g < f.length;
					g += d
				)
					for (var v = 0; v < d; v++) {
						var y = m(g, v);
						if (0 === v) h[y] = o ? 1 : f[y];
						else {
							var b = m(g, v - 1);
							h[y] = o ? f[b] * h[b] : f[y] * h[b];
						}
					}
				var x = n.makeTensorInfo(l.shape, p, h);
				if (null != u) {
					var w = WV({ inputs: { x: x }, backend: n, attrs: { perm: JT(u) } });
					return n.disposeIntermediateTensorInfo(x), n.disposeIntermediateTensorInfo(l), w;
				}
				return x;
			},
		},
		Pj = {
			kernelName: sy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.exclusive,
					s = r.reverse;
				vU(a, "cumsum");
				var u = YT([i], a.shape.length),
					l = a;
				null != u && (l = WV({ inputs: { x: a }, backend: n, attrs: { perm: u } }));
				var c = ZT(1, a.shape.length)[0];
				if (c !== l.shape.length - 1)
					throw new Error(
						"backend.cumsum in CPU expects an inner-most axis=" +
							(l.shape.length - 1) +
							" but got axis=" +
							c
					);
				for (
					var p = Kw(l.dtype, "int32"),
						h = cv(zg(l.shape), p),
						f = n.data.get(l.dataId).values,
						d = l.shape[l.shape.length - 1],
						m = s
							? function (e, t) {
									return e + d - t - 1;
							  }
							: function (e, t) {
									return e + t;
							  },
						g = 0;
					g < f.length;
					g += d
				)
					for (var v = 0; v < d; v++) {
						var y = m(g, v);
						if (0 === v) h[y] = o ? 0 : f[y];
						else {
							var b = m(g, v - 1);
							h[y] = o ? f[b] + h[b] : f[y] + h[b];
						}
					}
				var x = n.makeTensorInfo(l.shape, p, h);
				if (null != u) {
					var w = WV({ inputs: { x: x }, backend: n, attrs: { perm: JT(u) } });
					return n.disposeIntermediateTensorInfo(x), n.disposeIntermediateTensorInfo(l), w;
				}
				return x;
			},
		},
		Bj = {
			kernelName: ly,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.weights,
					o = r.size,
					s = r.binaryOutput;
				if (1 === a.shape.length) {
					var u = PU(n.data.get(a.dataId).values, n.data.get(i.dataId).values, i.dtype, i.shape, o);
					return n.makeTensorInfo([o], i.dtype, u);
				}
				if (2 === a.shape.length) {
					var l = BU(n.bufferSync(a), n.bufferSync(i), o, s);
					return n.makeTensorInfo(l.shape, i.dtype, l.values);
				}
				throw new Error(
					"Error in denseBincount: input must be at most rank 2, but got rank" + a.shape.length + "."
				);
			},
		},
		Wj = {
			kernelName: cy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.blockSize,
					o = r.dataFormat;
				Dg("NHWC" === o, function () {
					return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + o;
				});
				for (
					var s = a.shape[0],
						u = a.shape[1],
						l = a.shape[2],
						c = a.shape[3],
						p = u * i,
						h = l * i,
						f = c / (i * i),
						d = n.data.get(a.dataId).values,
						m = new Float32Array(s * p * h * f),
						g = 0,
						v = 0;
					v < s;
					++v
				)
					for (var y = 0; y < p; ++y)
						for (var b = Math.floor(y / i), x = y % i, w = 0; w < h; ++w)
							for (var k = Math.floor(w / i), N = (x * i + (w % i)) * f, I = 0; I < f; ++I) {
								var S = I + N + c * (k + l * (b + u * v));
								m[g++] = d[S];
							}
				return n.makeTensorInfo([s, p, h, f], a.dtype, m);
			},
		};
	function Uj(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = t.filter,
			o = r.strides,
			s = r.pad,
			u = r.dilations,
			l = r.dimRoundingMode;
		vU([a, i], "depthwiseConv2DNative");
		var c = ov(a.shape),
			p = ov(i.shape),
			h = u;
		null == h && (h = [1, 1]),
			Dg(yS(o, h), function () {
				return (
					"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " +
					o +
					" and dilations '" +
					h +
					"'"
				);
			});
		for (
			var f = cS(a.shape, i.shape, o, h, s, l, !0),
				d = f.filterHeight,
				m = f.filterWidth,
				g = f.dilationHeight,
				v = f.dilationWidth,
				y = f.padInfo,
				b = y.left,
				x = y.top,
				w = f.outChannels / f.inChannels,
				k = new Mw(f.outShape, a.dtype),
				N = n.data.get(a.dataId).values,
				I = n.data.get(i.dataId).values,
				S = k.values,
				T = 0;
			T < f.batchSize;
			++T
		)
			for (var C = T * c[0], E = T * k.strides[0], R = 0; R < f.outHeight; ++R)
				for (var A = E + R * k.strides[1], _ = R * f.strideHeight - x, F = 0; F < d; ++F) {
					var D = _ + F * g;
					if (!(D < 0 || D >= f.inHeight))
						for (var O = F * p[0], M = C + D * c[1], L = 0; L < f.outWidth; ++L)
							for (var z = A + L * k.strides[2], P = L * f.strideWidth - b, B = 0; B < m; ++B) {
								var W = P + B * v;
								if (!(W < 0 || W >= f.inWidth))
									for (
										var U = O + B * p[1], V = M + W * f.inChannels, G = z, j = U, H = 0;
										H < f.inChannels;
										++H
									) {
										for (var q = N[V + H], K = 0; K < w; ++K) S[G + K] += q * I[j + K];
										(G += w), (j += w);
									}
							}
				}
		return n.makeTensorInfo(k.shape, k.dtype, k.values);
	}
	var Vj = { kernelName: py, backendName: "cpu", kernelFunc: Uj },
		Gj = {
			kernelName: hy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.dy,
					o = r.strides,
					s = r.dilations,
					u = r.pad,
					l = r.dimRoundingMode,
					c = r.filterShape;
				vU([a, i], "depthwiseConv2dNativeBackpropFilter");
				for (
					var p = cS(a.shape, c, o, s, u, l, !0),
						h = p.strideHeight,
						f = p.strideWidth,
						d = p.filterHeight,
						m = p.filterWidth,
						g = new Mw(p.filterShape, "float32"),
						v = p.padInfo.left,
						y = p.padInfo.top,
						b = p.outChannels / p.inChannels,
						x = n.data.get(a.dataId).values,
						w = new Mw(a.shape, a.dtype, x),
						k = n.data.get(i.dataId).values,
						N = new Mw(i.shape, i.dtype, k),
						I = 0;
					I < d;
					++I
				)
					for (
						var S = Math.max(0, Math.ceil((y - I) / h)),
							T = Math.min(p.outHeight, (p.inHeight + y - I) / h),
							C = 0;
						C < m;
						++C
					)
						for (
							var E = Math.max(0, Math.ceil((v - C) / f)),
								R = Math.min(p.outWidth, (p.inWidth + v - C) / f),
								A = 0;
							A < p.outChannels;
							++A
						) {
							for (var _ = Math.trunc(A / b), F = A % b, D = 0, O = 0; O < p.batchSize; ++O)
								for (var M = S; M < T; ++M)
									for (var L = I + M * h - y, z = E; z < R; ++z) {
										var P = C + z * f - v;
										D += w.get(O, L, P, _) * N.get(O, M, z, A);
									}
							g.set(D, I, C, _, F);
						}
				return n.makeTensorInfo(g.shape, g.dtype, g.values);
			},
		},
		jj = {
			kernelName: fy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.filter,
					o = r.strides,
					s = r.dilations,
					u = r.pad,
					l = r.dimRoundingMode,
					c = r.inputShape;
				vU([a, i], "depthwiseConv2DNativeBackpropInput");
				for (
					var p = ov(a.shape),
						h = ov(i.shape),
						f = cS(c, i.shape, o, s, u, l, !0),
						d = new Mw(f.inShape, "float32"),
						m = d.values,
						g = d.strides,
						v = g[0],
						y = g[1],
						b = g[2],
						x = n.data.get(a.dataId).values,
						w = p[0],
						k = p[1],
						N = p[2],
						I = n.data.get(i.dataId).values,
						S = h[0],
						T = h[1],
						C = h[2],
						E = f.batchSize,
						R = f.filterHeight,
						A = f.filterWidth,
						_ = f.inChannels,
						F = f.inHeight,
						D = f.inWidth,
						O = f.outChannels,
						M = f.outHeight,
						L = f.outWidth,
						z = f.strideHeight,
						P = f.strideWidth,
						B = R - 1 - f.padInfo.top,
						W = A - 1 - f.padInfo.left,
						U = O / _,
						V = 0;
					V < E;
					++V
				)
					for (var G = 0; G < _; ++G)
						for (var j = 0; j < F; ++j)
							for (
								var H = j - B, q = Math.max(0, Math.ceil(H / z)), K = Math.min(M, (R + H) / z), X = 0;
								X < D;
								++X
							) {
								for (
									var Y = X - W,
										J = Math.max(0, Math.ceil(Y / P)),
										Z = Math.min(L, (A + Y) / P),
										Q = 0,
										$ = q;
									$ < K;
									++$
								)
									for (var ee = $ * z - H, te = J; te < Z; ++te)
										for (
											var ne = w * V + k * $ + N * te,
												re = S * (R - 1 - ee) + T * (A - 1 - (te * P - Y)) + C * G,
												ae = 0;
											ae < U;
											++ae
										)
											Q += x[ne + (G * U + ae)] * I[re + ae];
								m[v * V + y * j + b * X + G] = Q;
							}
				return n.makeTensorInfo(d.shape, d.dtype, d.values);
			},
		},
		Hj = {
			kernelName: dy,
			backendName: "cpu",
			kernelFunc: function (e) {
				for (
					var t = e.inputs,
						n = e.backend,
						r = t.x,
						a = zg(r.shape),
						i = n.data.get(r.dataId).values,
						o = kN([a, a], r.dtype),
						s = o.values,
						u = 0;
					u < i.length;
					u++
				)
					s[u * a + u] = i[u];
				var l = [].concat(r.shape, r.shape);
				return n.makeTensorInfo(l, o.dtype, o.values);
			},
		},
		qj = {
			kernelName: my,
			backendName: "cpu",
			kernelFunc: function (e) {
				for (
					var t = e.inputs,
						n = e.backend,
						r = e.attrs,
						a = t.x,
						i = t.filter,
						o = r.strides,
						s = r.pad,
						u = r.dilations,
						l = n,
						c = l.data.get(a.dataId).values,
						p = a.shape.length,
						h = l.data.get(i.dataId).values,
						f = i.shape.length,
						d = sS(a.shape, i.shape, o, s, "NHWC", u),
						m = d.batchSize,
						g = d.inHeight,
						v = d.inWidth,
						y = d.inChannels,
						b = d.outHeight,
						x = d.outWidth,
						w = d.padInfo,
						k = d.strideHeight,
						N = d.strideWidth,
						I = d.filterHeight,
						S = d.filterWidth,
						T = d.dilationHeight,
						C = d.dilationWidth,
						E = d.outShape,
						R = zg(E),
						A = E.length,
						_ = Kg(a.dtype, R),
						F = 0;
					F < m;
					++F
				)
					for (var D = 0; D < b; ++D)
						for (var O = D * k - w.top, M = 0; M < x; ++M)
							for (var L = M * N - w.left, z = 0; z < y; ++z) {
								for (var P = Number.MIN_SAFE_INTEGER, B = 0; B < I; ++B) {
									var W = O + B * T;
									if (W >= 0 && W < g)
										for (var U = 0; U < S; ++U) {
											var V = L + U * C;
											if (V >= 0 && V < v) {
												var G = fv([F, W, V, z], p, ov(a.shape)),
													j = fv([B, U, z], f, ov(i.shape)),
													H = c[G] + h[j];
												H > P && (P = H);
											}
										}
								}
								_[fv([F, D, M, z], A, ov(E))] = P;
							}
				return { dataId: l.write(kw(_, a.dtype), E, a.dtype), shape: E, dtype: a.dtype };
			},
		},
		Kj = {
			kernelName: vy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.filter,
					o = t.dy,
					s = r.strides,
					u = r.pad,
					l = r.dilations,
					c = n,
					p = uv(a.shape, c.data.get(a.dataId).values),
					h = uv(i.shape, c.data.get(i.dataId).values),
					f = sS(a.shape, i.shape, s, u, "NHWC", l),
					d = f.batchSize,
					m = f.inHeight,
					g = f.inWidth,
					v = f.inChannels,
					y = f.outHeight,
					b = f.outWidth,
					x = f.padInfo,
					w = f.strideHeight,
					k = f.strideWidth,
					N = f.filterHeight,
					I = f.filterWidth,
					S = f.dilationHeight,
					T = f.dilationWidth,
					C = f.outShape;
				Dg(o.rank === C.length, function () {
					return (
						"Error in Dilation2DBackpropFilter, dy must have the same rank as output " +
						C.length +
						", but got " +
						o.rank
					);
				});
				for (var E = uv(C, c.data.get(o.dataId).values), R = pv(i.shape, i.dtype), A = 0; A < d; ++A)
					for (var _ = 0; _ < y; ++_)
						for (var F = _ * w - x.top, D = 0; D < b; ++D)
							for (var O = D * k - x.left, M = 0; M < v; ++M) {
								for (var L = Number.MIN_SAFE_INTEGER, z = 0, P = 0, B = 0; B < N; ++B) {
									var W = F + B * S;
									if (W >= 0 && W < m)
										for (var U = 0; U < I; ++U) {
											var V = O + U * T;
											if (V >= 0 && V < g) {
												var G = p[A][W][V][M] + h[B][U][M];
												G > L && ((L = G), (z = B), (P = U));
											}
										}
								}
								R[z][P][M] += E[A][_][D][M];
							}
				return { dataId: c.write(kw(R, a.dtype), i.shape, i.dtype), shape: i.shape, dtype: i.dtype };
			},
		},
		Xj = {
			kernelName: gy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.filter,
					o = t.dy,
					s = r.strides,
					u = r.pad,
					l = r.dilations,
					c = n,
					p = uv(a.shape, c.data.get(a.dataId).values),
					h = uv(i.shape, c.data.get(i.dataId).values),
					f = sS(a.shape, i.shape, s, u, "NHWC", l),
					d = f.batchSize,
					m = f.inHeight,
					g = f.inWidth,
					v = f.inChannels,
					y = f.outHeight,
					b = f.outWidth,
					x = f.padInfo,
					w = f.strideHeight,
					k = f.strideWidth,
					N = f.filterHeight,
					I = f.filterWidth,
					S = f.dilationHeight,
					T = f.dilationWidth,
					C = f.outShape;
				Dg(o.rank === C.length, function () {
					return (
						"Error in Dilation2DBackpropInput, dy must have the same rank as output " +
						C.length +
						", but got " +
						o.rank
					);
				});
				for (var E = uv(C, c.data.get(o.dataId).values), R = pv(a.shape, a.dtype), A = 0; A < d; ++A)
					for (var _ = 0; _ < y; ++_)
						for (var F = _ * w - x.top, D = 0; D < b; ++D)
							for (var O = D * k - x.left, M = 0; M < v; ++M) {
								for (
									var L = Number.MIN_SAFE_INTEGER, z = F < 0 ? 0 : F, P = O < 0 ? 0 : O, B = 0;
									B < N;
									++B
								) {
									var W = F + B * S;
									if (W >= 0 && W < m)
										for (var U = 0; U < I; ++U) {
											var V = O + U * T;
											if (V >= 0 && V < g) {
												var G = p[A][W][V][M] + h[B][U][M];
												G > L && ((L = G), (z = W), (P = V));
											}
										}
								}
								R[A][z][P][M] += E[A][_][D][M];
							}
				return { dataId: c.write(kw(R, a.dtype), a.shape, a.dtype), shape: a.shape, dtype: a.dtype };
			},
		};
	function Yj(e) {
		var t,
			n = e.inputs,
			r = e.backend,
			a = e.attrs,
			i = n.x,
			o = a.axis,
			s = a.keepDims;
		vU(i, "sum");
		var u = (t =
				"bool" === i.dtype
					? AU({ inputs: { x: i }, backend: r, attrs: { dtype: "int32" } })
					: TU({ inputs: { x: i }, backend: r })).shape.length,
			l = jg(o, t.shape),
			c = YT(l, u),
			p = l,
			h = t;
		null != c && ((h = WV({ inputs: { x: t }, backend: r, attrs: { perm: c } })), (p = ZT(p.length, u))),
			XT("sum", p, h.shape.length);
		for (
			var f = qT(h.shape, p),
				d = f[0],
				m = f[1],
				g = SU(r, d, Kw(h.dtype, "int32")),
				v = zg(m),
				y = r.data.get(g.dataId).values,
				b = r.data.get(h.dataId).values,
				x = 0;
			x < y.length;
			++x
		) {
			for (var w = x * v, k = 0, N = 0; N < v; ++N) k += b[w + N];
			y[x] = k;
		}
		if (s) {
			var I = g;
			(g = LG({ inputs: { x: g }, backend: r, attrs: { shape: KT(g.shape, l) } })),
				r.disposeIntermediateTensorInfo(I);
		}
		return r.disposeIntermediateTensorInfo(t), null != c && r.disposeIntermediateTensorInfo(h), g;
	}
	var Jj = { kernelName: Jb, backendName: "cpu", kernelFunc: Yj },
		Zj = {
			kernelName: by,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t,
					a = XA(e.attrs.equation, r.length),
					i = a.allDims,
					o = a.summedDims,
					s = a.idDims;
				JA(i.length, s, r);
				for (
					var u = ZA(o, s), l = u.path, c = u.steps, p = c.length, h = null, f = i.length, d = [], m = 0;
					m < p;
					++m
				) {
					for (var g, v = Ig(c[m]); !(g = v()).done; ) {
						var y = g.value,
							b = YA(f, s[y]),
							x = b.permutationIndices,
							w = b.expandDims,
							k = void 0;
						QA(x)
							? (k = r[y])
							: ((k = WV({ inputs: { x: r[y] }, backend: n, attrs: { perm: x } })), d.push(k));
						for (var N = k.shape.slice(), I = 0; I < w.length; ++I) N.splice(w[I], 0, 1);
						Pg(k.shape, N) || ((k = LG({ inputs: { x: k }, backend: n, attrs: { shape: N } })), d.push(k)),
							null === h ? (h = k) : ((h = FV({ inputs: { a: k, b: h }, backend: n })), d.push(h));
					}
					m < p - 1 &&
						(l[m] >= 0 &&
							((h = Yj({
								inputs: { x: h },
								backend: n,
								attrs: { axis: l[m] - (i.length - f), keepDims: !1 },
							})),
							d.push(h)),
						f--);
				}
				for (var S = 0, T = d; S < T.length; S++) {
					var C = T[S];
					C !== h && n.disposeIntermediateTensorInfo(C);
				}
				return h;
			},
		},
		Qj = {
			kernelName: wy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.dy,
					a = t.y;
				vU([r, a], "eluGrad");
				for (
					var i = new Float32Array(zg(a.shape)),
						o = n.data.get(a.dataId).values,
						s = n.data.get(r.dataId).values,
						u = 0;
					u < o.length;
					++u
				) {
					var l = o[u];
					i[u] = l >= 1 ? s[u] : s[u] * (l + 1);
				}
				return n.makeTensorInfo(a.shape, "float32", i);
			},
		},
		$j = UU(ky, function (e) {
			var t = Math.sign(e),
				n = Math.abs(e),
				r = 1 / (1 + 0.3275911 * n);
			return (
				t *
				(1 -
					((((1.061405429 * r - 1.453152027) * r + 1.421413741) * r - 0.284496736) * r + 0.254829592) *
						r *
						Math.exp(-n * n))
			);
		}),
		eH = { kernelName: ky, backendName: "cpu", kernelFunc: $j };
	function tH(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.input,
			i = r.dim,
			o = a.shape.length,
			s = a.shape.slice(),
			u = i;
		return (
			i < 0 &&
				(Dg(-(o + 1) <= i, function () {
					return "Axis must be in the interval [" + -(o + 1) + ", " + o + "]";
				}),
				(u = o + i + 1)),
			s.splice(u, 0, 1),
			LG({ inputs: { x: a }, backend: n, attrs: { shape: s } })
		);
	}
	var nH = { kernelName: Sy, backendName: "cpu", kernelFunc: tH },
		rH = kU(function (e, t) {
			return e / t;
		}),
		aH = FU(yy, rH),
		iH = { kernelName: yy, backendName: "cpu", kernelFunc: aH };
	function oH(e, t, n) {
		for (
			var r = e.shape,
				a = r[0],
				i = r[1],
				o = n.data.get(e.dataId),
				s = o.complexTensorInfos.real,
				u = o.complexTensorInfos.imag,
				l = [a, i],
				c = zg(l),
				p = qg("float32", c),
				h = qg("float32", c),
				f = 0;
			f < a;
			f++
		) {
			for (
				var d = QV({ inputs: { x: s }, backend: n, attrs: { begin: [f, 0], size: [1, i] } }),
					m = QV({ inputs: { x: u }, backend: n, attrs: { begin: [f, 0], size: [1, i] } }),
					g = NU({ inputs: { real: d, imag: m }, backend: n }),
					v = sH(g, t, n),
					y = BA(v.real, v.imag),
					b = 0;
				b < i;
				b++
			) {
				var x = GA(y, b);
				(p[f * i + b] = x.real), (h[f * i + b] = x.imag);
			}
			n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(g);
		}
		var w = n.makeTensorInfo(l, "float32", p),
			k = n.makeTensorInfo(l, "float32", h),
			N = NU({ inputs: { real: w, imag: k }, backend: n });
		return n.disposeIntermediateTensorInfo(w), n.disposeIntermediateTensorInfo(k), N;
	}
	function sH(e, t, n) {
		var r,
			a = zg(e.shape),
			i = n.data.get(e.dataId),
			o = n.data.get(i.complexTensorInfos.real.dataId).values,
			s = n.data.get(i.complexTensorInfos.imag.dataId).values;
		if (0 == ((r = a) & (r - 1))) {
			var u = uH(o, s, a, t, n),
				l = [e.shape[0], e.shape[1]];
			if (t) {
				var c = n.makeTensorInfo(l, "float32", u.real),
					p = n.makeTensorInfo(l, "float32", u.imag),
					h = n.makeTensorInfo([], "float32", ww(a, "float32")),
					f = TU({ inputs: { x: h }, backend: n }),
					d = iH.kernelFunc({ inputs: { a: c, b: h }, backend: n }),
					m = iH.kernelFunc({ inputs: { a: p, b: f }, backend: n }),
					g = n.data.get(d.dataId).values,
					v = n.data.get(m.dataId).values;
				return (
					n.disposeIntermediateTensorInfo(c),
					n.disposeIntermediateTensorInfo(p),
					n.disposeIntermediateTensorInfo(h),
					n.disposeIntermediateTensorInfo(f),
					n.disposeIntermediateTensorInfo(d),
					n.disposeIntermediateTensorInfo(m),
					{ real: g, imag: v }
				);
			}
			return u;
		}
		return WA(
			(function (e, t, n) {
				for (var r = new Float32Array(2 * t), a = 0; a < t; a++) {
					for (var i = 0, o = 0, s = 0; s < t; s++) {
						var u = qA(a * s, t, n),
							l = GA(e, s);
						(i += l.real * u.real - l.imag * u.imag), (o += l.real * u.imag + l.imag * u.real);
					}
					n && ((i /= t), (o /= t)), jA(r, i, o, a);
				}
				return r;
			})(BA(o, s), a, t)
		);
	}
	function uH(e, t, n, r, a) {
		if (1 === n) return { real: e, imag: t };
		var i = BA(e, t),
			o = n / 2,
			s = UA(i),
			u = s.real,
			l = s.imag,
			c = [u.length],
			p = a.makeTensorInfo(c, "float32", u),
			h = a.makeTensorInfo(c, "float32", l),
			f = NU({ inputs: { real: p, imag: h }, backend: a }),
			d = VA(i),
			m = d.real,
			g = d.imag,
			v = [m.length],
			y = a.makeTensorInfo(v, "float32", m),
			b = a.makeTensorInfo(v, "float32", g),
			x = NU({ inputs: { real: y, imag: b }, backend: a }),
			w = uH(u, l, o, r, a),
			k = w.real,
			N = w.imag,
			I = [k.length],
			S = a.makeTensorInfo(I, "float32", k),
			T = a.makeTensorInfo(I, "float32", N),
			C = NU({ inputs: { real: S, imag: T }, backend: a }),
			E = uH(m, g, o, r, a),
			R = E.real,
			A = E.imag,
			_ = [R.length],
			F = a.makeTensorInfo(_, "float32", R),
			D = a.makeTensorInfo(_, "float32", A),
			O = NU({ inputs: { real: F, imag: D }, backend: a }),
			M = HA(n, r),
			L = [M.real.length],
			z = a.makeTensorInfo(L, "float32", M.real),
			P = a.makeTensorInfo(L, "float32", M.imag),
			B = NU({ inputs: { real: z, imag: P }, backend: a }),
			W = FV({ inputs: { a: B, b: O }, backend: a }),
			U = LU({ inputs: { a: C, b: W }, backend: a }),
			V = vG({ inputs: { a: C, b: W }, backend: a }),
			G = EU({ inputs: { input: U }, backend: a }),
			j = EU({ inputs: { input: V }, backend: a }),
			H = wj({ inputs: { input: U }, backend: a }),
			q = wj({ inputs: { input: V }, backend: a }),
			K = Nj({ inputs: [G, j], backend: a, attrs: { axis: 0 } }),
			X = Nj({ inputs: [H, q], backend: a, attrs: { axis: 0 } }),
			Y = a.data.get(K.dataId).values,
			J = a.data.get(X.dataId).values;
		return (
			a.disposeIntermediateTensorInfo(p),
			a.disposeIntermediateTensorInfo(h),
			a.disposeIntermediateTensorInfo(f),
			a.disposeIntermediateTensorInfo(y),
			a.disposeIntermediateTensorInfo(b),
			a.disposeIntermediateTensorInfo(x),
			a.disposeIntermediateTensorInfo(S),
			a.disposeIntermediateTensorInfo(T),
			a.disposeIntermediateTensorInfo(C),
			a.disposeIntermediateTensorInfo(F),
			a.disposeIntermediateTensorInfo(D),
			a.disposeIntermediateTensorInfo(O),
			a.disposeIntermediateTensorInfo(z),
			a.disposeIntermediateTensorInfo(P),
			a.disposeIntermediateTensorInfo(B),
			a.disposeIntermediateTensorInfo(W),
			a.disposeIntermediateTensorInfo(U),
			a.disposeIntermediateTensorInfo(V),
			a.disposeIntermediateTensorInfo(G),
			a.disposeIntermediateTensorInfo(H),
			a.disposeIntermediateTensorInfo(j),
			a.disposeIntermediateTensorInfo(q),
			a.disposeIntermediateTensorInfo(K),
			a.disposeIntermediateTensorInfo(X),
			{ real: Y, imag: J }
		);
	}
	var lH = {
		kernelName: Cy,
		backendName: "cpu",
		kernelFunc: function (e) {
			var t = e.inputs,
				n = e.backend,
				r = t.input,
				a = zg(r.shape),
				i = r.shape[r.shape.length - 1],
				o = LG({ inputs: { x: r }, backend: n, attrs: { shape: [a / i, i] } }),
				s = oH(o, !1, n),
				u = LG({ inputs: { x: s }, backend: n, attrs: { shape: r.shape } });
			return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u;
		},
	};
	function cH(e) {
		var t = e.backend,
			n = e.attrs,
			r = n.shape,
			a = n.value,
			i = n.dtype || rv(a),
			o = Kg(i, zg(r));
		return (
			(function (e, t, n) {
				e.fill(t);
			})(o, a),
			t.makeTensorInfo(r, i, o)
		);
	}
	var pH = { kernelName: Ey, backendName: "cpu", kernelFunc: cH },
		hH = {
			kernelName: Ry,
			backendName: "cpu",
			kernelFunc: function (e) {
				for (
					var t = e.inputs,
						n = (e.attrs, e.backend),
						r = t.image,
						a = n,
						i = qg(r.dtype, zg(r.shape)),
						o = r.shape,
						s = o[0],
						u = o[1],
						l = o[2],
						c = o[3],
						p = a.data.get(r.dataId).values,
						h = 0;
					h < s;
					h++
				)
					for (var f = h * l * u * c, d = 0; d < u; d++)
						for (var m = d * (l * c), g = 0; g < l; g++)
							for (var v = g * c, y = 0; y < c; y++) {
								var b = Math.round(l - g - 1),
									x = f + m + v + y,
									w = p[x];
								b >= 0 && b < l && (w = p[f + m + b * c + y]), (i[x] = w);
							}
				return { dataId: a.write(i, r.shape, r.dtype), shape: r.shape, dtype: r.dtype };
			},
		},
		fH = kU(function (e, t) {
			return Math.floor(e / t);
		}),
		dH = FU(_y, fH, null, "int32"),
		mH = { kernelName: _y, backendName: "cpu", kernelFunc: dH },
		gH = {
			kernelName: Tx,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.filter,
					o = t.bias,
					s = t.preluActivationWeights,
					u = r.strides,
					l = r.pad,
					c = r.dataFormat,
					p = r.dilations,
					h = r.dimRoundingMode,
					f = r.activation,
					d = r.leakyreluAlpha,
					m = Sj({
						inputs: { x: a, filter: i },
						backend: n,
						attrs: { strides: u, pad: l, dataFormat: c, dilations: p, dimRoundingMode: h },
					});
				if (o) {
					var g = m;
					(m = LU({ inputs: { a: m, b: o }, backend: n })), n.disposeIntermediateTensorInfo(g);
				}
				if (f) {
					var v = m;
					(m = MG(n, m, f, s, d)), n.disposeIntermediateTensorInfo(v);
				}
				return m;
			},
		},
		vH = {
			kernelName: Cx,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.filter,
					o = t.bias,
					s = t.preluActivationWeights,
					u = r.strides,
					l = r.pad,
					c = r.dataFormat,
					p = r.dilations,
					h = r.dimRoundingMode,
					f = r.activation,
					d = r.leakyreluAlpha,
					m = Uj({
						inputs: { x: a, filter: i },
						backend: n,
						attrs: { strides: u, pad: l, dataFormat: c, dilations: p, dimRoundingMode: h },
					});
				if (o) {
					var g = m;
					(m = LU({ inputs: { a: m, b: o }, backend: n })), n.disposeIntermediateTensorInfo(g);
				}
				if (f) {
					var v = m;
					(m = MG(n, m, f, s, d)), n.disposeIntermediateTensorInfo(v);
				}
				return m;
			},
		},
		yH = {
			kernelName: Oy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.params,
					a = t.indices,
					i = zg(r.shape),
					o = a.shape,
					s = o[o.length - 1],
					u = oI(r, a),
					l = u[0],
					c = u[1],
					p = u[2],
					h = u[3];
				if (0 === c) return n.makeTensorInfo(l, r.dtype, []);
				var f = iV(n.data.get(a.dataId).values, n.bufferSync(r), r.dtype, c, s, p, h, r.shape, i);
				return n.makeTensorInfo(l, r.dtype, f.values);
			},
		},
		bH = {
			kernelName: Dy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.indices,
					o = r.axis,
					s = r.batchDims;
				vU([a, i], "gatherV2");
				for (
					var u = jg(o, a.shape)[0],
						l = n.data.get(i.dataId).values,
						c = a.shape[u],
						p = function (e) {
							var t = l[e];
							Dg(t <= c - 1 && t >= 0, function () {
								return "GatherV2: the index value " + t + " is not in [0, " + (c - 1) + "]";
							});
						},
						h = 0;
					h < l.length;
					++h
				)
					p(h);
				var f = s;
				null == s && (f = 0);
				var d = zg(i.shape),
					m = h_(a, i, u, f),
					g = LG({
						inputs: { x: a },
						backend: n,
						attrs: { shape: [m.batchSize, m.outerSize, m.dimSize, m.sliceSize] },
					}),
					v = LG({ inputs: { x: i }, backend: n, attrs: { shape: [m.batchSize, d / m.batchSize] } }),
					y = [m.batchSize, m.outerSize, d / m.batchSize, m.sliceSize],
					b = n.bufferSync(v),
					x = oV(n.bufferSync(g), b, y);
				return (
					n.disposeIntermediateTensorInfo(g),
					n.disposeIntermediateTensorInfo(v),
					n.makeTensorInfo(m.outputShape, x.dtype, x.values)
				);
			},
		},
		xH = {
			kernelName: Py,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.input,
					a = zg(r.shape),
					i = r.shape[r.shape.length - 1],
					o = LG({ inputs: { x: r }, backend: n, attrs: { shape: [a / i, i] } }),
					s = oH(o, !0, n),
					u = LG({ inputs: { x: s }, backend: n, attrs: { shape: r.shape } });
				return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u;
			},
		},
		wH = UU(
			Wy,
			function (e) {
				return Number.isFinite(e) ? 1 : 0;
			},
			"bool"
		),
		kH = { kernelName: Wy, backendName: "cpu", kernelFunc: wH },
		NH = UU(
			Uy,
			function (e) {
				return Math.abs(e) === 1 / 0 ? 1 : 0;
			},
			"bool"
		),
		IH = { kernelName: Uy, backendName: "cpu", kernelFunc: NH },
		SH = UU(
			Vy,
			function (e) {
				return Number.isNaN(e) ? 1 : 0;
			},
			"bool"
		),
		TH = { kernelName: Vy, backendName: "cpu", kernelFunc: SH },
		CH = {
			kernelName: qy,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.backend,
					n = e.attrs,
					r = bV(n.start, n.stop, n.num);
				return t.makeTensorInfo([r.length], "float32", r);
			},
		},
		EH = UU(Xy, function (e) {
			return Math.log1p(e);
		}),
		RH = { kernelName: Xy, backendName: "cpu", kernelFunc: EH },
		AH = kU(function (e, t) {
			return e && t;
		}),
		_H = FU(Yy, AH, null, "bool"),
		FH = { kernelName: Yy, backendName: "cpu", kernelFunc: _H },
		DH = UU(
			Jy,
			function (e) {
				return e ? 0 : 1;
			},
			"bool"
		),
		OH = { kernelName: Jy, backendName: "cpu", kernelFunc: DH },
		MH = kU(function (e, t) {
			return e || t;
		}),
		LH = FU(Zy, MH, null, "bool"),
		zH = { kernelName: Zy, backendName: "cpu", kernelFunc: LH },
		PH = {
			kernelName: $y,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.depthRadius,
					o = r.bias,
					s = r.alpha,
					u = r.beta;
				vU(a, "LRN");
				var l = a.shape[3],
					c = l - 1,
					p = n.data.get(a.dataId).values,
					h = zg(a.shape),
					f = new Float32Array(h);
				function d(e) {
					for (
						var t = e % l, n = e - t + Math.max(0, t - i), r = e - t + Math.min(t + i, c), a = 0;
						n <= r;
						n++
					) {
						var o = p[n];
						a += o * o;
					}
					return a;
				}
				for (var m = 0; m < h; m++) {
					var g = d(m),
						v = p[m] * Math.pow(o + s * g, -u);
					f[m] = v;
				}
				return n.makeTensorInfo(a.shape, a.dtype, f);
			},
		},
		BH = {
			kernelName: eb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.y,
					o = t.dy,
					s = r.depthRadius,
					u = r.bias,
					l = r.alpha,
					c = r.beta;
				vU(o, "LRNGrad");
				for (
					var p = zg(o.shape),
						h = o.shape[3],
						f = n.data.get(o.dataId).values,
						d = n.data.get(a.dataId).values,
						m = n.data.get(i.dataId).values,
						g = new Float32Array(p),
						v = p,
						y = 0;
					y < v;
					y++
				) {
					for (
						var b = y % h, x = y - b + Math.max(0, b - s), w = y - b + Math.min(h, b + s + 1), k = 0, N = x;
						N < w;
						N++
					)
						k += Math.pow(d[N], 2);
					k = l * k + u;
					for (var I = x; I < w; I++) {
						var S = (-2 * l * c * d[I] * m[y]) / k;
						y === I && (S += Math.pow(k, -c)), (S *= f[y]), (g[I] += S);
					}
				}
				return n.makeTensorInfo(o.shape, a.dtype, g);
			},
		};
	function WH(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = r.reductionIndices,
			o = r.keepDims,
			s = n,
			u = a.shape,
			l = u.length,
			c = jg(i, u),
			p = c,
			h = YT(p, l),
			f = s.data.get(a.dataId).values;
		if (null != h) {
			for (var d = new Array(l), m = 0; m < d.length; m++) d[m] = u[h[m]];
			(f = BV(f, u, a.dtype, h, d)), (p = ZT(p.length, l)), (u = d);
		}
		vU(a, "max"), XT("max", p, l);
		var g = qT(u, p),
			v = g[0],
			y = NV(f, zg(g[1]), v, a.dtype),
			b = s.write(y, v, a.dtype),
			x = v;
		return o && (x = KT(v, c)), { dataId: b, shape: x, dtype: a.dtype };
	}
	var UH = { kernelName: tb, backendName: "cpu", kernelFunc: WH },
		VH = {
			kernelName: rb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x;
				vU(a, "maxPool");
				var i = r.filterSize,
					o = r.strides,
					s = r.pad,
					u = r.dimRoundingMode;
				Dg(yS(o, 1), function () {
					return (
						"Error in maxPool: Either strides or dilations must be 1. Got strides " +
						o +
						" and dilations '1'"
					);
				});
				var l,
					c = uS(a.shape, i, o, 1, s, u);
				if (1 === c.filterWidth && 1 === c.filterHeight && Pg(c.inShape, c.outShape))
					l = TU({ inputs: { x: a }, backend: n });
				else {
					var p = n.data.get(a.dataId).values,
						h = ov(a.shape),
						f = sj(p, a.shape, a.dtype, h, c, "max");
					l = n.makeTensorInfo(c.outShape, a.dtype, f.values);
				}
				return l;
			},
		},
		GH = {
			kernelName: ib,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.filterSize,
					o = r.strides,
					s = r.pad,
					u = r.dimRoundingMode,
					l = r.dataFormat;
				vU(a, "maxPool3d");
				var c = lS(a.shape, i, o, 1, s, u, l),
					p = lj(n.data.get(a.dataId).values, a.shape, a.dtype, ov(a.shape), c, "max");
				return n.makeTensorInfo(p.shape, "float32", p.values);
			},
		},
		jH = {
			kernelName: ob,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.input,
					o = r.filterSize,
					s = r.strides,
					u = r.pad,
					l = r.dimRoundingMode;
				vU([a, i], "maxPool3DGrad");
				for (
					var c = lS(i.shape, o, s, 1, u, l),
						p = (function (e, t) {
							for (
								var n = kN(t.outShape, "int32"),
									r = t.strideDepth,
									a = t.strideHeight,
									i = t.strideWidth,
									o = t.dilationDepth,
									s = t.dilationHeight,
									u = t.dilationWidth,
									l = t.effectiveFilterDepth,
									c = t.effectiveFilterHeight,
									p = t.effectiveFilterWidth,
									h = t.padInfo.front,
									f = t.padInfo.top,
									d = t.padInfo.left,
									m = 0;
								m < t.batchSize;
								++m
							)
								for (var g = 0; g < t.inChannels; ++g)
									for (var v = 0; v < t.outDepth; ++v) {
										for (var y = v * r - h, b = y; b < 0; ) b += o;
										for (var x = Math.min(t.inDepth, l + y), w = 0; w < t.outHeight; ++w) {
											for (var k = w * a - f, N = k; N < 0; ) N += s;
											for (var I = Math.min(t.inHeight, c + k), S = 0; S < t.outWidth; ++S) {
												for (var T = S * i - d, C = T; C < 0; ) C += u;
												for (
													var E = Math.min(t.inWidth, p + T),
														R = Number.NEGATIVE_INFINITY,
														A = -1,
														_ = b;
													_ < x;
													_ += o
												)
													for (var F = _ - y, D = N; D < I; D += s)
														for (var O = D - k, M = C; M < E; M += u) {
															var L = M - T,
																z = e.get(m, _, D, M, g);
															z >= R && ((R = z), (A = F * c * p + O * c + L));
														}
												n.set(A, m, v, w, S, g);
											}
										}
									}
							return n;
						})(n.bufferSync(i), c),
						h = c.strideDepth,
						f = c.strideHeight,
						d = c.strideWidth,
						m = c.dilationDepth,
						g = c.dilationHeight,
						v = c.dilationWidth,
						y = c.effectiveFilterDepth,
						b = c.effectiveFilterHeight,
						x = c.effectiveFilterWidth,
						w = y - 1 - c.padInfo.front,
						k = x - 1 - c.padInfo.left,
						N = b - 1 - c.padInfo.top,
						I = kN(i.shape, "float32"),
						S = n.bufferSync(a),
						T = 0;
					T < c.batchSize;
					++T
				)
					for (var C = 0; C < c.inChannels; ++C)
						for (var E = 0; E < c.inDepth; ++E)
							for (var R = 0; R < c.inHeight; ++R)
								for (var A = 0; A < c.inWidth; ++A) {
									for (var _ = E - w, F = R - N, D = A - k, O = 0, M = 0; M < y; M += m) {
										var L = (_ + M) / h;
										if (!(L < 0 || L >= c.outDepth || Math.floor(L) !== L))
											for (var z = 0; z < b; z += g) {
												var P = (F + z) / f;
												if (!(P < 0 || P >= c.outHeight || Math.floor(P) !== P))
													for (var B = 0; B < x; B += v) {
														var W = (D + B) / d;
														if (!(W < 0 || W >= c.outWidth || Math.floor(W) !== W)) {
															var U =
																y * b * x - 1 - p.get(T, L, P, W, C) ===
																M * b * x + z * x + B
																	? 1
																	: 0;
															0 !== U && (O += S.get(T, L, P, W, C) * U);
														}
													}
											}
									}
									I.set(O, T, E, R, A, C);
								}
				return n.makeTensorInfo(I.shape, I.dtype, I.values);
			},
		},
		HH = {
			kernelName: ab,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.input,
					o = i;
				vU([i, t.output], "maxPoolGrad");
				for (
					var s = r.filterSize,
						u = r.strides,
						l = r.pad,
						c = r.dimRoundingMode,
						p = uS(o.shape, s, u, 1, l, c),
						h = n.data.get(o.dataId).values,
						f = kN(p.outShape, o.dtype, uj(h, o.shape, o.dtype, p).values),
						d = p.strideHeight,
						m = p.strideWidth,
						g = p.dilationHeight,
						v = p.dilationWidth,
						y = p.effectiveFilterHeight,
						b = p.effectiveFilterWidth,
						x = b - 1 - p.padInfo.left,
						w = y - 1 - p.padInfo.top,
						k = kN(o.shape, "float32"),
						N = n.data.get(a.dataId).values,
						I = kN(a.shape, "float32", N),
						S = 0;
					S < p.batchSize;
					++S
				)
					for (var T = 0; T < p.inChannels; ++T)
						for (var C = 0; C < p.inHeight; ++C)
							for (var E = 0; E < p.inWidth; ++E) {
								for (var R = C - w, A = E - x, _ = 0, F = 0; F < y; F += g) {
									var D = (R + F) / d;
									if (!(D < 0 || D >= p.outHeight || Math.floor(D) !== D))
										for (var O = 0; O < b; O += v) {
											var M = (A + O) / m;
											if (!(M < 0 || M >= p.outWidth || Math.floor(M) !== M)) {
												var L = y * b - 1 - f.get(S, D, M, T) === F * b + O ? 1 : 0;
												0 !== L && (_ += I.get(S, D, M, T) * L);
											}
										}
								}
								k.set(_, S, C, E, T);
							}
				return n.makeTensorInfo(k.shape, k.dtype, k.values);
			},
		},
		qH = {
			kernelName: sb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.attrs,
					r = e.backend,
					a = t.x,
					i = n.filterSize,
					o = n.strides,
					s = n.pad,
					u = n.includeBatchInIndex,
					l = r;
				vU(a, "MaxPoolWithArgmax");
				var c = l.data.get(a.dataId).values,
					p = uS(a.shape, i, o, [1, 1], s),
					h = (function (e, t, n, r, a) {
						var i = sj(e, 0, n, ov(t), a, "max"),
							o = uj(e, t, n, a, !0, r);
						return [i.values, o.values];
					})(c, a.shape, a.dtype, u, p),
					f = h[0],
					d = h[1],
					m = l.write(f, p.outShape, a.dtype),
					g = l.write(d, p.outShape, a.dtype);
				return [
					{ dataId: m, shape: p.outShape, dtype: a.dtype },
					{ dataId: g, shape: p.outShape, dtype: "int32" },
				];
			},
		},
		KH = {
			kernelName: ub,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.keepDims,
					s = jg(i, a.shape),
					u = zg(qT(a.shape, s)[1]),
					l = [],
					c = n.makeTensorInfo([], "float32", new Float32Array([u]));
				l.push(c);
				var p = AU({ inputs: { x: a }, backend: n, attrs: { dtype: "float32" } });
				l.push(p);
				var h = aH({ inputs: { a: p, b: c }, backend: n });
				l.push(h);
				var f = Yj({ inputs: { x: h }, backend: n, attrs: { axis: i, keepDims: o } });
				return (
					l.forEach(function (e) {
						return n.disposeIntermediateTensorInfo(e);
					}),
					f
				);
			},
		},
		XH = {
			kernelName: lb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.keepDims;
				vU(a, "min");
				var s = jg(i, a.shape),
					u = s,
					l = YT(u, a.shape.length),
					c = a;
				null != l &&
					((c = WV({ inputs: { x: a }, backend: n, attrs: { perm: l } })),
					(u = ZT(u.length, a.shape.length))),
					XT("min", u, c.shape.length);
				for (
					var p = qT(c.shape, u),
						h = p[0],
						f = zg(p[1]),
						d = cv(zg(h), c.dtype),
						m = n.data.get(c.dataId).values,
						g = 0;
					g < d.length;
					++g
				) {
					for (var v = g * f, y = m[v], b = 0; b < f; ++b) {
						var x = m[v + b];
						(Number.isNaN(x) || x < y) && (y = x);
					}
					d[g] = y;
				}
				null != l && n.disposeIntermediateTensorInfo(c);
				var w = n.makeTensorInfo(h, c.dtype, d);
				if (o) {
					var k = LG({ inputs: { x: w }, backend: n, attrs: { shape: KT(h, s) } });
					return n.disposeIntermediateTensorInfo(w), k;
				}
				return w;
			},
		},
		YH = {
			kernelName: pb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.paddings,
					o = r.mode;
				vU(a, "mirrorPad");
				for (
					var s = i.map(function (e, t) {
							return e[0] + a.shape[t] + e[1];
						}),
						u = i.map(function (e) {
							return e[0];
						}),
						l = i.map(function (e, t) {
							return e[0] + a.shape[t];
						}),
						c = "reflect" === o ? 0 : 1,
						p = n.data.get(a.dataId).values,
						h = a.shape.length,
						f = ov(a.shape),
						d = zg(s),
						m = s.length,
						g = ov(s),
						v = qg(a.dtype, d),
						y = 0;
					y < d;
					y++
				) {
					for (var b = dv(y, m, g), x = 0; x < m; x++)
						b[x] < u[x] ? (b[x] = 2 * u[x] - b[x] - c) : b[x] >= l[x] && (b[x] = 2 * (l[x] - 1) - b[x] + c);
					var w = fv(
						(b = b.map(function (e, t) {
							return e - u[t];
						})),
						h,
						f
					);
					v[y] = p[w];
				}
				return { dataId: n.write(v, s, a.dtype), shape: s, dtype: a.dtype };
			},
		},
		JH = kU(function (e, t) {
			var n = e % t;
			return (e < 0 && t < 0) || (e >= 0 && t >= 0) ? n : (n + t) % t;
		}),
		ZH = FU(hb, JH),
		QH = { kernelName: hb, backendName: "cpu", kernelFunc: ZH };
	function $H(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.logits,
			i = r.dim,
			o = a.shape.length,
			s = i;
		if ((-1 === s && (s = o - 1), s !== o - 1))
			throw Error(
				"Softmax along a non-last dimension is not yet supported. Logits was rank " + o + " and dim was " + s
			);
		var u = jg([s], a.shape),
			l = WH({ inputs: { x: a }, backend: n, attrs: { reductionIndices: u, keepDims: !1 } }),
			c = KT(l.shape, u),
			p = LG({ inputs: { x: l }, backend: n, attrs: { shape: c } }),
			h = vG({ inputs: { a: a, b: p }, backend: n }),
			f = ZU({ inputs: { x: h }, backend: n }),
			d = Yj({ inputs: { x: f }, backend: n, attrs: { axis: u, keepDims: !1 } }),
			m = LG({ inputs: { x: d }, backend: n, attrs: { shape: c } }),
			g = aH({ inputs: { a: f, b: m }, backend: n });
		return (
			n.disposeIntermediateTensorInfo(l),
			n.disposeIntermediateTensorInfo(p),
			n.disposeIntermediateTensorInfo(h),
			n.disposeIntermediateTensorInfo(f),
			n.disposeIntermediateTensorInfo(d),
			n.disposeIntermediateTensorInfo(m),
			g
		);
	}
	var eq = { kernelName: $b, backendName: "cpu", kernelFunc: $H },
		tq = {
			kernelName: fb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.logits,
					i = r.numSamples,
					o = r.seed,
					s = r.normalized;
				vU(a, "multinomial");
				for (
					var u = s ? a : $H({ inputs: { logits: a }, backend: n, attrs: { dim: -1 } }),
						l = u.shape[0],
						c = u.shape[1],
						p = n.data.get(u.dataId).values,
						h = [l, i],
						f = cv(zg(h), "int32"),
						d = 0;
					d < l;
					++d
				) {
					var m = d * c,
						g = new Float32Array(c - 1);
					g[0] = p[m];
					for (var v = 1; v < g.length; ++v) g[v] = g[v - 1] + p[m + v];
					for (var y = WC(o.toString()), b = d * i, x = 0; x < i; ++x) {
						var w = y();
						f[b + x] = g.length;
						for (var k = 0; k < g.length; k++)
							if (w < g[k]) {
								f[b + x] = k;
								break;
							}
					}
				}
				return s || n.disposeIntermediateTensorInfo(u), n.makeTensorInfo(h, "int32", f);
			},
		},
		nq = TR,
		rq = {
			kernelName: vb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.boxes,
					i = t.scores,
					o = r.maxOutputSize,
					s = r.iouThreshold,
					u = r.scoreThreshold;
				vU(a, "NonMaxSuppression");
				var l = n.data.get(a.dataId).values,
					c = n.data.get(i.dataId).values,
					p = nq(l, c, o, s, u).selectedIndices;
				return n.makeTensorInfo([p.length], "int32", new Int32Array(p));
			},
		},
		aq = CR,
		iq = {
			kernelName: yb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.boxes,
					i = t.scores,
					o = r.maxOutputSize,
					s = r.iouThreshold,
					u = r.scoreThreshold,
					l = r.padToMaxOutputSize;
				vU(a, "NonMaxSuppressionPadded");
				var c = n.data.get(a.dataId).values,
					p = n.data.get(i.dataId).values,
					h = aq(c, p, o, s, u, l),
					f = h.selectedIndices,
					d = h.validOutputs;
				return [
					n.makeTensorInfo([f.length], "int32", new Int32Array(f)),
					n.makeTensorInfo([], "int32", new Int32Array([d])),
				];
			},
		},
		oq = ER,
		sq = {
			kernelName: bb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.boxes,
					i = t.scores,
					o = r.maxOutputSize,
					s = r.iouThreshold,
					u = r.scoreThreshold,
					l = r.softNmsSigma;
				vU(a, "NonMaxSuppressionWithScore");
				var c = n.data.get(a.dataId).values,
					p = n.data.get(i.dataId).values,
					h = oq(c, p, o, s, u, l),
					f = h.selectedIndices,
					d = h.selectedScores;
				return [
					n.makeTensorInfo([f.length], "int32", new Int32Array(f)),
					n.makeTensorInfo([d.length], "float32", new Float32Array(d)),
				];
			},
		},
		uq = {
			kernelName: wb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.indices,
					i = r.depth,
					o = r.onValue,
					s = r.offValue;
				vU(a, "oneHot");
				var u = zg(a.shape),
					l = new Float32Array(u * i);
				l.fill(s);
				for (var c = n.data.get(a.dataId).values, p = 0; p < u; ++p)
					c[p] >= 0 && c[p] < i && (l[p * i + c[p]] = o);
				return n.makeTensorInfo([].concat(a.shape, [i]), "int32", l);
			},
		};
	function lq(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.x;
		if ("string" === r.dtype) throw new Error("zerosLike is not supported for string tensors");
		if ("complex64" === r.dtype) {
			var a = EU({ inputs: { input: r }, backend: n }),
				i = lq({ inputs: { x: a }, backend: n }),
				o = wj({ inputs: { input: r }, backend: n }),
				s = lq({ inputs: { x: o }, backend: n }),
				u = NU({ inputs: { real: i, imag: s }, backend: n });
			return (
				n.disposeIntermediateTensorInfo(a),
				n.disposeIntermediateTensorInfo(i),
				n.disposeIntermediateTensorInfo(o),
				n.disposeIntermediateTensorInfo(s),
				u
			);
		}
		return cH({ backend: n, attrs: { shape: r.shape, value: 0, dtype: r.dtype } });
	}
	var cq = { kernelName: wx, backendName: "cpu", kernelFunc: lq },
		pq = {
			kernelName: xb,
			backendName: "cpu",
			kernelFunc: function e(t) {
				var n = t.inputs,
					r = t.backend,
					a = n.x;
				if ("string" === a.dtype) throw new Error("onesLike is not supported for string tensors");
				if ("complex64" === a.dtype) {
					var i = EU({ inputs: { input: a }, backend: r }),
						o = e({ inputs: { x: i }, backend: r }),
						s = wj({ inputs: { input: a }, backend: r }),
						u = lq({ inputs: { x: s }, backend: r }),
						l = NU({ inputs: { real: o, imag: u }, backend: r });
					return (
						r.disposeIntermediateTensorInfo(i),
						r.disposeIntermediateTensorInfo(o),
						r.disposeIntermediateTensorInfo(s),
						r.disposeIntermediateTensorInfo(u),
						l
					);
				}
				return cH({ backend: r, attrs: { shape: a.shape, value: 1, dtype: a.dtype } });
			},
		};
	function hq(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs.axis;
		if (1 === t.length) return tH({ inputs: { input: t[0] }, backend: n, attrs: { dim: r } });
		var a = t[0].shape,
			i = t[0].dtype;
		t.forEach(function (e) {
			Og(a, e.shape, "All tensors passed to stack must have matching shapes"),
				Dg(i === e.dtype, function () {
					return "All tensors passed to stack must have matching dtypes";
				});
		});
		var o = [],
			s = Nj({
				inputs: t.map(function (e) {
					var t = tH({ inputs: { input: e }, backend: n, attrs: { dim: r } });
					return o.push(t), t;
				}),
				backend: n,
				attrs: { axis: r },
			});
		return (
			o.forEach(function (e) {
				return n.disposeIntermediateTensorInfo(e);
			}),
			s
		);
	}
	var fq = { kernelName: kb, backendName: "cpu", kernelFunc: hq },
		dq = {
			kernelName: Nb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.paddings,
					o = r.constantValue;
				vU(a, "pad");
				var s = i.map(function (e, t) {
						return e[0] + a.shape[t] + e[1];
					}),
					u = i.map(function (e) {
						return e[0];
					}),
					l = n.data.get(a.dataId).values,
					c = zg(a.shape),
					p = a.shape.length,
					h = ov(a.shape),
					f = zg(s),
					d = s.length,
					m = ov(s),
					g = qg(a.dtype, f);
				0 !== o && g.fill(o);
				for (var v = 0; v < c; v++)
					g[
						fv(
							dv(v, p, h).map(function (e, t) {
								return e + u[t];
							}),
							d,
							m
						)
					] = l[v];
				return { dataId: n.write(g, s, a.dtype), shape: s, dtype: a.dtype };
			},
		},
		mq = kU(function (e, t) {
			return Math.pow(e, t);
		}),
		gq = FU(Ib, mq),
		vq = { kernelName: Ib, backendName: "cpu", kernelFunc: gq },
		yq = {
			kernelName: Cb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.backend,
					n = e.attrs,
					r = n.start,
					a = n.stop,
					i = n.dtype,
					o = jV(r, a, n.step, i);
				return t.makeTensorInfo([o.length], i, o);
			},
		},
		bq = UU(Rb, function (e) {
			return 1 / e;
		}),
		xq = { kernelName: Rb, backendName: "cpu", kernelFunc: bq },
		wq = {
			kernelName: Ob,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.images,
					i = r.alignCorners,
					o = r.halfPixelCenters,
					s = r.size;
				vU(a, "resizeBilinear");
				for (
					var u = ov(a.shape),
						l = s[0],
						c = s[1],
						p = a.shape,
						h = p[0],
						f = p[1],
						d = p[2],
						m = p[3],
						g = n.data.get(a.dataId).values,
						v = new Float32Array(zg([h, l, c, m])),
						y = [i && l > 1 ? f - 1 : f, i && c > 1 ? d - 1 : d],
						b = [i && l > 1 ? l - 1 : l, i && c > 1 ? c - 1 : c],
						x = 0,
						w = y[0] / b[0],
						k = y[1] / b[1],
						N = 0;
					N < h;
					N++
				)
					for (var I = 0; I < l; I++) {
						var S;
						S = o ? w * (I + 0.5) - 0.5 : w * I;
						for (
							var T = Math.max(0, Math.floor(S)),
								C = S - T,
								E = Math.min(f - 1, Math.ceil(S)),
								R = N * u[0] + T * u[1],
								A = N * u[0] + E * u[1],
								_ = 0;
							_ < c;
							_++
						) {
							var F;
							F = o ? k * (_ + 0.5) - 0.5 : k * _;
							for (
								var D = Math.max(0, Math.floor(F)),
									O = F - D,
									M = Math.min(d - 1, Math.ceil(F)),
									L = R + D * u[2],
									z = A + D * u[2],
									P = R + M * u[2],
									B = A + M * u[2],
									W = 0;
								W < m;
								W++
							) {
								var U = g[L + W],
									V = g[z + W],
									G = U + (g[P + W] - U) * O,
									j = G + (V + (g[B + W] - V) * O - G) * C;
								v[x++] = j;
							}
						}
					}
				return n.makeTensorInfo([h, l, c, m], "float32", v);
			},
		},
		kq = {
			kernelName: Mb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.images,
					i = t.dy,
					o = r.alignCorners;
				vU([i, a], "resizeBilinearGrad");
				for (
					var s = ov(a.shape),
						u = a.shape,
						l = u[0],
						c = u[1],
						p = u[2],
						h = u[3],
						f = i.shape,
						d = f[1],
						m = f[2],
						g = new Float32Array(l * c * p * h),
						v = [o && d > 1 ? c - 1 : c, o && m > 1 ? p - 1 : p],
						y = [o && d > 1 ? d - 1 : d, o && m > 1 ? m - 1 : m],
						b = v[0] / y[0],
						x = v[1] / y[1],
						w = n.data.get(i.dataId).values,
						k = 0,
						N = 0;
					N < l;
					N++
				)
					for (var I = N * s[0], S = 0; S < d; S++)
						for (
							var T = S * b,
								C = Math.floor(T),
								E = Math.min(Math.ceil(T), c - 1),
								R = I + C * s[1],
								A = I + E * s[1],
								_ = T - C,
								F = 1 - _,
								D = 0;
							D < m;
							D++
						)
							for (
								var O = D * x,
									M = Math.floor(O),
									L = Math.min(Math.ceil(O), p - 1),
									z = O - M,
									P = 1 - z,
									B = R + M * s[2],
									W = R + L * s[2],
									U = A + M * s[2],
									V = A + L * s[2],
									G = F * P,
									j = F * z,
									H = _ * P,
									q = _ * z,
									K = 0;
								K < h;
								K++
							) {
								var X = w[k++];
								(g[B + K] += X * G), (g[W + K] += X * j), (g[U + K] += X * H), (g[V + K] += X * q);
							}
				return n.makeTensorInfo([l, p, c, h], "float32", g);
			},
		},
		Nq = {
			kernelName: Fb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.images,
					i = r.alignCorners,
					o = r.halfPixelCenters,
					s = r.size;
				vU(a, "resizeNearestNeighbor");
				for (
					var u = ov(a.shape),
						l = s[0],
						c = s[1],
						p = a.shape,
						h = p[0],
						f = p[1],
						d = p[2],
						m = p[3],
						g = n.data.get(a.dataId).values,
						v = new Float32Array(h * l * c * m),
						y = [i && l > 1 ? f - 1 : f, i && c > 1 ? d - 1 : d],
						b = [i && l > 1 ? l - 1 : l, i && c > 1 ? c - 1 : c],
						x = y[0] / b[0],
						w = y[1] / b[1],
						k = 0,
						N = 0;
					N < h;
					N++
				)
					for (var I = N * u[0], S = 0; S < l; S++) {
						var T = o ? x * (S + 0.5) : x * S,
							C = Math.min(f - 1, i ? Math.round(T) : Math.floor(T));
						o && (C = Math.max(0, C));
						for (var E = I + C * u[1], R = 0; R < c; R++) {
							var A = o ? w * (R + 0.5) : w * R,
								_ = Math.min(d - 1, i ? Math.round(A) : Math.floor(A));
							o && (_ = Math.max(0, _));
							for (var F = E + _ * u[2], D = 0; D < m; D++) {
								var O = g[F + D];
								v[k++] = O;
							}
						}
					}
				return n.makeTensorInfo([h, l, c, m], a.dtype, v);
			},
		},
		Iq = {
			kernelName: Db,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.images,
					i = t.dy,
					o = r.alignCorners;
				vU([i, a], "resizeNearestNeighborGrad");
				for (
					var s = ov(a.shape),
						u = ov(i.shape),
						l = a.shape,
						c = l[0],
						p = l[1],
						h = l[2],
						f = l[3],
						d = i.shape,
						m = d[1],
						g = d[2],
						v = new Float32Array(c * p * h * f),
						y = n.data.get(i.dataId).values,
						b = [o && m > 1 ? p - 1 : p, o && g > 1 ? h - 1 : h],
						x = [o && m > 1 ? m - 1 : m, o && g > 1 ? g - 1 : g],
						w = b[0] / x[0],
						k = b[1] / x[1],
						N = 1 / w,
						I = 1 / k,
						S = 2 * Math.ceil(N) + 2,
						T = 2 * Math.ceil(I) + 2,
						C = 0;
					C < c;
					C++
				)
					for (var E = C * s[0], R = 0; R < p; R++)
						for (var A = E + R * s[1], _ = Math.floor(R * N), F = Math.floor(_ - S / 2), D = 0; D < h; D++)
							for (
								var O = A + D * s[2], M = Math.floor(D * I), L = Math.floor(M - T / 2), z = 0;
								z < f;
								z++
							) {
								for (var P = 0, B = 0; B < S; B++) {
									var W = B + F;
									if (!(W < 0 || W >= m)) {
										var U = E + W * u[1],
											V = W * w;
										if (R === Math.min(p - 1, o ? Math.round(V) : Math.floor(V)))
											for (var G = 0; G < T; G++) {
												var j = G + L;
												if (!(j < 0 || j >= g)) {
													var H = U + j * u[2],
														q = j * k;
													D === Math.min(h - 1, o ? Math.round(q) : Math.floor(q)) &&
														(P += y[H + z]);
												}
											}
									}
								}
								v[O + z] = P;
							}
				return n.makeTensorInfo(a.shape, a.dtype, v);
			},
		},
		Sq = {
			kernelName: zb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.dims;
				vU(a, "reverse");
				var o = a.shape.length,
					s = jg(i, a.shape);
				if (0 === o) return TU({ inputs: { x: a }, backend: n });
				for (
					var u = new Mw(a.shape, a.dtype),
						l = n.bufferSync(a),
						c = function (e) {
							var t = u.indexToLoc(e),
								n = t.slice();
							s.forEach(function (e) {
								return (n[e] = a.shape[e] - 1 - n[e]);
							}),
								u.set.apply(u, [l.get.apply(l, n)].concat(t));
						},
						p = 0;
					p < u.size;
					p++
				)
					c(p);
				return n.makeTensorInfo(u.shape, u.dtype, u.values);
			},
		},
		Tq = {
			kernelName: Ix,
			backendName: "cpu",
			kernelFunc: function (e) {
				for (
					var t = e.inputs,
						n = e.attrs,
						r = e.backend,
						a = t.image,
						i = n.radians,
						o = n.fillValue,
						s = n.center,
						u = r,
						l = qg(a.dtype, zg(a.shape)),
						c = a.shape,
						p = c[0],
						h = c[1],
						f = c[2],
						d = c[3],
						m = _A(s, h, f),
						g = m[0],
						v = m[1],
						y = Math.sin(i),
						b = Math.cos(i),
						x = u.data.get(a.dataId).values,
						w = 0;
					w < p;
					w++
				)
					for (var k = w * f * h * d, N = 0; N < h; N++)
						for (var I = N * (f * d), S = 0; S < f; S++)
							for (var T = S * d, C = 0; C < d; C++) {
								var E = [p, N, S, C],
									R = E[2],
									A = E[1],
									_ = (R - g) * b - (A - v) * y,
									F = (R - g) * y + (A - v) * b;
								(_ = Math.round(_ + g)), (F = Math.round(F + v));
								var D = o;
								"number" != typeof o && (D = 3 === C ? 255 : o[C]),
									_ >= 0 && _ < f && F >= 0 && F < h && (D = x[k + F * (f * d) + _ * d + C]),
									(l[k + I + T + C] = D);
							}
				return { dataId: u.write(l, a.shape, a.dtype), shape: a.shape, dtype: a.dtype };
			},
		},
		Cq = UU(Pb, function (e) {
			var t = Math.floor(e);
			return e - t < 0.5 ? Math.floor(e) : e - t > 0.5 ? Math.ceil(e) : t % 2 == 0 ? t : t + 1;
		}),
		Eq = { kernelName: Pb, backendName: "cpu", kernelFunc: Cq };
	function Rq(e, t, n, r, a, i, o, s, u, l) {
		var c = [r / a, a],
			p = e.values,
			h = t.values;
		if (0 === r) return kN(n, t.dtype);
		var f = kN(c, t.dtype);
		f.values.fill(u);
		for (var d = 0; d < i; d++) {
			for (var m = [], g = 0, v = 0; v < o; v++) {
				var y = p[d * o + v];
				m.push(y), (g += y * s[v]);
			}
			if (g < 0 || g >= r / a) throw new Error("Invalid indices: " + m + " does not index into " + n);
			for (var b = 0; b < a; b++)
				l ? (f.values[g * a + b] += h[d * a + b]) : (f.values[g * a + b] = 0 === t.rank ? h[0] : h[d * a + b]);
		}
		return f;
	}
	var Aq = {
			kernelName: Wb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.indices,
					i = t.updates,
					o = r.shape,
					s = cI(0, a, o),
					u = s.sliceRank,
					l = s.numUpdates,
					c = s.sliceSize,
					p = s.strides,
					h = s.outputSize,
					f = Rq(n.bufferSync(a), n.bufferSync(i), o, h, c, l, u, p, 0, !0);
				return n.makeTensorInfo(o, f.dtype, f.values);
			},
		},
		_q = {
			kernelName: Ub,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.condition,
					a = t.t,
					i = t.e;
				vU([r, a, i], "select");
				for (
					var o = r.shape.length,
						s = n.data.get(r.dataId).values,
						u = n.data.get(a.dataId).values,
						l = n.data.get(i.dataId).values,
						c = Kw(a.dtype, i.dtype),
						p = cv(zg(a.shape), c),
						h = 0,
						f = 0 === o || o > 1 || 1 === a.shape.length ? 1 : zg(a.shape.slice(1)),
						d = 0;
					d < s.length;
					d++
				)
					for (var m = 0; m < f; m++) 1 === s[d] ? (p[h++] = u[d]) : (p[h++] = l[d]);
				return n.makeTensorInfo(a.shape, c, p);
			},
		},
		Fq = UU(Vb, function (e) {
			return e >= 0 ? 1.0507009873554805 * e : 1.7580993408473768 * (Math.exp(e) - 1);
		}),
		Dq = { kernelName: Vb, backendName: "cpu", kernelFunc: Fq },
		Oq = UU(qb, function (e) {
			return e < 0 ? -1 : e > 0 ? 1 : 0;
		}),
		Mq = { kernelName: qb, backendName: "cpu", kernelFunc: Oq },
		Lq = UU(jb, function (e) {
			return Math.sin(e);
		}),
		zq = { kernelName: jb, backendName: "cpu", kernelFunc: Lq },
		Pq = UU(Hb, function (e) {
			return Math.sinh(e);
		}),
		Bq = { kernelName: Hb, backendName: "cpu", kernelFunc: Pq },
		Wq = Math.log(1.1920928955078125e-7) + 2,
		Uq = UU(Xb, function (e) {
			var t = e > -Wq,
				n = e < Wq,
				r = Math.exp(e);
			return n ? r : t ? e : Math.log(1 + r);
		}),
		Vq = { kernelName: Xb, backendName: "cpu", kernelFunc: Uq },
		Gq = {
			kernelName: Zb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.blockShape,
					o = r.paddings;
				vU([a], "spaceToBatchND");
				var s = zg(i),
					u = [[0, 0]];
				u.push.apply(u, o);
				for (var l = 1 + i.length; l < a.shape.length; ++l) u.push([0, 0]);
				var c = dq.kernelFunc({ inputs: { x: a }, backend: n, attrs: { paddings: u, constantValue: 0 } }),
					p = FA(c.shape, i, s, !1),
					h = DA(p.length, i.length, !1),
					f = OA(c.shape, i, s, !1),
					d = LG({ inputs: { x: c }, backend: n, attrs: { shape: p } }),
					m = WV({ inputs: { x: d }, backend: n, attrs: { perm: h } }),
					g = LG({ inputs: { x: m }, backend: n, attrs: { shape: f } });
				return (
					n.disposeIntermediateTensorInfo(c),
					n.disposeIntermediateTensorInfo(d),
					n.disposeIntermediateTensorInfo(m),
					g
				);
			},
		},
		jq = {
			kernelName: ex,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.indices,
					a = t.values,
					i = t.denseShape,
					o = t.defaultValue;
				if (1 !== i.shape.length) throw new Error("Dense shape must be a vector, saw:\n        " + i.shape);
				if (2 !== r.shape.length) throw new Error("Indices must be a matrix, saw:\n        " + r.shape);
				if (1 !== a.shape.length) throw new Error("Values must be a vector, saw:\n        " + a.shape);
				if (0 !== o.shape.length) throw new Error("Default value must be a scalar, saw:\n        " + o.shape);
				var s = n.data.get(r.dataId).values,
					u = n.data.get(a.dataId).values,
					l = n.data.get(i.dataId).values,
					c = n.data.get(o.dataId).values[0],
					p = eG(s, r.shape, r.dtype, u, a.dtype, l, c),
					h = p[0],
					f = p[1],
					d = p[2],
					m = p[3],
					g = p[4];
				return [
					n.makeTensorInfo(f, r.dtype, h),
					n.makeTensorInfo([f[0]], a.dtype, d),
					n.makeTensorInfo(
						[m.length],
						"bool",
						new Uint8Array(
							m.map(function (e) {
								return Number(e);
							})
						)
					),
					n.makeTensorInfo([g.length], r.dtype, new Int32Array(g)),
				];
			},
		},
		Hq = {
			kernelName: tx,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.inputIndices,
					a = t.inputShape,
					i = t.newShape;
				if (2 !== r.shape.length)
					throw new Error("Input indices should be a matrix but received shape\n        " + r.shape);
				if (1 !== a.shape.length)
					throw new Error("Input shape should be a vector but received shape\n        " + a.shape);
				if (1 !== i.shape.length)
					throw new Error("Target shape should be a vector but received shape " + i.shape);
				var o = Array.from(n.data.get(a.dataId).values),
					s = n.data.get(r.dataId).values,
					u = Array.from(n.data.get(i.dataId).values),
					l = tG(s, r.shape, r.dtype, o, u),
					c = l[0],
					p = l[1],
					h = l[2];
				return [n.makeTensorInfo(p, r.dtype, c), n.makeTensorInfo([h.length], i.dtype, new Int32Array(h))];
			},
		},
		qq = {
			kernelName: nx,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.data,
					a = t.indices,
					i = t.segmentIds;
				if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
				if (1 !== a.shape.length)
					throw new Error("Indices should be a vector but received shape\n          " + a.shape);
				if (1 !== i.shape.length)
					throw new Error("Segment ids should be a vector but received shape\n          " + i.shape);
				if (a.shape[0] !== i.shape[0]) throw new Error("segmentIds and indices should have same size.");
				var o = n.data.get(r.dataId).values,
					s = n.data.get(a.dataId).values,
					u = n.data.get(i.dataId).values,
					l = nG(o, r.shape, r.dtype, s, u, !0),
					c = l[0],
					p = l[1];
				return n.makeTensorInfo(p, r.dtype, c);
			},
		},
		Kq = {
			kernelName: rx,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.data,
					a = t.indices,
					i = t.segmentIds;
				if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
				if (1 !== a.shape.length)
					throw new Error("Indices should be a vector but received shape\n         " + a.shape);
				if (1 !== i.shape.length)
					throw new Error("Segment ids should be a vector but received shape\n         " + i.shape);
				if (a.shape[0] !== i.shape[0]) throw new Error("segmentIds and indices should have same size.");
				var o = n.data.get(r.dataId).values,
					s = n.data.get(a.dataId).values,
					u = n.data.get(i.dataId).values,
					l = nG(o, r.shape, r.dtype, s, u),
					c = l[0],
					p = l[1];
				return n.makeTensorInfo(p, r.dtype, c);
			},
		},
		Xq = {
			kernelName: ax,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.sparseIndices,
					i = t.sparseValues,
					o = t.defaultValue,
					s = r.outputShape,
					u = cI(0, a, s),
					l = u.sliceRank,
					c = u.numUpdates,
					p = u.sliceSize,
					h = u.strides,
					f = u.outputSize,
					d = Rq(n.bufferSync(a), n.bufferSync(i), s, f, p, c, l, h, n.data.get(o.dataId).values[0], !1);
				return n.makeTensorInfo(s, d.dtype, d.values);
			},
		},
		Yq = {
			kernelName: Qb,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.numOrSizeSplits,
					o = jg(r.axis, a.shape)[0],
					s = e_(a, i, o),
					u = new Array(a.shape.length).fill(0),
					l = a.shape.slice();
				return s.map(function (e) {
					var t = [].concat(l);
					t[o] = e;
					var r = QV({ inputs: { x: a }, backend: n, attrs: { begin: u, size: t } });
					return (u[o] += e), r;
				});
			},
		},
		Jq = {
			kernelName: ox,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.x,
					a = n;
				vU(r, "square");
				for (var i = a.data.get(r.dataId).values, o = new Float32Array(i.length), s = 0; s < i.length; ++s) {
					var u = i[s];
					o[s] = u * u;
				}
				return { dataId: a.write(o, r.shape, r.dtype), shape: r.shape, dtype: r.dtype };
			},
		},
		Zq = UU(kx, function (e, t) {
			var n = t;
			return isNaN(e) ? NaN : e > 0 ? 1 : n.alpha;
		}),
		Qq = { kernelName: kx, backendName: "cpu", kernelFunc: Zq },
		$q = {
			kernelName: sx,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.begin,
					o = r.end,
					s = r.strides,
					u = r.beginMask,
					l = r.endMask,
					c = r.ellipsisMask,
					p = r.newAxisMask,
					h = r.shrinkAxisMask;
				vU(a, "stridedSlice");
				var f,
					d = SI(a.shape, i, o, s, u, l, c, p, h),
					m = d.finalShapeSparse,
					g = d.finalShape,
					v = d.isIdentity,
					y = d.sliceDim0,
					b = d.isSimpleSlice,
					x = d.begin,
					w = d.end,
					k = d.strides;
				if (v) f = LG({ inputs: { x: a }, backend: n, attrs: { shape: g } });
				else if (y || b) {
					Dg(a.shape.length >= 1, function () {
						return "Input must have rank at least 1, got: " + a.shape.length;
					});
					var N = fI(x, w, k),
						I = QV({ inputs: { x: a }, backend: n, attrs: { begin: x, size: N } });
					(f = LG({ inputs: { x: I }, backend: n, attrs: { shape: g } })), n.disposeIntermediateTensorInfo(I);
				} else {
					var S = lG(m, n.bufferSync(a), k, x);
					f = n.makeTensorInfo(g, S.dtype, S.values);
				}
				return f;
			},
		},
		eK = {
			kernelName: ux,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = r.separator,
					i = r.nGramWidths,
					o = r.leftPad,
					s = r.rightPad,
					u = r.padWidth,
					l = r.preserveShortSequences,
					c = t.data,
					p = t.dataSplits,
					h = pG(n.data.get(c.dataId).values, n.data.get(p.dataId).values, a, i, o, s, u, l),
					f = h[0],
					d = h[1];
				return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(p.shape, "int32", d)];
			},
		},
		tK = {
			kernelName: lx,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs.skipEmpty,
					a = t.input,
					i = t.delimiter;
				if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
				if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: " + a.shape);
				if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: " + i.shape);
				var o = fG(n.data.get(a.dataId).values, n.data.get(i.dataId).values[0], r),
					s = o[0],
					u = o[1],
					l = o[2],
					c = u.length;
				return [
					n.makeTensorInfo([c, 2], "int32", s),
					n.makeTensorInfo([c], "string", u),
					n.makeTensorInfo([2], "int32", new Int32Array(l)),
				];
			},
		},
		nK = {
			kernelName: cx,
			backendName: "cpu",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs.numBuckets,
					a = t.input;
				if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
				if (r <= 0) throw new Error("Number of buckets must be at least 1");
				var i = dG(n.data.get(a.dataId).values, r);
				return n.makeTensorInfo(a.shape, "int32", i);
			},
		},
		rK = UU(hx, function (e) {
			return Math.tan(e);
		}),
		aK = { kernelName: hx, backendName: "cpu", kernelFunc: rK },
		iK = UU(fx, function (e) {
			return Math.tanh(e);
		});
	function oK(e, t, n) {
		switch (n) {
			case "reflect":
				return (function (e, t) {
					var n = e;
					if (n < 0)
						if (t <= 1) n = 0;
						else {
							var r = 2 * t;
							n < r && (n = r * Math.trunc(-n / r) + n), (n = n < -t ? n + r : -n - 1);
						}
					else if (n > t - 1)
						if (t <= 1) n = 0;
						else {
							var a = 2 * t;
							(n -= a * Math.trunc(n / a)) >= t && (n = a - n - 1);
						}
					return Rg(0, n, t - 1);
				})(e, t);
			case "wrap":
				return (function (e, t) {
					var n = e;
					if (n < 0)
						if (t <= 1) n = 0;
						else {
							var r = t - 1;
							n += t * (Math.trunc(-n / r) + 1);
						}
					else if (n > t - 1)
						if (t <= 1) n = 0;
						else {
							var a = t - 1;
							n -= t * Math.trunc(n / a);
						}
					return Rg(0, n, t - 1);
				})(e, t);
			case "nearest":
				return (function (e, t) {
					return Rg(0, e, t - 1);
				})(e, t);
			default:
				return (function (e, t) {
					return e;
				})(e);
		}
	}
	function sK(e, t, n, r, a, i, o, s, u, l, c) {
		return 0 <= s && s < t && 0 <= u && u < n ? e[o * r + s * a + u * i + l] : c;
	}
	function uK(e, t, n, r, a, i, o, s, u, l, c) {
		return sK(e, t, n, r, a, i, o, Math.round(s), Math.round(u), l, c);
	}
	function lK(e, t, n, r, a, i, o, s, u, l, c) {
		var p = Math.floor(s),
			h = Math.floor(u),
			f = p + 1,
			d = h + 1;
		return (
			(f - s) * ((d - u) * sK(e, t, n, r, a, i, o, p, h, l, c) + (u - h) * sK(e, t, n, r, a, i, o, p, d, l, c)) +
			(s - p) * ((d - u) * sK(e, t, n, r, a, i, o, f, h, l, c) + (u - h) * sK(e, t, n, r, a, i, o, f, d, l, c))
		);
	}
	for (
		var cK = 0,
			pK = [
				WG,
				wU,
				VG,
				jG,
				zU,
				HG,
				qG,
				KG,
				XG,
				YG,
				ZG,
				$G,
				tj,
				aj,
				oj,
				cj,
				pj,
				hj,
				fj,
				BG,
				dj,
				mj,
				gj,
				vj,
				_U,
				HU,
				bj,
				IU,
				xj,
				Ij,
				Tj,
				Cj,
				Ej,
				Rj,
				Aj,
				_j,
				Dj,
				Mj,
				Lj,
				zj,
				Pj,
				Bj,
				Wj,
				Vj,
				Gj,
				jj,
				Hj,
				qj,
				Kj,
				Xj,
				Zj,
				SG,
				Qj,
				YU,
				eH,
				QU,
				nH,
				tV,
				lH,
				pH,
				hH,
				aV,
				mH,
				gH,
				vH,
				yH,
				bH,
				lV,
				hV,
				CU,
				xH,
				kj,
				kH,
				IH,
				TH,
				CG,
				mV,
				yV,
				CH,
				kV,
				RH,
				FH,
				OH,
				zH,
				PH,
				BH,
				UH,
				TV,
				VH,
				GH,
				jH,
				HH,
				qH,
				KH,
				XH,
				RV,
				YH,
				QH,
				tq,
				DV,
				MV,
				rq,
				iq,
				sq,
				PV,
				uq,
				pq,
				fq,
				dq,
				vq,
				AG,
				GV,
				yq,
				RU,
				iH,
				xq,
				FG,
				OG,
				zG,
				wq,
				kq,
				Nq,
				Iq,
				Sq,
				Tq,
				Eq,
				KV,
				Aq,
				_q,
				Dq,
				JV,
				Mq,
				zq,
				Bq,
				$V,
				eq,
				Vq,
				Gq,
				jq,
				Hq,
				qq,
				Kq,
				Xq,
				Yq,
				iG,
				Jq,
				uG,
				Qq,
				$q,
				eK,
				tK,
				nK,
				yG,
				Jj,
				aK,
				{ kernelName: fx, backendName: "cpu", kernelFunc: iK },
				{
					kernelName: dx,
					backendName: "cpu",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.backend,
							r = e.attrs,
							a = t.x,
							i = r.reps;
						vU(a, "tile");
						var o = bG(n.bufferSync(a), i);
						return n.makeTensorInfo(o.shape, o.dtype, o.values);
					},
				},
				{
					kernelName: mx,
					backendName: "cpu",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.backend,
							r = e.attrs,
							a = t.x,
							i = r.k,
							o = r.sorted;
						vU(a, "topk");
						var s = kG(n.data.get(a.dataId).values, a.shape, a.dtype, i, o),
							u = s[0],
							l = s[1];
						return [
							n.makeTensorInfo(u.shape, u.dtype, u.values),
							n.makeTensorInfo(l.shape, l.dtype, l.values),
						];
					},
				},
				{
					kernelName: gx,
					backendName: "cpu",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.attrs,
							r = e.backend,
							a = t.image,
							i = t.transforms,
							o = n.interpolation,
							s = n.fillMode,
							u = n.fillValue,
							l = n.outputShape,
							c = a.shape,
							p = c[0],
							h = c[1],
							f = c[2],
							d = c[3],
							m = null != l ? l : [h, f],
							g = m[0],
							v = m[1],
							y = [p, g, v, d],
							b = ov(a.shape),
							x = b[0],
							w = b[1],
							k = b[2],
							N = qg(a.dtype, zg(y));
						N.fill(u);
						for (var I = r.data.get(a.dataId).values, S = r.data.get(i.dataId).values, T = 0; T < p; ++T) {
							for (var C = 1 === i.shape[0] ? S : S.subarray(8 * T, 8 * T + 8), E = 0; E < g; ++E)
								for (var R = 0; R < v; ++R)
									for (var A = 0; A < d; ++A) {
										var _ = void 0,
											F = C[6] * R + C[7] * E + 1;
										if (0 !== F) {
											var D = (C[0] * R + C[1] * E + C[2]) / F,
												O = (C[3] * R + C[4] * E + C[5]) / F,
												M = oK(D, f, s),
												L = oK(O, h, s);
											switch (o) {
												case "nearest":
													_ = uK(I, h, f, x, w, k, T, L, M, A, u);
													break;
												case "bilinear":
													_ = lK(I, h, f, x, w, k, T, L, M, A, u);
													break;
												default:
													throw new Error(
														"Error in Transform: Expect 'nearest' or 'bilinear', but got " +
															o
													);
											}
											N[T * x + E * w + R * k + A] = _;
										}
									}
							return r.makeTensorInfo(y, a.dtype, N);
						}
						return { dataId: r.write(N, y, a.dtype), shape: a.shape, dtype: a.dtype };
					},
				},
				UV,
				{
					kernelName: yx,
					backendName: "cpu",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.attrs,
							r = e.backend,
							a = n.axis,
							i = t.x;
						vU(i, "unique");
						var o = NG(r.data.get(i.dataId).values, a, i.shape, i.dtype),
							s = o.outputValues,
							u = o.outputShape,
							l = o.indices;
						return [r.makeTensorInfo(u, i.dtype, s), r.makeTensorInfo([l.length], "int32", l)];
					},
				},
				{
					kernelName: bx,
					backendName: "cpu",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.backend,
							r = e.attrs,
							a = t.value,
							i = r.axis;
						i < 0 && (i += a.shape.length);
						for (var o = a.shape.length, s = a.shape[i], u = new Array(o - 1), l = 0, c = 0; c < o; c++)
							c !== i && (u[l++] = a.shape[c]);
						var p = new Array(o).fill(0),
							h = a.shape.slice();
						h[i] = 1;
						for (var f = new Array(s), d = 0; d < f.length; d++) {
							p[i] = d;
							var m = QV({ inputs: { x: a }, backend: n, attrs: { begin: p, size: h } });
							(f[d] = LG({ inputs: { x: m }, backend: n, attrs: { shape: u } })),
								n.disposeIntermediateTensorInfo(m);
						}
						return f;
					},
				},
				{
					kernelName: xx,
					backendName: "cpu",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.backend,
							r = e.attrs,
							a = t.x,
							i = t.segmentIds,
							o = r.numSegments;
						vU(a, "unsortedSegmentSum");
						for (var s = [], u = [], l = a.shape.length - i.shape.length, c = i, p = 0; p < l; ++p) {
							var h = tH({ inputs: { input: c }, backend: n, attrs: { dim: p + 1 } });
							(c = h), u.push(h);
						}
						for (var f = 0; f < o; ++f) {
							var d = ww(f, "int32"),
								m = n.makeTensorInfo([], "int32", d),
								g = XU({ inputs: { a: m, b: c }, backend: n }),
								v = AU({ inputs: { x: g }, backend: n, attrs: { dtype: "float32" } }),
								y = FV({ inputs: { a: v, b: a }, backend: n }),
								b = Yj({ inputs: { x: y }, backend: n, attrs: { axis: 0, keepDims: !1 } });
							s.push(b), u.push(m), u.push(g), u.push(v), u.push(y), u.push(b);
						}
						var x = hq({ inputs: s, backend: n, attrs: { axis: 0 } });
						return (
							u.forEach(function (e) {
								return n.disposeIntermediateTensorInfo(e);
							}),
							x
						);
					},
				},
				cq,
			];
		cK < pK.length;
		cK++
	)
		Ox(pK[cK]);
	var hK,
		fK,
		dK,
		mK = {},
		gK = {
			alpha: !1,
			antialias: !1,
			premultipliedAlpha: !1,
			preserveDrawingBuffer: !1,
			depth: !1,
			stencil: !1,
			failIfMajorPerformanceCaveat: !0,
		};
	function vK(e, t) {
		if (!(e in mK) || null != t) {
			var n = (function (e, t) {
				if (1 !== e && 2 !== e) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
				var n =
					null == t
						? (function (e) {
								if ("undefined" != typeof OffscreenCanvas && 2 === e)
									return new OffscreenCanvas(300, 150);
								if ("undefined" != typeof document) return document.createElement("canvas");
								throw new Error("Cannot create a canvas in this context");
						  })(e)
						: t;
				return (
					n.addEventListener(
						"webglcontextlost",
						function (t) {
							t.preventDefault(), delete mK[e];
						},
						!1
					),
					1 === e
						? n.getContext("webgl", gK) || n.getContext("experimental-webgl", gK)
						: n.getContext("webgl2", gK)
				);
			})(e, t);
			if (null === n) return console.log("Could not get context for WebGL version", e), null;
			mK[e] = n;
		}
		var r = mK[e];
		return null == r || r.isContextLost()
			? (delete mK[e], vK(e))
			: (r.disable(r.DEPTH_TEST),
			  r.disable(r.STENCIL_TEST),
			  r.disable(r.BLEND),
			  r.disable(r.DITHER),
			  r.disable(r.POLYGON_OFFSET_FILL),
			  r.disable(r.SAMPLE_COVERAGE),
			  r.enable(r.SCISSOR_TEST),
			  r.enable(r.CULL_FACE),
			  r.cullFace(r.BACK),
			  mK[e]);
	}
	function yK(e, t) {
		return [t, e];
	}
	function bK(e) {
		var t = zg(e);
		return Wg(Math.ceil(t / 4));
	}
	function xK(e, t) {
		return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))];
	}
	function wK(e, t) {
		var n,
			r,
			a,
			i,
			o,
			s,
			u,
			l,
			c,
			p,
			h = e;
		return (
			2 === xv().getNumber("WEBGL_VERSION")
				? ((n = h.R32F),
				  (r = h.R16F),
				  (a = h.RGBA16F),
				  (i = h.RGBA32F),
				  (o = h.RED),
				  (u = 4),
				  (l = 1),
				  (c = h.HALF_FLOAT),
				  (p = h.FLOAT),
				  (s = h.RGBA8))
				: ((n = e.RGBA),
				  (r = e.RGBA),
				  (a = e.RGBA),
				  (i = h.RGBA),
				  (o = e.RGBA),
				  (u = 4),
				  (l = 4),
				  (c = null != t ? t.HALF_FLOAT_OES : null),
				  (p = e.FLOAT),
				  (s = e.RGBA)),
			{
				internalFormatFloat: n,
				internalFormatHalfFloat: r,
				internalFormatPackedHalfFloat: a,
				internalFormatPackedFloat: i,
				textureFormatFloat: o,
				downloadTextureFormat: s,
				downloadUnpackNumChannels: u,
				defaultNumChannels: l,
				textureTypeHalfFloat: c,
				textureTypeFloat: p,
			}
		);
	}
	function kK(e, t) {
		var n = t();
		return (
			xv().getBool("DEBUG") &&
				(function (e) {
					var t = e.getError();
					if (t !== e.NO_ERROR)
						throw new Error(
							"WebGL Error: " +
								(function (e, t) {
									switch (t) {
										case e.NO_ERROR:
											return "NO_ERROR";
										case e.INVALID_ENUM:
											return "INVALID_ENUM";
										case e.INVALID_VALUE:
											return "INVALID_VALUE";
										case e.INVALID_OPERATION:
											return "INVALID_OPERATION";
										case e.INVALID_FRAMEBUFFER_OPERATION:
											return "INVALID_FRAMEBUFFER_OPERATION";
										case e.OUT_OF_MEMORY:
											return "OUT_OF_MEMORY";
										case e.CONTEXT_LOST_WEBGL:
											return "CONTEXT_LOST_WEBGL";
										default:
											return "Unknown error code " + t;
									}
								})(e, t)
						);
				})(e),
			n
		);
	}
	function NK(e) {
		return !!(
			xv().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ||
			0 === e ||
			(5.96e-8 < Math.abs(e) && Math.abs(e) < 65504)
		);
	}
	function IK(e, t) {
		return MK(
			e,
			function () {
				return e.getExtension(t);
			},
			'Extension "' + t + '" not supported on this browser.'
		);
	}
	!(function (e) {
		(e[(e.DENSE = 0)] = "DENSE"), (e[(e.SHARED_BATCH = 1)] = "SHARED_BATCH");
	})(hK || (hK = {})),
		(function (e) {
			(e[(e.RENDER = 0)] = "RENDER"),
				(e[(e.UPLOAD = 1)] = "UPLOAD"),
				(e[(e.PIXELS = 2)] = "PIXELS"),
				(e[(e.DOWNLOAD = 3)] = "DOWNLOAD");
		})(fK || (fK = {})),
		(function (e) {
			(e[(e.UNPACKED_FLOAT16 = 0)] = "UNPACKED_FLOAT16"),
				(e[(e.UNPACKED_FLOAT32 = 1)] = "UNPACKED_FLOAT32"),
				(e[(e.PACKED_4X1_UNSIGNED_BYTE = 2)] = "PACKED_4X1_UNSIGNED_BYTE"),
				(e[(e.PACKED_2X2_FLOAT32 = 3)] = "PACKED_2X2_FLOAT32"),
				(e[(e.PACKED_2X2_FLOAT16 = 4)] = "PACKED_2X2_FLOAT16");
		})(dK || (dK = {}));
	var SK,
		TK,
		CK = /ERROR: [0-9]+:([0-9]+):/g;
	function EK(e, t) {
		var n = CK.exec(t);
		if (null == n) return console.log("Couldn't parse line number in error: " + t), void console.log(e);
		for (
			var r = +n[1],
				a = e.split("\n"),
				i = a.length.toString().length + 2,
				o = a.map(function (e, t) {
					return Ug((t + 1).toString(), i) + e;
				}),
				s = 0,
				u = 0;
			u < o.length;
			u++
		)
			s = Math.max(o[u].length, s);
		var l = o.slice(0, r - 1),
			c = o.slice(r - 1, r),
			p = o.slice(r);
		console.log(l.join("\n")),
			console.log(t.split("\n")[0]),
			console.log("%c " + Ug(c[0], s), "border:1px solid red; background-color:#e3d2d2; color:#a61717"),
			console.log(p.join("\n"));
	}
	function RK(e, t) {
		if (
			(kK(e, function () {
				return e.validateProgram(t);
			}),
			!1 === e.getProgramParameter(t, e.VALIDATE_STATUS))
		)
			throw (console.log(e.getProgramInfoLog(t)), new Error("Shader program validation failed."));
	}
	function AK(e, t, n, r, a, i, o) {
		var s = e.getAttribLocation(t, n);
		return (
			-1 !== s &&
			(kK(e, function () {
				return e.bindBuffer(e.ARRAY_BUFFER, r);
			}),
			kK(e, function () {
				return e.vertexAttribPointer(s, a, e.FLOAT, !1, i, o);
			}),
			kK(e, function () {
				return e.enableVertexAttribArray(s);
			}),
			!0)
		);
	}
	function _K(e, t, n, r) {
		kK(e, function () {
			return (function (e, t, n) {
				(function (e, t) {
					var n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
						r = t + e.TEXTURE0;
					if (r < e.TEXTURE0 || r > n)
						throw new Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE" + n + "].");
				})(e, n),
					kK(e, function () {
						return e.activeTexture(e.TEXTURE0 + n);
					}),
					kK(e, function () {
						return e.bindTexture(e.TEXTURE_2D, t);
					});
			})(e, t, r);
		}),
			kK(e, function () {
				return e.uniform1i(n, r);
			});
	}
	function FK(e, t, n) {
		kK(e, function () {
			return e.bindFramebuffer(e.FRAMEBUFFER, n);
		}),
			kK(e, function () {
				return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
			});
	}
	function DK(e, t) {
		kK(e, function () {
			return e.bindFramebuffer(e.FRAMEBUFFER, t);
		}),
			kK(e, function () {
				return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0);
			});
	}
	function OK(e) {
		var t = e.checkFramebufferStatus(e.FRAMEBUFFER);
		if (t !== e.FRAMEBUFFER_COMPLETE)
			throw new Error(
				"Error binding framebuffer: " +
					(function (e, t) {
						switch (t) {
							case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
								return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
							case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
								return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
							case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
								return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
							case e.FRAMEBUFFER_UNSUPPORTED:
								return "FRAMEBUFFER_UNSUPPORTED";
							default:
								return "unknown error " + t;
						}
					})(e, t)
			);
	}
	function MK(e, t, n) {
		var r = kK(e, function () {
			return t();
		});
		if (null == r) throw new Error(n);
		return r;
	}
	function LK(e, t) {
		return void 0 === t && (t = 2), zg(e.slice(0, e.length - t));
	}
	function zK(e) {
		if (0 === e.length) throw Error("Cannot get rows and columns of an empty shape array.");
		return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];
	}
	function PK(e) {
		var t = [1, 1, 1];
		return 0 === e.length || (1 === e.length && 1 === e[0]) || (t = [LK(e)].concat(zK(e))), t;
	}
	function BK(e) {
		return e % 2 == 0;
	}
	function WK(e, t) {
		if (Pg((e = e.slice(-2)), (t = t.slice(-2)))) return !0;
		if (!e.length || !t.length) return !0;
		if (0 === e[0] || 0 === e[1] || 0 === t[0] || 0 === t[1]) return !0;
		if (e.length !== t.length) {
			var n = e.slice(-1)[0],
				r = t.slice(-1)[0];
			if (n === r) return !0;
			if (BK(n) && BK(r) && (1 === e[0] || 1 === t[0])) return !0;
		}
		return e[1] === t[1] && BK(e[0]) && BK(t[0]);
	}
	function UK(e, t) {
		return null != e.getExtension(t);
	}
	function VK(e) {
		try {
			if (null != vK(e)) return !0;
		} catch (e) {
			return console.log("Error when getting WebGL context: ", e), !1;
		}
		return !1;
	}
	function GK(e) {
		var t = wK(e),
			n = e.createTexture();
		e.bindTexture(e.TEXTURE_2D, n),
			e.texImage2D(
				e.TEXTURE_2D,
				0,
				t.internalFormatFloat,
				1,
				1,
				0,
				t.textureFormatFloat,
				t.textureTypeFloat,
				null
			);
		var r = e.createFramebuffer();
		e.bindFramebuffer(e.FRAMEBUFFER, r),
			e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
		var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
		return (
			e.bindTexture(e.TEXTURE_2D, null),
			e.bindFramebuffer(e.FRAMEBUFFER, null),
			e.deleteTexture(n),
			e.deleteFramebuffer(r),
			a
		);
	}
	function jK(e, t) {
		Array.isArray(e) || (e = [e]),
			e.forEach(function (e) {
				null != e &&
					Dg("complex64" !== e.dtype, function () {
						return t + " does not support complex64 tensors in the WebGL backend.";
					});
			});
	}
	var HK = xv();
	function qK() {
		var e, t, n, r, a, i, o, s, u, l;
		return (
			2 === xv().getNumber("WEBGL_VERSION")
				? ((e = "#version 300 es"),
				  (t = "in"),
				  (n = "out"),
				  (r = "in"),
				  (a = "texture"),
				  (i = "outputColor"),
				  (o = "out vec4 outputColor;"),
				  (s =
						"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    "),
				  (u = ""),
				  (l =
						"\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "))
				: ((e = ""),
				  (t = "attribute"),
				  (n = "varying"),
				  (r = "varying"),
				  (a = "texture2D"),
				  (i = "gl_FragColor"),
				  (o = ""),
				  (s =
						"\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    "),
				  (u =
						"\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    "),
				  (l =
						"\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ")),
			{
				version: e,
				attribute: t,
				varyingVs: n,
				varyingFs: r,
				texture2D: a,
				output: i,
				defineOutput: o,
				defineSpecialNaN: s,
				defineSpecialInf: u,
				defineRound: l,
			}
		);
	}
	function KK(e, t, n) {
		void 0 === n && (n = "index");
		var r = ov(t);
		return r
			.map(function (t, a) {
				return (
					"int " +
					e[a] +
					" = " +
					n +
					" / " +
					t +
					"; " +
					(a === r.length - 1
						? "int " + e[a + 1] + " = " + n + " - " + e[a] + " * " + t
						: "index -= " + e[a] + " * " + t) +
					";"
				);
			})
			.join("");
	}
	function XK(e, t, n) {
		void 0 === n && (n = "index");
		var r = ov(t);
		return r
			.map(function (t, a) {
				return (
					"int " +
					e[a] +
					" = " +
					n +
					" / outShapeStrides[" +
					a +
					"]; " +
					(a === r.length - 1
						? "int " + e[a + 1] + " = " + n + " - " + e[a] + " * outShapeStrides[" + a + "]"
						: "index -= " + e[a] + " * outShapeStrides[" + a + "]") +
					";"
				);
			})
			.join("");
	}
	function YK(e) {
		var t = ov(e).map(function (e) {
			return e.toString();
		});
		return (
			"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " +
			t[0] +
			" + coords.y * " +
			t[1] +
			" + coords.z;\n  }\n"
		);
	}
	HK.registerFlag("HAS_WEBGL", function () {
		return HK.getNumber("WEBGL_VERSION") > 0;
	}),
		HK.registerFlag("WEBGL_VERSION", function () {
			return VK(2) ? 2 : VK(1) ? 1 : 0;
		}),
		HK.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", function () {
			return !1;
		}),
		HK.registerFlag("WEBGL_BUFFER_SUPPORTED", function () {
			return 2 === HK.get("WEBGL_VERSION");
		}),
		HK.registerFlag("WEBGL_CPU_FORWARD", function () {
			return !0;
		}),
		HK.registerFlag("WEBGL_FORCE_F16_TEXTURES", function () {
			return !1;
		}),
		HK.registerFlag("WEBGL_PACK", function () {
			return HK.getBool("HAS_WEBGL");
		}),
		HK.registerFlag("WEBGL_PACK_NORMALIZATION", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_PACK_CLIP", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_PACK_DEPTHWISECONV", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_PACK_REDUCE", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_LAZILY_UNPACK", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_CONV_IM2COL", function () {
			return HK.getBool("WEBGL_PACK");
		}),
		HK.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function () {
			return (function (e) {
				if (null == SK) {
					var t = vK(e);
					SK = t.getParameter(t.MAX_TEXTURE_SIZE);
				}
				return SK;
			})(HK.getNumber("WEBGL_VERSION"));
		}),
		HK.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function () {
			return (function (e) {
				if (null == TK) {
					var t = vK(e);
					TK = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
				}
				return Math.min(16, TK);
			})(HK.getNumber("WEBGL_VERSION"));
		}),
		HK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function () {
			var e = HK.getNumber("WEBGL_VERSION");
			return 0 === e
				? 0
				: (function (e) {
						if (0 === e) return 0;
						var t = vK(e);
						return UK(t, "EXT_disjoint_timer_query_webgl2") && 2 === e
							? 2
							: UK(t, "EXT_disjoint_timer_query")
							? 1
							: 0;
				  })(e);
		}),
		HK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function () {
			return HK.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !uk();
		}),
		HK.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function () {
			return (function (e) {
				if (0 === e) return !1;
				var t = vK(e);
				if (1 === e) {
					if (!UK(t, "OES_texture_float")) return !1;
				} else if (!UK(t, "EXT_color_buffer_float")) return !1;
				return GK(t);
			})(HK.getNumber("WEBGL_VERSION"));
		}),
		HK.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function () {
			return !HK.getBool("WEBGL_FORCE_F16_TEXTURES") && HK.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
		}),
		HK.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function () {
			return (function (e) {
				if (0 === e) return !1;
				var t = vK(e);
				if (1 !== e) {
					if (UK(t, "EXT_color_buffer_float")) return GK(t);
					var n = "EXT_color_buffer_half_float";
					if (UK(t, n)) {
						var r = t.getExtension(n);
						return (function (e, t) {
							var n = wK(e, t),
								r = e.createTexture();
							e.bindTexture(e.TEXTURE_2D, r),
								e.texImage2D(
									e.TEXTURE_2D,
									0,
									n.internalFormatHalfFloat,
									1,
									1,
									0,
									n.textureFormatFloat,
									n.textureTypeHalfFloat,
									null
								);
							var a = e.createFramebuffer();
							e.bindFramebuffer(e.FRAMEBUFFER, a),
								e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0);
							var i = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
							return (
								e.bindTexture(e.TEXTURE_2D, null),
								e.bindFramebuffer(e.FRAMEBUFFER, null),
								e.deleteTexture(r),
								e.deleteFramebuffer(a),
								i
							);
						})(t, r);
					}
					return !1;
				}
				return !!UK(t, "OES_texture_float") && !!UK(t, "WEBGL_color_buffer_float") && GK(t);
			})(HK.getNumber("WEBGL_VERSION"));
		}),
		HK.registerFlag("WEBGL_FENCE_API_ENABLED", function () {
			return 2 === (e = HK.getNumber("WEBGL_VERSION")) && null != vK(e).fenceSync;
			var e;
		}),
		HK.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function () {
			return HK.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
		}),
		HK.registerFlag(
			"WEBGL_DELETE_TEXTURE_THRESHOLD",
			function () {
				return -1;
			},
			function (e) {
				if (e < 0 && -1 !== e)
					throw new Error(
						"WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got " +
							e +
							"."
					);
			}
		),
		HK.registerFlag(
			"WEBGL_FLUSH_THRESHOLD",
			function () {
				return uk() ? 1 : -1;
			},
			function (e) {
				if (e < 0 && -1 !== e)
					throw new Error(
						"WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got " +
							e +
							"."
					);
			}
		),
		HK.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", function () {
			return 128;
		}),
		HK.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", function () {
			return !1;
		}),
		HK.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", function () {
			return 1e5;
		}),
		HK.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", function () {
			return 128;
		});
	var JK =
			"\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",
		ZK = XN;
	function QK(e, t, n) {
		var r = [];
		if (
			(e.forEach(function (e) {
				var t = zg(e.shapeInfo.logicalShape);
				if (
					(e.shapeInfo.isUniform
						? r.push("uniform float " + e.name + (t > 1 ? "[" + t + "]" : "") + ";")
						: (r.push("uniform sampler2D " + e.name + ";"), r.push("uniform int offset" + e.name + ";")),
					n.enableShapeUniforms)
				) {
					switch (uX(n.packedInputs, e.shapeInfo.logicalShape, e.shapeInfo.texShape).uniformShape.length) {
						case 1:
							r.push("uniform int " + e.name + "Shape;");
							break;
						case 2:
							r.push("uniform ivec2 " + e.name + "Shape;");
							break;
						case 3:
							r.push("uniform ivec3 " + e.name + "Shape;");
							break;
						case 4:
							r.push("uniform ivec4 " + e.name + "Shape;");
					}
					r.push("uniform ivec2 " + e.name + "TexShape;");
				}
			}),
			n.enableShapeUniforms)
		) {
			switch (t.logicalShape.length) {
				case 1:
					r.push("uniform int outShape;");
					break;
				case 2:
					r.push("uniform ivec2 outShape;"), r.push("uniform int outShapeStrides;");
					break;
				case 3:
					r.push("uniform ivec3 outShape;"), r.push("uniform ivec2 outShapeStrides;");
					break;
				case 4:
					r.push("uniform ivec4 outShape;"), r.push("uniform ivec3 outShapeStrides;");
			}
			r.push("uniform ivec2 outTexShape;");
		}
		n.customUniforms &&
			n.customUniforms.forEach(function (e) {
				r.push("uniform " + e.type + " " + e.name + (e.arrayIndex ? "[" + e.arrayIndex + "]" : "") + ";");
			});
		var a,
			i,
			o = r.join("\n"),
			s = e
				.map(function (e) {
					return (function (e, t, n, r) {
						void 0 === n && (n = !1);
						var a = "";
						a += n ? eX(e, r) : $K(e, r);
						var i = e.shapeInfo.logicalShape,
							o = t.logicalShape;
						return (
							i.length <= o.length &&
								(a += n
									? (function (e, t) {
											var n,
												r = e.name,
												a = r.charAt(0).toUpperCase() + r.slice(1),
												i = "get" + a + "AtOutCoords",
												o = e.shapeInfo.logicalShape.length,
												s = t.logicalShape.length,
												u = ZK(e.shapeInfo.logicalShape, t.logicalShape),
												l = sX(s),
												c = s - o,
												p = ["x", "y", "z", "w", "u", "v"];
											n =
												0 === o
													? ""
													: s < 2 && u.length >= 1
													? "coords = 0;"
													: u
															.map(function (e) {
																return "coords." + p[e + c] + " = 0;";
															})
															.join("\n");
											var h;
											h =
												s < 2 && o > 0
													? "coords"
													: e.shapeInfo.logicalShape
															.map(function (e, t) {
																return "coords." + p[t + c];
															})
															.join(", ");
											var f = "return outputValue;",
												d = 1 === zg(e.shapeInfo.logicalShape),
												m = 1 === zg(t.logicalShape);
											if (1 !== o || d || m) {
												if (d && !m)
													f =
														1 === s
															? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      "
															: "\n        return vec4(outputValue.x);\n      ";
												else if (u.length) {
													var g = o - 2,
														v = o - 1;
													u.indexOf(g) > -1 && u.indexOf(v) > -1
														? (f = "return vec4(outputValue.x);")
														: u.indexOf(g) > -1
														? (f =
																"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);")
														: u.indexOf(v) > -1 &&
														  (f = "return vec4(outputValue.xx, outputValue.zz);");
												}
											} else f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
											return (
												"\n    vec4 " +
												i +
												"() {\n      " +
												l +
												" coords = getOutputCoords();\n      " +
												n +
												"\n      vec4 outputValue = get" +
												a +
												"(" +
												h +
												");\n      " +
												f +
												"\n    }\n  "
											);
									  })(e, t)
									: (function (e, t) {
											var n = e.name,
												r = n.charAt(0).toUpperCase() + n.slice(1),
												a = "get" + r + "AtOutCoords",
												i = t.texShape,
												o = e.shapeInfo.texShape,
												s = e.shapeInfo.logicalShape.length,
												u = t.logicalShape.length;
											if (
												!e.shapeInfo.isUniform &&
												s === u &&
												null == e.shapeInfo.flatOffset &&
												Pg(o, i)
											)
												return (
													"\n      float " +
													a +
													"() {\n        return sampleTexture(" +
													n +
													", resultUV);\n      }\n    "
												);
											var l,
												c = sX(u),
												p = ZK(e.shapeInfo.logicalShape, t.logicalShape),
												h = u - s,
												f = ["x", "y", "z", "w", "u", "v"];
											l =
												0 === s
													? ""
													: u < 2 && p.length >= 1
													? "coords = 0;"
													: p
															.map(function (e) {
																return "coords." + f[e + h] + " = 0;";
															})
															.join("\n");
											var d;
											return (
												(d =
													u < 2 && s > 0
														? "coords"
														: e.shapeInfo.logicalShape
																.map(function (e, t) {
																	return "coords." + f[t + h];
																})
																.join(", ")),
												"\n    float " +
													a +
													"() {\n      " +
													c +
													" coords = getOutputCoords();\n      " +
													l +
													"\n      return get" +
													r +
													"(" +
													d +
													");\n    }\n  "
											);
									  })(e, t)),
							a
						);
					})(e, t, n.packedInputs, n.enableShapeUniforms);
				})
				.join("\n"),
			u = t.texShape,
			l = qK(),
			c = (function (e) {
				return (
					"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " +
					e.texture2D +
					"(textureSampler, uv).r;\n    }\n  "
				);
			})(l),
			p = (function (e) {
				return (
					e.version +
					"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " +
					e.varyingFs +
					" vec2 resultUV;\n    " +
					e.defineOutput +
					"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " +
					e.defineSpecialNaN +
					"\n    " +
					e.defineSpecialInf +
					"\n    " +
					e.defineRound +
					"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " +
					tX +
					"\n    " +
					nX +
					"\n    " +
					rX +
					"\n  "
				);
			})(l);
		return (
			t.isPacked
				? ((a = (function (e, t, n) {
						switch (e.length) {
							case 0:
								return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
							case 1:
								return (function (e, t, n) {
									var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
									return 1 === r[0]
										? n
											? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    "
											: "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " +
											  r[1] +
											  ".0);\n      }\n    "
										: 1 === r[1]
										? n
											? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    "
											: "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " +
											  r[0] +
											  ".0);\n      }\n    "
										: n
										? "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  "
										: "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
										  r[0] +
										  ", " +
										  r[1] +
										  "));\n      return 2 * (resTexRC.x * " +
										  r[1] +
										  " + resTexRC.y);\n    }\n  ";
								})(0, t, n);
							case 2:
								return (function (e, t, n) {
									var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
									if (Pg(e, t))
										return n
											? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    "
											: "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" +
													r[0] +
													", " +
													r[1] +
													"));\n      }\n    ";
									var a = Math.ceil(e[1] / 2);
									return n
										? "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  "
										: "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
												r[0] +
												", " +
												r[1] +
												"));\n\n      int index = resTexRC.x * " +
												r[1] +
												" + resTexRC.y;\n      int r = 2 * (index / " +
												a +
												");\n      int c = imod(index, " +
												a +
												") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
								})(e, t, n);
							case 3:
								return (function (e, t, n) {
									if (n)
										return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
									var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
										a = Math.ceil(e[2] / 2),
										i = a * Math.ceil(e[1] / 2);
									return (
										"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
										r[0] +
										", " +
										r[1] +
										"));\n      int index = resTexRC.x * " +
										r[1] +
										" + resTexRC.y;\n\n      int b = index / " +
										i +
										";\n      index -= b * " +
										i +
										";\n\n      int r = 2 * (index / " +
										a +
										");\n      int c = imod(index, " +
										a +
										") * 2;\n\n      return ivec3(b, r, c);\n    }\n  "
									);
								})(e, t, n);
							default:
								return (function (e, t, n) {
									if (n)
										return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
									for (
										var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
											a = Math.ceil(e[e.length - 1] / 2),
											i = a * Math.ceil(e[e.length - 2] / 2),
											o = i,
											s = "",
											u = "b, r, c",
											l = 2;
										l < e.length - 1;
										l++
									)
										(s =
											"\n      int b" +
											l +
											" = index / " +
											(o *= e[e.length - l - 1]) +
											";\n      index -= b" +
											l +
											" * " +
											o +
											";\n    " +
											s),
											(u = "b" + l + ", " + u);
									return (
										"\n    ivec" +
										e.length +
										" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
										r[0] +
										", " +
										r[1] +
										"));\n      int index = resTexRC.x * " +
										r[1] +
										" + resTexRC.y;\n\n      " +
										s +
										"\n\n      int b = index / " +
										i +
										";\n      index -= b * " +
										i +
										";\n\n      int r = 2 * (index / " +
										a +
										");\n      int c = imod(index, " +
										a +
										") * 2;\n\n      return ivec" +
										e.length +
										"(" +
										u +
										");\n    }\n  "
									);
								})(e, t, n);
						}
				  })(t.logicalShape, u, n.enableShapeUniforms)),
				  (i = (function (e) {
						return "\n    void setOutput(vec4 val) {\n      " + e.output + " = val;\n    }\n  ";
				  })(l)))
				: ((a = (function (e, t, n) {
						switch (e.length) {
							case 0:
								return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
							case 1:
								return (function (e, t, n) {
									return 1 === t[0]
										? n
											? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    "
											: "\n      int getOutputCoords() {\n        return int(resultUV.x * " +
											  t[1] +
											  ".0);\n      }\n    "
										: 1 === t[1]
										? n
											? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    "
											: "\n      int getOutputCoords() {\n        return int(resultUV.y * " +
											  t[0] +
											  ".0);\n      }\n    "
										: n
										? "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  "
										: "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
										  t[0] +
										  ", " +
										  t[1] +
										  "));\n      return resTexRC.x * " +
										  t[1] +
										  " + resTexRC.y;\n    }\n  ";
								})(0, t, n);
							case 2:
								return (function (e, t, n) {
									return Pg(e, t)
										? n
											? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    "
											: "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" +
											  t[0] +
											  ", " +
											  t[1] +
											  "));\n      }\n    "
										: 1 === e[1]
										? n
											? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    "
											: "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" +
											  t[0] +
											  ", " +
											  t[1] +
											  "));\n        int index = resTexRC.x * " +
											  t[1] +
											  " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    "
										: 1 === e[0]
										? n
											? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    "
											: "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" +
											  t[0] +
											  ", " +
											  t[1] +
											  "));\n        int index = resTexRC.x * " +
											  t[1] +
											  " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    "
										: n
										? "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  "
										: "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
										  t[0] +
										  ", " +
										  t[1] +
										  "));\n      int index = resTexRC.x * " +
										  t[1] +
										  " + resTexRC.y;\n      int r = index / " +
										  e[1] +
										  ";\n      int c = index - r * " +
										  e[1] +
										  ";\n      return ivec2(r, c);\n    }\n  ";
								})(e, t, n);
							case 3:
								return (function (e, t, n) {
									if (n)
										return (
											"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    " +
											XK(["r", "c", "d"], e) +
											"\n    return ivec3(r, c, d);\n  }\n"
										);
									var r = KK(["r", "c", "d"], e);
									return (
										"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" +
										t[0] +
										", " +
										t[1] +
										"));\n      int index = resTexRC.x * " +
										t[1] +
										" + resTexRC.y;\n      " +
										r +
										"\n      return ivec3(r, c, d);\n    }\n  "
									);
								})(e, t, n);
							case 4:
								return (function (e, t, n) {
									if (n)
										return (
											"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      " +
											XK(["r", "c", "d", "d2"], e) +
											"\n      return ivec4(r, c, d, d2);\n    }\n  "
										);
									var r = KK(["r", "c", "d", "d2"], e);
									return (
										"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" +
										t[0] +
										", " +
										t[1] +
										"));\n      int index = resTexRC.x * " +
										t[1] +
										" + resTexRC.y;\n      " +
										r +
										"\n      return ivec4(r, c, d, d2);\n    }\n  "
									);
								})(e, t, n);
							case 5:
								return (
									(r = t),
									(a = KK(["r", "c", "d", "d2", "d3"], e)),
									"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" +
										r[0] +
										",\n                             " +
										r[1] +
										"));\n\n      int index = resTexRC.x * " +
										r[1] +
										" + resTexRC.y;\n\n      " +
										a +
										"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "
								);
							case 6:
								return (function (e, t) {
									var n = KK(["r", "c", "d", "d2", "d3", "d4"], e);
									return (
										"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" +
										t[0] +
										", " +
										t[1] +
										"));\n      int index = resTexRC.x * " +
										t[1] +
										" + resTexRC.y;\n\n      " +
										n +
										"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "
									);
								})(e, t);
							default:
								throw new Error(e.length + "-D output sampling is not yet supported");
						}
						var r, a;
				  })(t.logicalShape, u, n.enableShapeUniforms)),
				  (i = (function (e) {
						return (
							"\n    void setOutput(float val) {\n      " + e.output + " = vec4(val, 0, 0, 0);\n    }\n  "
						);
				  })(l))),
			n.packedInputs && (p += aX),
			[p, c, i, o, a, s, n.userCode].join("\n")
		);
	}
	function $K(e, t) {
		void 0 === t && (t = !1);
		var n = e.shapeInfo.logicalShape;
		switch (n.length) {
			case 0:
				return (function (e, t) {
					var n = e.name,
						r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
					if (e.shapeInfo.isUniform) return "float " + r + "() {return " + n + ";}";
					var a = e.shapeInfo.texShape,
						i = a[0],
						o = a[1];
					if (1 === i && 1 === o)
						return (
							"\n      float " +
							r +
							"() {\n        return sampleTexture(" +
							n +
							", halfCR);\n      }\n    "
						);
					var s = iX(n);
					if (t)
						return (
							"\n    float " +
							r +
							"() {\n      vec2 uv = uvFromFlat(" +
							n +
							"TexShape[0], " +
							n +
							"TexShape[1], " +
							s +
							");\n      return sampleTexture(" +
							n +
							", uv);\n    }\n  "
						);
					var u = e.shapeInfo.texShape;
					return (
						"\n    float " +
						r +
						"() {\n      vec2 uv = uvFromFlat(" +
						u[0] +
						", " +
						u[1] +
						", " +
						s +
						");\n      return sampleTexture(" +
						n +
						", uv);\n    }\n  "
					);
				})(e, t);
			case 1:
				return (function (e, t) {
					var n = e.name,
						r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
					if (e.shapeInfo.isUniform)
						return "\n      float " + r + "(int index) {\n        " + oX(e) + "\n      }\n    ";
					var a = e.shapeInfo.texShape,
						i = a[0],
						o = a[1];
					if (1 === o && 1 === i)
						return (
							"\n      float " +
							r +
							"(int index) {\n        return sampleTexture(" +
							n +
							", halfCR);\n      }\n    "
						);
					var s = iX(n);
					return 1 === o
						? t
							? "\n      float " +
							  r +
							  "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " +
							  s +
							  ") + 0.5) / float(" +
							  n +
							  "TexShape[0]));\n        return sampleTexture(" +
							  n +
							  ", uv);\n      }\n    "
							: "\n      float " +
							  r +
							  "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " +
							  s +
							  ") + 0.5) / " +
							  i +
							  ".0);\n        return sampleTexture(" +
							  n +
							  ", uv);\n      }\n    "
						: 1 === i
						? t
							? "\n      float " +
							  r +
							  "(int index) {\n        vec2 uv = vec2((float(index + " +
							  s +
							  ") + 0.5) / float(" +
							  n +
							  "TexShape[1]), 0.5);\n        return sampleTexture(" +
							  n +
							  ", uv);\n      }\n    "
							: "\n      float " +
							  r +
							  "(int index) {\n        vec2 uv = vec2((float(index + " +
							  s +
							  ") + 0.5) / " +
							  o +
							  ".0, 0.5);\n        return sampleTexture(" +
							  n +
							  ", uv);\n      }\n    "
						: t
						? "\n    float " +
						  r +
						  "(int index) {\n      vec2 uv = uvFromFlat(" +
						  n +
						  "TexShape[0], " +
						  n +
						  "TexShape[1], index + " +
						  s +
						  ");\n      return sampleTexture(" +
						  n +
						  ", uv);\n    }\n  "
						: "\n    float " +
						  r +
						  "(int index) {\n      vec2 uv = uvFromFlat(" +
						  i +
						  ", " +
						  o +
						  ", index + " +
						  s +
						  ");\n      return sampleTexture(" +
						  n +
						  ", uv);\n    }\n  ";
				})(e, t);
			case 2:
				return (function (e, t) {
					var n = e.shapeInfo.logicalShape,
						r = e.name,
						a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
						i = e.shapeInfo.texShape;
					if (null != i && Pg(n, i)) {
						if (t)
							return (
								"\n      float " +
								a +
								"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" +
								r +
								"TexShape[1], " +
								r +
								"TexShape[0]);\n        return sampleTexture(" +
								r +
								", uv);\n      }\n    "
							);
						var o = i[0];
						return (
							"\n    float " +
							a +
							"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" +
							i[1] +
							".0, " +
							o +
							".0);\n      return sampleTexture(" +
							r +
							", uv);\n    }\n  "
						);
					}
					var s = Hg(n),
						u = s.newShape,
						l = s.keptDims,
						c = u;
					if (c.length < n.length) {
						return (
							"\n      " +
							$K(lX(e, c), t) +
							"\n      float " +
							a +
							"(int row, int col) {\n        return " +
							a +
							"(" +
							cX(["row", "col"], l) +
							");\n      }\n    "
						);
					}
					if (e.shapeInfo.isUniform)
						return (
							"\n      float " +
							a +
							"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" +
							n[1] +
							", 1)));\n        " +
							oX(e) +
							"\n      }\n    "
						);
					var p = i[0],
						h = i[1],
						f = iX(r);
					return 1 === h
						? t
							? "\n      float " +
							  a +
							  "(int row, int col) {\n        float index = dot(vec3(row, col, " +
							  f +
							  "), vec3(" +
							  r +
							  "Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(" +
							  r +
							  "TexShape[0]));\n        return sampleTexture(" +
							  r +
							  ", uv);\n      }\n    "
							: "\n    float " +
							  a +
							  "(int row, int col) {\n      float index = dot(vec3(row, col, " +
							  f +
							  "), vec3(" +
							  n[1] +
							  ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " +
							  p +
							  ".0);\n      return sampleTexture(" +
							  r +
							  ", uv);\n    }\n  "
						: 1 === p
						? t
							? "\n      float " +
							  a +
							  "(int row, int col) {\n        float index = dot(vec3(row, col, " +
							  f +
							  "), vec3(" +
							  r +
							  "Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(" +
							  r +
							  "TexShape[1]), 0.5);\n        return sampleTexture(" +
							  r +
							  ", uv);\n      }\n    "
							: "\n    float " +
							  a +
							  "(int row, int col) {\n      float index = dot(vec3(row, col, " +
							  f +
							  "), vec3(" +
							  n[1] +
							  ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " +
							  h +
							  ".0, 0.5);\n      return sampleTexture(" +
							  r +
							  ", uv);\n    }\n  "
						: t
						? "\n      float " +
						  a +
						  "(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " +
						  r +
						  "Shape[1] + col + " +
						  f +
						  ";\n        vec2 uv = uvFromFlat(" +
						  r +
						  "TexShape[0], " +
						  r +
						  "TexShape[1], index);\n        return sampleTexture(" +
						  r +
						  ", uv);\n      }\n    "
						: "\n  float " +
						  a +
						  "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " +
						  n[1] +
						  " + col + " +
						  f +
						  ";\n    vec2 uv = uvFromFlat(" +
						  p +
						  ", " +
						  h +
						  ", index);\n    return sampleTexture(" +
						  r +
						  ", uv);\n  }\n";
				})(e, t);
			case 3:
				return (function (e, t) {
					var n = e.shapeInfo.logicalShape,
						r = e.name,
						a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
						i = n[1] * n[2],
						o = n[2],
						s = Hg(n),
						u = s.newShape,
						l = s.keptDims,
						c = u;
					if (c.length < n.length) {
						return (
							"\n        " +
							$K(lX(e, c), t) +
							"\n        float " +
							a +
							"(int row, int col, int depth) {\n          return " +
							a +
							"(" +
							cX(["row", "col", "depth"], l) +
							");\n        }\n      "
						);
					}
					if (e.shapeInfo.isUniform)
						return (
							"\n      float " +
							a +
							"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" +
							i +
							", " +
							o +
							", 1)));\n        " +
							oX(e) +
							"\n      }\n    "
						);
					var p = e.shapeInfo.texShape,
						h = p[0],
						f = p[1],
						d = e.shapeInfo.flatOffset;
					if (f === i && null == d)
						return t
							? "\n      float " +
									a +
									"(int row, int col, int depth) {\n        int stride1 = " +
									r +
									"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" +
									r +
									"TexShape[1], " +
									r +
									"TexShape[0]);\n        return sampleTexture(" +
									r +
									", uv);\n      }\n    "
							: "\n        float " +
									a +
									"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" +
									o +
									", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" +
									f +
									".0, " +
									h +
									".0);\n          return sampleTexture(" +
									r +
									", uv);\n        }\n      ";
					if (f === o && null == d)
						return t
							? "\n      float " +
									a +
									"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(" +
									r +
									"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" +
									r +
									"TexShape[1], " +
									r +
									"TexShape[0]);\n        return sampleTexture(" +
									r +
									", uv);\n      }\n    "
							: "\n    float " +
									a +
									"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" +
									n[1] +
									", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" +
									f +
									".0, " +
									h +
									".0);\n      return sampleTexture(" +
									r +
									", uv);\n    }\n  ";
					var m = iX(r);
					return t
						? "\n    float " +
								a +
								"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = " +
								r +
								"Shape[1] * " +
								r +
								"Shape[2];\n      int stride1 = " +
								r +
								"Shape[2];\n      int index = row * " +
								i +
								" + col * " +
								o +
								" + depth + " +
								m +
								";\n      vec2 uv = uvFromFlat(" +
								r +
								"TexShape[0], " +
								r +
								"TexShape[1], index);\n      return sampleTexture(" +
								r +
								", uv);\n    }\n    "
						: "\n      float " +
								a +
								"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " +
								i +
								" + col * " +
								o +
								" + depth + " +
								m +
								";\n        vec2 uv = uvFromFlat(" +
								h +
								", " +
								f +
								", index);\n        return sampleTexture(" +
								r +
								", uv);\n      }\n  ";
				})(e, t);
			case 4:
				return (function (e, t) {
					var n = e.shapeInfo.logicalShape,
						r = e.name,
						a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
						i = n[3],
						o = n[2] * i,
						s = n[1] * o,
						u = Hg(n),
						l = u.newShape,
						c = u.keptDims;
					if (l.length < n.length) {
						return (
							"\n      " +
							$K(lX(e, l), t) +
							"\n      float " +
							a +
							"(int row, int col, int depth, int depth2) {\n        return " +
							a +
							"(" +
							cX(["row", "col", "depth", "depth2"], c) +
							");\n      }\n    "
						);
					}
					if (e.shapeInfo.isUniform)
						return (
							"\n      float " +
							a +
							"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" +
							s +
							", " +
							o +
							", " +
							i +
							", 1)));\n        " +
							oX(e) +
							"\n      }\n    "
						);
					var p = e.shapeInfo.flatOffset,
						h = e.shapeInfo.texShape,
						f = h[0],
						d = h[1],
						m = "int stride2 = " + r + "Shape[3];",
						g = "int stride1 = " + r + "Shape[2] * stride2;",
						v = "int stride0 = " + r + "Shape[1] * stride1;";
					if (d === s && null == p)
						return t
							? "\n      float " +
									a +
									"(int row, int col, int depth, int depth2) {\n        " +
									m +
									"\n        " +
									g +
									"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" +
									r +
									"TexShape[1], " +
									r +
									"TexShape[0]);\n        return sampleTexture(" +
									r +
									", uv);\n      }\n    "
							: "\n      float " +
									a +
									"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" +
									o +
									", " +
									i +
									", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" +
									d +
									".0, " +
									f +
									".0);\n        return sampleTexture(" +
									r +
									", uv);\n      }\n    ";
					if (d === i && null == p)
						return t
							? "\n      float " +
									a +
									"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" +
									r +
									"Shape[1] * " +
									r +
									"Shape[2], " +
									r +
									"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" +
									r +
									"TexShape[1], " +
									r +
									"TexShape[0]);\n        return sampleTexture(" +
									r +
									", uv);\n      }\n    "
							: "\n      float " +
									a +
									"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" +
									n[1] * n[2] +
									", " +
									n[2] +
									", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" +
									d +
									".0, " +
									f +
									".0);\n        return sampleTexture(" +
									r +
									", uv);\n      }\n    ";
					var y = iX(r);
					return t
						? "\n    float " +
								a +
								"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      " +
								m +
								"\n      " +
								g +
								"\n      " +
								v +
								"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(" +
								r +
								"TexShape[0], " +
								r +
								"TexShape[1], index + " +
								y +
								");\n      return sampleTexture(" +
								r +
								", uv);\n    }\n  "
						: "\n    float " +
								a +
								"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " +
								s +
								" + col * " +
								o +
								" +\n          depth * " +
								i +
								" + depth2;\n      vec2 uv = uvFromFlat(" +
								f +
								", " +
								d +
								", index + " +
								y +
								");\n      return sampleTexture(" +
								r +
								", uv);\n    }\n  ";
				})(e, t);
			case 5:
				return (function (e) {
					var t = e.shapeInfo.logicalShape,
						n = e.name,
						r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
						a = t[4],
						i = t[3] * a,
						o = t[2] * i,
						s = t[1] * o,
						u = Hg(t),
						l = u.newShape,
						c = u.keptDims;
					if (l.length < t.length) {
						return (
							"\n      " +
							$K(lX(e, l)) +
							"\n      float " +
							r +
							"(int row, int col, int depth, int depth2, int depth3) {\n        return " +
							r +
							"(" +
							cX(["row", "col", "depth", "depth2", "depth3"], c) +
							");\n      }\n    "
						);
					}
					if (e.shapeInfo.isUniform)
						return (
							"\n      float " +
							r +
							"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" +
							s +
							", " +
							o +
							", " +
							i +
							", " +
							a +
							")) +\n          depth3;\n        " +
							oX(e) +
							"\n      }\n    "
						);
					var p = e.shapeInfo.flatOffset,
						h = e.shapeInfo.texShape,
						f = h[0],
						d = h[1];
					return d === s && null == p
						? "\n      float " +
								r +
								"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" +
								o +
								", " +
								i +
								", " +
								a +
								", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" +
								d +
								".0, " +
								f +
								".0);\n        return sampleTexture(" +
								n +
								", uv);\n      }\n    "
						: d === a && null == p
						? "\n      float " +
						  r +
						  "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" +
						  t[1] * t[2] * t[3] +
						  ",\n               " +
						  t[2] * t[3] +
						  ", " +
						  t[3] +
						  ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" +
						  d +
						  ".0, " +
						  f +
						  ".0);\n        return sampleTexture(" +
						  n +
						  ", uv);\n      }\n    "
						: "\n    float " +
						  r +
						  "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " +
						  s +
						  " + col * " +
						  o +
						  " + depth * " +
						  i +
						  " +\n          depth2 * " +
						  a +
						  " + depth3 + " +
						  iX(n) +
						  ";\n      vec2 uv = uvFromFlat(" +
						  f +
						  ", " +
						  d +
						  ", index);\n      return sampleTexture(" +
						  n +
						  ", uv);\n    }\n  ";
				})(e);
			case 6:
				return (function (e) {
					var t = e.shapeInfo.logicalShape,
						n = e.name,
						r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
						a = Hg(t),
						i = a.newShape,
						o = a.keptDims;
					if (i.length < t.length) {
						return (
							"\n      " +
							$K(lX(e, i)) +
							"\n      float " +
							r +
							"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " +
							r +
							"(" +
							cX(["row", "col", "depth", "depth2", "depth3", "depth4"], o) +
							");\n      }\n    "
						);
					}
					var s = t[5],
						u = t[4] * s,
						l = t[3] * u,
						c = t[2] * l,
						p = t[1] * c;
					if (e.shapeInfo.isUniform)
						return (
							"\n      float " +
							r +
							"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" +
							p +
							", " +
							c +
							", " +
							l +
							", " +
							u +
							")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" +
							s +
							", 1)));\n        " +
							oX(e) +
							"\n      }\n    "
						);
					var h = e.shapeInfo.flatOffset,
						f = e.shapeInfo.texShape,
						d = f[0],
						m = f[1];
					return m === p && null == h
						? "\n      float " +
								r +
								"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" +
								c +
								", " +
								l +
								", " +
								u +
								", " +
								s +
								")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" +
								m +
								".0, " +
								d +
								".0);\n        return sampleTexture(" +
								n +
								", uv);\n      }\n    "
						: m === s && null == h
						? "\n      float " +
						  r +
						  "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" +
						  t[1] * t[2] * t[3] * t[4] +
						  ",\n               " +
						  t[2] * t[3] * t[4] +
						  ",\n               " +
						  t[3] * t[4] +
						  ",\n               " +
						  t[4] +
						  ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" +
						  m +
						  ".0, " +
						  d +
						  ".0);\n        return sampleTexture(" +
						  n +
						  ", uv);\n      }\n    "
						: "\n    float " +
						  r +
						  "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " +
						  p +
						  " + col * " +
						  c +
						  " + depth * " +
						  l +
						  " +\n          depth2 * " +
						  u +
						  " + depth3 * " +
						  s +
						  " + depth4 + " +
						  iX(n) +
						  ";\n      vec2 uv = uvFromFlat(" +
						  d +
						  ", " +
						  m +
						  ", index);\n      return sampleTexture(" +
						  n +
						  ", uv);\n    }\n  ";
				})(e);
			default:
				throw new Error(n.length + "-D input sampling is not yet supported");
		}
	}
	function eX(e, t) {
		var n;
		switch (e.shapeInfo.logicalShape.length) {
			case 0:
				return (
					"\n    vec4 " +
					("get" + (n = e.name).charAt(0).toUpperCase() + n.slice(1)) +
					"() {\n      return " +
					qK().texture2D +
					"(" +
					n +
					", halfCR);\n    }\n  "
				);
			case 1:
				return (function (e, t) {
					var n = e.name,
						r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
						a = e.shapeInfo.texShape,
						i = qK();
					if (t)
						return (
							"\n    vec4 " +
							r +
							"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(" +
							n +
							"TexShape[0]) / 2.0), ceil(float(" +
							n +
							"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return " +
							i.texture2D +
							"(" +
							n +
							", uv);\n    }\n  "
						);
					var o = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];
					return (
						"\n    vec4 " +
						r +
						"(int index) {\n      vec2 uv = packedUVfrom1D(\n        " +
						o[0] +
						", " +
						o[1] +
						", index);\n      return " +
						i.texture2D +
						"(" +
						n +
						", uv);\n    }\n  "
					);
				})(e, t);
			case 2:
				return (function (e, t) {
					var n = e.shapeInfo.logicalShape,
						r = e.name,
						a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
						i = e.shapeInfo.texShape,
						o = i[0],
						s = i[1],
						u = qK();
					if (null != i && Pg(n, i))
						return t
							? "\n      vec4 " +
									a +
									"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" +
									r +
									"TexShape[1], " +
									r +
									"TexShape[0]);\n\n        return " +
									u.texture2D +
									"(" +
									r +
									", uv);\n      }\n    "
							: "\n      vec4 " +
									a +
									"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" +
									s +
									".0, " +
									o +
									".0);\n\n        return " +
									u.texture2D +
									"(" +
									r +
									", uv);\n      }\n    ";
					if (t)
						return (
							"\n    vec4 " +
							a +
							"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(" +
							r +
							"TexShape[0]) / 2.0), ceil(float(" +
							r +
							"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(" +
							r +
							"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return " +
							u.texture2D +
							"(" +
							r +
							", uv);\n    }\n  "
						);
					var l = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
					return (
						"\n    vec4 " +
						a +
						"(int row, int col) {\n      vec2 uv = packedUVfrom2D(" +
						Math.ceil(n[1] / 2) +
						", " +
						l[0] +
						", " +
						l[1] +
						", row, col);\n      return " +
						u.texture2D +
						"(" +
						r +
						", uv);\n    }\n  "
					);
				})(e, t);
			case 3:
				return (function (e, t) {
					var n = e.shapeInfo.logicalShape,
						r = e.name,
						a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
						i = e.shapeInfo.texShape,
						o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
					if (1 === n[0]) {
						return (
							"\n        " +
							eX(lX(e, n.slice(1)), t) +
							"\n        vec4 " +
							a +
							"(int b, int row, int col) {\n          return " +
							a +
							"(" +
							cX(["b", "row", "col"], [1, 2]) +
							");\n        }\n      "
						);
					}
					var s = qK();
					if (t)
						return (
							"\n    vec4 " +
							a +
							"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(" +
							r +
							"TexShape[0]) / 2.0), ceil(float(" +
							r +
							"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(" +
							r +
							"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(" +
							r +
							"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return " +
							s.texture2D +
							"(" +
							r +
							", uv);\n    }\n  "
						);
					var u = o[0],
						l = o[1],
						c = Math.ceil(n[2] / 2);
					return (
						"\n    vec4 " +
						a +
						"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " +
						u +
						", " +
						l +
						", " +
						c * Math.ceil(n[1] / 2) +
						", " +
						c +
						", b, row, col);\n      return " +
						s.texture2D +
						"(" +
						r +
						", uv);\n    }\n  "
					);
				})(e, t);
			default:
				return (function (e, t) {
					var n = e.name,
						r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
						a = qK();
					if (t)
						return (
							"\n    vec4 " +
							r +
							"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(" +
							n +
							"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(" +
							n +
							"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= " +
							n +
							"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(" +
							n +
							"TexShape[0]) / 2.0), ceil(float(" +
							n +
							"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return " +
							a.texture2D +
							"(" +
							n +
							", uv);\n    }\n  "
						);
					for (
						var i = e.shapeInfo.logicalShape,
							o = i.length,
							s = e.shapeInfo.texShape,
							u = [Math.ceil(s[0] / 2), Math.ceil(s[1] / 2)],
							l = u[0],
							c = u[1],
							p = Math.ceil(i[o - 1] / 2),
							h = p * Math.ceil(i[o - 2] / 2),
							f = "int b, int row, int col",
							d = "b * " + h + " + (row / 2) * " + p + " + (col / 2)",
							m = 2;
						m < o - 1;
						m++
					)
						(f = "int b" + m + ", " + f), (d = "b" + m + " * " + (h *= i[o - m - 1]) + " + " + d);
					return (
						"\n    vec4 " +
						r +
						"(" +
						f +
						") {\n      int index = " +
						d +
						";\n      int texR = index / " +
						c +
						";\n      int texC = index - texR * " +
						c +
						";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" +
						c +
						", " +
						l +
						");\n      return " +
						a.texture2D +
						"(" +
						n +
						", uv);\n    }\n  "
					);
				})(e, t);
		}
	}
	var tX =
			"\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
		nX =
			"\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
		rX =
			"\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
		aX =
			"\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
	function iX(e) {
		return "offset" + e;
	}
	function oX(e) {
		var t = e.name,
			n = zg(e.shapeInfo.logicalShape);
		return n < 2
			? "return " + t + ";"
			: "\n    for (int i = 0; i < " +
					n +
					"; i++) {\n      if (i == index) {\n        return " +
					t +
					"[i];\n      }\n    }\n  ";
	}
	function sX(e) {
		if (e <= 1) return "int";
		if (2 === e) return "ivec2";
		if (3 === e) return "ivec3";
		if (4 === e) return "ivec4";
		if (5 === e) return "ivec5";
		if (6 === e) return "ivec6";
		throw Error("GPU for rank " + e + " is not yet supported");
	}
	function uX(e, t, n) {
		var r = Hg(t),
			a = r.newShape,
			i = r.keptDims,
			o = t.length,
			s = e && 3 === o && 1 === t[0],
			u = s ? t.slice(1) : a,
			l = (!e && o > 1 && !Pg(t, n) && a.length < o) || s;
		return { useSqueezeShape: l, uniformShape: l ? u : t, keptDims: i };
	}
	function lX(e, t) {
		var n = JSON.parse(JSON.stringify(e));
		return (n.shapeInfo.logicalShape = t), n;
	}
	function cX(e, t) {
		return t
			.map(function (t) {
				return e[t];
			})
			.join(", ");
	}
	function pX(e, t, n) {
		var r,
			a,
			i,
			o,
			s = {},
			u = {},
			l = {},
			c = [],
			p = null;
		(o = e.getUniformLocation(n, "NAN", !1)),
			1 === xv().getNumber("WEBGL_VERSION") && (p = e.getUniformLocation(n, "INFINITY", !1));
		for (var h = !1, f = 0; f < t.variableNames.length; f++) {
			var d = t.variableNames[f];
			(s[d] = e.getUniformLocation(n, d, h)),
				(s["offset" + d] = e.getUniformLocation(n, "offset" + d, h)),
				t.enableShapeUniforms &&
					((u[d + "Shape"] = e.getUniformLocation(n, d + "Shape", h)),
					(l[d + "TexShape"] = e.getUniformLocation(n, d + "TexShape", h)));
		}
		return (
			t.enableShapeUniforms &&
				((r = e.getUniformLocation(n, "outShape", h)),
				(i = e.getUniformLocation(n, "outShapeStrides", h)),
				(a = e.getUniformLocation(n, "outTexShape", h))),
			t.customUniforms &&
				t.customUniforms.forEach(function (t, r) {
					c[r] = e.getUniformLocation(n, t.name, h);
				}),
			{
				uniformLocations: s,
				customUniformLocations: c,
				infLoc: p,
				nanLoc: o,
				inShapesLocations: u,
				inTexShapesLocations: l,
				outShapeLocation: r,
				outShapeStridesLocation: i,
				outTexShapeLocation: a,
			}
		);
	}
	function hX(e, t) {
		if (e.length !== t.length)
			throw Error(
				"Binary was compiled with " + e.length + " inputs, but was executed with " + t.length + " inputs"
			);
		e.forEach(function (e, n) {
			var r = e.logicalShape,
				a = t[n],
				i = a.shape;
			if (!Pg(r, i))
				throw Error(
					"Binary was compiled with different shapes than the current args. Shapes " +
						r +
						" and " +
						i +
						" must match"
				);
			if (!e.isUniform || !a.isUniform) {
				var o = e.texShape,
					s = a.isUniform ? null : a.texData.texShape;
				if (!Pg(o, s))
					throw Error(
						"Binary was compiled with different texture shapes than the current args. Shape " +
							o +
							" and " +
							s +
							" must match"
					);
			}
		});
	}
	function fX(e) {
		return xv().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e <= 4;
	}
	var dX = function (e) {
			(this.variableNames = ["A"]),
				(this.packedInputs = !1),
				(this.packedOutput = !0),
				(this.outPackingScheme = hK.DENSE),
				(this.customUniforms = [{ name: "texShape", type: "ivec2" }]);
			var t = qK();
			(this.outputShape = e),
				(this.enableShapeUniforms = fX(this.outputShape.length)),
				(this.userCode =
					"\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " +
					(this.enableShapeUniforms ? XK(["r", "c", "d"], e) : KK(["r", "c", "d"], e)) +
					"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " +
					t.output +
					" = result;\n      }\n    ");
		},
		mX = function (e) {
			(this.variableNames = ["A"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.outPackingScheme = hK.DENSE),
				(this.customUniforms = [{ name: "texShape", type: "ivec2" }]);
			var t = qK();
			(this.outputShape = e),
				(this.enableShapeUniforms = fX(this.outputShape.length)),
				(this.userCode =
					"\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " +
					(this.enableShapeUniforms ? XK(["r", "c", "d"], e) : KK(["r", "c", "d"], e)) +
					"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " +
					t.output +
					" = result;\n      }\n    ");
		},
		gX = function (e) {
			(this.variableNames = ["A"]), (this.outTexUsage = fK.DOWNLOAD);
			var t = qK();
			(this.outputShape = e),
				(this.userCode =
					"\n      " +
					JK +
					"\n\n      void main() {\n        float x = getAAtOutCoords();\n        " +
					t.output +
					" = encode_float(x);\n      }\n    ");
		},
		vX = function (e) {
			(this.variableNames = ["A"]),
				(this.packedInputs = !0),
				(this.packedOutput = !1),
				(this.outTexUsage = fK.DOWNLOAD);
			var t = qK();
			(this.outputShape = e),
				(this.userCode =
					"\n      " +
					JK +
					"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " +
					t.output +
					" = encode_float(x);\n      }\n    ");
		},
		yX = function (e, t) {
			void 0 === t && (t = !1),
				(this.variableNames = ["A"]),
				(this.customUniforms = [{ name: "texShape", type: "ivec2" }]);
			var n = qK();
			(this.outputShape = e), (this.enableShapeUniforms = fX(this.outputShape.length));
			var r = "result";
			t && (r = "floor(result * 255. + 0.5)"),
				(this.userCode =
					"\n      " +
					(this.enableShapeUniforms
						? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"
						: YK(e)) +
					"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = " +
					n.texture2D +
					"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " +
					n.output +
					" = vec4(" +
					r +
					", 0., 0., 0.);\n      }\n    ");
		},
		bX = function (e, t) {
			void 0 === t && (t = !1),
				(this.variableNames = ["A"]),
				(this.packedInputs = !1),
				(this.packedOutput = !0),
				(this.customUniforms = [{ name: "texShape", type: "ivec2" }]);
			var n = qK();
			(this.outputShape = e), (this.enableShapeUniforms = fX(this.outputShape.length));
			var r = "",
				a = "result";
			t && (a = "floor(result * 255. + 0.5)");
			for (var i = 0; i <= 1; i++)
				for (var o = 0; o <= 1; o++) {
					var s = 2 * i + o;
					r +=
						"\n          localCoords = coords;\n          if(localCoords[2] + " +
						o +
						" < " +
						(this.enableShapeUniforms ? "outShape[2]" : "" + e[2]) +
						") {\n          localCoords[2] += " +
						o +
						";\n          if (localCoords[1] + " +
						i +
						" < " +
						(this.enableShapeUniforms ? "outShape[1]" : "" + e[1]) +
						") {\n            localCoords[1] += " +
						i +
						";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = " +
						n.texture2D +
						"(A, uv);\n\n            if (offset == 0) {\n              result[" +
						s +
						"] = values[0];\n            } else if (offset == 1) {\n              result[" +
						s +
						"] = values[1];\n            } else if (offset == 2) {\n              result[" +
						s +
						"] = values[2];\n            } else {\n              result[" +
						s +
						"] = values[3];\n            }\n          }\n        }\n        ";
				}
			this.userCode =
				"\n        " +
				(this.enableShapeUniforms
					? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"
					: YK(e)) +
				"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          " +
				r +
				"\n\n          " +
				n.output +
				" = " +
				a +
				";\n        }\n    ";
		};
	function xX(e, t, n, r, a, i) {
		!(function (e, t) {
			var n = xv().getNumber("WEBGL_MAX_TEXTURE_SIZE");
			if (e <= 0 || t <= 0) throw new Error("Requested texture size [" + e + "x" + t + "] is invalid.");
			if (e > n || t > n)
				throw new Error(
					"Requested texture size [" +
						e +
						"x" +
						t +
						"] greater than WebGL maximum on this browser / GPU [" +
						n +
						"x" +
						n +
						"]."
				);
		})(t, n);
		var o = (function (e) {
				return MK(
					e,
					function () {
						return e.createTexture();
					},
					"Unable to create WebGLTexture."
				);
			})(e),
			s = e.TEXTURE_2D;
		return (
			kK(e, function () {
				return e.bindTexture(s, o);
			}),
			kK(e, function () {
				return e.texParameteri(s, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE);
			}),
			kK(e, function () {
				return e.texParameteri(s, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
			}),
			kK(e, function () {
				return e.texParameteri(s, e.TEXTURE_MIN_FILTER, e.NEAREST);
			}),
			kK(e, function () {
				return e.texParameteri(s, e.TEXTURE_MAG_FILTER, e.NEAREST);
			}),
			1 === xv().getNumber("WEBGL_VERSION")
				? kK(e, function () {
						return e.texImage2D(s, 0, r, t, n, 0, a, i, null);
				  })
				: kK(e, function () {
						return e.texStorage2D(s, 1, r, t, n);
				  }),
			kK(e, function () {
				return e.bindTexture(e.TEXTURE_2D, null);
			}),
			{ texture: o, texShape: [n, t] }
		);
	}
	function wX(e) {
		return e.internalFormatFloat;
	}
	function kX(e) {
		return e.internalFormatHalfFloat;
	}
	function NX(e) {
		return e.downloadTextureFormat;
	}
	function IX(e) {
		return e.internalFormatPackedFloat;
	}
	function SX(e) {
		return e.internalFormatPackedHalfFloat;
	}
	var TX = (function () {
			function e(e) {
				(this.outputTexture = null),
					(this.program = null),
					(this.disposed = !1),
					(this.vertexAttrsAreBound = !1),
					(this.itemsToPoll = []);
				var t = xv().getNumber("WEBGL_VERSION");
				null != e
					? ((this.gl = e),
					  (function (e, t) {
							mK[e] = t;
					  })(t, e))
					: (this.gl = vK(t));
				var n = "WEBGL_color_buffer_float",
					r = "EXT_color_buffer_half_float";
				if (
					((this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile")),
					1 === xv().getNumber("WEBGL_VERSION"))
				) {
					var a = "OES_texture_half_float";
					if (((this.textureFloatExtension = IK(this.gl, "OES_texture_float")), UK(this.gl, a)))
						this.textureHalfFloatExtension = IK(this.gl, a);
					else if (xv().get("WEBGL_FORCE_F16_TEXTURES"))
						throw new Error(
							"GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true."
						);
					if (((this.colorBufferFloatExtension = this.gl.getExtension(n)), UK(this.gl, r)))
						this.colorBufferHalfFloatExtension = IK(this.gl, r);
					else if (xv().get("WEBGL_FORCE_F16_TEXTURES"))
						throw new Error(
							"GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true."
						);
				} else if (((n = "EXT_color_buffer_float"), UK(this.gl, n)))
					this.colorBufferFloatExtension = this.gl.getExtension(n);
				else {
					if (!UK(this.gl, r)) throw new Error("GL context does not support color renderable floats");
					this.colorBufferHalfFloatExtension = this.gl.getExtension(r);
				}
				(this.vertexBuffer = (function (e) {
					return (function (e, t) {
						var n = MK(
							e,
							function () {
								return e.createBuffer();
							},
							"Unable to create WebGLBuffer"
						);
						return (
							kK(e, function () {
								return e.bindBuffer(e.ARRAY_BUFFER, n);
							}),
							kK(e, function () {
								return e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);
							}),
							n
						);
					})(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
				})(this.gl)),
					(this.indexBuffer = (function (e) {
						return (function (e, t) {
							var n = MK(
								e,
								function () {
									return e.createBuffer();
								},
								"Unable to create WebGLBuffer"
							);
							return (
								kK(e, function () {
									return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n);
								}),
								kK(e, function () {
									return e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW);
								}),
								n
							);
						})(e, new Uint16Array([0, 1, 2, 2, 1, 3]));
					})(this.gl)),
					(this.framebuffer = (function (e) {
						return MK(
							e,
							function () {
								return e.createFramebuffer();
							},
							"Unable to create WebGLFramebuffer."
						);
					})(this.gl)),
					(this.textureConfig = wK(this.gl, this.textureHalfFloatExtension));
			}
			var t = e.prototype;
			return (
				(t.dispose = function () {
					var e = this;
					if (!this.disposed) {
						null != this.program &&
							console.warn(
								"Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."
							),
							null != this.outputTexture &&
								console.warn(
									"Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing."
								);
						var t = this.gl;
						kK(t, function () {
							return t.finish();
						}),
							kK(t, function () {
								return t.bindFramebuffer(t.FRAMEBUFFER, null);
							}),
							kK(t, function () {
								return t.deleteFramebuffer(e.framebuffer);
							}),
							kK(t, function () {
								return t.bindBuffer(t.ARRAY_BUFFER, null);
							}),
							kK(t, function () {
								return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null);
							}),
							kK(t, function () {
								return t.deleteBuffer(e.indexBuffer);
							}),
							(this.disposed = !0);
					}
				}),
				(t.createFloat32MatrixTexture = function (e, t) {
					return (
						this.throwIfDisposed(),
						(function (e, t, n, r) {
							var a = yK(t, n);
							return xX(e, a[0], a[1], wX(r), r.textureFormatFloat, e.FLOAT);
						})(this.gl, e, t, this.textureConfig)
					);
				}),
				(t.createFloat16MatrixTexture = function (e, t) {
					return (
						this.throwIfDisposed(),
						(function (e, t, n, r) {
							var a = yK(t, n);
							return xX(e, a[0], a[1], kX(r), r.textureFormatFloat, r.textureTypeHalfFloat);
						})(this.gl, e, t, this.textureConfig)
					);
				}),
				(t.createUnsignedBytesMatrixTexture = function (e, t) {
					return (
						this.throwIfDisposed(),
						(function (e, t, n, r) {
							var a = yK(t, n);
							return xX(e, a[0], a[1], NX(r), e.RGBA, e.UNSIGNED_BYTE);
						})(this.gl, e, t, this.textureConfig)
					);
				}),
				(t.uploadPixelDataToTexture = function (e, t) {
					this.throwIfDisposed(),
						(function (e, t, n) {
							kK(e, function () {
								return e.bindTexture(e.TEXTURE_2D, t);
							}),
								n.data instanceof Uint8Array
									? 2 === xv().getNumber("WEBGL_VERSION")
										? kK(e, function () {
												return e.texSubImage2D(
													e.TEXTURE_2D,
													0,
													0,
													0,
													n.width,
													n.height,
													e.RGBA,
													e.UNSIGNED_BYTE,
													n.data
												);
										  })
										: kK(e, function () {
												return e.texImage2D(
													e.TEXTURE_2D,
													0,
													e.RGBA,
													n.width,
													n.height,
													0,
													e.RGBA,
													e.UNSIGNED_BYTE,
													n.data
												);
										  })
									: 2 === xv().getNumber("WEBGL_VERSION")
									? kK(e, function () {
											return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, e.RGBA, e.UNSIGNED_BYTE, n);
									  })
									: kK(e, function () {
											return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n);
									  }),
								kK(e, function () {
									return e.bindTexture(e.TEXTURE_2D, null);
								});
						})(this.gl, e, t);
				}),
				(t.uploadDenseMatrixToTexture = function (e, t, n, r) {
					this.throwIfDisposed(),
						(function (e, t, n, r, a, i) {
							var o, s, u;
							kK(e, function () {
								return e.bindTexture(e.TEXTURE_2D, t);
							}),
								a instanceof Uint8Array
									? ((o = new Uint8Array(n * r * 4)), (s = e.UNSIGNED_BYTE), (u = e.RGBA))
									: ((o = new Float32Array(n * r * 4)),
									  (s = e.FLOAT),
									  (u = i.internalFormatPackedFloat)),
								o.set(a),
								2 === xv().getNumber("WEBGL_VERSION")
									? kK(e, function () {
											return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n, r, e.RGBA, s, o);
									  })
									: kK(e, function () {
											return e.texImage2D(e.TEXTURE_2D, 0, u, n, r, 0, e.RGBA, s, o);
									  }),
								kK(e, function () {
									return e.bindTexture(e.TEXTURE_2D, null);
								});
						})(this.gl, e, t, n, r, this.textureConfig);
				}),
				(t.createFloat16PackedMatrixTexture = function (e, t) {
					return (
						this.throwIfDisposed(),
						(function (e, t, n, r) {
							var a = xK(t, n);
							return xX(e, a[0], a[1], SX(r), e.RGBA, r.textureTypeHalfFloat);
						})(this.gl, e, t, this.textureConfig)
					);
				}),
				(t.createPackedMatrixTexture = function (e, t) {
					return (
						this.throwIfDisposed(),
						(function (e, t, n, r) {
							var a = xK(t, n);
							return xX(e, a[0], a[1], IX(r), e.RGBA, e.FLOAT);
						})(this.gl, e, t, this.textureConfig)
					);
				}),
				(t.deleteMatrixTexture = function (e) {
					var t = this;
					this.throwIfDisposed(),
						this.outputTexture === e && (DK(this.gl, this.framebuffer), (this.outputTexture = null)),
						kK(this.gl, function () {
							return t.gl.deleteTexture(e);
						});
				}),
				(t.downloadByteEncodedFloatMatrixFromOutputTexture = function (e, t, n) {
					var r = this;
					return this.downloadMatrixDriver(e, function () {
						return (function (e, t, n, r) {
							var a = yK(t, n),
								i = a[0],
								o = a[1],
								s = new Uint8Array(t * n * 4);
							return (
								kK(e, function () {
									return e.readPixels(0, 0, i, o, r.downloadTextureFormat, e.UNSIGNED_BYTE, s);
								}),
								new Float32Array(s.buffer)
							);
						})(r.gl, t, n, r.textureConfig);
					});
				}),
				(t.downloadPackedMatrixFromBuffer = function (e, t, n, r, a, i) {
					return (function (e, t, n, r, a, i, o, s) {
						var u = e,
							l = new Float32Array(
								(function (e, t) {
									var n = xK(e, t);
									return n[0] * n[1] * 4;
								})(i, o)
							);
						return (
							u.bindBuffer(u.PIXEL_PACK_BUFFER, t),
							u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, l),
							u.bindBuffer(u.PIXEL_PACK_BUFFER, null),
							l
						);
					})(this.gl, e, 0, 0, 0, a, i, this.textureConfig);
				}),
				(t.downloadFloat32MatrixFromBuffer = function (e, t) {
					return (function (e, t, n) {
						var r = e,
							a = new Float32Array(n);
						return (
							r.bindBuffer(r.PIXEL_PACK_BUFFER, t),
							r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, a),
							r.bindBuffer(r.PIXEL_PACK_BUFFER, null),
							a
						);
					})(this.gl, e, t);
				}),
				(t.createBufferFromTexture = function (e, t, n) {
					this.bindTextureToFrameBuffer(e);
					var r = (function (e, t, n, r) {
						var a = e.createBuffer();
						kK(e, function () {
							return e.bindBuffer(e.PIXEL_PACK_BUFFER, a);
						});
						var i = 16 * t * n;
						return (
							kK(e, function () {
								return e.bufferData(e.PIXEL_PACK_BUFFER, i, e.STREAM_READ);
							}),
							kK(e, function () {
								return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0);
							}),
							kK(e, function () {
								return e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
							}),
							a
						);
					})(this.gl, t, n, this.textureConfig);
					return this.unbindTextureToFrameBuffer(), r;
				}),
				(t.createAndWaitForFence = function () {
					var e = this.createFence(this.gl);
					return this.pollFence(e);
				}),
				(t.createFence = function (e) {
					var t,
						n,
						r = this;
					if (xv().getBool("WEBGL_FENCE_API_ENABLED")) {
						var a = e,
							i = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0);
						e.flush(),
							(n = function () {
								var e = a.clientWaitSync(i, 0, 0);
								return e === a.ALREADY_SIGNALED || e === a.CONDITION_SATISFIED;
							}),
							(t = i);
					} else
						xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0
							? ((t = this.beginQuery()),
							  this.endQuery(),
							  (n = function () {
									return r.isQueryAvailable(
										t,
										xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")
									);
							  }))
							: (n = function () {
									return !0;
							  });
					return { query: t, isFencePassed: n };
				}),
				(t.downloadMatrixFromPackedTexture = function (e, t, n) {
					var r = this;
					return this.downloadMatrixDriver(e, function () {
						return (function (e, t, n) {
							var r = new Float32Array(t * n * 4);
							return (
								kK(e, function () {
									return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, r);
								}),
								r
							);
						})(r.gl, t, n);
					});
				}),
				(t.createProgram = function (e) {
					var t = this;
					this.throwIfDisposed();
					var n = this.gl;
					null == this.vertexShader &&
						(this.vertexShader = (function (e) {
							var t = qK();
							return (function (e, t) {
								var n = MK(
									e,
									function () {
										return e.createShader(e.VERTEX_SHADER);
									},
									"Unable to create vertex WebGLShader."
								);
								if (
									(kK(e, function () {
										return e.shaderSource(n, t);
									}),
									kK(e, function () {
										return e.compileShader(n);
									}),
									!1 === e.getShaderParameter(n, e.COMPILE_STATUS))
								)
									throw (
										(console.log(e.getShaderInfoLog(n)),
										new Error("Failed to compile vertex shader."))
									);
								return n;
							})(
								e,
								t.version +
									"\n    precision highp float;\n    " +
									t.attribute +
									" vec3 clipSpacePos;\n    " +
									t.attribute +
									" vec2 uv;\n    " +
									t.varyingVs +
									" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"
							);
						})(n));
					var r = (function (e) {
						return MK(
							e,
							function () {
								return e.createProgram();
							},
							"Unable to create WebGLProgram."
						);
					})(n);
					return (
						kK(n, function () {
							return n.attachShader(r, t.vertexShader);
						}),
						kK(n, function () {
							return n.attachShader(r, e);
						}),
						(function (e, t) {
							if (
								(kK(e, function () {
									return e.linkProgram(t);
								}),
								!xv().get("ENGINE_COMPILE_ONLY") && !1 === e.getProgramParameter(t, e.LINK_STATUS))
							)
								throw (
									(console.log(e.getProgramInfoLog(t)),
									new Error("Failed to link vertex and fragment shaders."))
								);
						})(n, r),
						this.debug && RK(n, r),
						this.vertexAttrsAreBound ||
							(this.setProgram(r),
							(this.vertexAttrsAreBound = (function (e, t, n) {
								return (
									kK(e, function () {
										return e.bindBuffer(e.ARRAY_BUFFER, n);
									}),
									AK(e, t, "clipSpacePos", n, 3, 20, 0) && AK(e, t, "uv", n, 2, 20, 12)
								);
							})(n, this.program, this.vertexBuffer))),
						r
					);
				}),
				(t.deleteProgram = function (e) {
					var t = this;
					this.throwIfDisposed(),
						e === this.program && (this.program = null),
						null != e &&
							kK(this.gl, function () {
								return t.gl.deleteProgram(e);
							});
				}),
				(t.setProgram = function (e) {
					var t = this;
					this.throwIfDisposed(),
						(this.program = e),
						null != this.program && this.debug && RK(this.gl, this.program),
						kK(this.gl, function () {
							return t.gl.useProgram(e);
						});
				}),
				(t.getUniformLocation = function (e, t, n) {
					return (
						void 0 === n && (n = !0),
						this.throwIfDisposed(),
						n
							? (function (e, t, n) {
									return MK(
										e,
										function () {
											return e.getUniformLocation(t, n);
										},
										'uniform "' + n + '" not present in program.'
									);
							  })(this.gl, e, t)
							: (function (e, t, n) {
									return e.getUniformLocation(t, n);
							  })(this.gl, e, t)
					);
				}),
				(t.getAttributeLocation = function (e, t) {
					var n = this;
					return (
						this.throwIfDisposed(),
						kK(this.gl, function () {
							return n.gl.getAttribLocation(e, t);
						})
					);
				}),
				(t.getUniformLocationNoThrow = function (e, t) {
					return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);
				}),
				(t.setInputMatrixTexture = function (e, t, n) {
					this.throwIfDisposed(), this.throwIfNoProgram(), _K(this.gl, e, t, n);
				}),
				(t.setOutputMatrixTexture = function (e, t, n) {
					this.setOutputMatrixTextureDriver(e, n, t);
				}),
				(t.setOutputPackedMatrixTexture = function (e, t, n) {
					this.throwIfDisposed();
					var r = xK(t, n),
						a = r[0],
						i = r[1];
					this.setOutputMatrixTextureDriver(e, a, i);
				}),
				(t.setOutputMatrixWriteRegion = function (e, t, n, r) {
					this.setOutputMatrixWriteRegionDriver(n, e, r, t);
				}),
				(t.setOutputPackedMatrixWriteRegion = function (e, t, n, r) {
					throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
				}),
				(t.debugValidate = function () {
					null != this.program && RK(this.gl, this.program), OK(this.gl);
				}),
				(t.executeProgram = function () {
					this.throwIfDisposed(), this.throwIfNoProgram();
					var e = this.gl;
					this.debug && this.debugValidate(),
						kK(e, function () {
							return e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0);
						});
				}),
				(t.blockUntilAllProgramsCompleted = function () {
					var e = this;
					this.throwIfDisposed(),
						kK(this.gl, function () {
							return e.gl.finish();
						});
				}),
				(t.getQueryTimerExtension = function () {
					return (
						null == this.disjointQueryTimerExtension &&
							(this.disjointQueryTimerExtension = IK(
								this.gl,
								2 === xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")
									? "EXT_disjoint_timer_query_webgl2"
									: "EXT_disjoint_timer_query"
							)),
						this.disjointQueryTimerExtension
					);
				}),
				(t.getQueryTimerExtensionWebGL2 = function () {
					return this.getQueryTimerExtension();
				}),
				(t.getQueryTimerExtensionWebGL1 = function () {
					return this.getQueryTimerExtension();
				}),
				(t.beginQuery = function () {
					if (2 === xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
						var e = this.gl,
							t = this.getQueryTimerExtensionWebGL2(),
							n = e.createQuery();
						return e.beginQuery(t.TIME_ELAPSED_EXT, n), n;
					}
					var r = this.getQueryTimerExtensionWebGL1(),
						a = r.createQueryEXT();
					return r.beginQueryEXT(r.TIME_ELAPSED_EXT, a), a;
				}),
				(t.endQuery = function () {
					if (2 !== xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
						var e = this.getQueryTimerExtensionWebGL1();
						e.endQueryEXT(e.TIME_ELAPSED_EXT);
					} else {
						var t = this.gl,
							n = this.getQueryTimerExtensionWebGL2();
						t.endQuery(n.TIME_ELAPSED_EXT);
					}
				}),
				(t.waitForQueryAndGetTime = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												return (
													(e.next = 2),
													Vg(function () {
														return (
															n.disposed ||
															n.isQueryAvailable(
																t,
																xv().getNumber(
																	"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"
																)
															)
														);
													})
												);
											case 2:
												return e.abrupt(
													"return",
													this.getQueryTime(
														t,
														xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")
													)
												);
											case 3:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(t.getQueryTime = function (e, t) {
					if (0 === t) return null;
					if (2 === t) {
						var n = this.gl;
						return n.getQueryParameter(e, n.QUERY_RESULT) / 1e6;
					}
					var r = this.getQueryTimerExtensionWebGL1();
					return r.getQueryObjectEXT(e, r.QUERY_RESULT_EXT) / 1e6;
				}),
				(t.isQueryAvailable = function (e, t) {
					if (0 === t) return !0;
					if (2 === t) {
						var n = this.gl,
							r = this.getQueryTimerExtensionWebGL2(),
							a = n.getQueryParameter(e, n.QUERY_RESULT_AVAILABLE);
						return (
							null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)),
							a && !this.disjoint
						);
					}
					var i = this.getQueryTimerExtensionWebGL1(),
						o = i.getQueryObjectEXT(e, i.QUERY_RESULT_AVAILABLE_EXT);
					return (
						null == this.disjoint && (this.disjoint = this.gl.getParameter(i.GPU_DISJOINT_EXT)),
						o && !this.disjoint
					);
				}),
				(t.pollFence = function (e) {
					var t = this;
					return new Promise(function (n) {
						t.addItemToPoll(
							function () {
								return e.isFencePassed();
							},
							function () {
								return n();
							}
						);
					});
				}),
				(t.pollItems = function () {
					for (
						var e = (function (e) {
								for (var t = 0; t < e.length && e[t](); ++t);
								return t - 1;
							})(
								this.itemsToPoll.map(function (e) {
									return e.isDoneFn;
								})
							),
							t = 0;
						t <= e;
						++t
					)
						(0, this.itemsToPoll[t].resolveFn)();
					this.itemsToPoll = this.itemsToPoll.slice(e + 1);
				}),
				(t.addItemToPoll = function (e, t) {
					var n = this;
					this.itemsToPoll.push({ isDoneFn: e, resolveFn: t }),
						this.itemsToPoll.length > 1 ||
							Vg(function () {
								return n.pollItems(), 0 === n.itemsToPoll.length;
							});
				}),
				(t.bindTextureToFrameBuffer = function (e) {
					this.throwIfDisposed(), FK(this.gl, e, this.framebuffer), this.debug && OK(this.gl);
				}),
				(t.unbindTextureToFrameBuffer = function () {
					null != this.outputTexture
						? (FK(this.gl, this.outputTexture, this.framebuffer), this.debug && OK(this.gl))
						: DK(this.gl, this.framebuffer);
				}),
				(t.downloadMatrixDriver = function (e, t) {
					this.bindTextureToFrameBuffer(e);
					var n = t();
					return this.unbindTextureToFrameBuffer(), n;
				}),
				(t.setOutputMatrixTextureDriver = function (e, t, n) {
					this.throwIfDisposed();
					var r = this.gl;
					FK(r, e, this.framebuffer),
						this.debug && OK(r),
						(this.outputTexture = e),
						kK(r, function () {
							return r.viewport(0, 0, t, n);
						}),
						kK(r, function () {
							return r.scissor(0, 0, t, n);
						});
				}),
				(t.setOutputMatrixWriteRegionDriver = function (e, t, n, r) {
					var a = this;
					this.throwIfDisposed(),
						kK(this.gl, function () {
							return a.gl.scissor(e, t, n, r);
						});
				}),
				(t.throwIfDisposed = function () {
					if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
				}),
				(t.throwIfNoProgram = function () {
					if (null == this.program) throw new Error("No GPU program is currently set.");
				}),
				mg(e, [
					{
						key: "debug",
						get: function () {
							return xv().getBool("DEBUG");
						},
					},
				]),
				e
			);
		})(),
		CX = OU,
		EX = PU,
		RX = BU,
		AX = GU,
		_X = qU,
		FX = KU,
		DX = JU,
		OX = $U,
		MX = nV,
		LX = iV,
		zX = oV,
		PX = sV,
		BX = cV,
		WX = fV,
		UX = gV,
		VX = bV,
		GX = xV,
		jX = NV,
		HX = IV,
		qX = CV,
		KX = AV,
		XX = OV,
		YX = LV,
		JX = VV,
		ZX = jV,
		QX = HV,
		$X = XV,
		eY = xU,
		tY = ZV,
		nY = eG,
		rY = tG,
		aY = nG,
		iY = rG,
		oY = lG,
		sY = pG,
		uY = fG,
		lY = dG,
		cY = mG,
		pY = bG,
		hY = kG,
		fY = BV,
		dY = NG;
	function mY(e, t) {
		return ["x", "y", "z", "w", "u", "v"].slice(0, t).map(function (t) {
			return e + "." + t;
		});
	}
	function gY(e, t) {
		return 1 === t ? [e] : mY(e, t);
	}
	var vY = (function () {
			function e(e) {
				if (
					((this.variableNames = ["A"]),
					(this.packedInputs = !1),
					(this.packedOutput = !0),
					(this.outputShape = e),
					(this.rank = e.length),
					(this.enableShapeUniforms = fX(this.outputShape.length)),
					0 === this.rank)
				)
					this.userCode =
						"\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
				else {
					var t = gY("rc", this.rank),
						n = sX(this.rank),
						r = this.getOutOfBoundsCondition(t),
						a = this.getSetup(t),
						i = this.getOutput(t);
					this.userCode =
						"\n        void main() {\n          " +
						n +
						" rc = getOutputCoords();\n\n          if(" +
						r +
						") {\n            setOutput(vec4(0));\n          } else {\n            " +
						a +
						"\n\n            setOutput(vec4(" +
						i +
						"));\n          }\n        }\n      ";
				}
			}
			var t = e.prototype;
			return (
				(t.getSourceCoordsArr = function (e) {
					for (var t = [], n = 0; n <= 1; n++)
						for (var r = 0; r <= 1; r++) {
							for (
								var a = (0 === n ? "r" : "rp1") + ", " + (0 === r ? "c" : "cp1"), i = 2;
								i < this.rank;
								i++
							)
								a = e[e.length - 1 - i] + "," + a;
							t.push(a);
						}
					return t;
				}),
				(t.getOutOfBoundsCondition = function (e) {
					if (1 === this.rank) return "rc > " + (this.enableShapeUniforms ? "outShape" : this.outputShape[0]);
					for (var t = "", n = this.rank - 2; n < this.rank; n++)
						(t += e[n] + " >= " + (this.enableShapeUniforms ? "outShape[" + n + "]" : this.outputShape[n])),
							n < this.rank - 1 && (t += "||");
					return t;
				}),
				(t.getSetup = function (e) {
					if (1 === this.rank) return "";
					var t = e.slice(-2),
						n = this.enableShapeUniforms
							? "outShape[" + this.rank + " - 1]"
							: this.outputShape[this.rank - 1],
						r = this.enableShapeUniforms
							? "outShape[" + this.rank + " - 2]"
							: this.outputShape[this.rank - 2];
					return (
						"\n      int r = " +
						t[0] +
						";\n      int c = " +
						t[1] +
						";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= " +
						n +
						";\n      bool rEdge = rp1 >= " +
						r +
						";\n    "
					);
				}),
				(t.getOutput = function (e) {
					var t = this.getSourceCoordsArr(e);
					return 1 === this.rank
						? "getA(rc), (rc + 1 >= " +
								(this.enableShapeUniforms ? "outShape" : this.outputShape[0]) +
								" ? 0. : getA(rc + 1)), 0, 0"
						: "getA(" +
								t[0] +
								"),\n            cEdge ? 0. : getA(" +
								t[1] +
								"),\n            rEdge ? 0. : getA(" +
								t[2] +
								"),\n            rEdge || cEdge ? 0. : getA(" +
								t[3] +
								")";
				}),
				e
			);
		})(),
		yY = function (e, t) {
			(this.variableNames = ["A"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.customUniforms = [{ name: "inputShape", type: "ivec3" }]),
				(this.outputShape = e),
				(this.enableShapeUniforms = fX(this.outputShape.length));
			for (var n, r = "", a = 0; a < 4; a++) {
				var i = "thisRC = rc;";
				a % 2 == 1 && (i += "thisRC.z += 1;"),
					a > 1 && (i += "thisRC.y += 1;"),
					(r +=
						"\n        " +
						i +
						"\n        " +
						(a > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") +
						"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" +
						a +
						"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " +
						(a > 0 ? "}" : "") +
						"\n      ");
			}
			this.userCode =
				"\n      " +
				((n = t),
				"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " +
					(this.enableShapeUniforms
						? (function (e, t, n) {
								void 0 === n && (n = "index");
								var r = (function (e, t) {
									var n = e.length,
										r = e.map(function (e) {
											return t + "[" + e + "]";
										}),
										a = new Array(n - 1);
									a[n - 2] = r[n - 1];
									for (var i = n - 3; i >= 0; --i) a[i] = "(" + a[i + 1] + " * " + r[i + 1] + ")";
									return a;
								})(
									e.map(function (e, t) {
										return t;
									}),
									t
								);
								return r
									.map(function (t, a) {
										return (
											"int " +
											e[a] +
											" = " +
											n +
											" / " +
											r[a] +
											"; " +
											(a === r.length - 1
												? "int " + e[a + 1] + " = " + n + " - " + e[a] + " * " + r[a]
												: "index -= " + e[a] + " * " + r[a]) +
											";"
										);
									})
									.join("");
						  })(["r", "c", "d"], "inputShape")
						: KK(["r", "c", "d"], n)) +
					"\n      return ivec3(r, c, d);\n    }\n  \n      ") +
				(this.enableShapeUniforms
					? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"
					: YK(e)) +
				"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " +
				(this.enableShapeUniforms ? "outShape[1]" : e[1]) +
				";\n        int cols = " +
				(this.enableShapeUniforms ? "outShape[2]" : e[2]) +
				";\n\n        " +
				r +
				"\n\n        setOutput(result);\n      }\n    ";
		},
		bY = (function () {
			function e(e) {
				(this.gpgpu = e),
					(this.numUsedTextures = 0),
					(this.numFreeTextures = 0),
					(this._numBytesAllocated = 0),
					(this._numBytesFree = 0),
					(this.freeTextures = {}),
					(this.logEnabled = !1),
					(this.usedTextures = {});
			}
			var t = e.prototype;
			return (
				(t.acquireTexture = function (e, t, n) {
					var r = wY(t, n),
						a = kY(e, r, n);
					a in this.freeTextures || (this.freeTextures[a] = []),
						a in this.usedTextures || (this.usedTextures[a] = []);
					var i,
						o = xY(e, r, this.gpgpu.gl, this.gpgpu.textureConfig, n);
					if (this.freeTextures[a].length > 0) {
						this.numFreeTextures--, this.numUsedTextures++, (this._numBytesFree -= o), this.log();
						var s = this.freeTextures[a].shift();
						return this.usedTextures[a].push(s), s;
					}
					return (
						r === dK.PACKED_2X2_FLOAT32
							? (i = this.gpgpu.createPackedMatrixTexture(e[0], e[1]))
							: r === dK.PACKED_2X2_FLOAT16
							? (i = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]))
							: r === dK.UNPACKED_FLOAT32
							? (i = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]))
							: r === dK.UNPACKED_FLOAT16
							? (i = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]))
							: r === dK.PACKED_4X1_UNSIGNED_BYTE &&
							  (i = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])),
						this.usedTextures[a].push(i),
						this.numUsedTextures++,
						(this._numBytesAllocated += o),
						this.log(),
						i
					);
				}),
				(t.releaseTexture = function (e, t, n, r) {
					if (null != this.freeTextures) {
						var a = wY(n, r),
							i = kY(t, a, r);
						i in this.freeTextures || (this.freeTextures[i] = []);
						var o = xY(t, a, this.gpgpu.gl, this.gpgpu.textureConfig, r),
							s = xv().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
						-1 !== s && this._numBytesAllocated > s
							? (this.gpgpu.deleteMatrixTexture(e.texture), (this._numBytesAllocated -= o))
							: (this.freeTextures[i].push(e), this.numFreeTextures++, (this._numBytesFree += o)),
							this.numUsedTextures--;
						var u = this.usedTextures[i],
							l = u.indexOf(e);
						if (l < 0)
							throw new Error("Cannot release a texture that was never provided by this texture manager");
						u.splice(l, 1), this.log();
					}
				}),
				(t.log = function () {
					if (this.logEnabled) {
						var e = this.numFreeTextures + this.numUsedTextures;
						console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + e + ")");
						var t = this._numBytesFree / this._numBytesAllocated;
						console.log("Bytes allocated: " + this._numBytesAllocated),
							console.log("Bytes unused: " + this._numBytesFree + " (" + Math.round(100 * t) + "%)");
					}
				}),
				(t.getNumUsedTextures = function () {
					return this.numUsedTextures;
				}),
				(t.getNumFreeTextures = function () {
					return this.numFreeTextures;
				}),
				(t.dispose = function () {
					var e = this;
					if (null != this.freeTextures) {
						for (var t in this.freeTextures)
							this.freeTextures[t].forEach(function (t) {
								e.gpgpu.deleteMatrixTexture(t.texture);
							});
						for (var n in this.usedTextures)
							this.usedTextures[n].forEach(function (t) {
								e.gpgpu.deleteMatrixTexture(t.texture);
							});
						(this.freeTextures = null),
							(this.usedTextures = null),
							(this.numUsedTextures = 0),
							(this.numFreeTextures = 0),
							(this._numBytesAllocated = 0),
							(this._numBytesFree = 0);
					}
				}),
				mg(e, [
					{
						key: "numBytesAllocated",
						get: function () {
							return this._numBytesAllocated;
						},
					},
					{
						key: "numBytesFree",
						get: function () {
							return this._numBytesFree;
						},
					},
				]),
				e
			);
		})();
	function xY(e, t, n, r, a) {
		var i,
			o = (function (e, t) {
				switch (e) {
					case dK.PACKED_2X2_FLOAT32:
						return IX(t);
					case dK.PACKED_2X2_FLOAT16:
						return SX(t);
					case dK.UNPACKED_FLOAT32:
						return wX(t);
					case dK.UNPACKED_FLOAT16:
						return kX(t);
					case dK.PACKED_4X1_UNSIGNED_BYTE:
						return NX(t);
					default:
						throw new Error("Unknown physical texture type " + e);
				}
			})(t, r);
		if (a) {
			var s = xK(e[0], e[1]);
			i = s[0] * s[1];
		} else {
			var u = yK(e[0], e[1]);
			i = u[0] * u[1];
		}
		return (
			i *
			(function (e, t) {
				var n = e;
				if (t === n.R32F) return 4;
				if (t === n.R16F) return 2;
				if (t === n.RGBA32F) return 16;
				if (t === e.RGBA) return 16;
				if (t === n.RGBA16F) return 8;
				if (t === n.RGBA8) return 4;
				throw new Error("Unknown internal format " + t);
			})(n, o)
		);
	}
	function wY(e, t) {
		if (e === fK.UPLOAD) return dK.PACKED_2X2_FLOAT32;
		if (e === fK.RENDER || null == e)
			return (function (e) {
				return xv().getBool("WEBGL_RENDER_FLOAT32_ENABLED")
					? e
						? dK.PACKED_2X2_FLOAT32
						: dK.UNPACKED_FLOAT32
					: e
					? dK.PACKED_2X2_FLOAT16
					: dK.UNPACKED_FLOAT16;
			})(t);
		if (e === fK.DOWNLOAD || e === fK.PIXELS) return dK.PACKED_4X1_UNSIGNED_BYTE;
		throw new Error("Unknown logical texture type " + e);
	}
	function kY(e, t, n) {
		return e[0] + "_" + e[1] + "_" + t + "_" + n;
	}
	var NY = function (e, t) {
			(this.variableNames = ["A"]),
				(this.outputShape = e),
				(this.enableShapeUniforms = fX(this.outputShape.length)),
				(this.userCode =
					"\n      float unaryOperation(float x) {\n        " +
					t +
					"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
		},
		IY = "return abs(x);",
		SY = "return x;",
		TY = function (e, t) {
			(this.variableNames = ["A"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.outputShape = e),
				(this.enableShapeUniforms = fX(this.outputShape.length)),
				(this.userCode =
					"\n      vec4 unaryOperation(vec4 x) {\n        " +
					t +
					"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
		},
		CY = function (e) {
			(this.variableNames = ["A"]),
				(this.packedInputs = !0),
				(this.packedOutput = !1),
				(this.outputShape = e),
				(this.enableShapeUniforms = fX(this.outputShape.length));
			var t = e.length,
				n = gY("rc", t),
				r = sX(t),
				a = (function (e, t) {
					if (1 === e) return "rc";
					for (var n = "", r = 0; r < e; r++) (n += t[r]), r < e - 1 && (n += ",");
					return n;
				})(t, n),
				i = n.slice(-2),
				o = t <= 1 ? "rc" : "vec2(" + i.join(",") + ")";
			this.userCode =
				"\n      void main() {\n        " +
				r +
				" rc = getOutputCoords();\n        vec4 packedInput = getA(" +
				a +
				");\n\n        setOutput(getChannel(packedInput, " +
				o +
				"));\n      }\n    ";
		},
		EY = UE,
		RY = {},
		AY = xv().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),
		_Y = (function (e) {
			function t(t) {
				var n, r, a;
				if (
					(((n = e.call(this) || this).pendingRead = new WeakMap()),
					(n.pendingDisposal = new WeakSet()),
					(n.dataRefCount = new WeakMap()),
					(n.numBytesInGPU = 0),
					(n.uploadWaitMs = 0),
					(n.downloadWaitMs = 0),
					(n.lastGlFlushTime = 0),
					(n.warnedAboutMemory = !1),
					(n.pendingDeletes = 0),
					(n.disposed = !1),
					!xv().getBool("HAS_WEBGL"))
				)
					throw new Error("WebGL is not supported on this device");
				if (null != t) {
					if (t instanceof TX) r = t;
					else {
						var i = vK(xv().getNumber("WEBGL_VERSION"), t);
						r = new TX(i);
					}
					(n.binaryCache = {}), (n.gpgpuCreatedLocally = !1);
				} else {
					var o = vK(xv().getNumber("WEBGL_VERSION"));
					(r = new TX(o)),
						(n.binaryCache = ((a = xv().getNumber("WEBGL_VERSION")) in RY || (RY[a] = {}), RY[a])),
						(n.gpgpuCreatedLocally = !0);
				}
				return (
					(n.gpgpu = r),
					(n.canvas = n.gpgpu.gl.canvas),
					(n.textureManager = new bY(n.gpgpu)),
					(n.numMBBeforeWarning =
						null == xv().global.screen
							? 1024
							: (xv().global.screen.height * xv().global.screen.width * window.devicePixelRatio * 600) /
							  1024 /
							  1024),
					(n.texData = new Sg(kg(n), zI())),
					n
				);
			}
			gg(t, e);
			var n = t.prototype;
			return (
				(n.nextDataId = function () {
					return t.nextDataId++;
				}),
				(n.numDataIds = function () {
					return this.texData.numDataIds() - this.pendingDeletes;
				}),
				(n.write = function (e, t, n) {
					if (
						((xv().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || xv().getBool("DEBUG")) &&
							this.checkNumericalProblems(e),
						"complex64" === n && null != e)
					)
						throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
					var r = { id: this.nextDataId() };
					return this.texData.set(r, { shape: t, dtype: n, values: e, usage: fK.UPLOAD, refCount: 1 }), r;
				}),
				(n.refCount = function (e) {
					return this.texData.has(e) ? this.texData.get(e).refCount : 0;
				}),
				(n.incRef = function (e) {
					this.texData.get(e).refCount++;
				}),
				(n.decRef = function (e) {
					this.texData.has(e) && this.texData.get(e).refCount--;
				}),
				(n.move = function (e, t, n, r, a) {
					if ((xv().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === r))
						throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
					this.texData.set(e, { shape: n, dtype: r, values: t, usage: fK.UPLOAD, refCount: a });
				}),
				(n.disposeIntermediateTensorInfo = function (e) {
					this.disposeData(e.dataId);
				}),
				(n.readSync = function (e) {
					var t = this.texData.get(e),
						n = t.values,
						r = t.dtype,
						a = t.complexTensorInfos,
						i = t.slice,
						o = t.shape,
						s = t.isPacked;
					if (null != i) {
						var u;
						u = s ? new TY(o, SY) : new NY(o, SY);
						var l = this.runWebGLProgram(u, [{ dataId: e, shape: o, dtype: r }], r),
							c = this.readSync(l.dataId);
						return this.disposeIntermediateTensorInfo(l), c;
					}
					if (null != n) return this.convertAndCacheOnCPU(e);
					if ("string" === r) return n;
					var p,
						h,
						f = null != this.activeTimers;
					return (
						f && (p = Nw()),
						(h =
							"complex64" === r
								? BA(this.readSync(a.real.dataId), this.readSync(a.imag.dataId))
								: this.getValuesFromTexture(e)),
						f && (this.downloadWaitMs += Nw() - p),
						this.convertAndCacheOnCPU(e, h)
					);
				}),
				(n.read = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n, r, a, i, o, s, u, l, c, p, h, f, d, m, g, v, y, b, x, w, k, N, I;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (!this.pendingRead.has(t)) {
													e.next = 3;
													break;
												}
												return (
													(n = this.pendingRead.get(t)),
													e.abrupt(
														"return",
														new Promise(function (e) {
															return n.push(e);
														})
													)
												);
											case 3:
												if (
													((r = this.texData.get(t)),
													(a = r.values),
													(i = r.shape),
													(o = r.slice),
													(s = r.dtype),
													(u = r.complexTensorInfos),
													(l = r.isPacked),
													null == o)
												) {
													e.next = 11;
													break;
												}
												return (
													(c = l ? new TY(i, SY) : new NY(i, SY)),
													(p = this.runWebGLProgram(
														c,
														[{ dataId: t, shape: i, dtype: s }],
														s
													)),
													(h = this.read(p.dataId)),
													this.disposeIntermediateTensorInfo(p),
													e.abrupt("return", h)
												);
											case 11:
												if (null == a) {
													e.next = 13;
													break;
												}
												return e.abrupt("return", this.convertAndCacheOnCPU(t));
											case 13:
												if (!xv().getBool("DEBUG")) {
													e.next = 16;
													break;
												}
												if (
													xv().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") ||
													2 !== xv().getNumber("WEBGL_VERSION")
												) {
													e.next = 16;
													break;
												}
												throw new Error(
													"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported."
												);
											case 16:
												if (
													((f = null),
													"complex64" !== s &&
														xv().get("WEBGL_BUFFER_SUPPORTED") &&
														((d = this.decode(t)),
														(g = this.texData.get(d.dataId)),
														(f = (m = this.gpgpu).createBufferFromTexture.apply(
															m,
															[g.texture.texture].concat(bK(i))
														))),
													this.pendingRead.set(t, []),
													"complex64" === s)
												) {
													e.next = 22;
													break;
												}
												return (e.next = 22), this.gpgpu.createAndWaitForFence();
											case 22:
												if ("complex64" !== s) {
													e.next = 31;
													break;
												}
												return (
													(e.next = 25),
													Promise.all([this.read(u.real.dataId), this.read(u.imag.dataId)])
												);
											case 25:
												(y = e.sent), (b = y[0]), (x = y[1]), (v = BA(b, x)), (e.next = 32);
												break;
											case 31:
												null == f
													? (v = this.getValuesFromTexture(t))
													: ((w = zg(i)),
													  (v = this.gpgpu.downloadFloat32MatrixFromBuffer(f, w)));
											case 32:
												return (
													null != d && this.disposeIntermediateTensorInfo(d),
													null != f &&
														kK((k = this.gpgpu.gl), function () {
															return k.deleteBuffer(f);
														}),
													(N = this.convertAndCacheOnCPU(t, v)),
													(I = this.pendingRead.get(t)),
													this.pendingRead.delete(t),
													I.forEach(function (e) {
														return e(N);
													}),
													this.pendingDisposal.has(t) &&
														(this.pendingDisposal.delete(t),
														this.disposeData(t) && zI().removeDataId(t, this),
														this.pendingDeletes--),
													e.abrupt("return", N)
												);
											case 40:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.readToGPU = function (e, t) {
					void 0 === t && (t = {});
					var n = this.texData.get(e),
						r = n.values,
						a = n.shape,
						i = n.slice,
						o = n.dtype,
						s = n.isPacked,
						u = n.texture;
					if ("complex64" === o) throw new Error("Does not support reading texture for complex64 dtype.");
					if (null != i) {
						var l;
						l = s ? new TY(a, SY) : new NY(a, SY);
						var c = this.runWebGLProgram(l, [{ dataId: e, shape: a, dtype: o }], o),
							p = this.readToGPU(c, t);
						return this.disposeIntermediateTensorInfo(c), p;
					}
					if (null == u)
						throw null != r
							? new Error("Data is not on GPU but on CPU.")
							: new Error("There is no data on GPU or CPU.");
					var h = this.decode(e, t.customTexShape),
						f = zI().makeTensorFromDataId(h.dataId, h.shape, h.dtype),
						d = this.texData.get(h.dataId);
					return Object.assign({ tensorRef: f }, d.texture);
				}),
				(n.bufferSync = function (e) {
					var t = this.readSync(e.dataId),
						n = t;
					if ("string" === e.dtype)
						try {
							n = t.map(function (e) {
								return Tw(e);
							});
						} catch (e) {
							throw new Error("Failed to decode encoded string bytes into utf-8");
						}
					return kN(e.shape, e.dtype, n);
				}),
				(n.checkNumericalProblems = function (e) {
					if (null != e)
						for (var t = 0; t < e.length; t++) {
							var n = e[t];
							if (!NK(n)) {
								if (xv().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))
									throw Error(
										"The value " +
											n +
											" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"
									);
								throw Error("The value " + n + " cannot be represented on this device.");
							}
						}
				}),
				(n.getValuesFromTexture = function (e) {
					var t = this.texData.get(e),
						n = t.shape,
						r = t.dtype,
						a = t.isPacked,
						i = zg(n);
					if (xv().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
						var o,
							s = this.decode(e),
							u = this.texData.get(s.dataId),
							l = (o = this.gpgpu).downloadMatrixFromPackedTexture
								.apply(o, [u.texture.texture].concat(bK(n)))
								.subarray(0, i);
						return this.disposeIntermediateTensorInfo(s), l;
					}
					var c = xv().getBool("WEBGL_PACK") && !0 === a,
						p = c ? PK(n) : n,
						h = c ? new vX(p) : new gX(p),
						f = this.runWebGLProgram(h, [{ shape: p, dtype: r, dataId: e }], "float32"),
						d = this.texData.get(f.dataId),
						m = this.gpgpu
							.downloadByteEncodedFloatMatrixFromOutputTexture(
								d.texture.texture,
								d.texShape[0],
								d.texShape[1]
							)
							.subarray(0, i);
					return this.disposeIntermediateTensorInfo(f), m;
				}),
				(n.timerAvailable = function () {
					return xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
				}),
				(n.time = function (e) {
					var t = this,
						n = this.activeTimers,
						r = [],
						a = !1;
					null == this.programTimersStack
						? ((this.programTimersStack = r), (a = !0))
						: this.activeTimers.push(r),
						(this.activeTimers = r),
						e();
					var i = Lg(
							this.activeTimers.map(function (e) {
								return e.query;
							})
						).filter(function (e) {
							return null != e;
						}),
						o = Lg(
							this.activeTimers.map(function (e) {
								return e.name;
							})
						).filter(function (e) {
							return null != e;
						});
					(this.activeTimers = n), a && (this.programTimersStack = null);
					var s = {
						uploadWaitMs: this.uploadWaitMs,
						downloadWaitMs: this.downloadWaitMs,
						kernelMs: null,
						wallMs: null,
					};
					return fg(
						regeneratorRuntime.mark(function e() {
							var n;
							return regeneratorRuntime.wrap(function (e) {
								for (;;)
									switch ((e.prev = e.next)) {
										case 0:
											if (
												!(xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)
											) {
												e.next = 8;
												break;
											}
											return (e.next = 3), Promise.all(i);
										case 3:
											(n = e.sent),
												(s.kernelMs = Fg(n)),
												(s.getExtraProfileInfo = function () {
													return n
														.map(function (e, t) {
															return { name: o[t], ms: e };
														})
														.map(function (e) {
															return e.name + ": " + e.ms;
														})
														.join(", ");
												}),
												(e.next = 9);
											break;
										case 8:
											s.kernelMs = {
												error: "WebGL query timers are not supported in this environment.",
											};
										case 9:
											return (t.uploadWaitMs = 0), (t.downloadWaitMs = 0), e.abrupt("return", s);
										case 12:
										case "end":
											return e.stop();
									}
							}, e);
						})
					)();
				}),
				(n.memory = function () {
					return {
						unreliable: !1,
						numBytesInGPU: this.numBytesInGPU,
						numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
						numBytesInGPUFree: this.textureManager.numBytesFree,
					};
				}),
				(n.startTimer = function () {
					return xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0
						? this.gpgpu.beginQuery()
						: { startMs: Nw(), endMs: null };
				}),
				(n.endTimer = function (e) {
					return xv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0
						? (this.gpgpu.endQuery(), e)
						: ((e.endMs = Nw()), e);
				}),
				(n.getQueryTime = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							var n;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (
													!(
														xv().getNumber(
															"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"
														) > 0
													)
												) {
													e.next = 2;
													break;
												}
												return e.abrupt("return", this.gpgpu.waitForQueryAndGetTime(t));
											case 2:
												return (n = t), e.abrupt("return", n.endMs - n.startMs);
											case 4:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.disposeData = function (e, t) {
					if ((void 0 === t && (t = !1), this.pendingDisposal.has(e))) return !1;
					if (!this.texData.has(e)) return !0;
					if (
						(t ? (this.texData.get(e).refCount = 0) : this.texData.get(e).refCount--,
						!t && this.texData.get(e).refCount > 0)
					)
						return !1;
					if (this.pendingRead.has(e)) return this.pendingDisposal.add(e), this.pendingDeletes++, !1;
					this.releaseGPUData(e);
					var n = this.texData.get(e).complexTensorInfos;
					return (
						null != n && (this.disposeData(n.real.dataId, t), this.disposeData(n.imag.dataId, t)),
						this.texData.delete(e),
						!0
					);
				}),
				(n.releaseGPUData = function (e) {
					var t = this.texData.get(e),
						n = t.texture,
						r = t.dtype,
						a = t.texShape,
						i = t.usage,
						o = t.isPacked,
						s = t.slice,
						u = (s && s.origDataId) || e,
						l = this.dataRefCount.get(u);
					l > 1
						? this.dataRefCount.set(u, l - 1)
						: (this.dataRefCount.delete(u),
						  null != n &&
								((this.numBytesInGPU -= this.computeBytes(a, r)),
								this.textureManager.releaseTexture(n, a, i, o)));
					var c = this.texData.get(e);
					(c.texture = null), (c.texShape = null), (c.isPacked = !1), (c.slice = null);
				}),
				(n.getTexture = function (e) {
					return this.uploadToGPU(e), this.texData.get(e).texture.texture;
				}),
				(n.getDataInfo = function (e) {
					return this.texData.get(e);
				}),
				(n.shouldExecuteOnCPU = function (e, t) {
					var n = this;
					return (
						void 0 === t && (t = AY),
						xv().getBool("WEBGL_CPU_FORWARD") &&
							e.every(function (e) {
								return null == n.texData.get(e.dataId).texture && zg(e.shape) < t;
							})
					);
				}),
				(n.getGPGPUContext = function () {
					return this.gpgpu;
				}),
				(n.where = function (e) {
					Ex("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
					var t = e.dataSync();
					return EY(e.shape, t);
				}),
				(n.packedUnaryOp = function (e, t, n) {
					var r = new TY(e.shape, t),
						a = this.compileAndRun(r, [e], n);
					return zI().makeTensorFromDataId(a.dataId, a.shape, a.dtype);
				}),
				(n.abs = function (e) {
					if (this.shouldExecuteOnCPU([e]) && "complex64" !== e.dtype) {
						var t = eY(this.texData.get(e.dataId).values);
						return this.makeOutput(e.shape, e.dtype, t);
					}
					if (xv().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e, IY, e.dtype);
					var n = new NY(e.shape, IY),
						r = this.compileAndRun(n, [e]);
					return zI().makeTensorFromDataId(r.dataId, r.shape, r.dtype);
				}),
				(n.makeTensorInfo = function (e, t, n) {
					var r;
					if ("string" === t && null != n && n.length > 0 && ev(n[0])) {
						var a = n.map(function (e) {
							return Sw(e);
						});
						r = this.write(a, e, t);
					} else r = this.write(n, e, t);
					return (this.texData.get(r).usage = null), { dataId: r, shape: e, dtype: t };
				}),
				(n.makeOutput = function (e, t, n) {
					var r = this.makeTensorInfo(e, t, n).dataId;
					return zI().makeTensorFromDataId(r, e, t, this);
				}),
				(n.unpackTensor = function (e) {
					var t = new CY(e.shape);
					return this.runWebGLProgram(t, [e], e.dtype);
				}),
				(n.packTensor = function (e) {
					var t = new vY(e.shape);
					return this.runWebGLProgram(t, [e], e.dtype, null, !0);
				}),
				(n.packedReshape = function (e, t) {
					var n = [LK(e.shape)].concat(zK(e.shape)),
						r = { dtype: e.dtype, shape: n, dataId: e.dataId },
						a = [LK(t)].concat(zK(t)),
						i = new yY(a, n),
						o = [n],
						s = this.runWebGLProgram(i, [r], e.dtype, o, !0);
					return { dataId: s.dataId, shape: t, dtype: s.dtype };
				}),
				(n.decode = function (e, t) {
					var n = this.texData.get(e),
						r = n.isPacked,
						a = n.shape,
						i = n.dtype;
					null != t &&
						Dg(zg(a) <= t[0] * t[1] * 4, function () {
							return "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.";
						});
					var o,
						s = PK(a);
					o = r ? new mX(s) : new dX(s);
					var u = [null != t ? t : bK(s)];
					return {
						dtype: i,
						shape: a,
						dataId: this.runWebGLProgram(o, [{ shape: s, dtype: i, dataId: e }], i, u, !0, t).dataId,
					};
				}),
				(n.runWebGLProgram = function (e, t, n, r, a, i) {
					var o = this;
					void 0 === a && (a = !1);
					var s = this.makeTensorInfo(e.outputShape, n),
						u = this.texData.get(s.dataId);
					if ((e.packedOutput && (u.isPacked = !0), e.outPackingScheme === hK.DENSE)) {
						var l = null != i ? i : bK(e.outputShape);
						u.texShape = l.map(function (e) {
							return 2 * e;
						});
					}
					if ((null != e.outTexUsage && (u.usage = e.outTexUsage), 0 === zg(s.shape)))
						return (u.values = qg(s.dtype, 0)), s;
					var c = [],
						p = t.map(function (t) {
							if ("complex64" === t.dtype)
								throw new Error(
									"GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts."
								);
							var n = o.texData.get(t.dataId);
							if (null == n.texture) {
								if (!e.packedInputs && zg(t.shape) <= xv().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))
									return { shape: t.shape, texData: null, isUniform: !0, uniformValues: n.values };
								e.packedInputs && ((n.isPacked = !0), (n.shape = t.shape));
							}
							if ((o.uploadToGPU(t.dataId), !!n.isPacked != !!e.packedInputs))
								(t = n.isPacked ? o.unpackTensor(t) : o.packTensor(t)),
									c.push(t),
									(n = o.texData.get(t.dataId));
							else if (n.isPacked && !WK(n.shape, t.shape)) {
								var r = t,
									a = t.shape;
								(t.shape = n.shape),
									(t = o.packedReshape(t, a)),
									c.push(t),
									(n = o.texData.get(t.dataId)),
									(r.shape = a);
							}
							return { shape: t.shape, texData: n, isUniform: !1 };
						});
					this.uploadToGPU(s.dataId);
					var h,
						f = { shape: s.shape, texData: u, isUniform: !1 },
						d = (function (e, t, n) {
							var r = "";
							t.concat(n).forEach(function (t) {
								var a = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0;
								if (e.enableShapeUniforms && !t.isUniform) {
									var i = t.texData.texShape,
										o = uX(e.packedInputs, t.shape, i),
										s = o.useSqueezeShape,
										u = o.uniformShape,
										l = o.keptDims,
										c = "",
										p = "",
										h = "";
									if (1 === u.length && e.packedInputs) {
										var f = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
										c = (f[0] > 1) + "_" + (f[1] > 1);
									} else if (2 !== u.length || e.packedInputs) {
										if (u.length > 2 && !e.packedInputs) {
											var d = ov(u);
											h = (d[0] === i[1]) + "_" + (d[d.length - 1] === i[1]);
										}
									} else p = (u[0] > 1) + "_" + (u[1] > 1);
									var m = t.shape.length,
										g = 2 === u.length && Pg(t.shape, i),
										v = 1 === zg(t.shape),
										y = XN(t.shape, n.shape),
										b = !e.packedInputs && m === n.shape.length && Pg(i, n.texData.texShape),
										x = e.packedInputs || u.length > 2 ? "" : (i[0] > 1) + "_" + (i[1] > 1);
									r +=
										m +
										"_" +
										b +
										"_" +
										(s ? l : "") +
										"_" +
										u.length +
										"_" +
										v +
										"_" +
										y +
										"_" +
										g +
										"_" +
										c +
										"_" +
										p +
										"_" +
										h +
										"_" +
										x +
										"_" +
										a;
								} else {
									var w = t.isUniform ? "uniform" : t.texData.texShape;
									r += t.shape + "_" + w + "_" + a;
								}
							});
							var a = e.userCode;
							return e.constructor.name + "_" + r + "_" + a + xv().getNumber("WEBGL_VERSION");
						})(e, p, f),
						m = this.getAndSaveBinary(d, function () {
							return (function (e, t, n, r) {
								var a = n.map(function (e, n) {
										var r = {
											logicalShape: e.shape,
											texShape: e.isUniform ? null : e.texData.texShape,
											isUniform: e.isUniform,
											isPacked: !e.isUniform && e.texData.isPacked,
											flatOffset: null,
										};
										return (
											null != e.texData &&
												null != e.texData.slice &&
												e.texData.slice.flatOffset > 0 &&
												(r.flatOffset = e.texData.slice.flatOffset),
											{ name: t.variableNames[n], shapeInfo: r }
										);
									}),
									i = a.map(function (e) {
										return e.shapeInfo;
									}),
									o = {
										logicalShape: r.shape,
										texShape: r.texData.texShape,
										isUniform: !1,
										isPacked: r.texData.isPacked,
										flatOffset: null,
									},
									s = QK(a, o, t),
									u = (function (e, t) {
										var n = MK(
											e,
											function () {
												return e.createShader(e.FRAGMENT_SHADER);
											},
											"Unable to create fragment WebGLShader."
										);
										if (
											(kK(e, function () {
												return e.shaderSource(n, t);
											}),
											kK(e, function () {
												return e.compileShader(n);
											}),
											xv().get("ENGINE_COMPILE_ONLY"))
										)
											return n;
										if (!1 === e.getShaderParameter(n, e.COMPILE_STATUS))
											throw (
												(EK(t, e.getShaderInfoLog(n)),
												new Error("Failed to compile fragment shader."))
											);
										return n;
									})(e.gl, s),
									l = e.createProgram(u);
								return xv().get("ENGINE_COMPILE_ONLY")
									? {
											program: t,
											fragmentShader: u,
											source: s,
											webGLProgram: l,
											inShapeInfos: i,
											outShapeInfo: o,
											uniformLocations: null,
											customUniformLocations: null,
											infLoc: null,
											nanLoc: null,
											inShapesLocations: null,
											inTexShapesLocations: null,
											outShapeLocation: null,
											outShapeStridesLocation: null,
											outTexShapeLocation: null,
									  }
									: Object.assign(
											{
												program: t,
												fragmentShader: u,
												source: s,
												webGLProgram: l,
												inShapeInfos: i,
												outShapeInfo: o,
											},
											pX(e, t, l)
									  );
							})(o.gpgpu, e, p, f);
						}),
						g = null != this.activeTimers;
					g && (h = this.startTimer()),
						xv().get("ENGINE_COMPILE_ONLY") ||
							(function (e, t, n, r, a) {
								t.program.enableShapeUniforms || (hX(t.inShapeInfos, n), hX([t.outShapeInfo], [r]));
								var i = r.texData.texture,
									o = r.texData.texShape;
								r.texData.isPacked
									? e.setOutputPackedMatrixTexture(i.texture, o[0], o[1])
									: e.setOutputMatrixTexture(i.texture, o[0], o[1]),
									e.setProgram(t.webGLProgram),
									1 === xv().getNumber("WEBGL_VERSION") &&
										null !== t.infLoc &&
										e.gl.uniform1f(t.infLoc, 1 / 0),
									null !== t.nanLoc && e.gl.uniform1f(t.nanLoc, NaN),
									n.forEach(function (n, r) {
										var a = t.program.variableNames[r],
											i = t.uniformLocations[a],
											o = t.uniformLocations["offset" + a],
											s = t.inShapesLocations[a + "Shape"],
											u = t.inTexShapesLocations[a + "TexShape"];
										if (s) {
											var l = uX(
												t.program.packedInputs,
												n.shape,
												n.texData.texShape
											).uniformShape;
											switch (l.length) {
												case 1:
													e.gl.uniform1iv(s, new Int32Array(l));
													break;
												case 2:
													e.gl.uniform2iv(s, new Int32Array(l));
													break;
												case 3:
													e.gl.uniform3iv(s, new Int32Array(l));
													break;
												case 4:
													e.gl.uniform4iv(s, new Int32Array(l));
											}
										}
										if (
											(u && e.gl.uniform2i(u, n.texData.texShape[0], n.texData.texShape[1]),
											null != i)
										)
											if (n.isUniform)
												if (zg(n.shape) < 2) e.gl.uniform1f(i, n.uniformValues[0]);
												else {
													var c = n.uniformValues;
													c instanceof Float32Array || (c = new Float32Array(c)),
														e.gl.uniform1fv(i, c);
												}
											else
												null != n.texData.slice &&
													null != o &&
													e.gl.uniform1i(o, n.texData.slice.flatOffset),
													e.setInputMatrixTexture(n.texData.texture.texture, i, r);
									});
								var s = t.outShapeLocation;
								if (s)
									switch (r.shape.length) {
										case 1:
											e.gl.uniform1iv(s, new Int32Array(r.shape));
											break;
										case 2:
											e.gl.uniform2iv(s, new Int32Array(r.shape));
											break;
										case 3:
											e.gl.uniform3iv(s, new Int32Array(r.shape));
											break;
										case 4:
											e.gl.uniform4iv(s, new Int32Array(r.shape));
									}
								if (t.outShapeStridesLocation) {
									var u = ov(r.shape);
									switch (r.shape.length) {
										case 2:
											e.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(u));
											break;
										case 3:
											e.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(u));
											break;
										case 4:
											e.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(u));
									}
								}
								t.outTexShapeLocation &&
									e.gl.uniform2i(t.outTexShapeLocation, r.texData.texShape[0], r.texData.texShape[1]),
									t.program.customUniforms &&
										a &&
										t.program.customUniforms.forEach(function (n, r) {
											var i = t.customUniformLocations[r],
												o = a[r];
											if ("float" === n.type) e.gl.uniform1fv(i, o);
											else if ("vec2" === n.type) e.gl.uniform2fv(i, o);
											else if ("vec3" === n.type) e.gl.uniform3fv(i, o);
											else if ("vec4" === n.type) e.gl.uniform4fv(i, o);
											else if ("int" === n.type) e.gl.uniform1iv(i, o);
											else if ("ivec2" === n.type) e.gl.uniform2iv(i, o);
											else if ("ivec3" === n.type) e.gl.uniform3iv(i, o);
											else {
												if ("ivec4" !== n.type)
													throw Error("uniform type " + n.type + " is not supported yet.");
												e.gl.uniform4iv(i, o);
											}
										}),
									e.executeProgram();
							})(this.gpgpu, m, p, f, r),
						c.forEach(function (e) {
							return o.disposeIntermediateTensorInfo(e);
						}),
						g &&
							((h = this.endTimer(h)),
							this.activeTimers.push({ name: e.constructor.name, query: this.getQueryTime(h) }));
					var v = xv().get("WEBGL_FLUSH_THRESHOLD");
					if (v > 0) {
						var y = Nw();
						y - this.lastGlFlushTime > v && (this.gpgpu.gl.flush(), (this.lastGlFlushTime = y));
					}
					if (!xv().getBool("WEBGL_LAZILY_UNPACK") && u.isPacked && !1 === a) {
						var b = this.unpackTensor(s);
						return this.disposeIntermediateTensorInfo(s), b;
					}
					return s;
				}),
				(n.compileAndRun = function (e, t, n, r, a) {
					return void 0 === a && (a = !1), (n = n || t[0].dtype), this.runWebGLProgram(e, t, n, r, a);
				}),
				(n.getAndSaveBinary = function (e, t) {
					return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e];
				}),
				(n.getTextureManager = function () {
					return this.textureManager;
				}),
				(n.dispose = function () {
					var e = this;
					this.disposed ||
						(xv().getBool("IS_TEST") ||
							Object.keys(this.binaryCache).forEach(function (t) {
								e.gpgpu.deleteProgram(e.binaryCache[t].webGLProgram), delete e.binaryCache[t];
							}),
						this.textureManager.dispose(),
						null != this.canvas &&
						"undefined" != typeof HTMLCanvasElement &&
						this.canvas instanceof HTMLCanvasElement
							? this.canvas.remove()
							: (this.canvas = null),
						this.gpgpuCreatedLocally && ((this.gpgpu.program = null), this.gpgpu.dispose()),
						(this.disposed = !0));
				}),
				(n.floatPrecision = function () {
					var e = this;
					return (
						null == this.floatPrecisionValue &&
							(this.floatPrecisionValue = BI(function () {
								if (!xv().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
									var t = xv().getBool("DEBUG");
									xv().set("DEBUG", !1);
									var n = e.abs(iE(1e-8)).dataSync()[0];
									if ((xv().set("DEBUG", t), n > 0)) return 32;
								}
								return 16;
							})),
						this.floatPrecisionValue
					);
				}),
				(n.epsilon = function () {
					return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
				}),
				(n.uploadToGPU = function (e) {
					var t = this.texData.get(e),
						n = t.shape,
						r = t.dtype,
						a = t.values,
						i = t.texture,
						o = t.usage,
						s = t.isPacked;
					if (null == i) {
						var u,
							l = null != this.activeTimers;
						l && (u = Nw());
						var c = t.texShape;
						if (
							(null == c &&
								((c = (function (e, t) {
									void 0 === t && (t = !1);
									var n = xv().getNumber("WEBGL_MAX_TEXTURE_SIZE");
									if (
										(t &&
											((n *= 2),
											1 ===
												(e = e.map(function (t, n) {
													return n >= e.length - 2 ? Ag(e[n]) : e[n];
												})).length && (e = [2, e[0]])),
										2 !== e.length)
									) {
										var r = Hg(e);
										e = r.newShape;
									}
									var a = zg(e);
									if (e.length <= 1 && a <= n) return [1, a];
									if (2 === e.length && e[0] <= n && e[1] <= n) return e;
									if (3 === e.length && e[0] * e[1] <= n && e[2] <= n) return [e[0] * e[1], e[2]];
									if (3 === e.length && e[0] <= n && e[1] * e[2] <= n) return [e[0], e[1] * e[2]];
									if (4 === e.length && e[0] * e[1] * e[2] <= n && e[3] <= n)
										return [e[0] * e[1] * e[2], e[3]];
									if (4 === e.length && e[0] <= n && e[1] * e[2] * e[3] <= n)
										return [e[0], e[1] * e[2] * e[3]];
									if (t) {
										var i = LK(e),
											o = 2,
											s = 2;
										if (e.length) {
											var u = zK(e);
											(o = u[0]), (s = u[1]);
										}
										return Wg((a = i * (o / 2) * (s / 2))).map(function (e) {
											return 2 * e;
										});
									}
									return Wg(a);
								})(n, s)),
								(t.texShape = c)),
							null != a)
						) {
							var p,
								h = PK(n),
								f = c[1],
								d = c[0],
								m = a instanceof Uint8Array || a instanceof Uint8ClampedArray;
							if (s || !m) {
								var g = xK(c[0], c[1]);
								(f = g[0]), (d = g[1]);
							}
							p = s ? new bX(h, m) : new yX(h, m);
							var v = m ? [d, f] : c,
								y = this.makeTensorInfo(v, r),
								b = this.texData.get(y.dataId);
							(b.usage = m ? fK.PIXELS : fK.UPLOAD),
								(b.texShape = v),
								this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId), f, d, a);
							var x = [[d, f]],
								w = this.runWebGLProgram(p, [y], r, x, !0),
								k = this.texData.get(w.dataId);
							(t.texShape = k.texShape),
								(t.isPacked = k.isPacked),
								(t.usage = k.usage),
								xv().get("ENGINE_COMPILE_ONLY")
									? this.disposeData(w.dataId)
									: ((t.texture = k.texture), (t.values = null), this.texData.delete(w.dataId)),
								this.disposeIntermediateTensorInfo(y),
								l && (this.uploadWaitMs += Nw() - u);
						} else {
							var N = this.acquireTexture(c, o, r, s);
							t.texture = N;
						}
					}
				}),
				(n.convertAndCacheOnCPU = function (e, t) {
					var n = this.texData.get(e),
						r = n.dtype;
					return (
						this.releaseGPUData(e),
						null != t &&
							(n.values = (function (e, t) {
								if ("float32" === t || "complex64" === t) return e;
								if ("int32" === t || "bool" === t) {
									for (
										var n = "int32" === t ? new Int32Array(e.length) : new Uint8Array(e.length),
											r = 0;
										r < n.length;
										++r
									)
										n[r] = Math.round(e[r]);
									return n;
								}
								throw new Error("Unknown dtype " + t);
							})(t, r)),
						n.values
					);
				}),
				(n.acquireTexture = function (e, t, n, r) {
					if (
						((this.numBytesInGPU += this.computeBytes(e, n)),
						!this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024)
					) {
						var a = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
						(this.warnedAboutMemory = !0),
							console.warn("High memory usage in GPU: " + a + " MB, most likely due to a memory leak");
					}
					return this.textureManager.acquireTexture(e, t, r);
				}),
				(n.computeBytes = function (e, t) {
					return e[0] * e[1] * Qg(t);
				}),
				(n.checkCompileCompletion = function () {
					for (var e = 0, t = Object.entries(this.binaryCache); e < t.length; e++) {
						var n = t[e][1];
						this.checkCompletion_(n);
					}
				}),
				(n.checkCompileCompletionAsync = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e() {
							var t,
								n,
								r,
								a,
								i,
								o,
								s,
								u,
								l = this;
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (((t = []), !this.gpgpu.parallelCompilationExtension)) {
													e.next = 6;
													break;
												}
												for (n = 0, r = Object.entries(this.binaryCache); n < r.length; n++)
													(a = r[n]), (i = a[1]), t.push(this.checkCompletionAsync_(i));
												return e.abrupt("return", Promise.all(t));
											case 6:
												for (
													o = function () {
														var e = u[s][1],
															n = new Promise(function (t) {
																try {
																	l.checkCompletion_(e), t(!0);
																} catch (e) {
																	throw e;
																}
															});
														t.push(n);
													},
														s = 0,
														u = Object.entries(this.binaryCache);
													s < u.length;
													s++
												)
													o();
												return e.abrupt("return", Promise.all(t));
											case 9:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function () {
						return e.apply(this, arguments);
					};
				})()),
				(n.checkCompletionAsync_ = (function () {
					var e = fg(
						regeneratorRuntime.mark(function e(t) {
							return regeneratorRuntime.wrap(
								function (e) {
									for (;;)
										switch ((e.prev = e.next)) {
											case 0:
												if (
													!this.gpgpu.gl.getProgramParameter(
														t.webGLProgram,
														this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR
													)
												) {
													e.next = 4;
													break;
												}
												return e.abrupt("return", this.checkCompletion_(t));
											case 4:
												return (e.next = 6), CA();
											case 6:
												return e.abrupt("return", this.checkCompletionAsync_(t));
											case 7:
											case "end":
												return e.stop();
										}
								},
								e,
								this
							);
						})
					);
					return function (t) {
						return e.apply(this, arguments);
					};
				})()),
				(n.checkCompletion_ = function (e) {
					if (!1 === this.gpgpu.gl.getProgramParameter(e.webGLProgram, this.gpgpu.gl.LINK_STATUS)) {
						if (
							(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),
							!1 === this.gpgpu.gl.getShaderParameter(e.fragmentShader, this.gpgpu.gl.COMPILE_STATUS))
						)
							throw (
								(EK(e.source, this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),
								new Error("Failed to compile fragment shader."))
							);
						throw new Error("Failed to link vertex and fragment shaders.");
					}
					return !0;
				}),
				(n.getUniformLocations = function () {
					for (var e = 0, t = Object.entries(this.binaryCache); e < t.length; e++) {
						var n = t[e][1],
							r = pX(this.gpgpu, n.program, n.webGLProgram),
							a = r.uniformLocations,
							i = r.customUniformLocations,
							o = r.infLoc,
							s = r.nanLoc,
							u = r.inShapesLocations,
							l = r.inTexShapesLocations,
							c = r.outShapeLocation,
							p = r.outShapeStridesLocation,
							h = r.outTexShapeLocation;
						(n.uniformLocations = a),
							(n.customUniformLocations = i),
							(n.infLoc = o),
							(n.nanLoc = s),
							(n.inShapesLocations = u),
							(n.inTexShapesLocations = l),
							(n.outShapeLocation = c),
							(n.outShapeStridesLocation = p),
							(n.outTexShapeLocation = h);
					}
				}),
				t
			);
		})(Tg);
	(_Y.nextDataId = 0),
		lk() &&
			VI(
				"webgl",
				function () {
					return new _Y();
				},
				2
			);
	var FY = function (e, t, n) {
			(this.variableNames = ["A", "B"]),
				(this.outputShape = JN(t, n)),
				(this.enableShapeUniforms = fX(this.outputShape.length)),
				(this.userCode =
					"\n      float binaryOperation(float a, float b) {\n        " +
					e +
					"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ");
		},
		DY = function (e, t, n, r) {
			void 0 === r && (r = !1),
				(this.variableNames = ["A", "B"]),
				(this.supportsBroadcasting = !0),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.outputShape = JN(t, n));
			var a = this.outputShape.length;
			this.enableShapeUniforms = fX(a);
			var i = "";
			if (r)
				if (0 === a || 1 === zg(this.outputShape))
					i = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
				else if (((i = "\n          " + sX(a) + " coords = getOutputCoords();\n        "), 1 === a))
					this.enableShapeUniforms
						? (i +=
								"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ")
						: (i +=
								"\n            result.y = (coords + 1) >= " +
								this.outputShape[0] +
								" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");
				else {
					var o = gY("coords", a);
					this.enableShapeUniforms
						? (i +=
								"\n            bool nextRowOutOfBounds =\n              (" +
								o[a - 2] +
								" + 1) >= outShape[" +
								a +
								" - 2];\n            bool nextColOutOfBounds =\n              (" +
								o[a - 1] +
								" + 1) >= outShape[" +
								a +
								" - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")
						: (i +=
								"\n            bool nextRowOutOfBounds =\n              (" +
								o[a - 2] +
								" + 1) >= " +
								this.outputShape[a - 2] +
								";\n            bool nextColOutOfBounds =\n              (" +
								o[a - 1] +
								" + 1) >= " +
								this.outputShape[a - 1] +
								";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ");
				}
			this.userCode =
				"\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " +
				e +
				"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " +
				i +
				"\n\n        setOutput(result);\n      }\n    ";
		};
	function OY(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.x;
		return n.incRef(r.dataId), { dataId: r.dataId, shape: r.shape, dtype: r.dtype };
	}
	var MY = { kernelName: zy, backendName: "webgl", kernelFunc: OY };
	function LY(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.real,
			a = t.imag,
			i = n.makeTensorInfo(r.shape, "complex64"),
			o = n.texData.get(i.dataId),
			s = OY({ inputs: { x: r }, backend: n }),
			u = OY({ inputs: { x: a }, backend: n });
		return (o.complexTensorInfos = { real: s, imag: u }), i;
	}
	var zY = { kernelName: Yv, backendName: "webgl", kernelFunc: LY },
		PY = "return (a < 0.) ? b * a : a;",
		BY =
			"\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
		WY = {
			kernelName: Gy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.alpha,
					o = n.makeTensorInfo([], "float32", ww(i, "float32")),
					s = xv().getBool("WEBGL_PACK_BINARY_OPERATIONS")
						? new DY(BY, a.shape, o.shape)
						: new FY(PY, a.shape, o.shape),
					u = n.runWebGLProgram(s, [a, o], "float32");
				return n.disposeIntermediateTensorInfo(o), u;
			},
		},
		UY = "return (a < 0.) ? b * a : a;",
		VY =
			"\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
		GY = {
			kernelName: Sb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.x,
					a = t.alpha,
					i = xv().getBool("WEBGL_PACK_BINARY_OPERATIONS")
						? new DY(VY, r.shape, a.shape)
						: new FY(UY, r.shape, a.shape);
				return n.runWebGLProgram(i, [r, a], "float32");
			},
		};
	function jY(e) {
		var t = e.opSnippet,
			n = e.packedOpSnippet,
			r = e.cpuKernelImpl,
			a = e.dtype;
		return function (e) {
			var i,
				o = e.inputs,
				s = e.backend,
				u = o.x,
				l = s,
				c = a || u.dtype;
			if (l.shouldExecuteOnCPU([u]) && null != r) {
				var p = l.texData.get(u.dataId),
					h = r(p.values, c);
				return l.makeTensorInfo(u.shape, c, h);
			}
			return (
				(i =
					xv().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != n ? new TY(u.shape, n) : new NY(u.shape, t)),
				l.runWebGLProgram(i, [u], c)
			);
		};
	}
	function HY(e) {
		var t = e.opSnippet,
			n = e.packedOpSnippet,
			r = e.checkOutOfBounds,
			a = void 0 !== r && r,
			i = e.supportsComplex,
			o = void 0 !== i && i,
			s = e.cpuKernelImpl,
			u = e.dtype;
		return function (e) {
			var r = e.inputs,
				i = e.backend,
				l = r.a,
				c = r.b,
				p = i;
			if (o && "complex64" === l.dtype) {
				var h = p.texData.get(l.dataId),
					f = p.texData.get(c.dataId),
					d = [
						[h.complexTensorInfos.real, f.complexTensorInfos.real],
						[h.complexTensorInfos.imag, f.complexTensorInfos.imag],
					].map(function (e) {
						var n = e[0],
							r = e[1],
							a = { dataId: n.dataId, dtype: n.dtype, shape: l.shape },
							i = { dataId: r.dataId, dtype: r.dtype, shape: c.shape },
							o = new FY(t, l.shape, c.shape);
						return p.runWebGLProgram(o, [a, i], Kw(n.dtype, r.dtype));
					}),
					m = d[0],
					g = d[1],
					v = LY({ inputs: { real: m, imag: g }, backend: p });
				return p.disposeIntermediateTensorInfo(m), p.disposeIntermediateTensorInfo(g), v;
			}
			var y,
				b = u || Kw(l.dtype, c.dtype);
			if (("string" === l.dtype || "string" === c.dtype || p.shouldExecuteOnCPU([l, c])) && null != s) {
				var x = p.texData.get(l.dataId).values,
					w = p.texData.get(c.dataId).values,
					k = "string" === l.dtype ? f_(x) : x,
					N = "string" === l.dtype ? f_(w) : w,
					I = s(l.shape, c.shape, k, N, b),
					S = I[0],
					T = I[1],
					C = p.makeTensorInfo(T, b);
				return (p.texData.get(C.dataId).values = S), C;
			}
			return (
				(y =
					xv().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != n
						? new DY(n, l.shape, c.shape, a)
						: new FY(t, l.shape, c.shape)),
				p.runWebGLProgram(y, [l, c], b)
			);
		};
	}
	function qY(e, t) {
		if ((void 0 === t && (t = !1), "linear" === e)) return "return x;";
		if ("relu" === e)
			return t
				? "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
				: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";
		if ("elu" === e)
			return t
				? "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
				: "return (x >= 0.0) ? x : (exp(x) - 1.0);";
		if ("relu6" === e)
			return t
				? "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
				: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
		if ("prelu" === e) return t ? VY : UY;
		if ("leakyrelu" === e) return t ? BY : PY;
		if ("sigmoid" === e) return "return 1.0 / (1.0 + exp(-1.0 * x));";
		throw new Error("Activation " + e + " has not been implemented for the WebGL backend.");
	}
	var KY = function (e, t, n, r, a, i, o, s, u) {
			void 0 === r && (r = !1),
				void 0 === a && (a = !1),
				void 0 === i && (i = !1),
				void 0 === o && (o = null),
				void 0 === s && (s = !1),
				void 0 === u && (u = !1),
				(this.variableNames = ["matrixA", "matrixB"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.outputShape = n),
				(this.enableShapeUniforms = fX(this.outputShape.length));
			var l = r ? e[1] : e[2],
				c = Math.ceil(l / 2),
				p = r ? "i * 2, rc.y" : "rc.y, i * 2",
				h = a ? "rc.z, i * 2" : "i * 2, rc.z",
				f = r ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
				d = a ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
				m = "",
				g = "";
			o &&
				((m = s
					? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " +
					  o +
					  "\n        }"
					: u
					? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          " +
					  o +
					  "\n        }"
					: "vec4 activation(vec4 x) {\n          " + o + "\n        }"),
				(g = "result = activation(result);"));
			var v = i ? "result += getBiasAtOutCoords();" : "";
			i && this.variableNames.push("bias"),
				s && this.variableNames.push("preluActivationWeights"),
				u && this.variableNames.push("leakyreluAlpha");
			var y = "rc.x",
				b = "rc.x";
			e[0] < t[0]
				? (y = "int(min(float(rc.x), " + (e[0] - 1) + ".))")
				: t[0] < e[0] && (b = "int(min(float(rc.x), " + (t[0] - 1) + ".))"),
				(this.userCode =
					"\n      " +
					m +
					"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = " +
					c +
					".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " +
					c +
					"; i++) {\n          int batchA = " +
					y +
					";\n          int batchB = " +
					b +
					";\n          vec4 a = getMatrixA(batchA, " +
					p +
					");\n          vec4 b = getMatrixB(batchB, " +
					h +
					");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" +
					f[0] +
					" * " +
					d[0] +
					");\n          result += (" +
					f[1] +
					" * " +
					d[1] +
					");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " +
					v +
					"\n\n        " +
					g +
					"\n\n        setOutput(result);\n      }\n    ");
		},
		XY = function (e, t, n) {
			(this.variableNames = ["AReal", "AImag", "BReal", "BImag"]),
				(this.outputShape = JN(t, n)),
				(this.userCode =
					"\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " +
					e +
					"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ");
		},
		YY = "return a * b;";
	function JY(e) {
		var t,
			n = e.inputs,
			r = e.backend,
			a = n.a,
			i = n.b,
			o = Kw(a.dtype, i.dtype);
		if ("complex64" === a.dtype) {
			var s = r.texData.get(a.dataId),
				u = r.texData.get(i.dataId),
				l = new XY("return areal * breal - aimag * bimag;", a.shape, i.shape),
				c = new XY("return areal * bimag + aimag * breal;", a.shape, i.shape),
				p = [
					{
						dataId: s.complexTensorInfos.real.dataId,
						dtype: s.complexTensorInfos.real.dtype,
						shape: a.shape,
					},
					{
						dataId: s.complexTensorInfos.imag.dataId,
						dtype: s.complexTensorInfos.imag.dtype,
						shape: a.shape,
					},
					{
						dataId: u.complexTensorInfos.real.dataId,
						dtype: u.complexTensorInfos.real.dtype,
						shape: i.shape,
					},
					{
						dataId: u.complexTensorInfos.imag.dataId,
						dtype: u.complexTensorInfos.imag.dtype,
						shape: i.shape,
					},
				],
				h = r.runWebGLProgram(l, p, "float32"),
				f = r.runWebGLProgram(c, p, "float32"),
				d = LY({ inputs: { real: h, imag: f }, backend: r });
			return r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(f), d;
		}
		if (r.shouldExecuteOnCPU([a, i])) {
			var m = r.texData.get(a.dataId),
				g = r.texData.get(i.dataId),
				v = KX(a.shape, i.shape, m.values, g.values, o),
				y = v[0],
				b = v[1],
				x = r.makeTensorInfo(b, o);
			return (r.texData.get(x.dataId).values = y), x;
		}
		return (
			(t = xv().getBool("WEBGL_PACK_BINARY_OPERATIONS")
				? new DY(YY, a.shape, i.shape)
				: new FY(YY, a.shape, i.shape)),
			r.runWebGLProgram(t, [a, i], o)
		);
	}
	var ZY = { kernelName: db, backendName: "webgl", kernelFunc: JY };
	function QY(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = r.shape,
			o = n,
			s = zg(a.shape),
			u = Gg(i, s),
			l = zg(u);
		Dg(s === l, function () {
			return (
				"The new shape (" +
				u +
				") has " +
				l +
				" elements and the old shape (" +
				a.shape +
				") has " +
				s +
				" elements. The new shape and old shape must have the same number of elements."
			);
		});
		var c = o.texData.get(a.dataId);
		return !c.isPacked || WK(a.shape, u) || (null !== c.texture && WK(c.shape, u))
			? (o.incRef(a.dataId), { dataId: a.dataId, shape: u, dtype: a.dtype })
			: (function (e, t, n) {
					var r = [LK(e.shape)].concat(zK(e.shape)),
						a = { dtype: e.dtype, shape: r, dataId: e.dataId },
						i = [LK(t)].concat(zK(t)),
						o = new yY(i, r),
						s = [r],
						u = n.runWebGLProgram(o, [a], e.dtype, s, !0);
					return { dataId: u.dataId, shape: t, dtype: u.dtype };
			  })(a, u, o);
	}
	var $Y = { kernelName: _b, backendName: "webgl", kernelFunc: QY },
		eJ = function (e, t) {
			this.variableNames = ["x"];
			var n = e.windowSize,
				r = e.batchSize,
				a = e.inSize,
				i = e.outSize;
			this.outputShape = [r, i];
			var o = 4 * Math.floor(n / 4),
				s = n % 4,
				u = "sumValue += dot(values, ones);";
			if (null != t) {
				var l = 1 / t;
				u = "sumValue += dot(values * " + (Bg(l) ? l.toPrecision(2) : l) + ", ones);";
			}
			var c = "";
			a % n > 0 &&
				(c = "\n        if (inIdx < 0 || inIdx >= " + a + ") {\n          return 0.0;\n        }\n      "),
				(this.userCode =
					"\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " +
					c +
					"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " +
					n +
					";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " +
					o +
					"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " +
					u +
					"\n        }\n\n        int inIdx = inOffset + " +
					o +
					";\n        if (" +
					(1 === s) +
					") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          " +
					u +
					"\n        } else if (" +
					(2 === s) +
					") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          " +
					u +
					"\n        } else if (" +
					(3 === s) +
					") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          " +
					u +
					"\n        }\n        setOutput(sumValue);\n      }\n    ");
		},
		tJ = function (e, t) {
			this.variableNames = ["x"];
			var n = e.windowSize,
				r = e.batchSize,
				a = e.inSize,
				i = e.outSize;
			this.outputShape = [r, i];
			var o = "0.0",
				s = "";
			"prod" === t
				? (o = "1.0")
				: "min" === t
				? ((o = "1.0 / 1e-20"), (s = "min"))
				: "max" === t && ((o = "-1.0 / 1e-20"), (s = "max"));
			var u = t + "(" + t + "(" + t + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
			"sum" === t
				? (u = "sumValue")
				: "prod" === t
				? (u = "prodValue")
				: "all" === t
				? (u = "allValue")
				: "any" === t && (u = "anyValue");
			var l = 4 * Math.floor(n / 4),
				c = n % 4,
				p =
					"\n      if (" +
					("sum" === t) +
					") {\n        sumValue += dot(values, ones);\n      } else if (" +
					("prod" === t) +
					") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " +
					s +
					"(values, minMaxValue);\n        if (" +
					("min" === t) +
					" || " +
					("max" === t) +
					") {\n          minMaxValue = " +
					s +
					"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    ",
				h = "vec4";
			"all" === t
				? ((o = "1.0"),
				  (p =
						"\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      "),
				  (h = "bvec4"))
				: "any" === t &&
				  ((o = "0.0"),
				  (p =
						"\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      "),
				  (h = "bvec4"));
			var f = "";
			a % n > 0 &&
				(f =
					"\n        if (inIdx < 0 || inIdx >= " +
					a +
					") {\n          return initializationValue;\n        }\n      "),
				(this.userCode =
					"\n      const float initializationValue = " +
					o +
					";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " +
					f +
					"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " +
					n +
					";\n\n        vec4 minMaxValue = vec4(" +
					o +
					");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " +
					l +
					"; i += 4) {\n          int inIdx = inOffset + i;\n          " +
					h +
					" values = " +
					h +
					"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " +
					p +
					"\n        }\n\n        int inIdx = inOffset + " +
					l +
					";\n        if (" +
					(1 === c) +
					") {\n          " +
					h +
					" values = " +
					h +
					"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " +
					p +
					"\n        } else if (" +
					(2 === c) +
					") {\n          " +
					h +
					" values = " +
					h +
					"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " +
					p +
					"\n        } else if (" +
					(3 === c) +
					") {\n          " +
					h +
					" values = " +
					h +
					"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " +
					p +
					"\n        }\n        setOutput(" +
					u +
					");\n      }\n    ");
		};
	function nJ(e, t, n, r) {
		for (
			var a = (function (e) {
					for (var t = []; 0 === t.length || 1 !== t[t.length - 1].outSize; ) {
						var n = t.length ? t[t.length - 1].outSize : e[1],
							r = AA(n);
						t.push({ inSize: n, windowSize: r, outSize: Math.ceil(n / r) });
					}
					return t;
				})(e.shape),
				i = e,
				o = 0;
			o < a.length;
			o++
		) {
			var s,
				u,
				l = a[o],
				c = l.inSize,
				p = l.windowSize,
				h = l.outSize;
			(u =
				"mean" === n
					? 0 === o
						? new eJ({ windowSize: p, inSize: c, batchSize: e.shape[0], outSize: h }, c)
						: new eJ({ windowSize: p, inSize: c, batchSize: e.shape[0], outSize: h })
					: new tJ({ windowSize: p, inSize: c, batchSize: e.shape[0], outSize: h }, n)),
				(s = i),
				(i = r.runWebGLProgram(u, [i], t)),
				s.dataId !== e.dataId && r.disposeIntermediateTensorInfo(s);
		}
		return i;
	}
	var rJ = function (e, t) {
			this.variableNames = ["A"];
			for (var n = new Array(e.length), r = 0; r < n.length; r++) n[r] = e[t[r]];
			(this.outputShape = n), (this.rank = n.length);
			var a = sX(this.rank),
				i = (function (e) {
					var t = e.length;
					if (t > 6) throw Error("Transpose for rank " + t + " is not yet supported");
					for (
						var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"],
							r = new Array(t),
							a = 0;
						a < e.length;
						a++
					)
						r[e[a]] = n[a];
					return r.join();
				})(t);
			this.userCode =
				"\n    void main() {\n      " +
				a +
				" resRC = getOutputCoords();\n      setOutput(getA(" +
				i +
				"));\n    }\n    ";
		},
		aJ = function (e, t) {
			(this.variableNames = ["A"]), (this.packedInputs = !0), (this.packedOutput = !0);
			for (var n = new Array(e.length), r = 0; r < n.length; r++) n[r] = e[t[r]];
			if (((this.outputShape = n), (this.rank = n.length), this.rank > 6))
				throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
			for (var a = sX(this.rank), i = mY("rc", this.rank), o = new Array(this.rank), s = 0; s < t.length; s++)
				o[t[s]] = i[s];
			var u = "vec2(" + o.slice(-2).join() + ")",
				l = "++" + i[this.rank - 1] + " < " + n[this.rank - 1],
				c = "getChannel(getA(" + o.join() + "), " + u + ")";
			this.userCode =
				"\n    void main() {\n      " +
				a +
				" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " +
				c +
				";\n      if(" +
				l +
				") {\n        result[1] = " +
				c +
				";\n      }\n      --" +
				i[this.rank - 1] +
				";\n      if(++" +
				i[this.rank - 2] +
				" < " +
				n[this.rank - 2] +
				") {\n        result[2] = " +
				c +
				";\n        if(" +
				l +
				") {\n          result[3] = " +
				c +
				";\n        }\n      }\n      setOutput(result);\n    }\n    ";
		};
	function iJ(e, t, n) {
		var r = xv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new aJ(e.shape, t) : new rJ(e.shape, t);
		return n.runWebGLProgram(r, [e], e.dtype);
	}
	function oJ(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs;
		return (function (e, t, n, r) {
			var a = t,
				i = e.shape.length,
				o = jg(a, e.shape),
				s = o,
				u = YT(s, i),
				l = null != u,
				c = e;
			l && ((c = iJ(e, u, r)), (s = ZT(s.length, i))), XT("sum", s, i);
			var p = qT(c.shape, s),
				h = p[0],
				f = p[1],
				d = h;
			n && (d = KT(h, o));
			var m = zg(f),
				g = QY({ inputs: { x: c }, attrs: { shape: [zg(e.shape) / m, m] }, backend: r }),
				v = nJ(g, Xw(e.dtype), "sum", r),
				y = QY({ inputs: { x: v }, attrs: { shape: d }, backend: r });
			return (
				r.disposeIntermediateTensorInfo(g),
				r.disposeIntermediateTensorInfo(v),
				l && r.disposeIntermediateTensorInfo(c),
				y
			);
		})(t.x, r.axis, r.keepDims, n);
	}
	var sJ = { kernelName: Jb, backendName: "webgl", kernelFunc: oJ };
	function uJ(e) {
		for (
			var t,
				n = e.inputs,
				r = e.backend,
				a = e.attrs,
				i = n.x,
				o = a.perm,
				s = r,
				u = i.shape.length,
				l = new Array(u),
				c = 0;
			c < l.length;
			c++
		)
			l[c] = i.shape[o[c]];
		if (s.shouldExecuteOnCPU([i])) {
			var p = s.texData.get(i.dataId).values,
				h = fY(p, i.shape, i.dtype, o, l);
			(t = s.makeTensorInfo(l, i.dtype)), (s.texData.get(t.dataId).values = h);
		} else t = iJ(i, o, s);
		return t;
	}
	var lJ = { kernelName: vx, backendName: "webgl", kernelFunc: uJ };
	function cJ(e) {
		var t = e.a,
			n = e.b,
			r = e.transposeA,
			a = e.transposeB,
			i = e.backend,
			o = e.bias,
			s = void 0 === o ? null : o,
			u = e.preluActivationWeights,
			l = void 0 === u ? null : u,
			c = e.leakyreluAlpha,
			p = void 0 === c ? 0 : c,
			h = e.activation,
			f = void 0 === h ? null : h,
			d = t.shape.length,
			m = n.shape.length,
			g = r ? t.shape[d - 2] : t.shape[d - 1],
			v = a ? n.shape[m - 1] : n.shape[m - 2],
			y = r ? t.shape[d - 1] : t.shape[d - 2],
			b = a ? n.shape[m - 2] : n.shape[m - 1],
			x = t.shape.slice(0, -2),
			w = n.shape.slice(0, -2),
			k = zg(x),
			N = zg(w),
			I = JN(t.shape.slice(0, -2), n.shape.slice(0, -2)).concat([y, b]);
		Dg(g === v, function () {
			return (
				"Error in matMul: inner shapes (" +
				g +
				") and (" +
				v +
				") of Tensors with shapes " +
				t.shape +
				" and " +
				n.shape +
				" and transposeA=" +
				r +
				" and transposeB=" +
				a +
				" must match."
			);
		});
		var S,
			T = r ? [k, g, y] : [k, y, g],
			C = a ? [N, b, v] : [N, v, b],
			E = QY({ inputs: { x: t }, backend: i, attrs: { shape: T } }),
			R = QY({ inputs: { x: n }, backend: i, attrs: { shape: C } }),
			A = [E, R],
			_ = Math.max(k, N),
			F = r ? E.shape[1] : E.shape[2],
			D = null != s,
			O = null != l,
			M = "leakyrelu" === f,
			L = null != f ? qY(f, !0) : null;
		if ((1 === y || 1 === b) && F > 1e3 && !1 === (D || O || M || null != L)) {
			var z = E,
				P = R;
			r && ((z = uJ({ inputs: { x: E }, backend: i, attrs: { perm: [0, 2, 1] } })), A.push(z)),
				a && ((P = uJ({ inputs: { x: R }, backend: i, attrs: { perm: [0, 2, 1] } })), A.push(P));
			var B = 1 === b,
				W = z;
			1 !== b && ((W = QY({ inputs: { x: z }, backend: i, attrs: { shape: [_, F, 1] } })), A.push(W));
			var U = 1 === b ? 2 : 1,
				V = P;
			B && ((V = QY({ inputs: { x: P }, backend: i, attrs: { shape: [_, 1, F] } })), A.push(V));
			var G = JY({ inputs: { a: W, b: V }, backend: i });
			(S = oJ({ inputs: { x: G }, backend: i, attrs: { axis: U, keepDims: !0 } })), A.push(G);
		} else {
			var j = Kw(t.dtype, n.dtype),
				H = new KY(T, C, [_, y, b], r, a, D, L, O, M),
				q = [E, R];
			if ((null != s && q.push(s), O && q.push(l), M)) {
				var K = i.makeTensorInfo([], "float32", ww(p, "float32"));
				q.push(K), A.push(K);
			}
			S = i.runWebGLProgram(H, q, j);
		}
		var X = QY({ inputs: { x: S }, backend: i, attrs: { shape: I } });
		A.push(S);
		for (var Y = 0, J = A; Y < J.length; Y++) {
			var Z = J[Y];
			i.disposeIntermediateTensorInfo(Z);
		}
		return X;
	}
	var pJ = {
			kernelName: Sx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.a,
					i = t.b,
					o = t.bias,
					s = t.preluActivationWeights,
					u = r.transposeA,
					l = r.transposeB,
					c = r.activation;
				return cJ({
					a: a,
					b: i,
					transposeA: u,
					transposeB: l,
					backend: n,
					bias: o,
					preluActivationWeights: s,
					leakyreluAlpha: r.leakyreluAlpha,
					activation: c,
				});
			},
		},
		hJ = "return abs(x);",
		fJ = {
			kernelName: Nv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t,
					n = e.inputs,
					r = e.backend,
					a = n.x;
				if (r.shouldExecuteOnCPU([a]) && "complex64" !== a.dtype) {
					var i = r.texData.get(a.dataId),
						o = eY(i.values);
					return r.makeTensorInfo(a.shape, a.dtype, o);
				}
				return (
					(t = xv().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new TY(a.shape, hJ) : new NY(a.shape, hJ)),
					r.runWebGLProgram(t, [a], a.dtype)
				);
			},
		},
		dJ = jY({
			opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",
		}),
		mJ = { kernelName: Iv, backendName: "webgl", kernelFunc: dJ },
		gJ = jY({
			opSnippet: "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",
		}),
		vJ = { kernelName: Sv, backendName: "webgl", kernelFunc: gJ },
		yJ = "return a + b;",
		bJ = HY({ opSnippet: yJ, packedOpSnippet: yJ, supportsComplex: !0, cpuKernelImpl: CX }),
		xJ = { kernelName: Tv, backendName: "webgl", kernelFunc: bJ },
		wJ = function (e, t) {
			(this.outputShape = []),
				(this.outputShape = e),
				(this.variableNames = t.map(function (e, t) {
					return "T" + t;
				}));
			var n = [];
			this.variableNames.forEach(function (e) {
				n.push("float v" + e + " = get" + e + "AtOutCoords();");
			});
			var r = this.variableNames
				.map(function (e) {
					return "v" + e;
				})
				.join(" + ");
			this.userCode =
				"\n      void main() {\n        " +
				n.join("\n        ") +
				"\n\n        float result = " +
				r +
				";\n        setOutput(result);\n      }\n    ";
		},
		kJ = function (e, t) {
			(this.outputShape = []),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.outputShape = e),
				(this.variableNames = t.map(function (e, t) {
					return "T" + t;
				}));
			var n = [];
			this.variableNames.forEach(function (e) {
				n.push("vec4 v" + e + " = get" + e + "AtOutCoords();");
			});
			var r = this.variableNames
				.map(function (e) {
					return "v" + e;
				})
				.join(" + ");
			this.userCode =
				"\n      void main() {\n        " +
				n.join("\n        ") +
				"\n\n        vec4 result = " +
				r +
				";\n        setOutput(result);\n      }\n    ";
		},
		NJ = {
			kernelName: Cv,
			backendName: "webgl",
			kernelFunc: function e(t) {
				var n = t.inputs,
					r = t.backend,
					a = n;
				if (1 === a.length) return OY({ inputs: { x: a[0] }, backend: r });
				if (a.length > xv().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
					var i = Math.floor(a.length / 2),
						o = e({ inputs: a.slice(0, i), backend: r }),
						s = e({ inputs: a.slice(i), backend: r });
					return e({ inputs: [o, s], backend: r });
				}
				var u = a
						.map(function (e) {
							return e.dtype;
						})
						.reduce(function (e, t) {
							return Kw(e, t);
						}),
					l = a.map(function (e) {
						return e.shape;
					}),
					c = xv().getBool("WEBGL_PACK") ? new kJ(a[0].shape, l) : new wJ(a[0].shape, l);
				return r.runWebGLProgram(c, a, u);
			},
		},
		IJ = {
			kernelName: Ev,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.keepDims,
					s = a.shape.length,
					u = jg(i, a.shape),
					l = u,
					c = YT(l, s),
					p = a;
				null != c && ((p = uJ({ inputs: { x: a }, backend: n, attrs: { perm: c } })), (l = ZT(l.length, s))),
					XT("all", l, s);
				var h,
					f = qT(p.shape, l),
					d = f[0],
					m = QY({ inputs: { x: p }, backend: n, attrs: { shape: [-1, zg(f[1])] } }),
					g = nJ(m, m.dtype, "all", n);
				return (
					(h = QY(
						o
							? { inputs: { x: g }, backend: n, attrs: { shape: KT(d, u) } }
							: { inputs: { x: g }, backend: n, attrs: { shape: d } }
					)),
					n.disposeIntermediateTensorInfo(m),
					n.disposeIntermediateTensorInfo(g),
					null != c && n.disposeIntermediateTensorInfo(p),
					h
				);
			},
		},
		SJ = {
			kernelName: Rv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.keepDims,
					s = a.shape.length,
					u = jg(i, a.shape),
					l = u,
					c = YT(l, s),
					p = a;
				null != c && ((p = uJ({ inputs: { x: a }, backend: n, attrs: { perm: c } })), (l = ZT(l.length, s))),
					XT("any", l, s);
				var h,
					f = qT(p.shape, l),
					d = f[0],
					m = QY({ inputs: { x: p }, backend: n, attrs: { shape: [-1, zg(f[1])] } }),
					g = nJ(m, m.dtype, "any", n);
				return (
					(h = QY(
						o
							? { inputs: { x: g }, backend: n, attrs: { shape: KT(d, u) } }
							: { inputs: { x: g }, backend: n, attrs: { shape: d } }
					)),
					n.disposeIntermediateTensorInfo(m),
					n.disposeIntermediateTensorInfo(g),
					null != c && n.disposeIntermediateTensorInfo(p),
					h
				);
			},
		},
		TJ = function (e, t, n) {
			this.variableNames = ["A"];
			var r = e.windowSize,
				a = e.batchSize,
				i = e.outSize;
			n || this.variableNames.push("bestIndicesA"), (this.outputShape = [a, i]);
			var o = "max" === t ? ">" : "<",
				s = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
			this.userCode =
				"\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " +
				r +
				";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " +
				r +
				"; i++) {\n          int inIdx = " +
				s +
				";\n          float candidate = getA(batch, inIdx);\n          if (candidate " +
				o +
				" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
		},
		CJ = function (e, t, n, r) {
			(this.variableNames = ["A"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				Dg(e.length > 2, function () {
					return (
						"Packed arg" +
						(n.charAt(0).toUpperCase() + n.slice(1)) +
						" supports only inputs with rank above 2."
					);
				});
			var a = e[e.length - 1],
				i = Math.ceil(a / t);
			(this.outputShape = e.slice(0, -1)),
				i > 1 && this.outputShape.push(i),
				r || this.variableNames.push("bestIndicesA");
			var o,
				s,
				u = this.outputShape,
				l = u.length,
				c = sX(l),
				p = gY("coords", l);
			if (1 === i) {
				var h = sX((s = l + 1));
				o =
					"\n        " +
					h +
					" sourceLocR = " +
					h +
					"(" +
					p.join() +
					", 0);\n        ++" +
					p[l - 1] +
					";\n        " +
					h +
					" sourceLocG = " +
					h +
					"(" +
					p.join() +
					", 0);\n        ++" +
					p[l - 2] +
					";\n        " +
					h +
					" sourceLocA = " +
					h +
					"(" +
					p.join() +
					", 0);\n        --" +
					p[l - 1] +
					";\n        " +
					h +
					" sourceLocB = " +
					h +
					"(" +
					p.join() +
					", 0);\n        --" +
					p[l - 2] +
					";";
			} else
				(s = l),
					(o =
						"\n        " +
						c +
						" sourceLocR = coords;\n        ++" +
						p[l - 1] +
						";\n        " +
						c +
						" sourceLocG = coords;\n        ++" +
						p[l - 2] +
						";\n        " +
						c +
						" sourceLocA = coords;\n        --" +
						p[l - 1] +
						";\n        " +
						c +
						" sourceLocB = coords;\n        --" +
						p[l - 2] +
						";");
			var f = ["x", "y", "z", "w", "u", "v"].slice(0, s),
				d = "." + f[s - 1],
				m = f.map(function (e) {
					return "int " + e;
				}),
				g = gY("sourceLocR", s - 1).concat("inIdx.r"),
				v = gY("sourceLocG", s - 1).concat("inIdx.g"),
				y = gY("sourceLocB", s - 1).concat("inIdx.b"),
				b = gY("sourceLocA", s - 1).concat("inIdx.a"),
				x = "max" === n ? "greaterThan" : "lessThan",
				w = r
					? ""
					: "\n          inIdx = round(vec4(getBestIndicesAChannel(" +
					  g.join() +
					  "),\n                             getBestIndicesAChannel(" +
					  v.join() +
					  "),\n                             getBestIndicesAChannel(" +
					  y.join() +
					  "),\n                             getBestIndicesAChannel(" +
					  b.join() +
					  ")));",
				k =
					"vec4(\n            getAChannel(" +
					g.join() +
					"),\n            hasNextCol ? getAChannel(" +
					v.join() +
					") : 0.,\n            hasNextRow ? getAChannel(" +
					y.join() +
					") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" +
					b.join() +
					") : 0.)",
				N = r
					? ""
					: "\n      float getBestIndicesAChannel(" +
					  m.join() +
					  ") {\n        return getChannel(getBestIndicesA(" +
					  f.join() +
					  "),\n                                          vec2(" +
					  f.slice(-2).join() +
					  "));\n      }";
			this.userCode =
				"\n      float getAChannel(" +
				m.join() +
				") {\n        return getChannel(getA(" +
				f.join() +
				"),\n                               vec2(" +
				f.slice(-2).join() +
				"));\n      }\n      " +
				N +
				"\n      void main() {\n        " +
				c +
				" coords = getOutputCoords();\n        bool hasNextCol = " +
				p[l - 1] +
				" < " +
				(u[l - 1] - 1) +
				";\n        bool hasNextRow = " +
				p[l - 2] +
				" < " +
				(u[l - 2] - 1) +
				";\n        " +
				o +
				"\n        ivec4 srcIdx = ivec4(sourceLocR" +
				d +
				", sourceLocG" +
				d +
				",\n          sourceLocB" +
				d +
				", sourceLocA" +
				d +
				") * " +
				t +
				";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " +
				k +
				";\n\n        for (int i = 0; i < " +
				t +
				"; i++) {\n          inIdx = srcIdx;\n          " +
				w +
				"\n          vec4 candidate = " +
				k +
				";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" +
				x +
				"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
		};
	function EJ(e, t, n, r) {
		void 0 === r && (r = null);
		var a = t.shape[0],
			i = t.shape[1];
		null != r && ((a = r.shape[0]), (i = r.shape[1]));
		var o = AA(i),
			s = { windowSize: o, inSize: i, batchSize: a, outSize: Math.ceil(i / o) },
			u = new TJ(s, n, null == r),
			l = [t];
		null != r && l.push(r);
		var c = e.runWebGLProgram(u, l, "int32");
		if (1 === c.shape[1]) return c;
		var p = EJ(e, t, n, c);
		return e.disposeIntermediateTensorInfo(c), p;
	}
	function RJ(e, t, n, r) {
		void 0 === r && (r = null);
		var a = null != r ? r.shape : t.shape,
			i = AA(a[a.length - 1]),
			o = new CJ(a, i, n, null == r),
			s = null == r ? [t] : [t, r],
			u = e.runWebGLProgram(o, s, "int32");
		if (u.shape.length === t.shape.length) {
			var l = RJ(e, t, n, u);
			return e.disposeIntermediateTensorInfo(u), l;
		}
		return u;
	}
	function AJ(e, t, n, r) {
		var a = [n];
		if (
			(XT("arg" + r.charAt(0).toUpperCase() + r.slice(1), a, t.shape.length),
			!xv().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2)
		) {
			var i = [],
				o = e.texData.get(t.dataId),
				s = t;
			null !== o && o.isPacked && ((s = e.unpackTensor(t)), i.push(s));
			var u = qT(s.shape, a),
				l = u[0],
				c = zg(u[1]),
				p = QY({ inputs: { x: s }, backend: e, attrs: { shape: [-1, c] } });
			i.push(p);
			var h = EJ(e, p, r);
			i.push(h);
			var f = QY({ inputs: { x: h }, backend: e, attrs: { shape: l } });
			return (
				i.forEach(function (t) {
					return e.disposeIntermediateTensorInfo(t);
				}),
				f
			);
		}
		return RJ(e, t, r);
	}
	var _J = {
			kernelName: Av,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = jg(r.axis, a.shape),
					o = YT(i, a.shape.length),
					s = a,
					u = [];
				null != o &&
					((s = uJ({ inputs: { x: a }, backend: n, attrs: { perm: o } })),
					u.push(s),
					(i = ZT(i.length, s.shape.length))),
					XT("argMax", [i[0]], s.shape.length);
				var l = AJ(n, s, i[0], "max");
				return (
					u.forEach(function (e) {
						return n.disposeIntermediateTensorInfo(e);
					}),
					l
				);
			},
		},
		FJ = {
			kernelName: _v,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = jg(r.axis, a.shape),
					o = YT(i, a.shape.length),
					s = a,
					u = [];
				null != o &&
					((s = uJ({ inputs: { x: a }, backend: n, attrs: { perm: o } })),
					u.push(s),
					(i = ZT(i.length, s.shape.length))),
					XT("argMin", [i[0]], s.shape.length);
				var l = AJ(n, s, i[0], "min");
				return (
					u.forEach(function (e) {
						return n.disposeIntermediateTensorInfo(e);
					}),
					l
				);
			},
		},
		DJ = jY({
			opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",
		}),
		OJ = { kernelName: Fv, backendName: "webgl", kernelFunc: DJ },
		MJ = jY({ opSnippet: "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));" }),
		LJ = { kernelName: Dv, backendName: "webgl", kernelFunc: MJ },
		zJ = jY({ opSnippet: "if (isnan(x)) return x;\n  return atan(x);\n" }),
		PJ = { kernelName: Ov, backendName: "webgl", kernelFunc: zJ },
		BJ = HY({
			opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",
			packedOpSnippet:
				"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
		}),
		WJ = { kernelName: Lv, backendName: "webgl", kernelFunc: BJ },
		UJ = jY({
			opSnippet:
				"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",
		}),
		VJ = { kernelName: Mv, backendName: "webgl", kernelFunc: UJ },
		GJ = function (e, t, n, r, a) {
			if ((void 0 === r && (r = !1), void 0 === a && (a = !1), (this.variableNames = ["x"]), "avg" === t && n))
				throw new Error("Cannot compute positions for average pool.");
			var i = e.filterWidth,
				o = e.strideHeight,
				s = e.strideWidth,
				u = e.dilationHeight,
				l = e.dilationWidth,
				c = e.effectiveFilterHeight,
				p = e.effectiveFilterWidth,
				h = e.padInfo.top,
				f = e.padInfo.left;
			this.outputShape = e.outShape;
			var d = "avg" === t,
				m = "((batch  * " + e.inHeight + " + xR) * " + e.inWidth + " + xC) * " + e.inChannels + " + d",
				g = "(xR * " + e.inWidth + " + xC) * " + e.inChannels + " + d",
				v = "0.0";
			if ((d || (v = "-1.0 / 1e-20"), n))
				this.userCode =
					"\n        const ivec2 strides = ivec2(" +
					o +
					", " +
					s +
					");\n        const ivec2 pads = ivec2(" +
					h +
					", " +
					f +
					");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " +
					c +
					";\n              wR += " +
					u +
					") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " +
					e.inHeight +
					") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " +
					p +
					";\n                wC += " +
					l +
					") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " +
					e.inWidth +
					") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = " +
					(r ? (a ? m : g) : "wR * " + p + " + wC") +
					";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
			else {
				var y = t + "(" + t + "(" + t + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
				"avg" === t && (y = "avgValue / count");
				var b = 4 * Math.floor(i / 4),
					x = i % 4,
					w =
						"\n      if (" +
						d +
						") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
				this.userCode =
					"\n      const ivec2 strides = ivec2(" +
					o +
					", " +
					s +
					");\n      const ivec2 pads = ivec2(" +
					h +
					", " +
					f +
					");\n      const float initializationValue = " +
					v +
					";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " +
					e.inWidth +
					") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" +
					v +
					");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " +
					c +
					";\n            wR += " +
					u +
					") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " +
					e.inHeight +
					") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " +
					b +
					"; wC += 4) {\n            int xC = xCCorner + wC * " +
					l +
					";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " +
					l +
					", d),\n              getValue(batch, xR, xC + 2 * " +
					l +
					", d),\n              getValue(batch, xR, xC + 3 * " +
					l +
					", d)\n            );\n\n            " +
					w +
					"\n          }\n\n          int xC = xCCorner + " +
					b +
					";\n          if (" +
					(1 === x) +
					") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " +
					w +
					"\n          } else if (" +
					(2 === x) +
					") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " +
					l +
					", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " +
					w +
					"\n          } else if (" +
					(3 === x) +
					") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " +
					l +
					", d),\n              getValue(batch, xR, xC + 2 * " +
					l +
					", d),\n              initializationValue\n            );\n\n            " +
					w +
					"\n          }\n        }\n        setOutput(" +
					y +
					");\n      }\n    ";
			}
		},
		jJ = function (e, t, n, r, a) {
			if ((void 0 === r && (r = !1), void 0 === a && (a = !1), (this.variableNames = ["x"]), "avg" === t && n))
				throw new Error("Cannot compute positions for average pool.");
			var i = e.filterWidth,
				o = e.strideDepth,
				s = e.strideHeight,
				u = e.strideWidth,
				l = e.dilationDepth,
				c = e.dilationHeight,
				p = e.dilationWidth,
				h = e.effectiveFilterDepth,
				f = e.effectiveFilterHeight,
				d = e.effectiveFilterWidth,
				m = e.padInfo.front,
				g = e.padInfo.top,
				v = e.padInfo.left;
			this.outputShape = e.outShape;
			var y = "avg" === t,
				b = "0.0";
			if ((y || (b = "-1.0 / 1e-20"), n))
				this.userCode =
					"\n        const ivec3 strides =\n            ivec3(" +
					o +
					", " +
					s +
					", " +
					u +
					");\n        const ivec3 pads = ivec3(" +
					m +
					", " +
					g +
					", " +
					v +
					");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " +
					h +
					";\n              wD += " +
					l +
					") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " +
					e.inDepth +
					") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " +
					f +
					";\n                wR += " +
					c +
					") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " +
					e.inHeight +
					") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " +
					d +
					";\n                  wC += " +
					p +
					") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " +
					e.inWidth +
					") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = " +
					(r
						? a
							? "(((batch * " +
							  e.inDepth +
							  " + xD) * " +
							  e.inHeight +
							  " + xR) * " +
							  e.inWidth +
							  " + xC) * " +
							  e.inChannels +
							  " + ch"
							: "((xD * " + e.inHeight + " + xR) * " + e.inWidth + " + xC) * " + e.inChannels + " + ch"
						: "wD * " + f + " * " + d + " +\n                      wR * " + d + " + wC") +
					";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
			else {
				var x = t + "(" + t + "(" + t + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
				"avg" === t && (x = "avgValue / count");
				var w = 4 * Math.floor(i / 4),
					k = i % 4,
					N =
						"\n      if (" +
						y +
						") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
				this.userCode =
					"\n      const ivec3 strides =\n        ivec3(" +
					o +
					", " +
					s +
					", " +
					u +
					");\n      const ivec3 pads = ivec3(" +
					m +
					", " +
					g +
					", " +
					v +
					");\n      const float initializationValue = " +
					b +
					";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " +
					e.inWidth +
					") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" +
					b +
					");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " +
					h +
					";\n            wD += " +
					l +
					") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " +
					e.inDepth +
					") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " +
					f +
					";\n            wR += " +
					c +
					") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " +
					e.inHeight +
					") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " +
					w +
					"; wC += 4) {\n              int xC = xCCorner + wC * " +
					p +
					";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " +
					p +
					", ch),\n                getValue(batch, xD, xR, xC + 2 * " +
					p +
					", ch),\n                getValue(batch, xD, xR, xC + 3 * " +
					p +
					", ch)\n              );\n\n              " +
					N +
					"\n            }\n\n            int xC = xCCorner + " +
					w +
					";\n            if (" +
					(1 === k) +
					") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " +
					N +
					"\n            } else if (" +
					(2 === k) +
					") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " +
					p +
					", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " +
					N +
					"\n            } else if (" +
					(3 === k) +
					") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " +
					p +
					", ch),\n                getValue(batch, xD, xR, xC + 2 * " +
					p +
					", ch),\n                initializationValue\n              );\n\n              " +
					N +
					"\n            }\n          }\n          setOutput(" +
					x +
					");\n        }\n      }\n    ";
			}
		},
		HJ = {
			kernelName: zv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x;
				jK(a, "avgPool");
				var i = r.filterSize,
					o = r.strides,
					s = r.pad,
					u = r.dimRoundingMode;
				Dg(yS(o, 1), function () {
					return (
						"Error in avgPool: Either strides or dilations must be 1. Got strides " +
						o +
						" and dilations '1'"
					);
				});
				var l = uS(a.shape, i, o, 1, s, u);
				if (1 === l.filterWidth && 1 === l.filterHeight && Pg(l.inShape, l.outShape))
					return OY({ inputs: { x: a }, backend: n });
				var c = new GJ(l, "avg", !1);
				return n.runWebGLProgram(c, [a], "float32");
			},
		},
		qJ = {
			kernelName: Bv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.filterSize,
					o = r.strides,
					s = r.pad,
					u = r.dimRoundingMode,
					l = r.dataFormat,
					c = lS(a.shape, i, o, [1, 1, 1], s, u, l),
					p = new jJ(c, "avg", !1);
				return n.runWebGLProgram(p, [a], "float32");
			},
		},
		KJ = function (e) {
			(this.variableNames = ["dy"]), (this.outputShape = e.inShape);
			var t = e.filterHeight,
				n = e.filterWidth,
				r = e.strideHeight,
				a = e.strideWidth,
				i = e.dilationHeight,
				o = e.dilationWidth,
				s = e.effectiveFilterHeight,
				u = e.effectiveFilterWidth,
				l = s - 1 - e.padInfo.top,
				c = u - 1 - e.padInfo.left,
				p = 1 / (t * n);
			this.userCode =
				"\n      const ivec2 pads = ivec2(" +
				l +
				", " +
				c +
				");\n      const float avgMultiplier = float(" +
				p +
				");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " +
				s +
				";\n            wR += " +
				i +
				") {\n          float dyR = float(dyRCorner + wR) / " +
				r +
				".0;\n\n          if (dyR < 0.0 || dyR >= " +
				e.outHeight +
				".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " +
				u +
				";\n            wC+= " +
				o +
				") {\n            float dyC = float(dyCCorner + wC) / " +
				a +
				".0;\n\n            if (dyC < 0.0 || dyC >= " +
				e.outWidth +
				".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		XJ = function (e) {
			(this.variableNames = ["dy"]), (this.outputShape = e.inShape);
			var t = e.filterDepth,
				n = e.filterHeight,
				r = e.filterWidth,
				a = e.strideDepth,
				i = e.strideHeight,
				o = e.strideWidth,
				s = e.dilationDepth,
				u = e.dilationHeight,
				l = e.dilationWidth,
				c = e.effectiveFilterDepth,
				p = e.effectiveFilterHeight,
				h = e.effectiveFilterWidth,
				f = c - 1 - e.padInfo.front,
				d = p - 1 - e.padInfo.top,
				m = h - 1 - e.padInfo.left,
				g = 1 / (t * n * r);
			this.userCode =
				"\n      const ivec3 pads = ivec3(" +
				f +
				", " +
				d +
				", " +
				m +
				");\n      const float avgMultiplier = float(" +
				g +
				");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " +
				c +
				";\n            wD += " +
				s +
				") {\n          float dyD = float(dyDCorner + wD) / " +
				a +
				".0;\n\n          if (dyD < 0.0 || dyD >= " +
				e.outDepth +
				".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " +
				p +
				";\n              wR += " +
				u +
				") {\n            float dyR = float(dyRCorner + wR) / " +
				i +
				".0;\n\n            if (dyR < 0.0 || dyR >= " +
				e.outHeight +
				".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " +
				h +
				";\n                wC += " +
				l +
				") {\n              float dyC = float(dyCCorner + wC) / " +
				o +
				".0;\n\n              if (dyC < 0.0 || dyC >= " +
				e.outWidth +
				".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		YJ = {
			kernelName: Wv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.input,
					o = r.filterSize,
					s = r.strides,
					u = r.pad,
					l = r.dimRoundingMode,
					c = lS(i.shape, o, s, [1, 1, 1], u, l),
					p = new XJ(c);
				return n.runWebGLProgram(p, [a], i.dtype);
			},
		},
		JJ = {
			kernelName: Pv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.input,
					o = i;
				jK([a, i], "avgPoolGrad");
				var s = r.filterSize,
					u = r.strides,
					l = r.pad,
					c = uS(o.shape, s, u, 1, l),
					p = new KJ(c);
				return n.runWebGLProgram(p, [a], o.dtype);
			},
		},
		ZJ = {
			kernelName: Uv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs;
				return cJ({ a: t.a, b: t.b, transposeA: r.transposeA, transposeB: r.transposeB, backend: n });
			},
		},
		QJ = function (e, t, n, r, a, i) {
			(this.outputShape = []), (this.variableNames = ["x", "mean", "variance"]), JN(e, t), JN(e, n);
			var o = "0.0";
			null != r && (JN(e, r), this.variableNames.push("offset"), (o = "getOffsetAtOutCoords()"));
			var s = "1.0";
			null != a && (JN(e, a), this.variableNames.push("scale"), (s = "getScaleAtOutCoords()")),
				(this.outputShape = e),
				(this.userCode =
					"\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " +
					o +
					";\n        float scale = " +
					s +
					";\n        float inv = scale * inversesqrt(variance + float(" +
					i +
					"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ");
		},
		$J = function (e, t, n, r, a, i) {
			(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.variableNames = ["x", "mean", "variance"]),
				JN(e, t),
				JN(e, n);
			var o = "vec4(0.0)";
			null != r && (JN(e, r), this.variableNames.push("offset"), (o = "getOffsetAtOutCoords()"));
			var s = "vec4(1.0)";
			null != a && (JN(e, a), this.variableNames.push("scale"), (s = "getScaleAtOutCoords()")),
				(this.outputShape = e),
				(this.userCode =
					"\n      void main() {\n        vec4 offset = " +
					o +
					";\n        vec4 scale = " +
					s +
					";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" +
					i +
					"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ");
		},
		eZ = {
			kernelName: Fy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.mean,
					o = t.variance,
					s = t.offset,
					u = t.scale;
				Dg(i.shape.length === o.shape.length, function () {
					return "Batch normalization gradient requires mean and variance to have equal ranks.";
				}),
					Dg(null == s || i.shape.length === s.shape.length, function () {
						return "Batch normalization gradient requires mean and offset to have equal ranks.";
					}),
					Dg(null == u || i.shape.length === u.shape.length, function () {
						return "Batch normalization gradient requires mean and scale to have equal ranks.";
					});
				var l = r.varianceEpsilon;
				null == l && (l = 0.001);
				var c = [a, i, o],
					p = null;
				null != s && ((p = s.shape), c.push(s));
				var h = null;
				null != u && ((h = u.shape), c.push(u));
				var f = xv().getBool("WEBGL_PACK_NORMALIZATION")
					? new $J(a.shape, i.shape, o.shape, p, h, l)
					: new QJ(a.shape, i.shape, o.shape, p, h, l);
				return n.runWebGLProgram(f, c, c[0].dtype);
			},
		},
		tZ = function (e) {
			(this.variableNames = ["source"]), (this.outputShape = e), (this.rank = e.length);
			var t = sX(this.rank);
			this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
			var n,
				r = (function (e) {
					if (1 === e) return "sourceLoc";
					if (e <= 6)
						return nZ
							.slice(0, e)
							.map(function (e) {
								return "sourceLoc." + e;
							})
							.join(",");
					throw Error("Slicing for rank " + e + " is not yet supported");
				})(this.rank);
			(n =
				"\n        " +
				t +
				" sourceLoc;\n        " +
				t +
				" coords = getOutputCoords();\n        " +
				e
					.map(function (e, t) {
						return "sourceLoc." + nZ[t] + " = start[" + t + "] + coords." + nZ[t] + ";";
					})
					.join("\n") +
				"\n      "),
				(this.userCode =
					"\n      void main() {\n        " +
					n +
					"\n        setOutput(getSource(" +
					r +
					"));\n      }\n    ");
		},
		nZ = ["x", "y", "z", "w", "u", "v"],
		rZ = function (e) {
			(this.variableNames = ["source"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.outputShape = e),
				(this.rank = e.length),
				(this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }]);
			var t = sX(this.rank),
				n = gY("coords", this.rank),
				r = gY("sourceLoc", this.rank),
				a = 1 === this.rank ? "sourceLoc" : "vec2(" + r.slice(-2).join() + ")",
				i = "getChannel(getSource(" + r.join() + "), " + a + ")",
				o =
					"\n      result.x = " +
					i +
					";\n      if (++" +
					n[this.rank - 1] +
					" < " +
					e[this.rank - 1] +
					") {\n        ++" +
					r[this.rank - 1] +
					";\n        result.y = " +
					i +
					";\n        --" +
					r[this.rank - 1] +
					";\n      }\n    ",
				s =
					1 === this.rank
						? ""
						: "\n      --" +
						  n[this.rank - 1] +
						  ";\n      if (++" +
						  n[this.rank - 2] +
						  " < " +
						  e[this.rank - 2] +
						  ") {\n        ++" +
						  r[this.rank - 2] +
						  ";\n        result.z = " +
						  i +
						  ";\n        if (++" +
						  n[this.rank - 1] +
						  " < " +
						  e[this.rank - 1] +
						  ") {\n          ++" +
						  r[this.rank - 1] +
						  ";\n          result.w = " +
						  i +
						  ";\n        }\n      }\n    ",
				u =
					this.rank <= 4
						? "sourceLoc = coords +\n            " +
						  t +
						  "(" +
						  e
								.map(function (e, t) {
									return "start[" + t + "]";
								})
								.join() +
						  ");"
						: e
								.map(function (e, t) {
									return r[t] + " = " + n[t] + " + start[" + t + "];";
								})
								.join("\n");
			this.userCode =
				"\n      void main() {\n        " +
				t +
				" coords = getOutputCoords();\n        " +
				t +
				" sourceLoc;\n        " +
				u +
				"\n        vec4 result = vec4(0.);\n        " +
				o +
				"\n        " +
				s +
				"\n        setOutput(result);\n      }\n    ";
		};
	function aZ(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = II(a, r.begin, r.size),
			o = i[0],
			s = i[1];
		if ((hI(a, o, s), 0 === zg(s))) return n.makeTensorInfo(s, a.dtype, []);
		if (n.shouldExecuteOnCPU([a]) || "string" === a.dtype) {
			var u = n.texData.get(a.dataId),
				l = tY(u.values, o, s, a.shape, a.dtype);
			return n.makeTensorInfo(s, a.dtype, l);
		}
		var c = n.texData.get(a.dataId).isPacked,
			p = kI(a.shape, o, s);
		if (c || !p) {
			var h = xv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new rZ(s) : new tZ(s),
				f = [o];
			return n.runWebGLProgram(h, [a], a.dtype, f);
		}
		return (
			n.uploadToGPU(a.dataId),
			(function (e, t, n, r) {
				var a = r.texData.get(e.dataId),
					i = r.makeTensorInfo(n, e.dtype),
					o = r.texData.get(i.dataId);
				Object.assign(o, a), (o.refCount = 1), (o.shape = n), (o.dtype = e.dtype);
				var s = NI(t, ov(e.shape));
				a.slice && (s += a.slice.flatOffset),
					(o.slice = { flatOffset: s, origDataId: (a.slice && a.slice.origDataId) || e.dataId });
				var u = r.dataRefCount.get(o.slice.origDataId) || 1;
				return r.dataRefCount.set(o.slice.origDataId, u + 1), i;
			})(a, o, s, n)
		);
	}
	var iZ = { kernelName: Gb, backendName: "webgl", kernelFunc: aZ },
		oZ = {
			kernelName: Vv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.blockShape,
					o = r.crops;
				Dg(a.shape.length <= 4, function () {
					return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
				});
				var s = i.reduce(function (e, t) {
						return e * t;
					}),
					u = FA(a.shape, i, s),
					l = DA(u.length, i.length),
					c = OA(a.shape, i, s),
					p = MA(o, i.length),
					h = LA(c, o, i.length),
					f = [],
					d = QY({ inputs: { x: a }, backend: n, attrs: { shape: u } }),
					m = uJ({ inputs: { x: d }, backend: n, attrs: { perm: l } }),
					g = QY({ inputs: { x: m }, backend: n, attrs: { shape: c } }),
					v = aZ({ inputs: { x: g }, backend: n, attrs: { begin: p, size: h } });
				return (
					f.push(d),
					f.push(m),
					f.push(g),
					f.forEach(function (e) {
						return n.disposeIntermediateTensorInfo(e);
					}),
					v
				);
			},
		},
		sZ = {
			kernelName: Gv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.weights,
					o = r.size,
					s = n.readSync(a.dataId),
					u = n.readSync(i.dataId),
					l = EX(s, u, i.dtype, i.shape, o);
				return n.makeTensorInfo([o], i.dtype, l);
			},
		},
		uZ = {
			kernelName: Hv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.s0,
					a = t.s1,
					i = n.readSync(r.dataId),
					o = n.readSync(a.dataId),
					s = JN(Array.from(i), Array.from(o));
				return n.makeTensorInfo([s.length], "int32", Int32Array.from(s));
			},
		},
		lZ = HY({ opSnippet: "return float(a != b);", cpuKernelImpl: YX, dtype: "bool" }),
		cZ = { kernelName: gb, backendName: "webgl", kernelFunc: lZ };
	function pZ(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.input;
		return OY({ inputs: { x: n.texData.get(r.dataId).complexTensorInfos.real }, backend: n });
	}
	var hZ = { kernelName: Eb, backendName: "webgl", kernelFunc: pZ },
		fZ = {
			kernelName: qv,
			backendName: "webgl",
			kernelFunc: function e(t) {
				var n = t.inputs,
					r = t.backend,
					a = t.attrs,
					i = n.x,
					o = a.dtype;
				if ("complex64" === o) {
					if ("complex64" === i.dtype) return OY({ inputs: { x: i }, backend: r });
					var s = uC(i.shape),
						u = e({ inputs: { x: i }, backend: r, attrs: { dtype: "float32" } }),
						l = LY({ inputs: { real: u, imag: s }, backend: r });
					return s.dispose(), r.disposeIntermediateTensorInfo(u), l;
				}
				if ("complex64" === i.dtype) {
					var c = pZ({ inputs: { input: i }, backend: r }),
						p = e({ inputs: { x: c }, backend: r, attrs: { dtype: o } });
					return r.disposeIntermediateTensorInfo(c), p;
				}
				if (!Jg(i.dtype, o)) {
					var h = OY({ inputs: { x: i }, backend: r });
					return { dataId: h.dataId, shape: h.shape, dtype: o };
				}
				if ("int32" === o)
					return (function (e, t) {
						var n = new NY(e.shape, "return float(int(x));"),
							r = t.runWebGLProgram(n, [e], "int32");
						return { dataId: r.dataId, shape: r.shape, dtype: r.dtype };
					})(i, r);
				if ("bool" === o) {
					var f = r.makeTensorInfo([], "bool", qg("bool", 1)),
						d = lZ({ inputs: { a: i, b: f }, backend: r });
					return r.disposeIntermediateTensorInfo(f), d;
				}
				throw new Error("Error in Cast: failed to cast " + i.dtype + " to " + o);
			},
		},
		dZ = "return ceil(x);",
		mZ = jY({ opSnippet: dZ, packedOpSnippet: dZ, cpuKernelImpl: AX }),
		gZ = { kernelName: Kv, backendName: "webgl", kernelFunc: mZ },
		vZ = function (e) {
			(this.variableNames = ["A"]),
				(this.customUniforms = [
					{ name: "minVal", type: "float" },
					{ name: "maxVal", type: "float" },
				]),
				(this.outputShape = e),
				(this.userCode =
					"\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ");
		},
		yZ = function (e) {
			(this.variableNames = ["A"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.customUniforms = [
					{ name: "minVal", type: "float" },
					{ name: "maxVal", type: "float" },
				]),
				(this.outputShape = e),
				(this.userCode =
					"\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ");
		},
		bZ = {
			kernelName: Xv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t,
					n = e.inputs,
					r = e.backend,
					a = e.attrs,
					i = n.x,
					o = a.clipValueMin,
					s = a.clipValueMax;
				t = xv().getBool("WEBGL_PACK_CLIP") ? new yZ(i.shape) : new vZ(i.shape);
				var u = [[o], [s]];
				return r.runWebGLProgram(t, [i], i.dtype, u);
			},
		},
		xZ = function (e) {
			(this.variableNames = ["real", "imag"]),
				(this.outputShape = e),
				(this.userCode =
					"\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ");
		};
	function wZ(e, t) {
		return { dataId: t.dataId, dtype: t.dtype, shape: e.shape };
	}
	var kZ = {
			kernelName: Jv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.x,
					a = n.texData.get(r.dataId),
					i = new xZ(r.shape),
					o = [wZ(r, a.complexTensorInfos.real), wZ(r, a.complexTensorInfos.imag)];
				return n.runWebGLProgram(i, o, o[0].dtype);
			},
		},
		NZ = function (e) {
			(this.outputShape = []),
				(this.outputShape = RA(e, 1)),
				(this.variableNames = e.map(function (e, t) {
					return "T" + t;
				}));
			var t = new Array(e.length - 1);
			t[0] = e[0][1];
			for (var n = 1; n < t.length; n++) t[n] = t[n - 1] + e[n][1];
			for (var r = ["if (yC < " + t[0] + ") setOutput(getT0(yR, yC));"], a = 1; a < t.length; a++) {
				var i = t[a - 1];
				r.push("else if (yC < " + t[a] + ") setOutput(getT" + a + "(yR, yC-" + i + "));");
			}
			var o = t.length,
				s = t[t.length - 1];
			r.push("else setOutput(getT" + o + "(yR, yC-" + s + "));"),
				(this.userCode =
					"\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " +
					r.join("\n        ") +
					"\n      }\n    ");
		},
		IZ = function (e, t) {
			(this.packedInputs = !0), (this.packedOutput = !0), (this.outputShape = []), (this.outputShape = RA(e, t));
			var n = this.outputShape,
				r = n.length,
				a = sX(r),
				i = gY("coords", r),
				o = ["x", "y", "z", "w", "u", "v"].slice(0, r);
			this.variableNames = e.map(function (e, t) {
				return "T" + t;
			});
			var s = new Array(e.length - 1);
			s[0] = e[0][t];
			for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + e[u][t];
			for (
				var l = o[t],
					c = o.slice(-2),
					p = o.join(),
					h =
						"if (" +
						l +
						" < " +
						s[0] +
						") {\n        return getChannel(\n            getT0(" +
						p +
						"), vec2(" +
						c.join() +
						"));\n        }",
					f = 1;
				f < s.length;
				f++
			) {
				var d = s[f - 1];
				h +=
					"\n        if (" +
					l +
					" < " +
					s[f] +
					"  && " +
					l +
					" >= " +
					s[f - 1] +
					") {\n          return getChannel(\n            getT" +
					f +
					"(" +
					SZ(o, l, d) +
					"),\n            vec2(" +
					SZ(c, l, d) +
					"));\n        }";
			}
			var m = s.length,
				g = s[s.length - 1];
			(h +=
				"\n        return getChannel(\n          getT" +
				m +
				"(" +
				SZ(o, l, g) +
				"),\n          vec2(" +
				SZ(c, l, g) +
				"));"),
				(this.userCode =
					"\n      float getValue(" +
					o.map(function (e) {
						return "int " + e;
					}) +
					") {\n        " +
					h +
					"\n      }\n\n      void main() {\n        " +
					a +
					" coords = getOutputCoords();\n        vec4 result = vec4(getValue(" +
					i +
					"), 0., 0., 0.);\n\n        " +
					i[r - 1] +
					" = " +
					i[r - 1] +
					" + 1;\n        if (" +
					i[r - 1] +
					" < " +
					n[r - 1] +
					") {\n          result.g = getValue(" +
					i +
					");\n        }\n\n        " +
					i[r - 2] +
					" = " +
					i[r - 2] +
					" + 1;\n        if (" +
					i[r - 2] +
					" < " +
					n[r - 2] +
					") {\n          result.a = getValue(" +
					i +
					");\n        }\n\n        " +
					i[r - 1] +
					" = " +
					i[r - 1] +
					" - 1;\n        if (" +
					i[r - 2] +
					" < " +
					n[r - 2] +
					" &&\n            " +
					i[r - 1] +
					" < " +
					n[r - 1] +
					") {\n          result.b = getValue(" +
					i +
					");\n        }\n        setOutput(result);\n      }\n    ");
		};
	function SZ(e, t, n) {
		var r = e.indexOf(t);
		return e
			.map(function (e, t) {
				return t === r ? e + " - " + n : e;
			})
			.join();
	}
	function TZ(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.input;
		return OY({ inputs: { x: n.texData.get(r.dataId).complexTensorInfos.imag }, backend: n });
	}
	var CZ = { kernelName: By, backendName: "webgl", kernelFunc: TZ };
	function EZ(e, t, n) {
		var r = e[0].dtype;
		if ("complex64" === r) {
			var a = e.map(function (e) {
					return pZ({ inputs: { input: e }, backend: n });
				}),
				i = e.map(function (e) {
					return TZ({ inputs: { input: e }, backend: n });
				}),
				o = EZ(a, t, n),
				s = EZ(i, t, n),
				u = LY({ inputs: { real: o, imag: s }, backend: n });
			return (
				a.forEach(function (e) {
					return n.disposeIntermediateTensorInfo(e);
				}),
				i.forEach(function (e) {
					return n.disposeIntermediateTensorInfo(e);
				}),
				n.disposeIntermediateTensorInfo(o),
				n.disposeIntermediateTensorInfo(s),
				u
			);
		}
		var l = n.shouldExecuteOnCPU(e);
		if (("string" === r && (l = !0), l)) {
			var c = e.map(function (e) {
					var r = zg(e.shape.slice(t));
					return QY({ inputs: { x: e }, backend: n, attrs: { shape: [-1, r] } });
				}),
				p = c.map(function (e) {
					return { vals: n.readSync(e.dataId), shape: e.shape };
				}),
				h = RA(
					c.map(function (e) {
						return e.shape;
					}),
					1
				),
				f = 1 === c[0].shape[0],
				d = _X(p, h, r, f),
				m = RA(
					e.map(function (e) {
						return e.shape;
					}),
					t
				),
				g = n.makeTensorInfo(m, r, d);
			return (
				c.forEach(function (e) {
					return n.disposeIntermediateTensorInfo(e);
				}),
				g
			);
		}
		if (e.length > xv().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
			var v = Math.floor(e.length / 2),
				y = EZ(e.slice(0, v), t, n),
				b = EZ(e.slice(v), t, n),
				x = EZ([y, b], t, n);
			return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(b), x;
		}
		if (xv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && e[0].shape.length > 1) {
			var w = new IZ(
				e.map(function (e) {
					return e.shape;
				}),
				t
			);
			return n.runWebGLProgram(w, e, r);
		}
		var k = (function (e, t, n) {
				var r = RA(
					e.map(function (e) {
						return e.shape;
					}),
					t
				);
				return {
					tensors2D: e.map(function (e) {
						return QY({ inputs: { x: e }, attrs: { shape: [-1, zg(e.shape.slice(t))] }, backend: n });
					}),
					outShape: r,
				};
			})(e, t, n),
			N = k.tensors2D,
			I = k.outShape,
			S = new NZ(
				N.map(function (e) {
					return e.shape;
				})
			),
			T = n.runWebGLProgram(S, N, r);
		N.forEach(function (e) {
			return n.disposeIntermediateTensorInfo(e);
		});
		var C = QY({ inputs: { x: T }, attrs: { shape: I }, backend: n });
		return n.disposeIntermediateTensorInfo(T), C;
	}
	function RZ(e) {
		var t = e.inputs,
			n = e.backend,
			r = jg(e.attrs.axis, t[0].shape)[0],
			a = RA(
				t.map(function (e) {
					return e.shape;
				}),
				r
			);
		if (0 === zg(a)) return n.makeTensorInfo(a, t[0].dtype, []);
		var i = t.filter(function (e) {
			return zg(e.shape) > 0;
		});
		return 1 === i.length
			? OY({ inputs: { x: i[0] }, backend: n })
			: (EA(
					i.map(function (e) {
						return e.shape;
					}),
					r
			  ),
			  EZ(i, r, n));
	}
	var AZ = { kernelName: Zv, backendName: "webgl", kernelFunc: RZ },
		_Z = function (e, t, n, r, a) {
			void 0 === t && (t = !1),
				void 0 === n && (n = null),
				void 0 === r && (r = !1),
				void 0 === a && (a = !1),
				(this.variableNames = ["x", "W"]),
				(this.outputShape = e.outShape);
			var i = e.padInfo.top,
				o = e.padInfo.left,
				s = e.strideHeight,
				u = e.strideWidth,
				l = e.dilationHeight,
				c = e.dilationWidth,
				p = e.filterHeight,
				h = e.filterWidth,
				f = 4 * Math.floor(e.inChannels / 4),
				d = e.inChannels % 4,
				m = "channelsLast" === e.dataFormat,
				g = m ? 1 : 2,
				v = m ? 2 : 3,
				y = m ? 3 : 1,
				b = "",
				x = "";
			n &&
				((b = r
					? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " +
					  n +
					  "\n        }"
					: a
					? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          " +
					  n +
					  "\n        }"
					: "\n          float activation(float x) {\n            " + n + "\n          }\n        "),
				(x = "result = activation(result);"));
			var w = t ? "result += getBiasAtOutCoords();" : "";
			t && this.variableNames.push("bias"),
				r && this.variableNames.push("preluActivationWeights"),
				a && this.variableNames.push("leakyreluAlpha"),
				(this.userCode =
					"\n      " +
					b +
					"\n\n      const ivec2 strides = ivec2(" +
					s +
					", " +
					u +
					");\n      const ivec2 pads = ivec2(" +
					i +
					", " +
					o +
					");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" +
					y +
					"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" +
					g +
					"], coords[" +
					v +
					"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " +
					p +
					"; wR++) {\n          int xR = xRCorner + wR * " +
					l +
					";\n\n          if (xR < 0 || xR >= " +
					e.inHeight +
					") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " +
					h +
					"; wC++) {\n            int xC = xCCorner + wC * " +
					c +
					";\n\n            if (xC < 0 || xC >= " +
					e.inWidth +
					") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " +
					f +
					"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" +
					m +
					") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" +
					(1 === d) +
					") {\n\n              if (" +
					m +
					") {\n                dotProd +=\n                    getX(batch, xR, xC, " +
					f +
					") *\n                    getW(wR, wC, " +
					f +
					", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " +
					f +
					", xR, xC) *\n                    getW(wR, wC, " +
					f +
					", d2);\n              }\n\n            } else if (" +
					(2 === d) +
					") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " +
					f +
					", d2),\n                getW(wR, wC, " +
					f +
					" + 1, d2)\n              );\n\n              if (" +
					m +
					") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " +
					f +
					"),\n                  getX(batch, xR, xC, " +
					f +
					" + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " +
					f +
					", xR, xC),\n                  getX(batch, " +
					f +
					" + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" +
					(3 === d) +
					") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " +
					f +
					", d2),\n                getW(wR, wC, " +
					f +
					" + 1, d2),\n                getW(wR, wC, " +
					f +
					" + 2, d2)\n              );\n\n              if (" +
					m +
					") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " +
					f +
					"),\n                  getX(batch, xR, xC, " +
					f +
					" + 1),\n                  getX(batch, xR, xC, " +
					f +
					" + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " +
					f +
					", xR, xC),\n                  getX(batch, " +
					f +
					" + 1, xR, xC),\n                  getX(batch, " +
					f +
					" + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " +
					w +
					"\n        " +
					x +
					"\n        setOutput(result);\n      }\n    ");
		},
		FZ = function (e) {
			(this.variableNames = ["x", "W"]), (this.outputShape = e.outShape);
			var t = e.padInfo.front,
				n = e.padInfo.top,
				r = e.padInfo.left,
				a = e.strideDepth,
				i = e.strideHeight,
				o = e.strideWidth,
				s = e.dilationDepth,
				u = e.dilationHeight,
				l = e.dilationWidth,
				c = e.filterDepth,
				p = e.filterHeight,
				h = e.filterWidth,
				f = 4 * Math.floor(e.inChannels / 4),
				d = e.inChannels % 4;
			this.userCode =
				"\n      const ivec3 strides = ivec3(" +
				a +
				", " +
				i +
				", " +
				o +
				");\n      const ivec3 pads = ivec3(" +
				t +
				", " +
				n +
				", " +
				r +
				");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " +
				c +
				"; wF++) {\n          int xF = xFCorner + wF * " +
				s +
				";\n\n          if (xF < 0 || xF >= " +
				e.inDepth +
				") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " +
				p +
				"; wR++) {\n            int xR = xRCorner + wR * " +
				u +
				";\n\n            if (xR < 0 || xR >= " +
				e.inHeight +
				") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " +
				h +
				"; wC++) {\n              int xC = xCCorner + wC * " +
				l +
				";\n\n              if (xC < 0 || xC >= " +
				e.inWidth +
				") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " +
				f +
				"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" +
				(1 === d) +
				") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " +
				f +
				") *\n                  getW(wF, wR, wC, " +
				f +
				", d2);\n              } else if (" +
				(2 === d) +
				") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " +
				f +
				"),\n                  getX(batch, xF, xR, xC, " +
				f +
				" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " +
				f +
				", d2),\n                  getW(wF, wR, wC, " +
				f +
				" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" +
				(3 === d) +
				") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " +
				f +
				"),\n                  getX(batch, xF, xR, xC, " +
				f +
				" + 1),\n                  getX(batch, xF, xR, xC, " +
				f +
				" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " +
				f +
				", d2),\n                  getW(wF, wR, wC, " +
				f +
				" + 1, d2),\n                  getW(wF, wR, wC, " +
				f +
				" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		DZ = function (e, t) {
			(this.variableNames = ["A"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.customUniforms = [
					{ name: "inputShape", type: "ivec3" },
					{ name: "pad", type: "ivec2" },
					{ name: "stride", type: "ivec2" },
					{ name: "dilation", type: "ivec2" },
					{ name: "inChannels", type: "int" },
					{ name: "itemsPerBlockRow", type: "int" },
					{ name: "outWidth", type: "int" },
				]),
				(this.outputShape = e),
				(this.enableShapeUniforms = fX(this.outputShape.length));
			for (
				var n = t.dataFormat,
					r = qK(),
					a = "channelsLast" === n,
					i = a ? 0 : 1,
					o = a ? 1 : 2,
					s = this.enableShapeUniforms
						? "if(blockIndex < outShape[1] && pos < outShape[0]) {"
						: "if(blockIndex < " + e[1] + " && pos < " + e[0] + ") {",
					u = "",
					l = 0;
				l <= 1;
				l++
			)
				for (var c = 0; c <= 1; c++)
					u +=
						"\n          blockIndex = rc.y + " +
						c +
						";\n          pos = rc.x + " +
						l +
						";\n\n          " +
						s +
						"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[" +
						i +
						"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[" +
						o +
						"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (" +
						a +
						") {\n                  innerDims = vec2(d1, ch);\n                  result[" +
						(2 * l + c) +
						"] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" +
						(2 * l + c) +
						"] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
			this.userCode =
				"\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " +
				u +
				"\n\n        " +
				r.output +
				" = result;\n      }\n    ";
		};
	function OZ(e) {
		var t,
			n = e.x,
			r = e.filter,
			a = e.convInfo,
			i = e.backend,
			o = e.bias,
			s = void 0 === o ? null : o,
			u = e.preluActivationWeights,
			l = void 0 === u ? null : u,
			c = e.leakyreluAlpha,
			p = void 0 === c ? 0 : c,
			h = e.activation,
			f = void 0 === h ? null : h,
			d = n.shape,
			m = i.texData.get(n.dataId),
			g = a.inChannels,
			v = d[0] * d[1] * d[2],
			y = a.outChannels,
			b = "channelsLast" === a.dataFormat,
			x = [];
		if (
			((1 !== v && 1 !== y) || !(g > 1e3)) &&
			m.isPacked &&
			b &&
			null != m.texture &&
			d[2] % 2 != 0 &&
			Pg(m.shape.slice(-3), d.slice(-3))
		) {
			var w = d[0] * d[1] * (d[2] + 1),
				k = { dataId: n.dataId, shape: [1, w, a.inChannels], dtype: n.dtype },
				N = m.shape;
			(m.shape = m.shape.slice()),
				m.shape[m.shape.length - 2]++,
				Dg(WK(m.shape, k.shape), function () {
					return "packed reshape " + m.shape + " to " + k.shape + " isn't free";
				});
			var I = QY({ inputs: { x: r }, backend: i, attrs: { shape: [1, a.inChannels, a.outChannels] } });
			x.push(I);
			var S = cJ({
					a: k,
					b: I,
					backend: i,
					transposeA: !1,
					transposeB: !1,
					bias: s,
					activation: f,
					preluActivationWeights: l,
					leakyreluAlpha: p,
				}),
				T = i.texData.get(S.dataId);
			Dg(T.isPacked, function () {
				return "batchMatMul result is expected to be packed";
			}),
				(m.shape = N),
				(T.shape = a.outShape),
				((t = OY({ inputs: { x: S }, backend: i })).shape = a.outShape),
				x.push(S);
		} else {
			var C = QY({
					inputs: { x: n },
					backend: i,
					attrs: { shape: [1, b ? d[0] * d[1] * d[2] : d[0] * d[2] * d[3], a.inChannels] },
				}),
				E = QY({ inputs: { x: r }, backend: i, attrs: { shape: [1, a.inChannels, a.outChannels] } }),
				R = cJ({
					a: C,
					b: E,
					transposeA: !1,
					transposeB: !1,
					backend: i,
					bias: s,
					activation: f,
					preluActivationWeights: l,
					leakyreluAlpha: p,
				});
			(t = QY({ inputs: { x: R }, backend: i, attrs: { shape: a.outShape } })), x.push(C), x.push(E), x.push(R);
		}
		for (var A = 0, _ = x; A < _.length; A++) {
			var F = _[A];
			i.disposeIntermediateTensorInfo(F);
		}
		return t;
	}
	function MZ(e) {
		var t = e.x,
			n = e.filter,
			r = e.convInfo,
			a = e.backend,
			i = e.bias,
			o = void 0 === i ? null : i,
			s = e.preluActivationWeights,
			u = void 0 === s ? null : s,
			l = e.leakyreluAlpha,
			c = void 0 === l ? 0 : l,
			p = e.activation,
			h = void 0 === p ? null : p,
			f = r.filterWidth,
			d = r.filterHeight,
			m = r.inChannels,
			g = r.outWidth,
			v = r.outHeight,
			y = "channelsLast" === r.dataFormat,
			b = f * d * m,
			x = v * g,
			w = [b, x],
			k = [],
			N = QY({ inputs: { x: t }, backend: a, attrs: { shape: t.shape.slice(1) } }),
			I = QY({ inputs: { x: n }, backend: a, attrs: { shape: [1, b, zg(n.shape) / b] } });
		k.push(N), k.push(I);
		var S = new DZ(w, r),
			T = [
				N.shape,
				[r.padInfo.top, r.padInfo.left],
				[r.strideHeight, r.strideWidth],
				[r.dilationHeight, r.dilationWidth],
				[r.inChannels],
				[r.filterWidth * r.inChannels],
				[r.outWidth],
			],
			C = a.runWebGLProgram(S, [N], "float32", T),
			E = QY({ inputs: { x: C }, backend: a, attrs: { shape: [1, w[0], w[1]] } });
		k.push(C), k.push(E);
		var R = null != o,
			A = null != u,
			_ = "leakyrelu" === h,
			F = h ? qY(h, !0) : null,
			D = new KY(E.shape, I.shape, [1, x, r.outChannels], !0, !1, R, F, A, _),
			O = [E, I];
		if ((o && O.push(o), A && O.push(u), _)) {
			var M = a.makeTensorInfo([], "float32", ww(c, "float32"));
			O.push(M), k.push(M);
		}
		var L = a.runWebGLProgram(D, O, "float32"),
			z = QY({
				inputs: { x: L },
				backend: a,
				attrs: { shape: y ? [1, v, g, r.outChannels] : [1, r.outChannels, v, g] },
			});
		k.push(L);
		for (var P = 0, B = k; P < B.length; P++) {
			var W = B[P];
			a.disposeIntermediateTensorInfo(W);
		}
		return z;
	}
	var LZ = {
			kernelName: Qv,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t,
					n = e.inputs,
					r = e.backend,
					a = e.attrs,
					i = n.x,
					o = n.filter,
					s = a.strides,
					u = a.pad,
					l = a.dataFormat,
					c = a.dilations,
					p = a.dimRoundingMode,
					h = bS(l),
					f = cS(i.shape, o.shape, s, c, u, p, !1, h);
				if (
					1 !== f.filterHeight ||
					1 !== f.filterWidth ||
					1 !== f.dilationHeight ||
					1 !== f.dilationWidth ||
					1 !== f.strideHeight ||
					1 !== f.strideWidth ||
					("SAME" !== f.padInfo.type && "VALID" !== f.padInfo.type)
				)
					if (xv().getBool("WEBGL_CONV_IM2COL") && 1 === i.shape[0])
						t = MZ({ x: i, filter: o, convInfo: f, backend: r });
					else {
						var d = new _Z(f);
						t = r.runWebGLProgram(d, [i, o], "float32");
					}
				else t = OZ({ x: i, filter: o, convInfo: f, backend: r });
				var m = QY({ inputs: { x: t }, backend: r, attrs: { shape: f.outShape } });
				return r.disposeIntermediateTensorInfo(t), m;
			},
		},
		zZ = function (e) {
			(this.variableNames = ["x", "dy"]), (this.outputShape = e.filterShape);
			var t = e.strideHeight,
				n = e.strideWidth,
				r = e.padInfo.top,
				a = e.padInfo.left,
				i = "channelsLast" === e.dataFormat;
			this.userCode =
				"\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " +
				e.batchSize +
				"; b++) {\n          for (int yR = 0; yR < " +
				e.outHeight +
				"; yR++) {\n            int xR = wR + yR * " +
				t +
				" - " +
				r +
				";\n\n            if (xR < 0 || xR >= " +
				e.inHeight +
				") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " +
				e.outWidth +
				"; yC++) {\n              int xC = wC + yC * " +
				n +
				" - " +
				a +
				";\n\n              if (xC < 0 || xC >= " +
				e.inWidth +
				") {\n                continue;\n              }\n\n              if (" +
				i +
				") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		PZ = function (e) {
			(this.variableNames = ["dy", "W"]), (this.outputShape = e.inShape);
			var t = e.filterHeight,
				n = e.filterWidth,
				r = e.strideHeight,
				a = e.strideWidth,
				i = "channelsLast" === e.dataFormat,
				o = t - 1 - e.padInfo.top,
				s = n - 1 - e.padInfo.left,
				u = i ? 1 : 2,
				l = i ? 2 : 3,
				c = i ? 3 : 1;
			this.userCode =
				"\n      const ivec2 pads = ivec2(" +
				o +
				", " +
				s +
				");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" +
				c +
				"];\n\n        ivec2 dyCorner = ivec2(coords[" +
				u +
				"], coords[" +
				l +
				"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " +
				t +
				"; wR++) {\n          float dyR = float(dyRCorner + wR) / " +
				r +
				".0;\n\n          if (dyR < 0.0 || dyR >= " +
				e.outHeight +
				".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " +
				t +
				" - 1 - wR;\n\n          for (int wC = 0; wC < " +
				n +
				"; wC++) {\n            float dyC = float(dyCCorner + wC) / " +
				a +
				".0;\n\n            if (dyC < 0.0 || dyC >= " +
				e.outWidth +
				".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " +
				n +
				" - 1 - wC;\n\n            for (int d2 = 0; d2 < " +
				e.outChannels +
				"; d2++) {\n\n              if (" +
				i +
				") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		BZ = function (e) {
			(this.variableNames = ["x", "dy"]), (this.outputShape = e.filterShape);
			var t = e.strideDepth,
				n = e.strideHeight,
				r = e.strideWidth,
				a = e.padInfo.front,
				i = e.padInfo.top,
				o = e.padInfo.left;
			this.userCode =
				"\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " +
				e.batchSize +
				"; b++) {\n          for (int yF = 0; yF < " +
				e.outDepth +
				"; yF++) {\n            int xF = wF + yF * " +
				t +
				" - " +
				a +
				";\n\n            if (xF < 0 || xF >= " +
				e.inDepth +
				") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " +
				e.outHeight +
				"; yR++) {\n              int xR = wR + yR * " +
				n +
				" - " +
				i +
				";\n\n              if (xR < 0 || xR >= " +
				e.inHeight +
				") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " +
				e.outWidth +
				"; yC++) {\n                int xC = wC + yC * " +
				r +
				" - " +
				o +
				";\n\n                if (xC < 0 || xC >= " +
				e.inWidth +
				") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		WZ = function (e) {
			(this.variableNames = ["dy", "W"]), (this.outputShape = e.inShape);
			var t = e.filterDepth,
				n = e.filterHeight,
				r = e.filterWidth,
				a = e.strideDepth,
				i = e.strideHeight,
				o = e.strideWidth,
				s = t - 1 - e.padInfo.front,
				u = n - 1 - e.padInfo.top,
				l = r - 1 - e.padInfo.left;
			this.userCode =
				"\n      const ivec3 pads = ivec3(" +
				s +
				", " +
				u +
				", " +
				l +
				");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " +
				t +
				"; wF++) {\n          float dyF = float(dyFCorner + wF) / " +
				a +
				".0;\n\n          if (dyF < 0.0 || dyF >= " +
				e.outDepth +
				".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " +
				t +
				" - 1 - wF;\n\n          for (int wR = 0; wR < " +
				n +
				"; wR++) {\n            float dyR = float(dyRCorner + wR) / " +
				i +
				".0;\n\n            if (dyR < 0.0 || dyR >= " +
				e.outHeight +
				".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " +
				n +
				" - 1 - wR;\n\n            for (int wC = 0; wC < " +
				r +
				"; wC++) {\n              float dyC = float(dyCCorner + wC) / " +
				o +
				".0;\n\n              if (dyC < 0.0 || dyC >= " +
				e.outWidth +
				".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " +
				r +
				" - 1 - wC;\n\n              for (int d2 = 0; d2 < " +
				e.outChannels +
				"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		UZ = {
			kernelName: $v,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.dy,
					o = r.strides,
					s = r.pad,
					u = r.dataFormat,
					l = r.dimRoundingMode,
					c = r.filterShape,
					p = bS(u),
					h = cS(a.shape, c, o, 1, s, l, !1, p),
					f = new zZ(h);
				return n.runWebGLProgram(f, [a, i], "float32");
			},
		},
		VZ = {
			kernelName: ey,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.filter,
					o = r.inputShape,
					s = r.strides,
					u = r.pad,
					l = r.dataFormat,
					c = r.dimRoundingMode,
					p = bS(l),
					h = cS(o, i.shape, s, 1, u, c, !1, p),
					f = new PZ(h);
				return n.runWebGLProgram(f, [a, i], "float32");
			},
		},
		GZ = {
			kernelName: ty,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.filter,
					o = r.strides,
					s = r.pad,
					u = r.dilations,
					l = pS(a.shape, i.shape, o, u, s),
					c = new FZ(l);
				return n.runWebGLProgram(c, [a, i], "float32");
			},
		},
		jZ = {
			kernelName: ny,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.dy,
					o = r.strides,
					s = r.pad,
					u = r.filterShape,
					l = pS(a.shape, u, o, 1, s),
					c = new BZ(l);
				return n.runWebGLProgram(c, [a, i], "float32");
			},
		},
		HZ = {
			kernelName: ry,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.filter,
					o = r.pad,
					s = r.strides,
					u = pS(r.inputShape, i.shape, s, 1, o),
					l = new WZ(u);
				return n.runWebGLProgram(l, [a, i], "float32");
			},
		},
		qZ = jY({ opSnippet: "if (isnan(x)) return x;\n  return cos(x);\n" }),
		KZ = { kernelName: ay, backendName: "webgl", kernelFunc: qZ },
		XZ = jY({ opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n" }),
		YZ = { kernelName: iy, backendName: "webgl", kernelFunc: XZ },
		JZ = function (e, t, n, r, a) {
			(this.variableNames = ["Image", "Boxes", "BoxInd"]), (this.outputShape = []);
			var i = e[0],
				o = e[1],
				s = e[2],
				u = e[3],
				l = t[0],
				c = n[0],
				p = n[1];
			this.outputShape = [l, c, p, u];
			var h = "bilinear" === r ? 1 : 0,
				f = o - 1 + ".0",
				d = s - 1 + ".0",
				m =
					c > 1
						? ["" + (o - 1) / (c - 1), "(y2-y1) * height_ratio", "y1*" + f + " + float(y)*(height_scale)"]
						: ["0.0", "0.0", "0.5 * (y1+y2) * " + f],
				g = m[0],
				v = m[1],
				y = m[2],
				b =
					p > 1
						? ["" + (s - 1) / (p - 1), "(x2-x1) * width_ratio", "x1*" + d + " + float(x)*(width_scale)"]
						: ["0.0", "0.0", "0.5 * (x1+x2) * " + d],
				x = b[0],
				w = b[1],
				k = b[2];
			this.userCode =
				"\n      const float height_ratio = float(" +
				g +
				");\n      const float width_ratio = float(" +
				x +
				");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " +
				i +
				") {\n          return;\n        }\n\n        float height_scale = " +
				v +
				";\n        float width_scale = " +
				w +
				";\n\n        float in_y = " +
				y +
				";\n        if( in_y < 0.0 || in_y > " +
				f +
				" ) {\n          setOutput(float(" +
				a +
				"));\n          return;\n        }\n        float in_x = " +
				k +
				";\n        if( in_x < 0.0 || in_x > " +
				d +
				" ) {\n          setOutput(float(" +
				a +
				"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" +
				h +
				" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
		},
		ZZ = {
			kernelName: uy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.image,
					i = t.boxes,
					o = t.boxInd,
					s = r.cropSize,
					u = r.method,
					l = r.extrapolationValue,
					c = new JZ(a.shape, i.shape, s, u, l);
				return n.runWebGLProgram(c, [a, i, o], "float32");
			},
		},
		QZ = function (e, t, n) {
			(this.variableNames = ["x"]),
				(this.customUniforms = [{ name: "index", type: "float" }]),
				(this.outputShape = e);
			var r = e.length,
				a = t ? "1.0" : "getX(" + $Z(r, "coords") + ")",
				i = e[e.length - 1],
				o = "",
				s = "";
			t
				? ((o = n ? "end != " + (i - 1) : "end != 0"), (s = n ? "end + 1" : "end - 1"))
				: ((o = n ? "end + pow2 < " + i : "end >= pow2"), (s = n ? "end + pow2" : "end - pow2")),
				(this.userCode =
					"\n      void main() {\n        " +
					sX(r) +
					" coords = getOutputCoords();\n        int end = " +
					eQ(r, "coords") +
					";\n        float val = " +
					a +
					";\n        int pow2 = int(pow(2.0, index));\n        if (" +
					o +
					") {\n          int idx = " +
					s +
					";\n          " +
					eQ(r, "coords") +
					" = idx;\n          val *= getX(" +
					$Z(r, "coords") +
					");\n        }\n        setOutput(val);\n      }\n    ");
		};
	function $Z(e, t) {
		if (1 === e) return "" + t;
		if (2 === e) return t + ".x, " + t + ".y";
		if (3 === e) return t + ".x, " + t + ".y, " + t + ".z";
		if (4 === e) return t + ".x, " + t + ".y, " + t + ".z, " + t + ".w";
		throw Error("Cumulative product for rank " + e + " is not yet supported");
	}
	function eQ(e, t) {
		if (1 === e) return "" + t;
		if (2 === e) return t + ".y";
		if (3 === e) return t + ".z";
		if (4 === e) return t + ".w";
		throw Error("Cumulative product for rank " + e + " is not yet supported");
	}
	var tQ = {
			kernelName: oy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.exclusive,
					s = r.reverse,
					u = a.shape.length,
					l = YT([i], u),
					c = a;
				null != l && (c = uJ({ inputs: { x: a }, backend: n, attrs: { perm: l } }));
				var p = ZT(1, u)[0];
				if (p !== u - 1)
					throw new Error(
						"WebGL cumprod shader expects an inner-most axis=" + (a.shape.length - 1) + " but got axis=" + i
					);
				for (
					var h = c.shape[p], f = OY({ inputs: { x: c }, backend: n }), d = 0;
					d <= Math.ceil(Math.log2(h)) - 1;
					d++
				) {
					var m = new QZ(c.shape, !1, s),
						g = [[d]],
						v = f;
					(f = n.runWebGLProgram(m, [f], f.dtype, g)), n.disposeIntermediateTensorInfo(v);
				}
				if (o) {
					var y = new QZ(c.shape, o, s),
						b = f;
					(f = n.runWebGLProgram(y, [f], f.dtype)), n.disposeIntermediateTensorInfo(b);
				}
				if (null != l) {
					var x = uJ({ inputs: { x: f }, backend: n, attrs: { perm: JT(l) } });
					return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(c), x;
				}
				return f;
			},
		},
		nQ = function (e, t, n) {
			(this.variableNames = ["x"]),
				(this.customUniforms = [{ name: "index", type: "float" }]),
				(this.outputShape = e);
			var r = e.length,
				a = t ? "0.0" : "getX(" + rQ(r, "coords") + ")",
				i = e[e.length - 1],
				o = "",
				s = "";
			t
				? ((o = n ? "end != " + (i - 1) : "end != 0"), (s = n ? "end + 1" : "end - 1"))
				: ((o = n ? "end + pow2 < " + i : "end >= pow2"), (s = n ? "end + pow2" : "end - pow2")),
				(this.userCode =
					"\n      void main() {\n        " +
					sX(r) +
					" coords = getOutputCoords();\n        int end = " +
					aQ(r, "coords") +
					";\n        float val = " +
					a +
					";\n        int pow2 = int(pow(2.0, index));\n        if (" +
					o +
					") {\n          int idx = " +
					s +
					";\n          " +
					aQ(r, "coords") +
					" = idx;\n          val += getX(" +
					rQ(r, "coords") +
					");\n        }\n        setOutput(val);\n      }\n    ");
		};
	function rQ(e, t) {
		if (1 === e) return "" + t;
		if (2 === e) return t + ".x, " + t + ".y";
		if (3 === e) return t + ".x, " + t + ".y, " + t + ".z";
		if (4 === e) return t + ".x, " + t + ".y, " + t + ".z, " + t + ".w";
		throw Error("Cumulative sum for rank " + e + " is not yet supported");
	}
	function aQ(e, t) {
		if (1 === e) return "" + t;
		if (2 === e) return t + ".y";
		if (3 === e) return t + ".z";
		if (4 === e) return t + ".w";
		throw Error("Cumulative sum for rank " + e + " is not yet supported");
	}
	var iQ = {
			kernelName: sy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.exclusive,
					s = r.reverse,
					u = a.shape.length,
					l = YT([i], u),
					c = a;
				null != l && (c = uJ({ inputs: { x: a }, backend: n, attrs: { perm: l } }));
				var p = ZT(1, u)[0];
				if (p !== u - 1)
					throw new Error(
						"WebGL cumsum shader expects an inner-most axis=" + (a.shape.length - 1) + " but got axis=" + i
					);
				for (
					var h = c.shape[p], f = OY({ inputs: { x: c }, backend: n }), d = 0;
					d <= Math.ceil(Math.log2(h)) - 1;
					d++
				) {
					var m = new nQ(c.shape, !1, s),
						g = [[d]],
						v = f;
					(f = n.runWebGLProgram(m, [f], f.dtype, g)), n.disposeIntermediateTensorInfo(v);
				}
				if (o) {
					var y = new nQ(c.shape, o, s),
						b = f;
					(f = n.runWebGLProgram(y, [f], f.dtype)), n.disposeIntermediateTensorInfo(b);
				}
				if (null != l) {
					var x = uJ({ inputs: { x: f }, backend: n, attrs: { perm: JT(l) } });
					return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(c), x;
				}
				return f;
			},
		},
		oQ = {
			kernelName: ly,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.weights,
					o = r.size,
					s = r.binaryOutput;
				if (1 === a.shape.length) {
					var u = n.readSync(a.dataId),
						l = n.readSync(i.dataId),
						c = EX(u, l, i.dtype, i.shape, o);
					return n.makeTensorInfo([o], i.dtype, c);
				}
				if (2 === a.shape.length) {
					var p = n.bufferSync(a),
						h = n.bufferSync(i),
						f = RX(p, h, o, s);
					return n.makeTensorInfo(f.shape, i.dtype, f.values);
				}
				throw new Error(
					"Error in denseBincount: input must be at most rank 2, but got rank" + a.shape.length + "."
				);
			},
		},
		sQ = (function () {
			function e(e, t, n) {
				(this.variableNames = ["x"]),
					(this.outputShape = []),
					(this.outputShape = e),
					(this.blockSize = t),
					(this.dataFormat = n),
					(this.userCode =
						"\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " +
						this.getHeightCoordString() +
						";\n      int w = " +
						this.getWidthCoordString() +
						";\n      int d = " +
						this.getDepthCoordString() +
						";\n\n      int in_h = h / " +
						t +
						";\n      int offset_h = imod(h, " +
						t +
						");\n      int in_w = w / " +
						t +
						";\n      int offset_w = imod(w, " +
						t +
						");\n      int offset_d = (offset_h * " +
						t +
						" + offset_w) *\n        " +
						this.getOutputDepthSize() +
						";\n      int in_d = d + offset_d;\n\n      float result = " +
						this.getInputSamplingString() +
						";\n      setOutput(result);\n    }\n  ");
			}
			var t = e.prototype;
			return (
				(t.getHeightCoordString = function () {
					return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
				}),
				(t.getWidthCoordString = function () {
					return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
				}),
				(t.getDepthCoordString = function () {
					return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
				}),
				(t.getOutputDepthSize = function () {
					return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
				}),
				(t.getInputSamplingString = function () {
					return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
				}),
				e
			);
		})(),
		uQ = {
			kernelName: cy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.blockSize,
					o = r.dataFormat,
					s = a.shape[0],
					u = ("NHWC" === o ? a.shape[1] : a.shape[2]) * i,
					l = ("NHWC" === o ? a.shape[2] : a.shape[3]) * i,
					c = ("NHWC" === o ? a.shape[3] : a.shape[1]) / (i * i),
					p = new sQ("NHWC" === o ? [s, u, l, c] : [s, c, u, l], i, o);
				return n.runWebGLProgram(p, [a], a.dtype);
			},
		},
		lQ = function (e, t, n, r, a) {
			void 0 === t && (t = !1),
				void 0 === n && (n = null),
				void 0 === r && (r = !1),
				void 0 === a && (a = !1),
				(this.variableNames = ["x", "W"]),
				(this.customUniforms = [
					{ name: "pads", type: "ivec2" },
					{ name: "strides", type: "ivec2" },
					{ name: "dilations", type: "ivec2" },
					{ name: "inDims", type: "ivec2" },
				]),
				(this.outputShape = e.outShape),
				(this.enableShapeUniforms = fX(this.outputShape.length));
			var i = e.filterHeight,
				o = e.filterWidth,
				s = e.outChannels / e.inChannels,
				u = "",
				l = "";
			n &&
				((u = r
					? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " +
					  n +
					  "\n        }"
					: a
					? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          " +
					  n +
					  "\n        }"
					: "\n          float activation(float x) {\n            " + n + "\n          }\n        "),
				(l = "result = activation(result);"));
			var c = t ? "result += getBiasAtOutCoords();" : "";
			t && this.variableNames.push("bias"),
				r && this.variableNames.push("preluActivationWeights"),
				a && this.variableNames.push("leakyreluAlpha"),
				(this.userCode =
					"\n      " +
					u +
					"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " +
					s +
					";\n        int q = d2 - d1 * " +
					s +
					";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " +
					i +
					"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < " +
					o +
					"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " +
					c +
					"\n        " +
					l +
					"\n        setOutput(result);\n      }\n    ");
		},
		cQ = function (e, t, n, r, a) {
			void 0 === t && (t = !1),
				void 0 === n && (n = null),
				void 0 === r && (r = !1),
				void 0 === a && (a = !1),
				(this.variableNames = ["x", "W"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.customUniforms = [
					{ name: "pads", type: "ivec2" },
					{ name: "strides", type: "ivec2" },
					{ name: "dilations", type: "ivec2" },
					{ name: "inDims", type: "ivec2" },
				]),
				(this.outputShape = e.outShape),
				(this.enableShapeUniforms = fX(this.outputShape.length));
			for (
				var i = e.outChannels / e.inChannels,
					o = e.padInfo.left,
					s = e.strideWidth,
					u = e.dilationWidth,
					l = e.filterHeight,
					c = e.filterWidth,
					p = c,
					h = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;",
					f = 0;
				f < c;
				f++
			)
				h +=
					"\n          vec4 xTexelC" +
					2 * f +
					";\n          int xTexelC" +
					2 * f +
					"Ready;\n          vec4 xTexelC" +
					(2 * f + 1) +
					";\n          int xTexelC" +
					(2 * f + 1) +
					"Ready;\n          vec4 xC" +
					f +
					";";
			h += "\n    for (int r = 0; r < " + l + "; r++) {\n      ";
			for (var d = 0; d < c; d++)
				h +=
					"\n          xTexelC" +
					2 * d +
					" = vec4(0.0);\n          xTexelC" +
					2 * d +
					"Ready = 0;\n          xTexelC" +
					(2 * d + 1) +
					" = vec4(0.0);\n          xTexelC" +
					(2 * d + 1) +
					"Ready = 0;\n          xC" +
					d +
					" = vec4(0.0);";
			h += "\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";
			for (var m = 0; m < (p + 1) / 2; m++) {
				var g = 2 * m;
				if (((h += "\n          xC = xCCorner + " + g * u + ";\n          "), 1 === s)) {
					if (
						g < c &&
						(o % 2 == 1
							? ((h +=
									"\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" +
									g +
									"Ready == 0) {\n                  xTexelC" +
									g +
									" = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC" +
									g +
									".zw = vec2(0.0);\n                  }\n                  xTexelC" +
									g +
									"Ready = 1;\n                }\n              "),
							  (h +=
									1 === u && g > 0
										? "\n                xC" +
										  g +
										  " = vec4(xTexelC" +
										  (g - 2) +
										  ".zw, xTexelC" +
										  g +
										  ".xy);\n                "
										: "\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC" +
										  g +
										  " = vec4(previous.zw, xTexelC" +
										  g +
										  ".xy);\n                  } else {\n                    xC" +
										  g +
										  " = vec4(0.0, 0.0, xTexelC" +
										  g +
										  ".xy);\n                  }\n                  "))
							: (h +=
									"\n                if (xC >= 0 && xC < inDims[1] && xTexelC" +
									g +
									"Ready == 0) {\n                  xTexelC" +
									g +
									" = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC" +
									g +
									".zw = vec2(0.0);\n                  }\n                  xTexelC" +
									g +
									"Ready = 1;\n                }\n\n                xC" +
									g +
									" = xTexelC" +
									g +
									";\n                "),
						g + 1 < c)
					) {
						var v = o % 2 == 0 ? Ag(u) : u;
						(u % 2 == 0 && o % 2 == 1) || (u % 2 != 0 && o % 2 != 1)
							? ((h +=
									"\n                  xCOffset = xC + imod(pads[1], 2) + " +
									v +
									";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" +
									(g + 1) +
									"Ready == 0) {\n                    xTexelC" +
									(g + 1) +
									" = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC" +
									(g + 1) +
									".zw = vec2(0.0);\n                    }\n                    xTexelC" +
									(g + 1) +
									"Ready = 1;\n                  }\n                  "),
							  u > 1 &&
									(h +=
										"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" +
										g +
										"Ready == 0) {\n                      xTexelC" +
										g +
										" = getX(batch, xR, xCOffset, d1);\n                      xTexelC" +
										g +
										"Ready = 1;\n                    }\n                    "),
							  (h +=
									"\n                  xC" +
									(g + 1) +
									" = vec4(xTexelC" +
									g +
									".zw, xTexelC" +
									(g + 1) +
									".xy);\n                  "))
							: (h +=
									1 === v
										? "\n                    xC" +
										  (g + 1) +
										  " = xTexelC" +
										  g +
										  ";\n                    "
										: "\n                    xCOffset = xC + " +
										  v +
										  ";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" +
										  (g + 1) +
										  "Ready == 0) {\n                      xTexelC" +
										  (g + 1) +
										  " = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC" +
										  (g + 1) +
										  ".zw = vec2(0.0);\n                      }\n                      xTexelC" +
										  (g + 1) +
										  "Ready = 1;\n                    }\n\n                    xC" +
										  (g + 1) +
										  " = xTexelC" +
										  (g + 1) +
										  ";\n                    ");
					}
				} else
					g < c &&
						(o % 2 == 1
							? ((h +=
									"\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" +
									g +
									"Ready == 0) {\n                  xTexelC" +
									g +
									" = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC" +
									g +
									".zw = vec2(0.0);\n                  }\n                  xTexelC" +
									g +
									"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC" +
									(g + 1) +
									"Ready == 0) {\n                  xTexelC" +
									(g + 1) +
									" = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC" +
									(g + 1) +
									".zw = vec2(0.0);\n                  }\n                  xTexelC" +
									(g + 1) +
									"Ready = 1;\n                }\n\n                xC" +
									g +
									" = vec4(xTexelC" +
									g +
									".zw, xTexelC" +
									(g + 1) +
									".zw);\n              "),
							  g + 1 < c &&
									(h +=
										"\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC" +
										(g + 1) +
										" = vec4(xTexelC" +
										(g + 1) +
										".xy, final.xy);\n                "))
							: ((h +=
									"\n                if(xC >= 0 && xC < inDims[1] && xTexelC" +
									g +
									"Ready == 0) {\n                  xTexelC" +
									g +
									" = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC" +
									g +
									".zw = vec2(0.0);\n                  }\n                  xTexelC" +
									g +
									"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" +
									(g + 1) +
									"Ready == 0) {\n                  xTexelC" +
									(g + 1) +
									" = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC" +
									(g + 1) +
									".zw = vec2(0.);\n                  }\n                  xTexelC" +
									(g + 1) +
									"Ready = 1;\n                }\n\n                xC" +
									g +
									" = vec4(\n                  xTexelC" +
									g +
									".xy, xTexelC" +
									(g + 1) +
									".xy);\n              "),
							  g + 1 < c &&
									(h +=
										"\n                  xC" +
										(g + 1) +
										" = vec4(xTexelC" +
										g +
										".zw, xTexelC" +
										(g + 1) +
										".zw);\n                ")));
				g < c &&
					((h +=
						"\n            wTexel = getW(r, " +
						g +
						", d1, q);\n            dotProd += xC" +
						g +
						" * vec4(wTexel.xz, wTexel.xz);\n          "),
					g + 1 < c &&
						(h +=
							"\n              wTexel = getW(r, " +
							(g + 1) +
							", d1, q);\n              dotProd += xC" +
							(g + 1) +
							" * vec4(wTexel.xz, wTexel.xz);\n            "));
			}
			(h += "\n    }\n  "), (h += "\n      }\n    ");
			var y = "",
				b = "";
			n &&
				((y = r
					? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " +
					  n +
					  "\n        }"
					: a
					? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          " +
					  n +
					  "\n        }"
					: "vec4 activation(vec4 x) {\n          " + n + "\n        }"),
				(b = "result = activation(result);"));
			var x = t ? "result += getBiasAtOutCoords();" : "";
			t && this.variableNames.push("bias"),
				r && this.variableNames.push("preluActivationWeights"),
				a && this.variableNames.push("leakyreluAlpha"),
				(this.userCode =
					"\n      " +
					y +
					"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " +
					i +
					";\n        int q = d2 - d1 * " +
					i +
					";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        " +
					h +
					"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        " +
					x +
					"\n        " +
					b +
					"\n        setOutput(result);\n      }\n    ");
		},
		pQ = {
			kernelName: py,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.filter,
					o = r.strides,
					s = r.pad,
					u = r.dilations,
					l = r.dimRoundingMode,
					c = u;
				null == c && (c = [1, 1]),
					Dg(yS(o, c), function () {
						return (
							"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " +
							o +
							" and dilations '" +
							c +
							"'"
						);
					});
				var p,
					h = cS(a.shape, i.shape, o, c, s, l, !0);
				p =
					xv().getBool("WEBGL_PACK_DEPTHWISECONV") && h.strideWidth <= 2 && h.outChannels / h.inChannels == 1
						? new cQ(h)
						: new lQ(h);
				var f = [
					[h.padInfo.top, h.padInfo.left],
					[h.strideHeight, h.strideWidth],
					[h.dilationHeight, h.dilationWidth],
					[h.inHeight, h.inWidth],
				];
				return n.runWebGLProgram(p, [a, i], "float32", f);
			},
		},
		hQ = function (e) {
			(this.variableNames = ["x", "dy"]), (this.outputShape = e.filterShape);
			var t = e.strideHeight,
				n = e.strideWidth,
				r = e.padInfo.top,
				a = e.padInfo.left,
				i = e.outChannels / e.inChannels;
			this.userCode =
				"\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " +
				i +
				" + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " +
				e.batchSize +
				"; b++) {\n          for (int yR = 0; yR < " +
				e.outHeight +
				"; yR++) {\n            int xR = wR + yR * " +
				t +
				" - " +
				r +
				";\n\n            if (xR < 0 || xR >= " +
				e.inHeight +
				") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " +
				e.outWidth +
				"; yC++) {\n              int xC = wC + yC * " +
				n +
				" - " +
				a +
				";\n\n              if (xC < 0 || xC >= " +
				e.inWidth +
				") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		fQ = function (e) {
			(this.variableNames = ["dy", "W"]), (this.outputShape = e.inShape);
			var t = e.filterHeight,
				n = e.filterWidth,
				r = e.strideHeight,
				a = e.strideWidth,
				i = t - 1 - e.padInfo.top,
				o = n - 1 - e.padInfo.left,
				s = e.outChannels / e.inChannels;
			this.userCode =
				"\n      const ivec2 pads = ivec2(" +
				i +
				", " +
				o +
				");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " +
				t +
				"; wR++) {\n          float dyR = float(dyRCorner + wR) / " +
				r +
				".0;\n\n          if (dyR < 0.0 || dyR >= " +
				e.outHeight +
				".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " +
				t +
				" - 1 - wR;\n\n          for (int wC = 0; wC < " +
				n +
				"; wC++) {\n            float dyC = float(dyCCorner + wC) / " +
				a +
				".0;\n\n            if (dyC < 0.0 || dyC >= " +
				e.outWidth +
				".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " +
				n +
				" - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " +
				s +
				"; dm++) {\n              int d2 = d1 * " +
				s +
				" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		dQ = {
			kernelName: hy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.dy,
					o = r.strides,
					s = r.dilations,
					u = r.pad,
					l = r.dimRoundingMode,
					c = r.filterShape,
					p = cS(a.shape, c, o, s, u, l, !0),
					h = new hQ(p);
				return n.runWebGLProgram(h, [a, i], "float32");
			},
		},
		mQ = {
			kernelName: fy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.filter,
					o = r.strides,
					s = r.dilations,
					u = r.pad,
					l = r.dimRoundingMode,
					c = cS(r.inputShape, i.shape, o, s, u, l, !0),
					p = new fQ(c);
				return n.runWebGLProgram(p, [a, i], "float32");
			},
		},
		gQ = function (e) {
			(this.variableNames = ["X"]),
				(this.outputShape = [e, e]),
				(this.userCode =
					"\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ");
		},
		vQ = {
			kernelName: dy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.x,
					a = [].concat(r.shape, r.shape),
					i = zg(r.shape),
					o = QY({ inputs: { x: r }, backend: n, attrs: { shape: [i] } }),
					s = new gQ(i),
					u = n.runWebGLProgram(s, [o], o.dtype),
					l = QY({ inputs: { x: u }, backend: n, attrs: { shape: a } });
				return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(u), l;
			},
		},
		yQ = function (e) {
			(this.variableNames = ["x", "W"]), (this.outputShape = e.outShape);
			var t = e.inHeight,
				n = e.inWidth,
				r = e.padInfo,
				a = e.strideHeight,
				i = e.strideWidth,
				o = e.filterHeight,
				s = e.filterWidth,
				u = e.dilationHeight,
				l = e.dilationWidth,
				c = r.top,
				p = r.left;
			this.userCode =
				"\n      const ivec2 strides = ivec2(" +
				a +
				", " +
				i +
				");\n      const ivec2 pads = ivec2(" +
				c +
				", " +
				p +
				");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < " +
				o +
				"; h++) {\n          int hIn = hBeg + h * " +
				u +
				";\n\n          if (hIn >= 0 && hIn < " +
				t +
				") {\n            for (int w = 0; w < " +
				s +
				"; w++) {\n              int wIn = wBeg + w * " +
				l +
				";\n\n              if (wIn >= 0 && wIn < " +
				n +
				") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ";
		},
		bQ = {
			kernelName: my,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t,
					n = e.inputs,
					r = e.backend,
					a = e.attrs,
					i = n.x,
					o = n.filter,
					s = a.strides,
					u = a.pad,
					l = a.dilations,
					c = sS(i.shape, o.shape, s, u, "NHWC", l),
					p = new yQ(c),
					h = QY({
						inputs: { x: (t = r.runWebGLProgram(p, [i, o], "float32")) },
						backend: r,
						attrs: { shape: c.outShape },
					});
				return r.disposeIntermediateTensorInfo(t), h;
			},
		},
		xQ = {
			kernelName: by,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t,
					a = XA(e.attrs.equation, r.length),
					i = a.allDims,
					o = a.summedDims,
					s = a.idDims;
				JA(i.length, s, r);
				for (
					var u = ZA(o, s), l = u.path, c = u.steps, p = c.length, h = null, f = i.length, d = [], m = 0;
					m < p;
					++m
				) {
					for (var g, v = Ig(c[m]); !(g = v()).done; ) {
						var y = g.value,
							b = YA(f, s[y]),
							x = b.permutationIndices,
							w = b.expandDims,
							k = void 0;
						QA(x)
							? (k = r[y])
							: ((k = uJ({ inputs: { x: r[y] }, backend: n, attrs: { perm: x } })), d.push(k));
						for (var N = k.shape.slice(), I = 0; I < w.length; ++I) N.splice(w[I], 0, 1);
						Pg(k.shape, N) || ((k = QY({ inputs: { x: k }, backend: n, attrs: { shape: N } })), d.push(k)),
							null === h ? (h = k) : ((h = JY({ inputs: { a: k, b: h }, backend: n })), d.push(h));
					}
					m < p - 1 &&
						(l[m] >= 0 &&
							((h = oJ({
								inputs: { x: h },
								backend: n,
								attrs: { axis: l[m] - (i.length - f), keepDims: !1 },
							})),
							d.push(h)),
						f--);
				}
				for (var S = 0, T = d; S < T.length; S++) {
					var C = T[S];
					C !== h && n.disposeIntermediateTensorInfo(C);
				}
				return h;
			},
		},
		wQ = jY({
			opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
			packedOpSnippet:
				"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
		}),
		kQ = { kernelName: xy, backendName: "webgl", kernelFunc: wQ },
		NQ = {
			kernelName: wy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.dy,
					a = t.y,
					i = xv().getBool("WEBGL_PACK_BINARY_OPERATIONS")
						? new DY(
								"\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",
								r.shape,
								a.shape
						  )
						: new FY("return (b >= 1.0) ? a : a * (b + 1.0);", r.shape, a.shape);
				return n.runWebGLProgram(i, [r, a], r.dtype);
			},
		},
		IQ = HY({
			opSnippet: "return float(a == b);",
			packedOpSnippet: "\n  return vec4(equal(a, b));\n",
			dtype: "bool",
			cpuKernelImpl: FX,
		}),
		SQ = { kernelName: Ny, backendName: "webgl", kernelFunc: IQ },
		TQ = jY({
			opSnippet:
				'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n',
		}),
		CQ = { kernelName: ky, backendName: "webgl", kernelFunc: TQ },
		EQ = jY({
			opSnippet: "if (isnan(x)) return x;\n  return exp(x);\n",
			packedOpSnippet:
				"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
			cpuKernelImpl: DX,
			dtype: "float32",
		}),
		RQ = { kernelName: Iy, backendName: "webgl", kernelFunc: EQ };
	function AQ(e) {
		var t = e.inputs,
			n = e.attrs,
			r = e.backend,
			a = n.dim,
			i = t.input,
			o = i.shape.length,
			s = i.shape.slice(),
			u = a;
		return (
			a < 0 &&
				(Dg(-(o + 1) <= a, function () {
					return "Axis must be in the interval [" + -(o + 1) + ", " + o + "]";
				}),
				(u = o + a + 1)),
			s.splice(u, 0, 1),
			QY({ inputs: { x: i }, backend: r, attrs: { shape: s } })
		);
	}
	var _Q = { kernelName: Sy, backendName: "webgl", kernelFunc: AQ },
		FQ = "return exp(x) - 1.0;",
		DQ = jY({ opSnippet: FQ, packedOpSnippet: FQ, cpuKernelImpl: OX }),
		OQ = { kernelName: Ty, backendName: "webgl", kernelFunc: DQ },
		MQ = function (e, t, n) {
			this.variableNames = ["real", "imag"];
			var r = t[1];
			this.outputShape = t;
			var a,
				i = n ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI,
				o = n ? r + ".0" : "1.0";
			if ("real" === e) a = "return real * expR - imag * expI;";
			else {
				if ("imag" !== e) throw new Error('FFT component must be either "real" or "imag", got ' + e + ".");
				a = "return real * expI + imag * expR;";
			}
			this.userCode =
				"\n      const float exponentMultiplier = " +
				i +
				";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " +
				a +
				"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" +
				r +
				");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " +
				r +
				"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " +
				o +
				";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
		};
	function LQ(e, t, n) {
		var r = n.texData.get(e.dataId),
			a = zg(e.shape),
			i = e.shape[e.shape.length - 1],
			o = QY({ inputs: { x: e }, backend: n, attrs: { shape: [a / i, i] } }),
			s = o.shape,
			u = new MQ("real", s, t),
			l = new MQ("imag", s, t),
			c = [
				{ dataId: r.complexTensorInfos.real.dataId, dtype: r.complexTensorInfos.real.dtype, shape: s },
				{ dataId: r.complexTensorInfos.imag.dataId, dtype: r.complexTensorInfos.imag.dtype, shape: s },
			],
			p = n.runWebGLProgram(u, c, "float32"),
			h = n.runWebGLProgram(l, c, "float32"),
			f = LY({ inputs: { real: p, imag: h }, backend: n });
		n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h);
		var d = QY({ inputs: { x: f }, backend: n, attrs: { shape: e.shape } });
		return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(f), d;
	}
	var zQ = {
			kernelName: Cy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend;
				return LQ(t.input, !1, n);
			},
		},
		PQ = function (e, t) {
			(this.outputShape = []),
				(this.customUniforms = [{ name: "value", type: "float" }]),
				(this.variableNames = ["x"]),
				(this.outputShape = e),
				(this.userCode =
					"\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ");
		};
	function BQ(e) {
		var t = e.backend,
			n = e.attrs,
			r = n.shape,
			a = n.value,
			i = n.dtype;
		if ("string" === (i = i || rv(a))) {
			var o = Kg(i, zg(r));
			return o.fill(a), t.makeTensorInfo(r, i, o);
		}
		var s = new PQ(r, a),
			u = [[a]];
		return t.runWebGLProgram(s, [], i, u);
	}
	var WQ,
		UQ = { kernelName: Ey, backendName: "webgl", kernelFunc: BQ },
		VQ = function (e) {
			(this.variableNames = ["Image"]), (this.outputShape = []);
			var t = e[2];
			(this.outputShape = e),
				(this.userCode =
					"\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = " +
					t +
					" - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < " +
					t +
					") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
		},
		GQ = {
			kernelName: Ry,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.image,
					a = n,
					i = new VQ(r.shape);
				return a.runWebGLProgram(i, [r], r.dtype);
			},
		},
		jQ = "return floor(x);",
		HQ = jY({ opSnippet: jQ, packedOpSnippet: jQ, cpuKernelImpl: MX }),
		qQ = { kernelName: Ay, backendName: "webgl", kernelFunc: HQ },
		KQ = HY({
			opSnippet:
				"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
			packedOpSnippet:
				"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
			dtype: "int32",
		}),
		XQ = { kernelName: _y, backendName: "webgl", kernelFunc: KQ },
		YQ = function (e) {
			this.variableNames = ["A"];
			var t = qK(),
				n = e[0],
				r = e[1];
			(this.outputShape = e),
				(this.userCode =
					"\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" +
					r +
					".0, " +
					n +
					".0);\n\n        vec4 values = " +
					t.texture2D +
					"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ");
		},
		JQ = function (e) {
			(this.variableNames = ["A"]), (this.packedInputs = !1), (this.packedOutput = !0);
			var t = qK(),
				n = e[0],
				r = e[1];
			(this.outputShape = e),
				(this.userCode =
					"\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" +
					r +
					".0, " +
					n +
					".0);\n            vec4 values = " +
					t.texture2D +
					"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " +
					t.output +
					" = result;\n      }\n    ");
		},
		ZQ = {
			kernelName: Nx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.pixels,
					i = r.numChannels,
					o = "undefined" != typeof HTMLVideoElement && a instanceof HTMLVideoElement,
					s = "undefined" != typeof HTMLImageElement && a instanceof HTMLImageElement,
					u = o ? [a.videoWidth, a.videoHeight] : [a.width, a.height],
					l = u[0],
					c = u[1],
					p = [c, l],
					h = [c, l, i];
				(s || o) &&
					(null == WQ && (WQ = document.createElement("canvas").getContext("2d")),
					(WQ.canvas.width = l),
					(WQ.canvas.height = c),
					WQ.drawImage(a, 0, 0, l, c),
					(a = WQ.canvas));
				var f = n.makeTensorInfo(p, "int32");
				(n.texData.get(f.dataId).usage = fK.PIXELS),
					n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId), a);
				var d = xv().getBool("WEBGL_PACK") ? new JQ(h) : new YQ(h),
					m = n.runWebGLProgram(d, [f], "int32");
				return n.disposeData(f.dataId), m;
			},
		},
		QQ = {
			kernelName: Tx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t,
					n = e.inputs,
					r = e.backend,
					a = e.attrs,
					i = n.x,
					o = n.filter,
					s = n.bias,
					u = n.preluActivationWeights,
					l = a.strides,
					c = a.pad,
					p = a.dataFormat,
					h = a.dilations,
					f = a.dimRoundingMode,
					d = a.activation,
					m = a.leakyreluAlpha,
					g = bS(p),
					v = cS(i.shape, o.shape, l, h, c, f, !1, g),
					y = [];
				if (
					1 !== v.filterHeight ||
					1 !== v.filterWidth ||
					1 !== v.dilationHeight ||
					1 !== v.dilationWidth ||
					1 !== v.strideHeight ||
					1 !== v.strideWidth ||
					("SAME" !== v.padInfo.type && "VALID" !== v.padInfo.type)
				)
					if (xv().getBool("WEBGL_CONV_IM2COL") && 1 === i.shape[0])
						t = MZ({
							x: i,
							filter: o,
							convInfo: v,
							backend: r,
							bias: s,
							activation: d,
							preluActivationWeights: u,
							leakyreluAlpha: m,
						});
					else {
						var b = null != s,
							x = null != u,
							w = "leakyrelu" === d,
							k = d ? qY(d, !1) : null,
							N = new _Z(v, b, k, x, w),
							I = [i, o];
						if ((s && I.push(s), u && I.push(u), w)) {
							var S = r.makeTensorInfo([], "float32", ww(m, "float32"));
							I.push(S), y.push(S);
						}
						t = r.runWebGLProgram(N, I, "float32");
					}
				else
					t = OZ({
						x: i,
						filter: o,
						convInfo: v,
						backend: r,
						bias: s,
						activation: d,
						preluActivationWeights: u,
						leakyreluAlpha: m,
					});
				var T = QY({ inputs: { x: t }, backend: r, attrs: { shape: v.outShape } });
				return (
					y.push(t),
					y.forEach(function (e) {
						return r.disposeIntermediateTensorInfo(e);
					}),
					T
				);
			},
		},
		$Q = {
			kernelName: Cx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.filter,
					o = t.bias,
					s = t.preluActivationWeights,
					u = r.strides,
					l = r.pad,
					c = r.dilations,
					p = r.dimRoundingMode,
					h = r.activation,
					f = r.leakyreluAlpha,
					d = [],
					m = c;
				null == m && (m = [1, 1]),
					Dg(yS(u, m), function () {
						return (
							"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " +
							u +
							" and dilations '" +
							m +
							"'"
						);
					});
				var g,
					v = cS(a.shape, i.shape, u, m, l, p, !0),
					y =
						xv().getBool("WEBGL_PACK_DEPTHWISECONV") &&
						v.strideWidth <= 2 &&
						v.outChannels / v.inChannels == 1,
					b = h ? qY(h, y) : null,
					x = [a, i],
					w = null != o,
					k = null != s,
					N = "leakyrelu" === h;
				if ((w && x.push(o), k && x.push(s), N)) {
					var I = n.makeTensorInfo([], "float32", ww(f, "float32"));
					x.push(I), d.push(I);
				}
				g = y ? new cQ(v, w, b, k, N) : new lQ(v, w, b, k, N);
				var S = [
						[v.padInfo.top, v.padInfo.left],
						[v.strideHeight, v.strideWidth],
						[v.dilationHeight, v.dilationWidth],
						[v.inHeight, v.inWidth],
					],
					T = n.runWebGLProgram(g, x, "float32", S);
				return (
					d.forEach(function (e) {
						return n.disposeIntermediateTensorInfo(e);
					}),
					T
				);
			},
		},
		e$ = function (e, t, n) {
			(this.sliceDim = e), (this.strides = t), (this.variableNames = ["x", "indices"]), (this.outputShape = n);
			var r = sX(t.length),
				a = sX(n.length),
				i = this.sliceDim > 1 ? "strides[j]" : "strides";
			this.userCode =
				"\n        " +
				r +
				" strides = " +
				r +
				"(" +
				this.strides +
				");\n         void main() {\n          " +
				a +
				" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " +
				this.sliceDim +
				"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " +
				i +
				";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
		},
		t$ = {
			kernelName: Oy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.params,
					a = t.indices,
					i = a.shape,
					o = i[i.length - 1],
					s = zg(r.shape),
					u = oI(r, a),
					l = u[0],
					c = u[1],
					p = u[2],
					h = u[3],
					f = QY({ inputs: { x: a }, backend: n, attrs: { shape: [c, o] } }),
					d = QY({ inputs: { x: r }, backend: n, attrs: { shape: [zg(r.shape) / p, p] } });
				if (n.shouldExecuteOnCPU([r, a]) || "string" === r.dtype) {
					var m = n.readSync(a.dataId),
						g = n.bufferSync(r),
						v = LX(m, g, r.dtype, c, o, p, h, r.shape, s);
					return n.makeTensorInfo(l, r.dtype, v.values);
				}
				var y = new e$(o, h, [c, p]),
					b = n.runWebGLProgram(y, [d, f], d.dtype),
					x = QY({ inputs: { x: b }, backend: n, attrs: { shape: l } });
				return (
					n.disposeIntermediateTensorInfo(f),
					n.disposeIntermediateTensorInfo(d),
					n.disposeIntermediateTensorInfo(b),
					x
				);
			},
		},
		n$ = function (e, t) {
			(this.variableNames = ["A", "indices"]), (this.outputShape = t), (this.rank = t.length);
			var n = sX(this.rank),
				r = (function (e, t) {
					for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], r = [], a = 0; a < e.length; a++)
						2 === a ? r.push("index") : r.push("" + n[a]);
					return r.join();
				})(e);
			this.userCode =
				"\n      void main() {\n        " +
				n +
				" resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < " +
				e[2] +
				") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(" +
				r +
				"));\n      }\n    ";
		};
	function r$(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = t.indices,
			o = r.axis,
			s = r.batchDims,
			u = jg(o, a.shape)[0];
		xv().get("DEBUG") &&
			(function () {
				for (
					var e = n.readSync(i.dataId),
						t = a.shape[u],
						r = function (n) {
							var r = e[n];
							Dg(r <= t - 1 && r >= 0, function () {
								return "GatherV2: the index value " + r + " is not in [0, " + (t - 1) + "]";
							});
						},
						o = 0;
					o < e.length;
					++o
				)
					r(o);
			})();
		var l = h_(a, i, u, s),
			c = zg(i.shape),
			p = [],
			h = QY({
				inputs: { x: a },
				backend: n,
				attrs: { shape: [l.batchSize, l.outerSize, l.dimSize, l.sliceSize] },
			}),
			f = QY({ inputs: { x: i }, backend: n, attrs: { shape: [l.batchSize, c / l.batchSize] } });
		p.push(h), p.push(f);
		var d = [l.batchSize, l.outerSize, c / l.batchSize, l.sliceSize];
		if (n.shouldExecuteOnCPU([a, i]) || "string" === a.dtype) {
			var m = n.bufferSync(f),
				g = n.bufferSync(h),
				v = zX(g, m, d);
			return (
				p.forEach(function (e) {
					return n.disposeIntermediateTensorInfo(e);
				}),
				n.makeTensorInfo(l.outputShape, v.dtype, v.values)
			);
		}
		var y = new n$(h.shape, d),
			b = n.runWebGLProgram(y, [h, f], h.dtype);
		p.push(b);
		var x = QY({ inputs: { x: b }, backend: n, attrs: { shape: l.outputShape } });
		return (
			p.forEach(function (e) {
				return n.disposeIntermediateTensorInfo(e);
			}),
			x
		);
	}
	var a$ = { kernelName: Dy, backendName: "webgl", kernelFunc: r$ },
		i$ = HY({
			opSnippet: "return float(a > b);",
			packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n",
			cpuKernelImpl: PX,
			dtype: "bool",
		}),
		o$ = { kernelName: My, backendName: "webgl", kernelFunc: i$ },
		s$ = HY({
			opSnippet: "return float(a >= b);",
			packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n",
			dtype: "bool",
			cpuKernelImpl: BX,
		}),
		u$ = { kernelName: Ly, backendName: "webgl", kernelFunc: s$ },
		l$ = {
			kernelName: Py,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend;
				return LQ(t.input, !0, n);
			},
		},
		c$ = jY({ opSnippet: "return float(!isnan(x) && !isinf(x));", dtype: "bool" }),
		p$ = { kernelName: Wy, backendName: "webgl", kernelFunc: c$ },
		h$ = jY({ opSnippet: "return float(isinf(x));", dtype: "bool" }),
		f$ = { kernelName: Uy, backendName: "webgl", kernelFunc: h$ },
		d$ = jY({ opSnippet: "return float(isnan(x));", dtype: "bool" }),
		m$ = { kernelName: Vy, backendName: "webgl", kernelFunc: d$ },
		g$ = HY({
			opSnippet: "return float(a < b);",
			packedOpSnippet: "\n  return vec4(lessThan(a, b));\n",
			cpuKernelImpl: WX,
			dtype: "bool",
		}),
		v$ = { kernelName: jy, backendName: "webgl", kernelFunc: g$ },
		y$ = HY({
			opSnippet: "return float(a <= b);",
			packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n",
			cpuKernelImpl: UX,
			dtype: "bool",
		}),
		b$ = { kernelName: Hy, backendName: "webgl", kernelFunc: y$ },
		x$ = {
			kernelName: qy,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.backend,
					n = e.attrs,
					r = n.start,
					a = n.stop,
					i = n.num,
					o = VX(r, a, i);
				return t.makeTensorInfo([o.length], "float32", o);
			},
		},
		w$ = jY({
			opSnippet: "if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",
			packedOpSnippet:
				"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",
			cpuKernelImpl: GX,
		}),
		k$ = { kernelName: Ky, backendName: "webgl", kernelFunc: w$ },
		N$ = jY({ opSnippet: "if (isnan(x)) return x;\n  return log(1.0 + x);\n" }),
		I$ = { kernelName: Xy, backendName: "webgl", kernelFunc: N$ },
		S$ = HY({
			opSnippet: "return float(a >= 1.0 && b >= 1.0);",
			packedOpSnippet:
				"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
			dtype: "bool",
		}),
		T$ = { kernelName: Yy, backendName: "webgl", kernelFunc: S$ },
		C$ = jY({ opSnippet: "return float(!(x >= 1.0));" }),
		E$ = { kernelName: Jy, backendName: "webgl", kernelFunc: C$ },
		R$ = HY({
			opSnippet: "return float(a >= 1.0 || b >= 1.0);",
			packedOpSnippet:
				"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
			dtype: "bool",
		}),
		A$ = { kernelName: Zy, backendName: "webgl", kernelFunc: R$ },
		_$ = function (e, t, n, r, a) {
			(this.variableNames = ["x"]), (this.outputShape = []);
			var i,
				o = t,
				s = e[3] - 1;
			this.outputShape = e;
			var u = "float(" + n + ") + float(" + r + ") * sum";
			(i =
				0.5 === a
					? "inversesqrt(" + u + ")"
					: 1 === a
					? "1.0/(" + u + ")"
					: "exp(log(" + u + ") * float(-" + a + "));"),
				(this.userCode =
					"\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" +
					o +
					"; j <= " +
					o +
					"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " +
					s +
					") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " +
					i +
					";\n        setOutput(val);\n      }\n    ");
		},
		F$ = function (e, t, n, r, a) {
			(this.variableNames = ["x"]), (this.outputShape = []), (this.packedInputs = !0), (this.packedOutput = !0);
			var i,
				o = t,
				s = e[3] - 1;
			this.outputShape = e;
			var u = "float(" + n + ") + float(" + r + ") * sum";
			(i =
				0.5 === a
					? "inversesqrt(" + u + ")"
					: 1 === a
					? "1.0/(" + u + ")"
					: "exp(log(" + u + ") * float(-" + a + "));"),
				(this.userCode =
					"\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " +
					this.outputShape[3] +
					";\n        bool hasNextRow = c < " +
					this.outputShape[2] +
					";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " +
					o +
					";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " +
					o +
					"; j <= " +
					o +
					"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" +
					s +
					"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " +
					i +
					";\n        setOutput(result);\n      }\n    ");
		},
		D$ = {
			kernelName: $y,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.depthRadius,
					o = r.bias,
					s = r.alpha,
					u = r.beta,
					l = xv().getBool("WEBGL_PACK_NORMALIZATION")
						? new F$(a.shape, i, o, s, u)
						: new _$(a.shape, i, o, s, u);
				return n.runWebGLProgram(l, [a], a.dtype);
			},
		},
		O$ = function (e, t, n, r, a) {
			(this.variableNames = ["inputImage", "outputImage", "dy"]),
				(this.outputShape = []),
				(this.outputShape = e),
				(this.depth = e[3]),
				(this.depthRadius = t),
				(this.bias = n),
				(this.alpha = r),
				(this.beta = a),
				(this.userCode =
					"\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " +
					this.depth +
					"; ++d) {\n          int depthBegin = int(max(0.0, float(d - " +
					t +
					")));\n          int depthEnd = int(min(float(" +
					this.depth +
					"),\n              float(d + " +
					t +
					" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " +
					this.depth +
					";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" +
					r +
					") * norm + float(" +
					n +
					");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" +
					r +
					")\n                * float(" +
					a +
					")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " +
					a +
					");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ");
		},
		M$ = {
			kernelName: eb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = t.y,
					o = t.dy,
					s = r.depthRadius,
					u = r.bias,
					l = r.alpha,
					c = r.beta,
					p = new O$(a.shape, s, u, l, c);
				return n.runWebGLProgram(p, [a, i, o], a.dtype);
			},
		};
	function L$(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = r.reductionIndices,
			o = r.keepDims,
			s = a.shape.length,
			u = jg(i, a.shape),
			l = u,
			c = YT(l, s),
			p = null != c,
			h = n.shouldExecuteOnCPU([a]),
			f = a;
		if (p) {
			if (h) {
				for (var d = n.texData.get(f.dataId).values, m = new Array(s), g = 0; g < m.length; g++)
					m[g] = a.shape[c[g]];
				var v = fY(d, a.shape, a.dtype, c, m);
				(f = n.makeTensorInfo(m, a.dtype)), (n.texData.get(f.dataId).values = v);
			} else f = iJ(a, c, n);
			l = ZT(l.length, s);
		}
		XT("max", l, s);
		var y,
			b = qT(f.shape, l),
			x = b[0],
			w = b[1],
			k = x;
		if ((o && (k = KT(x, u)), h)) {
			var N = n.texData.get(f.dataId).values,
				I = jX(N, zg(w), k, a.dtype);
			(y = n.makeTensorInfo(k, a.dtype)), (n.texData.get(y.dataId).values = I);
		} else
			y = (function (e, t, n, r) {
				var a = zg(t),
					i = QY({ inputs: { x: e }, attrs: { shape: [zg(e.shape) / a, a] }, backend: r }),
					o = nJ(i, e.dtype, "max", r),
					s = QY({ inputs: { x: o }, attrs: { shape: n }, backend: r });
				return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), s;
			})(f, w, k, n);
		return p && n.disposeIntermediateTensorInfo(f), y;
	}
	var z$ = { kernelName: tb, backendName: "webgl", kernelFunc: L$ },
		P$ = HY({
			opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",
			packedOpSnippet:
				"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
			cpuKernelImpl: HX,
		}),
		B$ = { kernelName: nb, backendName: "webgl", kernelFunc: P$ },
		W$ = {
			kernelName: rb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x;
				jK(a, "maxPool");
				var i = r.filterSize,
					o = r.strides,
					s = r.pad,
					u = r.dimRoundingMode;
				Dg(yS(o, 1), function () {
					return (
						"Error in maxPool: Either strides or dilations must be 1. Got strides " +
						o +
						" and dilations '1'"
					);
				});
				var l = uS(a.shape, i, o, 1, s, u);
				if (1 === l.filterWidth && 1 === l.filterHeight && Pg(l.inShape, l.outShape))
					return OY({ inputs: { x: a }, backend: n });
				var c = new GJ(l, "max", !1);
				return n.runWebGLProgram(c, [a], a.dtype);
			},
		},
		U$ = {
			kernelName: ib,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.filterSize,
					o = r.strides,
					s = r.pad,
					u = r.dataFormat,
					l = r.dimRoundingMode,
					c = lS(a.shape, i, o, [1, 1, 1], s, l, u),
					p = new jJ(c, "max", !1);
				return n.runWebGLProgram(p, [a], a.dtype);
			},
		},
		V$ = function (e) {
			(this.variableNames = ["dy", "maxPos"]), (this.outputShape = e.inShape);
			var t = e.strideHeight,
				n = e.strideWidth,
				r = e.dilationHeight,
				a = e.effectiveFilterHeight,
				i = e.effectiveFilterWidth,
				o = a - 1 - e.padInfo.top,
				s = i - 1 - e.padInfo.left,
				u = a * i - 1;
			this.userCode =
				"\n      const ivec2 pads = ivec2(" +
				o +
				", " +
				s +
				");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " +
				a +
				";\n          wR += " +
				r +
				") {\n          float dyR = float(dyRCorner + wR) / " +
				t +
				".0;\n\n          if (dyR < 0.0 || dyR >= " +
				e.outHeight +
				".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " +
				i +
				"; wC++) {\n            float dyC = float(dyCCorner + wC) / " +
				n +
				".0;\n\n            if (dyC < 0.0 || dyC >= " +
				e.outWidth +
				".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " +
				u +
				" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " +
				i +
				" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		G$ = function (e) {
			(this.variableNames = ["dy", "maxPos"]), (this.outputShape = e.inShape);
			var t = e.strideDepth,
				n = e.strideHeight,
				r = e.strideWidth,
				a = e.dilationDepth,
				i = e.dilationHeight,
				o = e.dilationWidth,
				s = e.effectiveFilterDepth,
				u = e.effectiveFilterHeight,
				l = e.effectiveFilterWidth,
				c = s - 1 - e.padInfo.front,
				p = u - 1 - e.padInfo.top,
				h = l - 1 - e.padInfo.left,
				f = s * u * l - 1;
			this.userCode =
				"\n      const ivec3 pads = ivec3(" +
				c +
				", " +
				p +
				", " +
				h +
				");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " +
				s +
				";\n           wD += " +
				a +
				") {\n          float dyD = float(dyDCorner + wD) / " +
				t +
				".0;\n\n          if (dyD < 0.0 || dyD >= " +
				e.outDepth +
				".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " +
				u +
				";\n              wR += " +
				i +
				") {\n            float dyR = float(dyRCorner + wR) / " +
				n +
				".0;\n\n            if (dyR < 0.0 || dyR >= " +
				e.outHeight +
				".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " +
				l +
				";\n                wC += " +
				o +
				") {\n              float dyC = float(dyCCorner + wC) / " +
				r +
				".0;\n\n              if (dyC < 0.0 || dyC >= " +
				e.outWidth +
				".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " +
				f +
				" -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " +
				u +
				" * " +
				l +
				" +\n                  wR * " +
				l +
				" + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
		},
		j$ = {
			kernelName: ob,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.input,
					o = r.filterSize,
					s = r.strides,
					u = r.pad,
					l = r.dimRoundingMode,
					c = lS(i.shape, o, s, [1, 1, 1], u, l),
					p = new jJ(c, "max", !0),
					h = n.runWebGLProgram(p, [i], i.dtype),
					f = new G$(c),
					d = n.runWebGLProgram(f, [a, h], i.dtype);
				return n.disposeIntermediateTensorInfo(h), d;
			},
		},
		H$ = {
			kernelName: ab,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.dy,
					i = t.input,
					o = i;
				jK([i, t.output], "maxPoolGrad");
				var s = r.filterSize,
					u = r.strides,
					l = r.pad,
					c = r.dimRoundingMode,
					p = uS(o.shape, s, u, 1, l, c),
					h = new GJ(p, "max", !0),
					f = n.runWebGLProgram(h, [o], o.dtype),
					d = new V$(p),
					m = n.runWebGLProgram(d, [a, f], o.dtype);
				return n.disposeIntermediateTensorInfo(f), m;
			},
		},
		q$ = {
			kernelName: sb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.attrs,
					r = e.backend,
					a = t.x,
					i = n.filterSize,
					o = n.strides,
					s = n.pad,
					u = n.includeBatchInIndex,
					l = r;
				Dg(4 === a.shape.length, function () {
					return "Error in maxPool: input must be rank 4 but got rank " + a.shape.length + ".";
				});
				var c = [1, 1];
				Dg(yS(o, c), function () {
					return (
						"Error in maxPool: Either strides or dilations must be 1. Got strides " +
						o +
						" and dilations '" +
						c +
						"'"
					);
				});
				var p = uS(a.shape, i, o, c, s),
					h = (function (e, t, n, r) {
						var a = new GJ(n, "max", !1),
							i = r.runWebGLProgram(a, [e], "float32");
						return (a = new GJ(n, "max", !0, !0, t)), [i, r.runWebGLProgram(a, [e], "float32")];
					})(a, u, p, l);
				return [h[0], h[1]];
			},
		},
		K$ = {
			kernelName: ub,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.attrs,
					r = e.backend,
					a = t.x,
					i = n.keepDims,
					o = n.axis,
					s = r,
					u = a.shape.length,
					l = jg(o, a.shape),
					c = l,
					p = YT(c, u),
					h = null != p,
					f = s.shouldExecuteOnCPU([a]),
					d = [],
					m = a;
				if (h) {
					if (f) {
						for (var g = s.texData.get(m.dataId).values, v = new Array(u), y = 0; y < v.length; y++)
							v[y] = a.shape[p[y]];
						var b = fY(g, a.shape, a.dtype, p, v);
						(m = s.makeTensorInfo(v, a.dtype)), (s.texData.get(m.dataId).values = b);
					} else m = iJ(a, p, s);
					d.push(m), (c = ZT(c.length, u));
				}
				XT("sum", c, u);
				var x = qT(m.shape, c),
					w = x[0],
					k = x[1],
					N = w;
				i && (N = KT(w, l));
				for (
					var I = (function (e, t, n, r) {
							var a = zg(t),
								i = QY({ inputs: { x: e }, attrs: { shape: [zg(e.shape) / a, a] }, backend: r }),
								o = nJ(i, "float32", "mean", r),
								s = QY({ inputs: { x: o }, attrs: { shape: n }, backend: r });
							return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), s;
						})(m, k, N, s),
						S = 0,
						T = d;
					S < T.length;
					S++
				) {
					var C = T[S];
					s.disposeIntermediateTensorInfo(C);
				}
				return I;
			},
		},
		X$ = {
			kernelName: lb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.axis,
					o = r.keepDims,
					s = a.shape.length,
					u = jg(i, a.shape),
					l = u,
					c = YT(l, s),
					p = a;
				null != c &&
					((p = uJ({ inputs: { x: a }, backend: n, attrs: { perm: c } })),
					(l = ZT(l.length, a.shape.length))),
					XT("min", l, s);
				var h,
					f = qT(p.shape, l),
					d = f[0],
					m = QY({ inputs: { x: p }, backend: n, attrs: { shape: [-1, zg(f[1])] } }),
					g = nJ(m, m.dtype, "min", n);
				return (
					(h = QY(
						o
							? { inputs: { x: g }, backend: n, attrs: { shape: KT(d, u) } }
							: { inputs: { x: g }, backend: n, attrs: { shape: d } }
					)),
					n.disposeIntermediateTensorInfo(m),
					n.disposeIntermediateTensorInfo(g),
					null != c && n.disposeIntermediateTensorInfo(p),
					h
				);
			},
		},
		Y$ = HY({
			opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",
			packedOpSnippet:
				"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
			cpuKernelImpl: qX,
		}),
		J$ = { kernelName: cb, backendName: "webgl", kernelFunc: Y$ },
		Z$ = function (e, t, n) {
			(this.variableNames = ["x"]),
				(this.outputShape = t.map(function (t, n) {
					return t[0] + e[n] + t[1];
				}));
			var r = e.length,
				a = sX(r),
				i = t
					.map(function (e) {
						return e[0];
					})
					.join(","),
				o = t
					.map(function (t, n) {
						return t[0] + e[n];
					})
					.join(","),
				s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r),
				u = "reflect" === n ? 0 : 1;
			this.userCode =
				1 !== r
					? "\n      " +
					  a +
					  " start = " +
					  a +
					  "(" +
					  i +
					  ");\n      " +
					  a +
					  " end = " +
					  a +
					  "(" +
					  o +
					  ");\n\n      void main() {\n        " +
					  a +
					  " outC = getOutputCoords();\n        for (int i = 0; i < " +
					  r +
					  "; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - " +
					  u +
					  ";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + " +
					  u +
					  ";\n          }\n        }\n        " +
					  a +
					  " coords = outC - start;\n        setOutput(getX(" +
					  s +
					  "));\n      }\n    "
					: "\n        int start = " +
					  i +
					  ";\n        int end = " +
					  o +
					  ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - " +
					  u +
					  ";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + " +
					  u +
					  ";\n          }\n          setOutput(getX(outC - start));\n        }\n      ";
		},
		Q$ = function (e, t, n) {
			(this.variableNames = ["x"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.outputShape = t.map(function (t, n) {
					return t[0] + e[n] + t[1];
				}));
			var r = e.length,
				a = sX(r),
				i = t
					.map(function (e) {
						return e[0];
					})
					.join(","),
				o = t
					.map(function (t, n) {
						return t[0] + e[n];
					})
					.join(","),
				s = gY("rc", r),
				u = gY("source", r),
				l = s[r - 1] + " < " + this.outputShape[r - 1],
				c = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")",
				p = "reflect" === n ? 0 : 1,
				h = "";
			if (1 === r) {
				var f =
					"\n        " +
					a +
					" source = rc;\n        if (source < start) {\n          source = start * 2 - source - " +
					p +
					";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + " +
					p +
					";\n        }\n        source -= start;\n      ";
				h =
					"\n        " +
					a +
					" rc = outputLoc;\n        " +
					f +
					"\n        result[0] = getChannel(getX(" +
					u.join() +
					"), " +
					c +
					");\n        " +
					s[r - 1] +
					" += 1;\n        if(" +
					l +
					") {\n          " +
					f +
					"\n          result[1] = getChannel(getX(" +
					u.join() +
					"), " +
					c +
					");\n        }\n      ";
			} else {
				var d =
					"\n        " +
					a +
					" source = rc;\n        " +
					a +
					" lt = " +
					a +
					"(lessThan(source, start));\n        " +
					a +
					" gte = " +
					a +
					"(greaterThanEqual(source, end));\n        " +
					a +
					" orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - " +
					p +
					") +\n                gte * ((end - 1) * 2 - source + " +
					p +
					");\n        source -= start;\n      ";
				h =
					"\n        " +
					a +
					" rc = outputLoc;\n        " +
					d +
					"\n        result[0] = getChannel(getX(" +
					u.join() +
					"), " +
					c +
					");\n        " +
					s[r - 1] +
					" += 1;\n        if(" +
					l +
					") {\n          " +
					d +
					"\n          result[1] = getChannel(getX(" +
					u.join() +
					"), " +
					c +
					");\n        }\n        rc = outputLoc;\n        " +
					s[r - 2] +
					" += 1;\n        if(" +
					s[r - 2] +
					" < " +
					this.outputShape[r - 2] +
					") {\n          " +
					d +
					"\n          result[2] = getChannel(getX(" +
					u.join() +
					"), " +
					c +
					");\n          " +
					s[r - 1] +
					" += 1;\n          if(" +
					l +
					") {\n            " +
					d +
					"\n            result[3] = getChannel(getX(" +
					u.join() +
					"), " +
					c +
					");\n          }\n        }\n      ";
			}
			this.userCode =
				"\n      const " +
				a +
				" start = " +
				a +
				"(" +
				i +
				");\n      const " +
				a +
				" end = " +
				a +
				"(" +
				o +
				");\n\n      void main() {\n        " +
				a +
				" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " +
				h +
				"\n        setOutput(result);\n      }\n    ";
		},
		$$ = {
			kernelName: pb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.paddings,
					o = r.mode,
					s = xv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Q$(a.shape, i, o) : new Z$(a.shape, i, o);
				return n.runWebGLProgram(s, [a], a.dtype);
			},
		},
		e0 = HY({
			opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);",
			packedOpSnippet:
				"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
		}),
		t0 = { kernelName: hb, backendName: "webgl", kernelFunc: e0 },
		n0 = function (e, t, n) {
			(this.variableNames = ["probs"]),
				(this.customUniforms = [{ name: "seed", type: "float" }]),
				(this.outputShape = [e, n]),
				(this.userCode =
					"\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " +
					(t - 1) +
					"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" +
					(t - 1) +
					"));\n      }\n    ");
		},
		r0 = HY({
			opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
			packedOpSnippet:
				"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
			checkOutOfBounds: !0,
		}),
		a0 = { kernelName: yy, backendName: "webgl", kernelFunc: r0 },
		i0 = "return a - b;",
		o0 = HY({ opSnippet: i0, packedOpSnippet: i0, supportsComplex: !0, cpuKernelImpl: cY }),
		s0 = { kernelName: px, backendName: "webgl", kernelFunc: o0 };
	function u0(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.logits,
			i = jg([r.dim], a.shape),
			o = L$({ inputs: { x: a }, backend: n, attrs: { reductionIndices: i, keepDims: !1 } }),
			s = KT(o.shape, i),
			u = QY({ inputs: { x: o }, backend: n, attrs: { shape: s } }),
			l = o0({ inputs: { a: a, b: u }, backend: n }),
			c = EQ({ inputs: { x: l }, backend: n }),
			p = oJ({ inputs: { x: c }, backend: n, attrs: { axis: i, keepDims: !1 } }),
			h = QY({ inputs: { x: p }, backend: n, attrs: { shape: s } }),
			f = r0({ inputs: { a: c, b: h }, backend: n });
		return (
			n.disposeIntermediateTensorInfo(o),
			n.disposeIntermediateTensorInfo(u),
			n.disposeIntermediateTensorInfo(l),
			n.disposeIntermediateTensorInfo(c),
			n.disposeIntermediateTensorInfo(p),
			n.disposeIntermediateTensorInfo(h),
			f
		);
	}
	var l0 = { kernelName: $b, backendName: "webgl", kernelFunc: u0 },
		c0 = {
			kernelName: fb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.logits,
					i = r.numSamples,
					o = r.seed,
					s = r.normalized,
					u = s ? a : u0({ inputs: { logits: a }, backend: n, attrs: { dim: a.shape.length - 1 } }),
					l = u.shape[0],
					c = u.shape[1],
					p = new n0(l, c, i),
					h = [[o]],
					f = n.runWebGLProgram(p, [u], "int32", h);
				return s || n.disposeIntermediateTensorInfo(u), f;
			},
		},
		p0 = {
			kernelName: mb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t,
					n = e.inputs,
					r = e.backend,
					a = n.x;
				if (r.shouldExecuteOnCPU([a])) {
					var i = r.texData.get(a.dataId),
						o = XX(i.values, a.shape, a.dtype),
						s = o[0],
						u = o[1];
					return r.makeTensorInfo(u, a.dtype, s);
				}
				return (
					(t = xv().getBool("WEBGL_PACK_UNARY_OPERATIONS")
						? new TY(
								a.shape,
								"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
						  )
						: new NY(a.shape, "if (isnan(x)) return x;\n  return -x;\n")),
					r.runWebGLProgram(t, [a], a.dtype)
				);
			},
		},
		h0 = TR,
		f0 = {
			kernelName: vb,
			backendName: "webgl",
			kernelFunc: function (e) {
				Ex("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.boxes,
					i = t.scores,
					o = r.maxOutputSize,
					s = r.iouThreshold,
					u = r.scoreThreshold,
					l = n.readSync(a.dataId),
					c = n.readSync(i.dataId),
					p = h0(l, c, o, s, u).selectedIndices;
				return n.makeTensorInfo([p.length], "int32", new Int32Array(p));
			},
		},
		d0 = CR,
		m0 = {
			kernelName: yb,
			backendName: "webgl",
			kernelFunc: function (e) {
				Ex("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.boxes,
					i = t.scores,
					o = r.maxOutputSize,
					s = r.iouThreshold,
					u = r.scoreThreshold,
					l = r.padToMaxOutputSize,
					c = n.readSync(a.dataId),
					p = n.readSync(i.dataId),
					h = d0(c, p, o, s, u, l),
					f = h.selectedIndices,
					d = h.validOutputs;
				return [
					n.makeTensorInfo([f.length], "int32", new Int32Array(f)),
					n.makeTensorInfo([], "int32", new Int32Array([d])),
				];
			},
		},
		g0 = ER,
		v0 = {
			kernelName: bb,
			backendName: "webgl",
			kernelFunc: function (e) {
				Ex("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.boxes,
					i = t.scores,
					o = r.maxOutputSize,
					s = r.iouThreshold,
					u = r.scoreThreshold,
					l = r.softNmsSigma,
					c = n.readSync(a.dataId),
					p = n.readSync(i.dataId),
					h = g0(c, p, o, s, u, l),
					f = h.selectedIndices,
					d = h.selectedScores;
				return [
					n.makeTensorInfo([f.length], "int32", new Int32Array(f)),
					n.makeTensorInfo([d.length], "float32", new Float32Array(d)),
				];
			},
		},
		y0 = function (e, t, n, r) {
			(this.variableNames = ["indices"]),
				(this.outputShape = [e, t]),
				(this.userCode =
					"\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" +
					r +
					"), float(" +
					n +
					"),\n                      float(index == coords.y)));\n      }\n    ");
		},
		b0 = {
			kernelName: wb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.indices,
					i = r.depth,
					o = r.onValue,
					s = r.offValue,
					u = zg(a.shape),
					l = new y0(u, i, o, s),
					c = QY({ inputs: { x: a }, backend: n, attrs: { shape: [u] } }),
					p = n.runWebGLProgram(l, [c], a.dtype);
				n.disposeIntermediateTensorInfo(c);
				var h = QY({ inputs: { x: p }, backend: n, attrs: { shape: [].concat(a.shape, [i]) } });
				return n.disposeIntermediateTensorInfo(p), h;
			},
		};
	function x0(e) {
		var t = e.inputs,
			n = e.backend,
			r = t.x;
		if ("complex64" === r.dtype) {
			var a = pZ({ inputs: { input: r }, backend: n }),
				i = x0({ inputs: { x: a }, backend: n }),
				o = TZ({ inputs: { input: r }, backend: n }),
				s = x0({ inputs: { x: o }, backend: n }),
				u = LY({ inputs: { real: i, imag: s }, backend: n });
			return (
				n.disposeIntermediateTensorInfo(a),
				n.disposeIntermediateTensorInfo(i),
				n.disposeIntermediateTensorInfo(o),
				n.disposeIntermediateTensorInfo(s),
				u
			);
		}
		return BQ({ attrs: { shape: r.shape, dtype: r.dtype, value: "string" === r.dtype ? "" : 0 }, backend: n });
	}
	var w0 = { kernelName: wx, backendName: "webgl", kernelFunc: x0 },
		k0 = {
			kernelName: xb,
			backendName: "webgl",
			kernelFunc: function e(t) {
				var n = t.inputs,
					r = t.backend,
					a = n.x;
				if ("string" === a.dtype) throw new Error("onesLike is not supported under string dtype");
				if ("complex64" === a.dtype) {
					var i = pZ({ inputs: { input: a }, backend: r }),
						o = e({ inputs: { x: i }, backend: r }),
						s = TZ({ inputs: { input: a }, backend: r }),
						u = x0({ inputs: { x: s }, backend: r }),
						l = LY({ inputs: { real: o, imag: u }, backend: r });
					return (
						r.disposeIntermediateTensorInfo(i),
						r.disposeIntermediateTensorInfo(o),
						r.disposeIntermediateTensorInfo(s),
						r.disposeIntermediateTensorInfo(u),
						l
					);
				}
				return BQ({ attrs: { shape: a.shape, dtype: a.dtype, value: 1 }, backend: r });
			},
		},
		N0 = {
			kernelName: kb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs.axis;
				if (1 === t.length) return AQ({ inputs: { input: t[0] }, backend: n, attrs: { dim: r } });
				var a = t[0].shape,
					i = t[0].dtype;
				t.forEach(function (e) {
					Og(a, e.shape, "All tensors passed to stack must have matching shapes"),
						Dg(i === e.dtype, function () {
							return "All tensors passed to stack must have matching dtypes";
						});
				});
				var o = [],
					s = RZ({
						inputs: t.map(function (e) {
							var t = AQ({ inputs: { input: e }, backend: n, attrs: { dim: r } });
							return o.push(t), t;
						}),
						backend: n,
						attrs: { axis: r },
					});
				return (
					o.forEach(function (e) {
						return n.disposeIntermediateTensorInfo(e);
					}),
					s
				);
			},
		},
		I0 = function (e, t, n) {
			(this.variableNames = ["x"]),
				(this.customUniforms = [{ name: "value", type: "float" }]),
				(this.outputShape = t.map(function (t, n) {
					return t[0] + e[n] + t[1];
				}));
			var r = e.length,
				a = sX(r),
				i = t
					.map(function (e) {
						return e[0];
					})
					.join(","),
				o = t
					.map(function (t, n) {
						return t[0] + e[n];
					})
					.join(","),
				s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
			this.userCode =
				1 !== r
					? "\n      " +
					  a +
					  " start = " +
					  a +
					  "(" +
					  i +
					  ");\n      " +
					  a +
					  " end = " +
					  a +
					  "(" +
					  o +
					  ");\n\n      void main() {\n        " +
					  a +
					  " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          " +
					  a +
					  " coords = outC - start;\n          setOutput(getX(" +
					  s +
					  "));\n        }\n      }\n    "
					: "\n        int start = " +
					  i +
					  ";\n        int end = " +
					  o +
					  ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
		},
		S0 = function (e, t, n) {
			(this.variableNames = ["x"]),
				(this.packedInputs = !0),
				(this.packedOutput = !0),
				(this.customUniforms = [{ name: "value", type: "float" }]),
				(this.outputShape = t.map(function (t, n) {
					return t[0] + e[n] + t[1];
				}));
			for (
				var r = e.length,
					a = sX(r),
					i = t
						.map(function (e) {
							return e[0];
						})
						.join(","),
					o = t
						.map(function (t, n) {
							return t[0] + e[n];
						})
						.join(","),
					s = gY("rc", r),
					u = gY("source", r),
					l = s[r - 1] + " < " + this.outputShape[r - 1],
					c = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")",
					p = [
						a + " rc = outputLoc;",
						s[r - 1] + " += 1;\n       if(" + l + ") {\n      ",
						1 === r
							? ""
							: "}\n       rc = outputLoc;\n       " +
							  s[r - 2] +
							  " += 1;\n       if(" +
							  s[r - 2] +
							  " < " +
							  this.outputShape[r - 2] +
							  ") {",
						1 === r ? "" : "  " + s[r - 1] + " += 1;\n         if(" + l + ") {",
					],
					h =
						1 === r
							? "rc < start || rc >= end"
							: "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",
					f = "",
					d = 0,
					m = 1 === r ? 2 : 4;
				d < m;
				d++
			)
				f +=
					"\n        " +
					p[d] +
					"\n        if (" +
					h +
					") {\n          result[" +
					d +
					"] = float(value);\n        } else {\n          " +
					a +
					" source = rc - start;\n          result[" +
					d +
					"] = getChannel(getX(" +
					u.join() +
					"), " +
					c +
					");\n        }\n      ";
			(f += 1 === r ? "} " : "}}"),
				(this.userCode =
					"\n      const " +
					a +
					" start = " +
					a +
					"(" +
					i +
					");\n      const " +
					a +
					" end = " +
					a +
					"(" +
					o +
					");\n\n      void main() {\n        " +
					a +
					" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " +
					f +
					"\n        setOutput(result);\n      }\n    ");
		},
		T0 = function (e) {
			var t = e.inputs,
				n = e.backend,
				r = e.attrs,
				a = t.x,
				i = r.paddings,
				o = r.constantValue;
			if (0 === zg(a.shape))
				return BQ({
					backend: n,
					attrs: {
						shape: i.map(function (e, t) {
							return e[0] + a.shape[t] + e[1];
						}),
						value: o,
						dtype: a.dtype,
					},
				});
			var s = xv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new S0(a.shape, i, o) : new I0(a.shape, i, o),
				u = [[o]];
			return n.runWebGLProgram(s, [a], a.dtype, u);
		},
		C0 = { kernelName: Nb, backendName: "webgl", kernelFunc: T0 },
		E0 = HY({
			opSnippet:
				"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
			packedOpSnippet:
				"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
		}),
		R0 = { kernelName: Ib, backendName: "webgl", kernelFunc: E0 },
		A0 = {
			kernelName: Tb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t,
					n = e.inputs,
					r = e.backend,
					a = e.attrs,
					i = n.x,
					o = a.axis,
					s = a.keepDims,
					u = i.shape.length,
					l = [],
					c = jg(o, i.shape),
					p = c,
					h = YT(p, u),
					f = i;
				if (
					(null != h &&
						((f = uJ({ inputs: { x: i }, backend: r, attrs: { perm: h } })),
						(p = ZT(p.length, u)),
						l.push(f)),
					XT("prod", p, u),
					r.shouldExecuteOnCPU([f]))
				) {
					var d = r.texData.get(f.dataId).values,
						m = JX(f.shape, f.dtype, d, p),
						g = m.outVals,
						v = m.outShape,
						y = m.outDtype;
					t = r.makeTensorInfo(v, y, g);
				} else {
					var b = qT(f.shape, p),
						x = b[0],
						w = zg(b[1]),
						k = QY({ inputs: { x: f }, backend: r, attrs: { shape: [-1, w] } }),
						N = nJ(k, Xw(i.dtype), "prod", r);
					(t = QY({ inputs: { x: N }, backend: r, attrs: { shape: x } })), l.push(k), l.push(N);
				}
				if (s) {
					l.push(t);
					var I = KT(t.shape, c);
					t = QY({ inputs: { x: t }, backend: r, attrs: { shape: I } });
				}
				return (
					l.forEach(function (e) {
						return r.disposeIntermediateTensorInfo(e);
					}),
					t
				);
			},
		},
		_0 = function (e) {
			var t = e.backend,
				n = e.attrs,
				r = n.start,
				a = n.stop,
				i = n.step,
				o = n.dtype,
				s = ZX(r, a, i, o);
			return t.makeTensorInfo([s.length], o, s);
		},
		F0 = { kernelName: Cb, backendName: "webgl", kernelFunc: _0 },
		D0 = jY({ opSnippet: "return 1.0 / x;" }),
		O0 = { kernelName: Rb, backendName: "webgl", kernelFunc: D0 },
		M0 = jY({
			opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",
			packedOpSnippet:
				"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
		}),
		L0 = { kernelName: Ab, backendName: "webgl", kernelFunc: M0 },
		z0 = jY({
			opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
			packedOpSnippet:
				"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
		}),
		P0 = { kernelName: Lb, backendName: "webgl", kernelFunc: z0 },
		B0 = function (e, t, n, r, a) {
			(this.variableNames = ["A"]), (this.outputShape = []);
			var i = e[0],
				o = e[1],
				s = e[2],
				u = e[3];
			this.outputShape = [i, t, n, u];
			var l,
				c = [r && t > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s],
				p = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n];
			(l = a
				? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)"
				: "vec2(yRC) * effectiveInputOverOutputRatioRC"),
				(this.userCode =
					"\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " +
					c[0] / p[0] +
					",\n          " +
					c[1] / p[1] +
					");\n      const vec2 inputShapeRC = vec2(" +
					o +
					".0, " +
					s +
					".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = " +
					l +
					";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ");
		},
		W0 = function (e, t, n, r, a) {
			(this.variableNames = ["A"]), (this.packedInputs = !0), (this.packedOutput = !0), (this.outputShape = []);
			var i = e[0],
				o = e[1],
				s = e[2],
				u = e[3];
			this.outputShape = [i, t, n, u];
			var l,
				c = [r && t > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s],
				p = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n];
			(l = a
				? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)"
				: "vec3(yRC) * effectiveInputOverOutputRatioRC"),
				(this.userCode =
					"\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " +
					c[0] / p[0] +
					",\n          " +
					c[1] / p[1] +
					",\n          " +
					c[1] / p[1] +
					");\n      const vec3 inputShapeRC = vec3(" +
					o +
					".0, " +
					s +
					".0,\n                                     " +
					s +
					".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = " +
					l +
					";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " +
					(u - 1) +
					";\n        bool hasNextRow = coords.z < " +
					(n - 1) +
					";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ");
		},
		U0 = {
			kernelName: Ob,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.images,
					i = r.alignCorners,
					o = r.halfPixelCenters,
					s = r.size,
					u = s[0],
					l = s[1],
					c = xv().getBool("WEBGL_PACK_IMAGE_OPERATIONS")
						? new W0(a.shape, u, l, i, o)
						: new B0(a.shape, u, l, i, o);
				return n.runWebGLProgram(c, [a], "float32");
			},
		},
		V0 = function (e, t, n) {
			(this.variableNames = ["dy"]), (this.outputShape = []), (this.outputShape = t);
			var r = t[1],
				a = t[2],
				i = e[1],
				o = e[2],
				s = [n && i > 1 ? r - 1 : r, n && o > 1 ? a - 1 : a],
				u = [n && i > 1 ? i - 1 : i, n && o > 1 ? o - 1 : o],
				l = s[0] / u[0],
				c = s[1] / u[1],
				p = 1 / l,
				h = 1 / c,
				f = 2 * Math.ceil(p) + 2,
				d = 2 * Math.ceil(h) + 2;
			this.userCode =
				"\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" +
				l +
				");\n        const float widthScale = float(" +
				c +
				");\n\n        const float invHeightScale = float(" +
				p +
				");\n        const float invWidthScale = float(" +
				h +
				");\n\n        const int winHeight = int(" +
				f +
				");\n        const int winWidth = int(" +
				d +
				");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " +
				i +
				") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " +
				o +
				") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " +
				(r - 1) +
				".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " +
				(a - 1) +
				".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
		},
		G0 = {
			kernelName: Mb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.images,
					i = t.dy,
					o = r.alignCorners,
					s = new V0(i.shape, a.shape, o);
				return n.runWebGLProgram(s, [i], i.dtype);
			},
		},
		j0 = function (e, t, n, r, a) {
			(this.variableNames = ["A"]), (this.outputShape = []);
			var i = e[0],
				o = e[1],
				s = e[2],
				u = e[3];
			this.outputShape = [i, t, n, u];
			var l,
				c = [r && t > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s],
				p = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n],
				h = r ? "0.5" : "0.0";
			(l = a
				? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))"
				: "vec2(yRC) * effectiveInputOverOutputRatioRC"),
				(this.userCode =
					"\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " +
					c[0] / p[0] +
					",\n          " +
					c[1] / p[1] +
					");\n      const vec2 inputShapeRC = vec2(" +
					o +
					".0, " +
					s +
					".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = " +
					l +
					";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " +
					h +
					")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ");
		},
		H0 = function (e, t, n, r, a) {
			(this.variableNames = ["A"]), (this.packedInputs = !0), (this.packedOutput = !0), (this.outputShape = []);
			var i = e[0],
				o = e[1],
				s = e[2],
				u = e[3];
			this.outputShape = [i, t, n, u];
			var l,
				c = [r && t > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s],
				p = [r && t > 1 ? t - 1 : t, r && n > 1 ? n - 1 : n],
				h = r ? "0.5" : "0.0";
			(l = a
				? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))"
				: "vec3(yRC) * effectiveInputOverOutputRatioRC"),
				(this.userCode =
					"\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " +
					c[0] / p[0] +
					",\n          " +
					c[1] / p[1] +
					",\n          " +
					c[1] / p[1] +
					");\n      const vec3 inputShapeRC = vec3(" +
					o +
					".0, " +
					s +
					".0,\n                                     " +
					s +
					".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = " +
					l +
					";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " +
					h +
					")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " +
					(u - 1) +
					";\n        bool hasNextRow = coords.z < " +
					(n - 1) +
					";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ");
		},
		q0 = {
			kernelName: Fb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.images,
					i = r.alignCorners,
					o = r.halfPixelCenters,
					s = r.size,
					u = s[0],
					l = s[1],
					c = xv().getBool("WEBGL_PACK_IMAGE_OPERATIONS")
						? new H0(a.shape, u, l, i, o)
						: new j0(a.shape, u, l, i, o);
				return n.runWebGLProgram(c, [a], a.dtype);
			},
		},
		K0 = function (e, t, n) {
			(this.variableNames = ["dy"]), (this.outputShape = []), (this.outputShape = t);
			var r = t[1],
				a = t[2],
				i = e[1],
				o = e[2],
				s = [n && i > 1 ? r - 1 : r, n && o > 1 ? a - 1 : a],
				u = [n && i > 1 ? i - 1 : i, n && o > 1 ? o - 1 : o],
				l = s[0] / u[0],
				c = s[1] / u[1],
				p = 1 / l,
				h = 1 / c,
				f = 2 * Math.ceil(p) + 2,
				d = 2 * Math.ceil(h) + 2;
			this.userCode =
				"\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" +
				l +
				");\n        const float widthScale = float(" +
				c +
				");\n\n        const float invHeightScale = float(" +
				p +
				");\n        const float invWidthScale = float(" +
				h +
				");\n\n        const int winHeight = int(" +
				f +
				");\n        const int winWidth = int(" +
				d +
				");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " +
				i +
				") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " +
				o +
				") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" +
				s[0] +
				") *\n                (float(dyR) / float(" +
				u[0] +
				"));\n\n            float sourceFracCol =\n                float(" +
				s[1] +
				") *\n                  (float(dyC) / float(" +
				u[1] +
				"));\n\n            int sourceNearestRow = int(min(\n                float(int(" +
				r +
				") - 1),\n                " +
				n +
				" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" +
				a +
				") - 1),\n                " +
				n +
				" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
		},
		X0 = {
			kernelName: Db,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.images,
					i = t.dy,
					o = r.alignCorners,
					s = new K0(i.shape, a.shape, o);
				return n.runWebGLProgram(s, [i], i.dtype);
			},
		},
		Y0 = function (e, t) {
			this.variableNames = ["x"];
			var n = e.length;
			if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
			if (((this.outputShape = e), 1 !== n)) {
				var r = e
						.map(function (n, r) {
							return (function (n) {
								return -1 !== t.indexOf(n) && 1 !== e[n]
									? e[n] + " - coords[" + n + "] - 1"
									: "coords[" + n + "]";
							})(r);
						})
						.join(","),
					a = sX(n);
				this.userCode =
					"\n      void main() {\n        " +
					a +
					" coords = getOutputCoords();\n        setOutput(getX(" +
					r +
					"));\n      }\n    ";
			} else
				this.userCode =
					"\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" +
					e[0] +
					" - coord - 1));\n        }\n      ";
		},
		J0 = function (e, t) {
			(this.variableNames = ["x"]), (this.packedInputs = !0), (this.packedOutput = !0);
			var n = e.length;
			if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
			this.outputShape = e;
			var r = gY("rc", n),
				a = r[n - 1] + " + 1 < " + this.outputShape[n - 1],
				i = r[n - 2] + " + 1 < " + this.outputShape[n - 2],
				o = sX(n);
			function s(n) {
				var r = e.map(function (r, a) {
					return (function (n, r) {
						return -1 !== t.indexOf(n) && 1 !== e[n] ? e[n] + " - " + r[n] + " - 1" : "" + r[n];
					})(a, n);
				});
				return "getChannel(getX(" + r.join(",") + "), vec2(" + r.slice(-2).join(",") + "))";
			}
			this.userCode =
				1 === n
					? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" +
					  e[0] +
					  " - rc - 1),\n            " +
					  e[0] +
					  " - rc - 1);\n          if(" +
					  a +
					  "){\n              result.g = getChannel(getX(" +
					  e[0] +
					  " - (rc  + 1) - 1),\n                " +
					  e[0] +
					  " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "
					: "\n        void main() {\n          " +
					  o +
					  " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " +
					  (function (e) {
							return s(e);
					  })(r.slice()) +
					  ";\n          if(" +
					  a +
					  "){\n            result.g = " +
					  (function (e) {
							return (e[n - 1] = "(" + e[n - 1] + " + 1)"), s(e);
					  })(r.slice()) +
					  ";\n          }\n          if(" +
					  i +
					  ") {\n            result.b = " +
					  (function (e) {
							return (e[n - 2] = "(" + e[n - 2] + " + 1)"), s(e);
					  })(r.slice()) +
					  ";\n            if(" +
					  a +
					  ") {\n              result.a = " +
					  (function (e) {
							return (e[n - 1] = "(" + e[n - 1] + " + 1)"), (e[n - 2] = "(" + e[n - 2] + " + 1)"), s(e);
					  })(r.slice()) +
					  ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
		},
		Z0 = {
			kernelName: zb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.dims,
					o = a.shape.length,
					s = jg(i, a.shape);
				if (0 === o) return OY({ inputs: { x: a }, backend: n });
				var u = xv().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new J0(a.shape, s) : new Y0(a.shape, s);
				return n.runWebGLProgram(u, [a], a.dtype);
			},
		},
		Q0 = function (e, t) {
			(this.variableNames = ["Image"]),
				(this.outputShape = []),
				(this.customUniforms = [{ name: "params", type: "vec4" }]);
			var n = e[1],
				r = e[2];
			this.outputShape = e;
			var a;
			(a =
				"number" == typeof t
					? "float outputValue = " + t.toFixed(2) + ";"
					: "\n        vec3 fill = vec3(" + t.join(",") + ");\n        float outputValue = fill[coords[3]];"),
				(this.userCode =
					"\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          " +
					a +
					"\n          if(coordX >= 0 && coordX < " +
					r +
					" && coordY >= 0 && coordY < " +
					n +
					") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
		},
		$0 = {
			kernelName: Ix,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.attrs,
					r = e.backend,
					a = t.image,
					i = n.radians,
					o = n.fillValue,
					s = n.center,
					u = r,
					l = new Q0(a.shape, o),
					c = _A(s, a.shape[1], a.shape[2]),
					p = [[c[0], c[1], Math.sin(i), Math.cos(i)]];
				return u.runWebGLProgram(l, [a], a.dtype, p);
			},
		},
		e1 = jY({
			opSnippet:
				"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",
		}),
		t1 = { kernelName: Pb, backendName: "webgl", kernelFunc: e1 },
		n1 = jY({ opSnippet: "return inversesqrt(x);", cpuKernelImpl: QX }),
		r1 = { kernelName: Bb, backendName: "webgl", kernelFunc: n1 },
		a1 = function (e, t, n, r, a, i, o) {
			void 0 === o && (o = !0),
				(this.variableNames = ["updates", "indices", "defaultValue"]),
				(this.outputShape = i);
			var s = sX(a.length),
				u = sX(i.length),
				l = "";
			1 === n ? (l = "i") : 2 === n && (l = "i, j");
			var c = "getIndices(" + l + ")",
				p = "";
			1 === r ? (p = "i") : 2 === r && (p = "i, coords[1]");
			var h = "getUpdates(" + p + ")",
				f = t > 1 ? "strides[j]" : "strides";
			this.userCode =
				"\n        " +
				s +
				" strides = " +
				s +
				"(" +
				a +
				");\n\n        void main() {\n          " +
				u +
				" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " +
				e +
				"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " +
				t +
				"; j++) {\n              int index = round(" +
				c +
				");\n              flattenedIndex += index * " +
				f +
				";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " +
				h +
				";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
		},
		i1 = {
			kernelName: Wb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.indices,
					i = t.updates,
					o = r.shape,
					s = cI(0, a, o),
					u = s.sliceRank,
					l = s.numUpdates,
					c = s.sliceSize,
					p = s.strides,
					h = s.outputSize,
					f = [h / c, c];
				if (0 === h) return n.makeTensorInfo(o, a.dtype);
				var d = QY({ inputs: { x: a }, backend: n, attrs: { shape: [l, u] } }),
					m = QY({ inputs: { x: i }, backend: n, attrs: { shape: [l, c] } }),
					g = n.makeTensorInfo([], "float32", new Float32Array([0])),
					v = new a1(l, u, d.shape.length, m.shape.length, p, f),
					y = n.runWebGLProgram(v, [m, d, g], m.dtype),
					b = QY({ inputs: { x: y }, backend: n, attrs: { shape: o } });
				return (
					n.disposeIntermediateTensorInfo(d),
					n.disposeIntermediateTensorInfo(m),
					n.disposeIntermediateTensorInfo(y),
					n.disposeIntermediateTensorInfo(g),
					b
				);
			},
		},
		o1 = function (e, t, n) {
			var r, a;
			if (((this.variableNames = ["c", "a", "b"]), (this.outputShape = t), n > 4))
				throw Error("Where for rank " + n + " is not yet supported");
			if (1 === n) (a = "resRC"), (r = "resRC");
			else {
				for (var i = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o = [], s = [], u = 0; u < t.length; u++)
					s.push("" + i[u]), u < e && o.push("" + i[u]);
				(r = o.join()), (a = s.join());
			}
			var l = sX(n);
			this.userCode =
				"\n      void main() {\n        " +
				l +
				" resRC = getOutputCoords();\n        float cVal = getC(" +
				r +
				");\n        if (cVal >= 1.0) {\n          setOutput(getA(" +
				a +
				"));\n        } else {\n          setOutput(getB(" +
				a +
				"));\n        }\n      }\n    ";
		},
		s1 = {
			kernelName: Ub,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.condition,
					a = t.t,
					i = t.e,
					o = new o1(r.shape.length, a.shape, a.shape.length);
				return n.runWebGLProgram(o, [r, a, i], Kw(a.dtype, i.dtype));
			},
		},
		u1 = jY({
			opSnippet:
				"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n",
		}),
		l1 = { kernelName: Vb, backendName: "webgl", kernelFunc: u1 },
		c1 = jY({
			opSnippet: "if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",
			packedOpSnippet:
				"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
			cpuKernelImpl: $X,
		}),
		p1 = { kernelName: Kb, backendName: "webgl", kernelFunc: c1 },
		h1 = jY({ opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n" }),
		f1 = { kernelName: qb, backendName: "webgl", kernelFunc: h1 },
		d1 = jY({ opSnippet: "if (isnan(x)) return x;\n  return sin(x);\n" }),
		m1 = { kernelName: jb, backendName: "webgl", kernelFunc: d1 },
		g1 = jY({ opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n" }),
		v1 = { kernelName: Hb, backendName: "webgl", kernelFunc: g1 },
		y1 = jY({
			opSnippet:
				"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",
		}),
		b1 = { kernelName: Xb, backendName: "webgl", kernelFunc: y1 },
		x1 = {
			kernelName: Zb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.blockShape,
					o = r.paddings;
				Dg(a.shape.length <= 4, function () {
					return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
				});
				var s = i.reduce(function (e, t) {
						return e * t;
					}),
					u = [[0, 0]];
				u.push.apply(u, o);
				for (var l = 1 + i.length; l < a.shape.length; ++l) u.push([0, 0]);
				var c = [],
					p = T0({ inputs: { x: a }, backend: n, attrs: { paddings: u, constantValue: 0 } }),
					h = FA(p.shape, i, s, !1),
					f = DA(h.length, i.length, !1),
					d = OA(p.shape, i, s, !1),
					m = QY({ inputs: { x: p }, backend: n, attrs: { shape: h } }),
					g = uJ({ inputs: { x: m }, backend: n, attrs: { perm: f } }),
					v = QY({ inputs: { x: g }, backend: n, attrs: { shape: d } });
				return (
					c.push(p),
					c.push(m),
					c.push(g),
					c.forEach(function (e) {
						return n.disposeIntermediateTensorInfo(e);
					}),
					v
				);
			},
		},
		w1 = {
			kernelName: ex,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.indices,
					a = t.values,
					i = t.denseShape,
					o = t.defaultValue;
				if (1 !== i.shape.length) throw new Error("Dense shape must be a vector, saw:\n         " + i.shape);
				if (2 !== r.shape.length) throw new Error("Indices must be a matrix, saw:\n         " + r.shape);
				if (1 !== a.shape.length) throw new Error("Values must be a vector, saw:\n         " + a.shape);
				if (0 !== o.shape.length) throw new Error("Default value must be a scalar, saw:\n        " + o.shape);
				var s = n.readSync(r.dataId),
					u = n.readSync(a.dataId),
					l = n.readSync(i.dataId),
					c = n.readSync(o.dataId)[0],
					p = nY(s, r.shape, r.dtype, u, a.dtype, l, c),
					h = p[0],
					f = p[1],
					d = p[2],
					m = p[3],
					g = p[4];
				return [
					n.makeTensorInfo(f, r.dtype, h),
					n.makeTensorInfo([f[0]], a.dtype, d),
					n.makeTensorInfo(
						[m.length],
						"bool",
						new Uint8Array(
							m.map(function (e) {
								return Number(e);
							})
						)
					),
					n.makeTensorInfo([g.length], r.dtype, new Int32Array(g)),
				];
			},
		},
		k1 = {
			kernelName: tx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.inputIndices,
					a = t.inputShape,
					i = t.newShape;
				if (2 !== r.shape.length)
					throw new Error("Input indices should be a matrix but received shape " + r.shape);
				if (1 !== a.shape.length)
					throw new Error("Input shape should be a vector but received shape " + a.shape);
				if (1 !== i.shape.length)
					throw new Error("Target shape should be a vector but received shape " + i.shape);
				var o = Array.from(n.readSync(a.dataId)),
					s = n.readSync(r.dataId),
					u = Array.from(n.readSync(i.dataId)),
					l = rY(s, r.shape, r.dtype, o, u),
					c = l[0],
					p = l[1],
					h = l[2];
				return [n.makeTensorInfo(p, r.dtype, c), n.makeTensorInfo([h.length], i.dtype, new Int32Array(h))];
			},
		},
		N1 = {
			kernelName: nx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.data,
					a = t.indices,
					i = t.segmentIds;
				if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
				if (1 !== a.shape.length)
					throw new Error("Indices should be a vector but received shape\n              " + a.shape);
				if (1 !== i.shape.length)
					throw new Error("Segment ids should be a vector but received shape\n              " + i.shape);
				var o = n.readSync(r.dataId),
					s = n.readSync(a.dataId),
					u = n.readSync(i.dataId),
					l = aY(o, r.shape, r.dtype, s, u, !0),
					c = l[0],
					p = l[1];
				return n.makeTensorInfo(p, r.dtype, c);
			},
		},
		I1 = {
			kernelName: rx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = t.data,
					a = t.indices,
					i = t.segmentIds;
				if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
				if (1 !== a.shape.length)
					throw new Error("Indices should be a vector but received shape\n             " + a.shape);
				if (1 !== i.shape.length)
					throw new Error("Segment ids should be a vector but received shape\n             " + i.shape);
				var o = n.readSync(r.dataId),
					s = n.readSync(a.dataId),
					u = n.readSync(i.dataId),
					l = aY(o, r.shape, r.dtype, s, u),
					c = l[0],
					p = l[1];
				return n.makeTensorInfo(p, r.dtype, c);
			},
		},
		S1 = {
			kernelName: ax,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.sparseIndices,
					i = t.sparseValues,
					o = t.defaultValue,
					s = r.outputShape,
					u = cI(0, a, s),
					l = u.sliceRank,
					c = u.numUpdates,
					p = u.strides,
					h = u.outputSize,
					f = new a1(c, l, a.shape.length, i.shape.length, p, [h, 1], !1),
					d = n.runWebGLProgram(f, [i, a, o], i.dtype),
					m = QY({ inputs: { x: d }, backend: n, attrs: { shape: s } });
				return n.disposeIntermediateTensorInfo(d), m;
			},
		},
		T1 = {
			kernelName: Qb,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = t.x,
					i = r.numOrSizeSplits,
					o = jg(r.axis, a.shape)[0],
					s = e_(a, i, o),
					u = a.shape.length,
					l = new Array(u).fill(0),
					c = a.shape.slice();
				return s.map(function (e) {
					var t = [].concat(c);
					t[o] = e;
					var r = aZ({ inputs: { x: a }, backend: n, attrs: { begin: l, size: t } });
					return (l[o] += e), r;
				});
			},
		},
		C1 = "return sqrt(x);",
		E1 = jY({ opSnippet: C1, packedOpSnippet: C1, cpuKernelImpl: iY }),
		R1 = { kernelName: Yb, backendName: "webgl", kernelFunc: E1 },
		A1 = { kernelName: ox, backendName: "webgl", kernelFunc: jY({ opSnippet: "return x * x;" }) },
		_1 = "return (a - b) * (a - b);",
		F1 = HY({ opSnippet: _1, packedOpSnippet: _1 }),
		D1 = { kernelName: ix, backendName: "webgl", kernelFunc: F1 },
		O1 = {
			kernelName: kx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.attrs,
					r = e.backend,
					a = t.x,
					i = "if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(" + n.alpha + ");\n  ",
					o = new NY(a.shape, i);
				return r.runWebGLProgram(o, [a], a.dtype);
			},
		},
		M1 = function (e, t, n) {
			(this.variableNames = ["x"]), (this.outputShape = n);
			var r = n.length,
				a = sX(n.length),
				i = sX(n.length),
				o = "";
			if (1 === r) o = "coords * strides + begin";
			else {
				var s = 0;
				o = n
					.map(function (e, t) {
						return (
							s++,
							1 === n.length
								? "coords * strides[" + t + "] + begin[" + t + "]"
								: "coords[" + (s - 1) + "] * strides[" + t + "] + begin[" + t + "]"
						);
					})
					.join(",");
			}
			this.userCode =
				"\n      " +
				a +
				" begin = " +
				a +
				"(" +
				e +
				");\n      " +
				a +
				" strides = " +
				a +
				"(" +
				t +
				");\n\n      void main() {\n        " +
				i +
				" coords = getOutputCoords();\n        setOutput(getX(" +
				o +
				"));\n      }\n    ";
		},
		L1 = {
			kernelName: sx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t,
					n = e.inputs,
					r = e.backend,
					a = e.attrs,
					i = n.x,
					o = a.begin,
					s = a.end,
					u = a.strides,
					l = a.beginMask,
					c = a.endMask,
					p = a.ellipsisMask,
					h = a.newAxisMask,
					f = a.shrinkAxisMask,
					d = SI(i.shape, o, s, u, l, c, p, h, f),
					m = d.finalShapeSparse,
					g = d.finalShape,
					v = d.isIdentity,
					y = d.sliceDim0,
					b = d.isSimpleSlice,
					x = d.begin,
					w = d.end,
					k = d.strides;
				if (v) t = QY({ inputs: { x: i }, backend: r, attrs: { shape: g } });
				else if (y || b) {
					Dg(i.shape.length >= 1, function () {
						return "Input must have rank at least 1, got: " + i.shape.length;
					});
					var N = fI(x, w, k),
						I = aZ({ inputs: { x: i }, backend: r, attrs: { begin: x, size: N } });
					(t = QY({ inputs: { x: I }, backend: r, attrs: { shape: g } })), r.disposeIntermediateTensorInfo(I);
				} else if (r.shouldExecuteOnCPU([i])) {
					var S = r.readSync(i.dataId),
						T = kN(i.shape, i.dtype, S),
						C = oY(m, T, k, x);
					t = r.makeTensorInfo(g, i.dtype, C.values);
				} else {
					var E = new M1(x, k, m);
					t = r.runWebGLProgram(E, [i], i.dtype);
				}
				var R = QY({ inputs: { x: t }, backend: r, attrs: { shape: g } });
				return r.disposeIntermediateTensorInfo(t), R;
			},
		},
		z1 = {
			kernelName: ux,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs,
					a = r.separator,
					i = r.nGramWidths,
					o = r.leftPad,
					s = r.rightPad,
					u = r.padWidth,
					l = r.preserveShortSequences,
					c = t.data,
					p = t.dataSplits,
					h = n.readSync(c.dataId),
					f = n.readSync(p.dataId),
					d = sY(h, f, a, i, o, s, u, l),
					m = d[0],
					g = d[1];
				return [n.makeTensorInfo([m.length], "string", m), n.makeTensorInfo(p.shape, "int32", g)];
			},
		},
		P1 = {
			kernelName: lx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs.skipEmpty,
					a = t.input,
					i = t.delimiter;
				if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
				if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: " + a.shape);
				if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: " + i.shape);
				var o = n.readSync(a.dataId),
					s = n.readSync(i.dataId)[0],
					u = uY(o, s, r),
					l = u[0],
					c = u[1],
					p = u[2],
					h = c.length;
				return [
					n.makeTensorInfo([h, 2], "int32", l),
					n.makeTensorInfo([h], "string", c),
					n.makeTensorInfo([2], "int32", new Int32Array(p)),
				];
			},
		},
		B1 = {
			kernelName: cx,
			backendName: "webgl",
			kernelFunc: function (e) {
				var t = e.inputs,
					n = e.backend,
					r = e.attrs.numBuckets,
					a = t.input;
				if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
				if (r <= 0) throw new Error("Number of buckets must be at least 1");
				var i = n.readSync(a.dataId),
					o = lY(i, r);
				return n.makeTensorInfo(a.shape, "int32", o);
			},
		},
		W1 = jY({ opSnippet: "return tan(x);" }),
		U1 = { kernelName: hx, backendName: "webgl", kernelFunc: W1 },
		V1 = jY({ opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n" }),
		G1 = function (e, t) {
			this.variableNames = ["A"];
			for (var n = new Array(e.length), r = 0; r < n.length; r++) n[r] = e[r] * t[r];
			(this.outputShape = n), (this.rank = n.length);
			var a = sX(this.rank),
				i = (function (e) {
					var t = e.length;
					if (t > 5) throw Error("Tile for rank " + t + " is not yet supported");
					if (1 === t) return "imod(resRC, " + e[0] + ")";
					for (
						var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r = [], a = 0;
						a < e.length;
						a++
					)
						r.push("imod(" + n[a] + ", " + e[a] + ")");
					return r.join();
				})(e);
			this.userCode =
				"\n      void main() {\n        " +
				a +
				" resRC = getOutputCoords();\n        setOutput(getA(" +
				i +
				"));\n      }\n    ";
		};
	function j1(e) {
		var t = e.inputs,
			n = e.backend,
			r = e.attrs,
			a = t.x,
			i = r.reps;
		if ("string" === a.dtype || a.shape.length > 5) {
			var o = n.readSync(a.dataId),
				s =
					"string" === a.dtype
						? o.map(function (e) {
								return Tw(e);
						  })
						: o,
				u = kN(a.shape, a.dtype, s),
				l = pY(u, i);
			return n.makeTensorInfo(l.shape, l.dtype, l.values);
		}
		var c = new G1(a.shape, i);
		return n.runWebGLProgram(c, [a], a.dtype);
	}
	var H1 = function (e) {
			(this.variableNames = ["x", "indices"]),
				(this.customUniforms = [
					{ name: "n", type: "int" },
					{ name: "firstPass", type: "int" },
					{ name: "negativeInf", type: "float" },
					{ name: "dir", type: "int" },
					{ name: "inc", type: "int" },
				]),
				(this.outputShape = e),
				(this.userCode =
					"\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     ");
		},
		q1 = function (e) {
			(this.variableNames = ["x", "indices"]),
				(this.customUniforms = [
					{ name: "n", type: "int" },
					{ name: "firstPass", type: "int" },
					{ name: "k", type: "int" },
				]),
				(this.outputShape = e),
				(this.userCode =
					"\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     ");
		};
	function K1(e, t) {
		null !== t && e.disposeIntermediateTensorInfo(t);
	}
	function X1(e) {
		for (var t = 1; t < e; ) t *= 2;
		return t;
	}
	for (
		var Y1 = function (e, t, n, r, a, i) {
				(this.variableNames = ["Image", "Transforms"]), (this.outputShape = i);
				var o,
					s = "nearest" === n ? 1 : 2;
				switch (r) {
					case "constant":
					default:
						o = 1;
						break;
					case "reflect":
						o = 2;
						break;
					case "wrap":
						o = 3;
						break;
					case "nearest":
						o = 4;
				}
				this.userCode =
					"\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(" +
					o +
					" == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (" +
					o +
					" == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (" +
					o +
					" == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < " +
					e +
					" && 0 <= coordX && coordX < " +
					t +
					") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(" +
					a +
					");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(" +
					a +
					");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(" +
					t +
					"));\n                float mapY = mapCoord(inY, float(" +
					e +
					"));\n\n                if (" +
					s +
					" == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ";
			},
			J1 = function (e, t) {
				this.variableNames = ["x", "segmentIds"];
				var n = e.windowSize,
					r = e.batchSize,
					a = e.inSize,
					i = e.numSegments,
					o = i * Math.ceil(a / n);
				this.outputShape = [r, o];
				var s = 4 * Math.floor(n / 4),
					u = n % 4,
					l = "\n        sumValue += dot(values, segFilter);\n    ",
					c = "";
				a % n > 0 &&
					(c =
						"\n        if (inIdx < 0 || inIdx >= " +
						a +
						") {\n          return initializationValue;\n        }\n      ");
				var p = "";
				a % n > 0 &&
					(p = "\n        if (inIdx < 0 || inIdx >= " + a + ") {\n          return -1.0;\n        }\n      "),
					(this.userCode =
						"\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " +
						c +
						"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " +
						p +
						"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " +
						i +
						")) * float(" +
						n +
						"));\n        int currentSeg = int(mod(float(outIdx), float(" +
						i +
						")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " +
						s +
						"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " +
						l +
						"\n        }\n\n        int inIdx = inOffset + " +
						s +
						";\n        if (" +
						(1 === u) +
						") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " +
						l +
						"\n        } else if (" +
						(2 === u) +
						") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " +
						l +
						"\n        } else if (" +
						(3 === u) +
						") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " +
						l +
						"\n        }\n        setOutput(sumValue);\n      }\n    ");
			},
			Z1 = 0,
			Q1 = [
				pJ,
				fJ,
				mJ,
				vJ,
				xJ,
				NJ,
				IJ,
				SJ,
				_J,
				FJ,
				OJ,
				LJ,
				PJ,
				WJ,
				VJ,
				HJ,
				qJ,
				YJ,
				JJ,
				ZJ,
				eZ,
				oZ,
				sZ,
				uZ,
				fZ,
				gZ,
				bZ,
				zY,
				kZ,
				AZ,
				LZ,
				UZ,
				VZ,
				GZ,
				jZ,
				HZ,
				KZ,
				YZ,
				ZZ,
				tQ,
				iQ,
				oQ,
				uQ,
				pQ,
				dQ,
				mQ,
				vQ,
				bQ,
				xQ,
				kQ,
				NQ,
				SQ,
				CQ,
				RQ,
				_Q,
				OQ,
				zQ,
				UQ,
				GQ,
				qQ,
				XQ,
				ZQ,
				QQ,
				$Q,
				t$,
				a$,
				o$,
				u$,
				MY,
				l$,
				CZ,
				p$,
				f$,
				m$,
				WY,
				v$,
				b$,
				x$,
				k$,
				I$,
				T$,
				E$,
				A$,
				D$,
				M$,
				z$,
				B$,
				W$,
				U$,
				j$,
				H$,
				q$,
				K$,
				X$,
				J$,
				$$,
				t0,
				c0,
				ZY,
				p0,
				f0,
				m0,
				v0,
				cZ,
				b0,
				k0,
				N0,
				C0,
				R0,
				GY,
				A0,
				F0,
				hZ,
				a0,
				O0,
				L0,
				P0,
				$Y,
				U0,
				G0,
				q0,
				X0,
				Z0,
				$0,
				t1,
				r1,
				i1,
				s1,
				l1,
				p1,
				f1,
				m1,
				v1,
				iZ,
				l0,
				b1,
				x1,
				w1,
				k1,
				N1,
				I1,
				S1,
				T1,
				R1,
				A1,
				D1,
				O1,
				L1,
				z1,
				P1,
				B1,
				s0,
				sJ,
				U1,
				{ kernelName: fx, backendName: "webgl", kernelFunc: V1 },
				{ kernelName: dx, backendName: "webgl", kernelFunc: j1 },
				{
					kernelName: mx,
					backendName: "webgl",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.backend,
							r = e.attrs,
							a = t.x,
							i = r.k,
							o = r.sorted,
							s = xv().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),
							u = xv().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),
							l = a.shape,
							c = l[l.length - 1];
						if (n.shouldExecuteOnCPU([a]) || c < s || i > u) {
							var p = n.readSync(a.dataId),
								h = hY(p, l, a.dtype, i, o),
								f = h[0],
								d = h[1];
							return [
								n.makeTensorInfo(f.shape, f.dtype, f.values),
								n.makeTensorInfo(d.shape, d.dtype, d.values),
							];
						}
						if (0 === i)
							return (
								(l[l.length - 1] = 0),
								[n.makeTensorInfo(l, a.dtype, []), n.makeTensorInfo(l, "int32", [])]
							);
						if (1 === c) return [a, BQ({ attrs: { shape: l, dtype: "int32", value: 0 }, backend: n })];
						var m = n.texData.get(a.dataId),
							g = null !== m && m.isPacked,
							v = g ? n.unpackTensor(a) : a,
							y = zg(l) / c,
							b = QY({ inputs: { x: v }, attrs: { shape: [y, c] }, backend: n });
						g && K1(n, v);
						for (
							var x = X1(i),
								w = X1(c),
								k = null,
								N = function () {
									return null === k ? [b, b] : [b, k];
								},
								I = function (e, t, r) {
									var a = N(),
										i = new H1(r),
										o = [[c], [null === k ? 1 : 0], [Number.NEGATIVE_INFINITY], [e], [t]],
										s = k;
									(k = n.runWebGLProgram(i, a, "int32", o)), K1(n, s);
								},
								S = 1;
							S < x;
							S *= 2
						)
							for (var T = 2 * S, C = S; C >= 1; C /= 2) I(T, C, [y, w]);
						for (var E = w; E > x; E /= 2) {
							var R = N(),
								A = new q1([y, E / 2]),
								_ = [[c], [null === k ? 1 : 0], [x]],
								F = k;
							(k = n.runWebGLProgram(A, R, "int32", _)), K1(n, F);
							for (var D = x / 2, O = 2 * D, M = D; M >= 1; M /= 2) I(O, M, k.shape);
						}
						var L = k;
						(k = aZ({ inputs: { x: k }, backend: n, attrs: { begin: 0, size: [y, i] } })), K1(n, L);
						var z = r$({ inputs: { x: b, indices: k }, backend: n, attrs: { axis: 1, batchDims: 1 } });
						K1(n, b);
						var P = l.slice(0, -1);
						P.push(i), (L = k), (k = QY({ inputs: { x: k }, attrs: { shape: P }, backend: n })), K1(n, L);
						var B = z;
						return (z = QY({ inputs: { x: z }, attrs: { shape: P }, backend: n })), K1(n, B), [z, k];
					},
				},
				{
					kernelName: gx,
					backendName: "webgl",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.backend,
							r = e.attrs,
							a = t.image,
							i = t.transforms,
							o = r.interpolation,
							s = r.fillMode,
							u = r.fillValue,
							l = r.outputShape,
							c = a.shape,
							p = c[0],
							h = c[1],
							f = c[2],
							d = c[3],
							m = null != l ? l : [h, f],
							g = m[0],
							v = m[1],
							y = new Y1(h, f, o, s, u, [p, g, v, d]);
						return n.runWebGLProgram(y, [a, i], "float32");
					},
				},
				lJ,
				{
					kernelName: yx,
					backendName: "webgl",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.attrs,
							r = e.backend,
							a = n.axis,
							i = t.x;
						jK(i, "unique"),
							console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
						var o = r.readSync(i.dataId),
							s = dY(o, a, i.shape, i.dtype),
							u = s.outputValues,
							l = s.outputShape,
							c = s.indices;
						return [r.makeTensorInfo(l, i.dtype, u), r.makeTensorInfo([c.length], "int32", c)];
					},
				},
				{
					kernelName: bx,
					backendName: "webgl",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.backend,
							r = e.attrs,
							a = t.value,
							i = r.axis;
						i < 0 && (i += a.shape.length);
						for (
							var o = a, s = o.shape.length, u = a.shape[i], l = new Array(s - 1), c = 0, p = 0;
							p < s;
							p++
						)
							p !== i && (l[c++] = o.shape[p]);
						var h = [],
							f = new Array(s).fill(0),
							d = o.shape.slice();
						d[i] = 1;
						for (var m = new Array(u), g = 0; g < m.length; g++) {
							f[i] = g;
							var v = aZ({ inputs: { x: o }, backend: n, attrs: { begin: f, size: d } }),
								y = QY({ inputs: { x: v }, backend: n, attrs: { shape: l } });
							(m[g] = y), h.push(v);
						}
						return (
							h.forEach(function (e) {
								return n.disposeIntermediateTensorInfo(e);
							}),
							m
						);
					},
				},
				{
					kernelName: xx,
					backendName: "webgl",
					kernelFunc: function (e) {
						var t = e.inputs,
							n = e.backend,
							r = e.attrs,
							a = t.x,
							i = t.segmentIds,
							o = r.numSegments,
							s = a.shape.length,
							u = [],
							l = 0,
							c = YT([l], s),
							p = a;
						null != c &&
							((p = uJ({ inputs: { x: a }, backend: n, attrs: { perm: c } })),
							u.push(p),
							(l = ZT(1, s)[0]));
						var h = p_(p.shape, l, o),
							f = zg([p.shape[l]]),
							d = QY({ inputs: { x: p }, backend: n, attrs: { shape: [-1, f] } });
						u.push(d);
						var m = QY({
								inputs: {
									x: (function e(t, r, a, i, o) {
										var s = t.shape[0],
											l = t.shape[1],
											c = c_(l, o),
											p = new J1({ windowSize: c, inSize: l, batchSize: s, numSegments: o }, r),
											h = n.compileAndRun(p, [t, a], i);
										if ((u.push(h), h.shape[1] === o)) return h;
										var f = _0({
												backend: n,
												attrs: { start: 0, stop: o, step: 1, dtype: "float32" },
											}),
											d = j1({ inputs: { x: f }, backend: n, attrs: { reps: [l / c] } });
										return u.push(f), u.push(d), e(h, r, d, i, o);
									})(d, "unsortedSegmentSum", i, Xw(a.dtype), o),
								},
								backend: n,
								attrs: { shape: h },
							}),
							g = m;
						if (null != c) {
							u.push(m);
							var v = JT(c);
							g = uJ({ inputs: { x: g }, backend: n, attrs: { perm: v } });
						}
						return (
							u.forEach(function (e) {
								return n.disposeIntermediateTensorInfo(e);
							}),
							g
						);
					},
				},
				w0,
			];
		Z1 < Q1.length;
		Z1++
	)
		Ox(Q1[Z1]);
	var $1 = {
		"tfjs-core": LI,
		"tfjs-backend-cpu": "3.15.0",
		"tfjs-backend-webgl": "3.15.0",
		"tfjs-data": mU,
		"tfjs-layers": CM,
		"tfjs-converter": oW,
		tfjs: "3.15.0",
	};
	(e.Abs = Nv),
		(e.Acos = Iv),
		(e.Acosh = Sv),
		(e.AdadeltaOptimizer = vA),
		(e.AdagradOptimizer = yA),
		(e.AdamOptimizer = bA),
		(e.AdamaxOptimizer = xA),
		(e.Add = Tv),
		(e.AddN = Cv),
		(e.All = Ev),
		(e.Any = Rv),
		(e.ArgMax = Av),
		(e.ArgMin = _v),
		(e.Asin = Fv),
		(e.Asinh = Dv),
		(e.Atan = Ov),
		(e.Atan2 = Lv),
		(e.Atanh = Mv),
		(e.AvgPool = zv),
		(e.AvgPool3D = Bv),
		(e.AvgPool3DGrad = Wv),
		(e.AvgPoolGrad = Pv),
		(e.BatchMatMul = Uv),
		(e.BatchToSpaceND = Vv),
		(e.Bincount = Gv),
		(e.BroadcastArgs = Hv),
		(e.BroadcastTo = jv),
		(e.Callback = _P),
		(e.CallbackList = jO),
		(e.Cast = qv),
		(e.Ceil = Kv),
		(e.ClipByValue = Xv),
		(e.Complex = Yv),
		(e.ComplexAbs = Jv),
		(e.Concat = Zv),
		(e.Conv2D = Qv),
		(e.Conv2DBackpropFilter = $v),
		(e.Conv2DBackpropInput = ey),
		(e.Conv3D = ty),
		(e.Conv3DBackpropFilterV2 = ny),
		(e.Conv3DBackpropInputV2 = ry),
		(e.Cos = ay),
		(e.Cosh = iy),
		(e.CropAndResize = uy),
		(e.Cumprod = oy),
		(e.Cumsum = sy),
		(e.CustomCallback = KO),
		(e.DataStorage = Sg),
		(e.DenseBincount = ly),
		(e.DepthToSpace = cy),
		(e.DepthwiseConv2dNative = py),
		(e.DepthwiseConv2dNativeBackpropFilter = hy),
		(e.DepthwiseConv2dNativeBackpropInput = fy),
		(e.Diag = dy),
		(e.Dilation2D = my),
		(e.Dilation2DBackpropFilter = vy),
		(e.Dilation2DBackpropInput = gy),
		(e.EarlyStopping = LP),
		(e.Einsum = by),
		(e.Elu = xy),
		(e.EluGrad = wy),
		(e.Environment = vv),
		(e.Equal = Ny),
		(e.Erf = ky),
		(e.Exp = Iy),
		(e.ExpandDims = Sy),
		(e.Expm1 = Ty),
		(e.FFT = Cy),
		(e.Fill = Ey),
		(e.FlipLeftRight = Ry),
		(e.Floor = Ay),
		(e.FloorDiv = _y),
		(e.FromPixels = Nx),
		(e.FusedBatchNorm = Fy),
		(e.FusedConv2D = Tx),
		(e.FusedDepthwiseConv2D = Cx),
		(e.GatherNd = Oy),
		(e.GatherV2 = Dy),
		(e.GraphModel = aW),
		(e.Greater = My),
		(e.GreaterEqual = Ly),
		(e.History = qO),
		(e.IFFT = Py),
		(e.Identity = zy),
		(e.Imag = By),
		(e.InputSpec = AO),
		(e.IsFinite = Wy),
		(e.IsInf = Uy),
		(e.IsNan = Vy),
		(e.KernelBackend = Tg),
		(e.LRN = $y),
		(e.LRNGrad = eb),
		(e.LayerVariable = CO),
		(e.LayersModel = lL),
		(e.LeakyRelu = Gy),
		(e.Less = jy),
		(e.LessEqual = Hy),
		(e.LinSpace = qy),
		(e.Log = Ky),
		(e.Log1p = Xy),
		(e.LogSoftmax = Qy),
		(e.LogicalAnd = Yy),
		(e.LogicalNot = Jy),
		(e.LogicalOr = Zy),
		(e.Max = tb),
		(e.MaxPool = rb),
		(e.MaxPool3D = ib),
		(e.MaxPool3DGrad = ob),
		(e.MaxPoolGrad = ab),
		(e.MaxPoolWithArgmax = sb),
		(e.Maximum = nb),
		(e.Mean = ub),
		(e.Min = lb),
		(e.Minimum = cb),
		(e.MirrorPad = pb),
		(e.Mod = hb),
		(e.MomentumOptimizer = kA),
		(e.Multinomial = fb),
		(e.Multiply = db),
		(e.Neg = mb),
		(e.NonMaxSuppressionV3 = vb),
		(e.NonMaxSuppressionV4 = yb),
		(e.NonMaxSuppressionV5 = bb),
		(e.NotEqual = gb),
		(e.OP_SCOPE_SUFFIX = vk),
		(e.OneHot = wb),
		(e.OnesLike = xb),
		(e.Optimizer = gA),
		(e.OptimizerConstructors = IA),
		(e.Pack = kb),
		(e.PadV2 = Nb),
		(e.Pool = "Pool"),
		(e.Pow = Ib),
		(e.Prelu = Sb),
		(e.Prod = Tb),
		(e.RMSPropOptimizer = NA),
		(e.RNN = mz),
		(e.Range = Cb),
		(e.Real = Eb),
		(e.RealDiv = yy),
		(e.Reciprocal = Rb),
		(e.Relu = Ab),
		(e.Relu6 = Lb),
		(e.Reshape = _b),
		(e.ResizeBilinear = Ob),
		(e.ResizeBilinearGrad = Mb),
		(e.ResizeNearestNeighbor = Fb),
		(e.ResizeNearestNeighborGrad = Db),
		(e.Reverse = zb),
		(e.RotateWithOffset = Ix),
		(e.Round = Pb),
		(e.Rsqrt = Bb),
		(e.SGDOptimizer = wA),
		(e.ScatterNd = Wb),
		(e.Select = Ub),
		(e.Selu = Vb),
		(e.Sequential = gL),
		(e.Sigmoid = Kb),
		(e.Sign = qb),
		(e.Sin = jb),
		(e.Sinh = Hb),
		(e.Slice = Gb),
		(e.Softmax = $b),
		(e.Softplus = Xb),
		(e.SpaceToBatchND = Zb),
		(e.SparseFillEmptyRows = ex),
		(e.SparseReshape = tx),
		(e.SparseSegmentMean = nx),
		(e.SparseSegmentSum = rx),
		(e.SparseToDense = ax),
		(e.SplitV = Qb),
		(e.Sqrt = Yb),
		(e.Square = ox),
		(e.SquaredDifference = ix),
		(e.Step = kx),
		(e.StridedSlice = sx),
		(e.StringNGrams = ux),
		(e.StringSplit = lx),
		(e.StringToHashBucketFast = cx),
		(e.Sub = px),
		(e.Sum = Jb),
		(e.SymbolicTensor = _O),
		(e.Tan = hx),
		(e.Tanh = fx),
		(e.Tensor = Pw),
		(e.TensorBuffer = Mw),
		(e.Tile = dx),
		(e.TopK = mx),
		(e.Transform = gx),
		(e.Transpose = vx),
		(e.Unique = yx),
		(e.Unpack = bx),
		(e.UnsortedSegmentSum = xx),
		(e.Variable = Hw),
		(e.ZerosLike = wx),
		(e._FusedMatMul = Sx),
		(e.abs = XI),
		(e.acos = YI),
		(e.acosh = JI),
		(e.add = jI),
		(e.addN = ZI),
		(e.all = QI),
		(e.any = $I),
		(e.argMax = eS),
		(e.argMin = tS),
		(e.asin = nS),
		(e.asinh = rS),
		(e.atan = aS),
		(e.atan2 = iS),
		(e.atanh = oS),
		(e.avgPool = kS),
		(e.avgPool3d = NS),
		(e.backend = GI),
		(e.backend_util = m_),
		(e.basicLSTMCell = ES),
		(e.batchNorm = AS),
		(e.batchNorm2d = _S),
		(e.batchNorm3d = FS),
		(e.batchNorm4d = DS),
		(e.batchToSpaceND = RS),
		(e.bincount = OS),
		(e.booleanMaskAsync = HE),
		(e.broadcastArgs = MS),
		(e.broadcastTo = LS),
		(e.broadcast_util = QN),
		(e.browser = iI),
		(e.buffer = kN),
		(e.callbacks = zP),
		(e.cast = NN),
		(e.ceil = zS),
		(e.clipByValue = PS),
		(e.clone = IN),
		(e.complex = bk),
		(e.concat = IS),
		(e.concat1d = BS),
		(e.concat2d = WS),
		(e.concat3d = US),
		(e.concat4d = VS),
		(e.constraints = hD),
		(e.conv1d = jS),
		(e.conv2d = GS),
		(e.conv2dTranspose = qS),
		(e.conv3d = KS),
		(e.conv3dTranspose = YS),
		(e.copyRegisteredKernels = function (e, t) {
			Dx(e).forEach(function (e) {
				Ox(Object.assign({}, e, { backendName: t }));
			});
		}),
		(e.cos = JS),
		(e.cosh = ZS),
		(e.cosineWindow = eR),
		(e.cumprod = QS),
		(e.cumsum = $S),
		(e.customGrad = MT),
		(e.data = gU),
		(e.denseBincount = eT),
		(e.deprecationWarn = function (e) {
			xv().getBool("DEPRECATION_WARNINGS_ENABLED") &&
				console.warn(e + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
		}),
		(e.depthToSpace = tT),
		(e.depthwiseConv2d = nT),
		(e.deregisterOp = function (e) {
			delete PP[e];
		}),
		(e.device_util = ck),
		(e.diag = rT),
		(e.dilation2d = aT),
		(e.disableDeprecationWarnings = function () {
			xv().set("DEPRECATION_WARNINGS_ENABLED", !1),
				console.warn("TensorFlow.js deprecation warnings have been disabled.");
		}),
		(e.dispose = WI),
		(e.disposeVariables = function () {
			ok.disposeVariables();
		}),
		(e.div = qI),
		(e.divNoNan = uT),
		(e.dot = lT),
		(e.dropout = QE),
		(e.einsum = cT),
		(e.elu = pT),
		(e.enableDebugMode = function () {
			xv().set("DEBUG", !0);
		}),
		(e.enableProdMode = function () {
			xv().set("PROD", !0);
		}),
		(e.enclosingPowerOfTwo = $E),
		(e.engine = zI),
		(e.env = xv),
		(e.equal = iT),
		(e.erf = hT),
		(e.exp = fT),
		(e.expandDims = dT),
		(e.expm1 = mT),
		(e.eye = vT),
		(e.fft = yE),
		(e.fill = yT),
		(e.findBackend = function (e) {
			return ok.findBackend(e);
		}),
		(e.findBackendFactory = function (e) {
			return ok.findBackendFactory(e);
		}),
		(e.floor = bT),
		(e.floorDiv = HI),
		(e.fused = fR),
		(e.gather = xT),
		(e.gatherND = ZE),
		(e.gather_util = sI),
		(e.getBackend = function () {
			return ok.backendName;
		}),
		(e.getGradient = Fx),
		(e.getKernel = _x),
		(e.getKernelsForBackend = Dx),
		(e.grad = function (e) {
			return (
				Dg(av(e), function () {
					return "The f passed in grad(f) must be a function";
				}),
				function (t, n) {
					var r = mk(t, "x", "tf.grad", "string_or_numeric"),
						a = null != n ? mk(n, "dy", "tf.grad") : null;
					return ok.tidy(function () {
						var t = ok.gradients(
								function () {
									return e(r);
								},
								[r],
								a
							),
							n = t.value,
							i = t.grads;
						return (
							null != a &&
								Og(
									n.shape,
									a.shape,
									"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"
								),
							LT(i),
							i[0]
						);
					});
				}
			);
		}),
		(e.grads = function (e) {
			return (
				Dg(av(e), function () {
					return "The f passed in grads(f) must be a function";
				}),
				function (t, n) {
					Dg(Array.isArray(t), function () {
						return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
					});
					var r = gk(t, "args", "tf.grads", "string_or_numeric"),
						a = null != n ? mk(n, "dy", "tf.grads") : null;
					return ok.tidy(function () {
						var t = ok.gradients(
								function () {
									return e.apply(void 0, r);
								},
								r,
								a
							),
							n = t.value,
							i = t.grads;
						return (
							null != a &&
								Og(
									n.shape,
									a.shape,
									"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"
								),
							LT(i),
							i
						);
					});
				}
			);
		}),
		(e.greater = wT),
		(e.greaterEqual = kT),
		(e.ifft = bE),
		(e.imag = NT),
		(e.image = pA),
		(e.inTopKAsync = nR),
		(e.initializers = gO),
		(e.input = vL),
		(e.io = GN),
		(e.irfft = xE),
		(e.isFinite = IT),
		(e.isInf = ST),
		(e.isNaN = TT),
		(e.keep = UI),
		(e.kernel_impls = g_),
		(e.layers = CP),
		(e.leakyRelu = CT),
		(e.less = ET),
		(e.lessEqual = RT),
		(e.linalg = hA),
		(e.linspace = AT),
		(e.loadGraphModel = function (e, t) {
			return iW.apply(this, arguments);
		}),
		(e.loadLayersModel = function (e, t) {
			return (
				null == t && (t = {}),
				(function (e, t) {
					return hL.apply(this, arguments);
				})(e, t)
			);
		}),
		(e.localResponseNormalization = _T),
		(e.log = FT),
		(e.log1p = DT),
		(e.logSigmoid = BT),
		(e.logSoftmax = GT),
		(e.logSumExp = QT),
		(e.logicalAnd = $T),
		(e.logicalNot = eC),
		(e.logicalOr = tC),
		(e.logicalXor = nC),
		(e.losses = fA),
		(e.matMul = jN),
		(e.math = KN),
		(e.max = WT),
		(e.maxPool = rC),
		(e.maxPool3d = aC),
		(e.maxPoolWithArgmax = iC),
		(e.maximum = oC),
		(e.mean = sC),
		(e.memory = PI),
		(e.meshgrid = cC),
		(e.metrics = EP),
		(e.min = pC),
		(e.minimum = hC),
		(e.mirrorPad = fC),
		(e.mod = dC),
		(e.model = function (e) {
			return new lL(e);
		}),
		(e.models = RP),
		(e.moments = gC),
		(e.movingAverage = XE),
		(e.mul = KI),
		(e.multiRNNCell = vC),
		(e.multinomial = yC),
		(e.neg = zT),
		(e.nextFrame = CA),
		(e.norm = KE),
		(e.notEqual = bC),
		(e.oneHot = HN),
		(e.ones = lC),
		(e.onesLike = xC),
		(e.op = yk),
		(e.outerProduct = wC),
		(e.pad = kC),
		(e.pad1d = NC),
		(e.pad2d = IC),
		(e.pad3d = SC),
		(e.pad4d = TC),
		(e.pool = EC),
		(e.pow = RC),
		(e.prelu = AC),
		(e.print = SN),
		(e.prod = _C),
		(e.profile = function (e) {
			return ok.profile(e);
		}),
		(e.rand = FC),
		(e.randomGamma = jC),
		(e.randomNormal = HC),
		(e.randomUniform = qC),
		(e.range = KC),
		(e.ready = function () {
			return ok.ready();
		}),
		(e.real = XC),
		(e.reciprocal = YC),
		(e.registerBackend = VI),
		(e.registerCallbackConstructor = function (e, t) {
			YO.registerCallbackConstructor(e, t);
		}),
		(e.registerGradient = Mx),
		(e.registerKernel = Ox),
		(e.registerOp = function (e, t) {
			var n = { tfOpName: e, category: "custom", inputs: [], attrs: [], customExecutor: t };
			PP[e] = n;
		}),
		(e.regularizers = AP),
		(e.relu = JC),
		(e.relu6 = ZC),
		(e.removeBackend = function (e) {
			ok.removeBackend(e);
		}),
		(e.reshape = wS),
		(e.reverse = QC),
		(e.reverse1d = $C),
		(e.reverse2d = eE),
		(e.reverse3d = tE),
		(e.reverse4d = nE),
		(e.rfft = kE),
		(e.round = rE),
		(e.rsqrt = aE),
		(e.scalar = iE),
		(e.scatterND = YE),
		(e.scatter_util = pI),
		(e.selu = oE),
		(e.separableConv2d = sE),
		(e.sequential = function (e) {
			return new gL(e);
		}),
		(e.serialization = _I),
		(e.setBackend = function (e) {
			return ok.setBackend(e);
		}),
		(e.setPlatform = function (e, t) {
			xv().setPlatform(e, t);
		}),
		(e.setdiff1dAsync = lE),
		(e.sigmoid = SS),
		(e.sign = cE),
		(e.signal = cA),
		(e.sin = pE),
		(e.sinh = hE),
		(e.slice = TS),
		(e.slice1d = fE),
		(e.slice2d = dE),
		(e.slice3d = mE),
		(e.slice4d = gE),
		(e.slice_util = CI),
		(e.softmax = vE),
		(e.softplus = PT),
		(e.spaceToBatchND = CC),
		(e.sparse = dA),
		(e.sparseToDense = JE),
		(e.spectral = lA),
		(e.split = wE),
		(e.sqrt = NE),
		(e.square = mC),
		(e.squaredDifference = IE),
		(e.squeeze = SE),
		(e.stack = TE),
		(e.step = CE),
		(e.stridedSlice = EE),
		(e.string = mA),
		(e.sub = UT),
		(e.sum = VT),
		(e.sumOutType = Xw),
		(e.tan = RE),
		(e.tanh = CS),
		(e.tensor = wk),
		(e.tensor1d = AE),
		(e.tensor2d = _E),
		(e.tensor3d = $N),
		(e.tensor4d = FE),
		(e.tensor5d = DE),
		(e.tensor6d = OE),
		(e.tensor_util = ek),
		(e.test_util = MI),
		(e.tidy = BI),
		(e.tile = gT),
		(e.time = function (e) {
			return ok.time(e);
		}),
		(e.topk = ME),
		(e.train = SA),
		(e.transpose = qN),
		(e.truncatedNormal = LE),
		(e.unique = zE),
		(e.unregisterGradient = function (e) {
			if (!Ax.has(e)) throw new Error("The gradient '" + e + "' for backend is not registered");
			Ax.delete(e);
		}),
		(e.unregisterKernel = function (e, t) {
			var n = Lx(e, t);
			if (!Rx.has(n)) throw new Error("The kernel '" + e + "' for backend '" + t + "' is not registered");
			Rx.delete(n);
		}),
		(e.unsortedSegmentSum = PE),
		(e.unstack = BE),
		(e.upcastType = Kw),
		(e.util = Cw),
		(e.valueAndGrad = function (e) {
			return (
				Dg(av(e), function () {
					return "The f passed in valueAndGrad(f) must be a function";
				}),
				function (t, n) {
					Dg(t instanceof Pw, function () {
						return "The x passed in valueAndGrad(f)(x) must be a tensor";
					}),
						Dg(null == n || n instanceof Pw, function () {
							return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
						});
					var r = ok.gradients(
							function () {
								return e(t);
							},
							[t],
							n
						),
						a = r.grads,
						i = r.value;
					return LT(a), { grad: a[0], value: i };
				}
			);
		}),
		(e.valueAndGrads = function (e) {
			return (
				Dg(av(e), function () {
					return "The f passed in valueAndGrads(f) must be a function";
				}),
				function (t, n) {
					Dg(
						Array.isArray(t) &&
							t.every(function (e) {
								return e instanceof Pw;
							}),
						function () {
							return "The args passed in valueAndGrads(f)(args) must be array of tensors";
						}
					),
						Dg(null == n || n instanceof Pw, function () {
							return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
						});
					var r = ok.gradients(
						function () {
							return e.apply(void 0, t);
						},
						t,
						n
					);
					return (
						null != n &&
							Og(
								r.value.shape,
								n.shape,
								"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"
							),
						LT(r.grads),
						r
					);
				}
			);
		}),
		(e.variable = WE),
		(e.variableGrads = OT),
		(e.version = $1),
		(e.version_converter = oW),
		(e.version_core = LI),
		(e.version_layers = CM),
		(e.where = oT),
		(e.whereAsync = GE),
		(e.zeros = uC),
		(e.zerosLike = sT),
		Object.defineProperty(e, "__esModule", { value: !0 });
});
function sc_logError(t) {
	console.log(t);
}
function sc_rlog(t) {}
function sc_log(t) {
	var e = sc_logPrefix() + t;
	sc_rlog(e), console.log(e);
}
function sc_getConsoleLog() {
	return window.sc_consoleLog ? window.sc_consoleLog.join("\n") : "<empty js console>";
}
window.onerror = function (t, e, n) {
	sc_logError(t + " at: " + e + ":" + n);
};
var sc$classTable = {},
	sc$liveDynamicTypes = !0,
	sc$nextid = 1;
function sc_id(t) {
	return sc_hasProp(t, "sc$id") || (t.sc$id = sc$nextid++), t.sc$id;
}
function sc_hasProp(t, e) {
	return t.hasOwnProperty ? t.hasOwnProperty(e) : void 0 !== t[e];
}
function sc_newObj(t, e, n, r) {
	return sc_newInnerObj(t, e, null, n, r);
}
function sc_newInnerObj(t, e, n, r, a) {
	var s = sc_newInnerClass(t, e, n, r, a);
	return (s.$objectType = !0), s;
}
function sc_newClass(t, e, n, r) {
	return sc_newInnerClass(t, e, null, n, r);
}
function sc_newInnerClass(t, e, n, r, a) {
	function s() {}
	if (
		(sc$classTable[t] &&
			sc_log(
				"Warning: class: " +
					t +
					" already defined in another js file - May need @JSSettings to specify a shared jsModuleFile for this type."
			),
		(void 0 !== e && null != e) || (console.log("No constructor for: " + t), (e = new s())),
		(e.$typeName = t),
		(sc$classTable[t] = e),
		r &&
			(null == r.$typeName && console.log("Class: " + t + " initialized before its extends class: " + r),
			(s.prototype = r.prototype),
			(e.prototype = new s()),
			sc$liveDynamicTypes))
	) {
		var c = r.$subClasses;
		void 0 === c && (c = r.$subClasses = []), c.push(e);
	}
	if ((((i = e.prototype).$protoName = t), a)) {
		var o;
		e.$implements = a;
		for (var i = e.prototype, l = 0; l < a.length; l++) {
			var u = a[l].prototype;
			for (o in u)
				"$extends" != o &&
					"prototype" != o &&
					"constructor" != o &&
					"$protoName" != o &&
					"$outerClass" != o &&
					"_clInit" != o &&
					(i.hasOwnProperty(o) || e.hasOwnProperty(o) || (i[o] = u[o]));
		}
	}
	return (e.$extendsClass = r), null != n && (i.$outerClass = n.prototype), (i.constructor = e), i;
}
function sc_initArrayInt(t, e, n) {
	(n._class = t), (n._ndim = e);
}
function sc_initArray(t, e, n) {
	return sc_initArrayInt(t, e - 1, n), n;
}
function sc_newArray(t) {
	return sc_initArrDim(null, t, arguments, 0);
}
function sc_initArrDim(t, e, n, r) {
	var a = Math.floor(n[1 + r]),
		s = n.length - 2 - r;
	if (0 == r) {
		var c = new Array(a);
		sc_initArrayInt(e, s, c), (t = c);
		for (var o = 0; o < a; o++) t[o] = e == Number_c ? 0 : null;
	} else if (s > 0) for (var i = 0; i < a; i++) t[i] = sc_initArrDim(t, e, n, ++r);
	return t;
}
function sc_isAssignableFrom(t, e) {
	if (
		(t.hasOwnProperty("$protoName") && t.constructor && (t = t.constructor),
		e.hasOwnProperty("$protoName") && e.constructor && (e = e.constructor),
		t === jv_Object)
	)
		return !0;
	if (t === e) return !0;
	do {
		if (t.$typeName === e.$typeName) return !0;
		var n = e.$implements;
		if (n)
			for (var r = 0; r < n.length; r++) {
				if (sc_isAssignableFrom(t, n[r])) return !0;
			}
		e = e.$extendsClass;
	} while (e);
	return !1;
}
function sc_paramType(t, e) {
	return null == t || sc_instanceOf(t, e);
}
function sc_instanceOf(t, e) {
	return null != t && sc_isAssignableFrom(e, t.constructor);
}
function sc_arrayInstanceOf(t, e, n) {
	return null != t && null != t._class && t._ndim == n && sc_isAssignableFrom(e, t._class.constructor);
}
function sc_arrayParamType(t, e, n) {
	return null == t || sc_arrayInstanceOf(t, e, n);
}
function sc_instanceOfChar(t, e) {
	return null != t && t.constructor == String && 1 == t.length;
}
function sc_charParamType(t, e) {
	return null == t || sc_instanceOfChar(t, e);
}
function sc_instanceOfClass(t, e) {
	return null != t && (t.hasOwnProperty("$protoName") || t.hasOwnProperty("$typeName"));
}
function sc_clInit(t) {
	return null != t._clInit && t._clInit(), t;
}
function sc_length(t) {
	return null == t ? 0 : t.length ? t.length : t.size ? t.size() : (console.log("invalid array"), -1);
}
function sc_arrayValue(t, e) {
	return t.get ? t.get(e) : t[e];
}
function sc_addEventListener(t, e, n) {
	t.attachEvent
		? ((t["e" + e + n] = n),
		  (t[e + n] = function () {
				t["e" + e + n](window.event);
		  }),
		  t.attachEvent("on" + e, t[e + n]))
		: t.addEventListener(e, n, !1);
}
function sc_removeEventListener(t, e, n) {
	t.detachEvent ? (t.detachEvent("on" + e, t[e + n]), (t[e + n] = null)) : t.removeEventListener(e, n, !1);
}
function sc_newEventArgListener(t, e) {
	return function (n) {
		t(n, e);
	};
}
function sc_methodCallback(t, e) {
	return function () {
		var n = t;
		e.call(n);
	};
}
function sc_methodArgCallback(t, e, n) {
	return function () {
		var r = t,
			a = n;
		e.call(r, a);
	};
}
var sc_runLaterMethods = [],
	sc_clientInitMethods = [];
function sc_runRunLaterMethods() {
	for (; sc_runLaterMethods.length > 0; ) {
		var t = sc_runLaterMethods.slice(0);
		sc_runLaterMethods = [];
		for (var e = 0; e < t.length; e++) {
			var n = t[e];
			try {
				n.method.call(n.thisObj);
			} catch (t) {
				console.error("Exception: " + t + " in run later method: " + n + " stack:" + t.stack);
			}
		}
	}
	sc_runLaterScheduled = !1;
}
var sc_runLaterScheduled = !1,
	sc_evCt = 0;
function sc_addRunLaterMethod(t, e, n) {
	var r,
		a = sc_runLaterMethods.length;
	for (
		0 != a || sc_runLaterScheduled || (setTimeout(sc_runRunLaterMethods, 1), (sc_runLaterScheduled = !0)), r = 0;
		r < a && !(n > sc_runLaterMethods[r].priority);
		r++
	);
	var s = { thisObj: t, method: e, priority: n, id: sc_evCt++ };
	return r == a ? sc_runLaterMethods.push(s) : sc_runLaterMethods.splice(r, 0, s), s;
}
function sc_removeRunLaterMethod(t) {
	for (var e = 0; e < sc_runLaterMethods.length; e++)
		if (sc_runLaterMethods[e].id === t.id) return sc_runLaterMethods.splice(e, 1), !0;
	return !1;
}
function sc_hasPendingJobs() {
	return sc_runLaterMethods.length > 0;
}
function sc_addScheduledJob(t, e, n, r) {
	return (r ? setInterval : setTimeout)(sc_methodCallback(t, e), n);
}
function sc_cancelScheduledJob(t, e) {
	e ? clearInterval(t) : clearTimeout(t);
}
function sc_addLoadMethodListener(t, e) {
	"complete" === document.readyState
		? (console.log("readyState already at complete for addLoadMethodListener"), sc_addScheduledJob(t, e, 1))
		: document.addEventListener
		? window.addEventListener("load", sc_methodCallback(t, e), !1)
		: window.attachEvent("onload", sc_methodCallback(t, e));
}
function sc_addClientInitJob(t, e) {
	sc_clientInitMethods.push({ thisObj: t, method: e });
}
function sc_runClientInitJobs() {
	for (; sc_clientInitMethods.length > 0; ) {
		var t = sc_clientInitMethods.slice(0);
		sc_clientInitMethods = [];
		for (var e = 0; e < t.length; e++) {
			var n = t[e];
			try {
				n.method.call(n.thisObj);
			} catch (t) {
				console.error("Exception: " + t + " in client init method: " + n + " stack:" + t.stack);
			}
		}
	}
}
function sc_vararg(t, e) {
	if (e >= t.length) return [];
	var n = t[e];
	return e != t.length - 1 || (null !== n && n.constructor !== Array) ? Array.prototype.slice.call(t, e) : n;
}
function sc_charToInt(t) {
	return t.charCodeAt(0);
}
function sc_addTypeAliases(t, e) {
	for (var n = sc$classTable[t.$protoName], r = 0; r < e.length; r++) sc$classTable[e[r]] = n;
}
function sc_addTypeAlias(t, e) {
	sc$classTable[e] = sc$classTable[t];
}
function sc_noMeth(t) {
	throw new Error("Invalid method call to: " + t);
}
function sc_logPrefix() {
	return "undefined" != typeof sc_testVerifyMode && sc_testVerifyMode
		? ""
		: sc_getTimeDelta(sc$startTime, new Date().getTime());
}
function sc_getTimeDelta(t, e) {
	if (0 == t) return "<server not yet started!>";
	var n = new Array(),
		r = e - t;
	n.push("+");
	var a = !1;
	if (r > 36e5) {
		var s = Math.trunc(r / 36e5);
		(r -= 60 * s * 60 * 1e3), s < 10 && n.push("0"), n.push(s), n.push(":"), (a = !0);
	}
	if (r > 6e4 || a) {
		var c = Math.trunc(r / 6e4);
		(r -= 60 * c * 1e3), c < 10 && n.push("0"), n.push(c), n.push(":");
	}
	if (r > 1e3 || a) {
		var o = Math.trunc(r / 1e3);
		(r -= 1e3 * o), o < 10 && n.push("0"), n.push(o), n.push(".");
	}
	return (
		r > 1e3 && console.error("bad time in sc_getTimeDelta"),
		r < 10 ? n.push("00") : r < 100 && n.push("0"),
		n.push(Math.trunc(r)),
		n.push(":"),
		n.join("")
	);
}
sc$startTime = new Date().getTime();
var Error_c = sc_newClass("java.lang.Error", Error, null, null);
function jv_Object() {}
function jv_EmptyInterface() {}
(jv_Object_c = sc_newClass("java.lang.Object", jv_Object, null, null)),
	(jv_Object_c.equals = function (t) {
		return this == t;
	}),
	(jv_Object_c.getClass = function () {
		return this.constructor.prototype;
	}),
	(jv_Object_c.hashCode = function () {
		return sc_id(this);
	}),
	(Error_c.equals = jv_Object_c.equals),
	(Error_c.hashCode = jv_Object_c.hashCode),
	(jv_Object_c.getName = function () {
		if (this.hasOwnProperty("$protoName")) return this.$protoName;
	});
var jv_EmptyInterface_c = sc_newClass("sc.js.EmptyInterface", jv_EmptyInterface, null, null);
function jv_Comparable() {}
var jv_Comparable_c = sc_newClass("java.lang.Comparable", jv_Comparable, null, null),
	Number_c = sc_newClass("java.lang.Number", Number, null, [jv_Comparable]);
function sc_parseInt(t) {
	var e = parseInt(t);
	if (isNaN(e)) throw new jv_NumberFormatException("For input string: " + t);
	return e;
}
function sc_parseFloat(t) {
	var e = parseFloat(t);
	if (isNaN(e)) throw new jv_NumberFormatException("For input string: " + t);
	return e;
}
sc_addTypeAlias("java.lang.Number", "java.lang.Short"),
	sc_addTypeAlias("java.lang.Number", "java.lang.Integer"),
	sc_addTypeAlias("java.lang.Number", "java.lang.Long"),
	sc_addTypeAlias("java.lang.Number", "java.lang.Float"),
	sc_addTypeAlias("java.lang.Number", "java.lang.Double"),
	(Number_c.TYPE = Number_c),
	(Number.prototype.hashCode = function () {
		return 17 * Math.floor(this);
	}),
	(Number.prototype.equals = jv_Object_c.equals),
	(Number.prototype.getClass = jv_Object_c.getClass),
	(Number.prototype.intValue = function () {
		return this < 0 ? Math.ceil(this) : Math.floor(this);
	}),
	(Number.prototype.compareTo = function (t) {
		return t == this ? 0 : t < this ? -1 : 1;
	}),
	(Number_c.parseInt = sc_parseInt),
	(Number_c.parseLong = sc_parseInt),
	(Number_c.parseDouble = sc_parseFloat),
	(Number_c.parseFloat = sc_parseFloat),
	(Number_c.valueOf = function (t) {
		if (0 == arguments.length) return this;
		if (sc_instanceOf(t, Number)) return t;
		var e = t.toString(),
			n = parseFloat(e);
		if (isNaN(n)) throw new jv_NumberFormatException(e + " is not a number");
		return n;
	}),
	(Number_c.compare = function (t, e) {
		return t == e ? 0 : t > e ? 1 : -1;
	}),
	(Number_c.toHexString = function (t) {
		return t.toString(16);
	}),
	(jv_Object_c.clone = function () {
		var t,
			e = function () {};
		for (var n in ((e.prototype = this.constructor.prototype), (t = new e()), this))
			this.hasOwnProperty(n) && (t[n] = this[n]);
		return t;
	});
var String_c = sc_newClass("String", String, null, [jv_Comparable]);
(String_c._valueOf = function (t) {
	return null == t ? "null" : t.toString();
}),
	(String_c.getName = function () {
		return "java.lang.String";
	}),
	(String.prototype._length = function () {
		return this.length;
	}),
	(String.prototype.contains = function (t) {
		return -1 != this.indexOf(t);
	}),
	(String.prototype.hashCode = function () {
		var t = this.length;
		return 0 == t
			? 0
			: 1 == t
			? this.length * this.charCodeAt(0) * 53
			: this.length * this.charCodeAt(0) * this.charCodeAt(t - 1) * 7;
	}),
	(String.prototype.getClass = jv_Object_c.getClass),
	(String.prototype.toString = function () {
		return this;
	}),
	(String.prototype.startsWith = function (t) {
		return 0 == this.indexOf(t);
	}),
	(String.prototype.endsWith = function (t) {
		var e = this.lastIndexOf(t);
		return -1 != e && this.length - t.length == e;
	}),
	(String.prototype.equals = function (t) {
		return null !== t && this.length == t.length && 0 == this.compareTo(t);
	}),
	(String.prototype.compareTo = function (t) {
		for (var e = this.length, n = t.length, r = Math.min(e, n), a = 0; a < r; a++) {
			var s = this.charCodeAt(a),
				c = t.charCodeAt(a);
			if (s !== c) return s - c;
		}
		return e - n;
	}),
	(String.prototype.toCharArray = function () {
		return this.split("");
	}),
	(String.prototype.equalsIgnoreCase = function (t) {
		return this.toUpperCase() === t.toUpperCase();
	}),
	(String.prototype.matches = function (t) {
		var e = this.match(new RegExp(t));
		return null != e && 1 == e.length && e[0].length == length;
	});
var Boolean_c = sc_newClass("java.lang.Boolean", Boolean, null, null);
function jv_Void() {}
sc_addTypeAlias("java.lang.Boolean", "boolean"),
	(Boolean.prototype.getClass = jv_Object_c.getClass),
	(Boolean_c.FALSE = !1),
	(Boolean_c.TRUE = !0),
	(Boolean_c.hashCode = jv_Object_c.hashCode),
	(Boolean_c.equals = jv_Object_c.equals);
var jv_Void_c = sc_newClass("java.lang.Void", jv_Void, null, null);
function jv_Byte() {}
(jv_Void_c.hashCode = jv_Object_c.hashCode), (jv_Void_c.equals = jv_Object_c.equals);
var jv_Byte_c = sc_newClass("java.lang.Byte", jv_Byte, null, null);
function jv_System() {}
(jv_Byte_c.hashCode = jv_Object_c.hashCode),
	(jv_Byte_c.equals = jv_Object_c.equals),
	(Error.prototype.printStackTrace = function () {
		this.stack && sc_log(this.stack);
	});
var jv_System_c = sc_newClass("java.lang.System", jv_System, null, null);
function jv_PrintStream() {
	(this.buf = null), (this.err = 1 == arguments.length && arguments[0]);
}
(jv_System_c.out = new jv_PrintStream()),
	(jv_System_c.err = new jv_PrintStream(!0)),
	(jv_System_c.arraycopy = function (t, e, n, r, a) {
		if (e < r) for (var s = a - 1; s >= 0; s--) n[r + s] = t[e + s];
		else for (s = 0; s < a; s++) n[r + s] = t[e + s];
	}),
	(jv_System_c.currentTimeMillis = function () {
		return Date.now ? Date.now() : new Date().getTime();
	}),
	(jv_System_c.identityHashCode = function (t) {
		return null == t ? 0 : sc_id(t);
	});
var jv_PrintStream_c = sc_newClass("java.io.PrintStream", jv_PrintStream, null, null);
function jv_Enum(t, e) {
	(this._name = t), (this._ordinal = e);
}
function jv_StringBuilder() {
	if (((this.value = new Array()), 1 == arguments.length)) {
		var t = arguments[0];
		"number" != typeof t && this.value.push(t);
	}
}
function jv_Array() {}
function jv_Exception() {
	(this.stack = new Error().stack), (this.message = 1 === arguments.length ? arguments[0] : null);
}
(jv_PrintStream_c.println = function () {
	for (var t = "", e = 0; e < arguments.length; e++) t += arguments[e];
	var n = this.buf,
		r = (null == n ? "" : n) + t;
	this.err && console.error ? sc_logError(r) : console.log && sc_log(r), (this.buf = null);
}),
	(jv_PrintStream_c.print = function () {
		for (var t = "", e = 0; e < arguments.length; e++) t += arguments[e];
		null == this.buf ? (this.buf = t) : (this.buf = this.buf + t);
	}),
	(jv_Enum_c = sc_newClass("java.lang.Enum", jv_Enum, jv_Object, null)),
	(jv_Enum_c.toString = jv_Enum_c.name =
		function () {
			return this._name;
		}),
	(jv_Enum_c.values = jv_Enum_c.getEnumConstants =
		function () {
			return sc_clInit(this), void 0 === this._values && console.log("*** enum not initialized"), this._values;
		}),
	(jv_Enum_c._valueOf = function (t) {
		sc_clInit(this);
		for (var e = 0; e < this._values.length; e++) if (this._values[e]._name == t) return this._values[e];
		return null;
	}),
	(jv_StringBuilder_c = sc_newClass("java.lang.StringBuilder", jv_StringBuilder, jv_Object, null)),
	(jv_StringBuilder_c.append = function (t) {
		null != t && this.value.push(t.toString());
	}),
	(jv_StringBuilder_c._length = function () {
		for (var t = 0, e = 0; e < this.value.length; e++) t += this.value[e].length;
		return t;
	}),
	(jv_StringBuilder_c.toString = function () {
		return this.value.join("");
	}),
	(jv_StringBuilder_c.substring = jv_StringBuilder_c.subSequence =
		function (t, e) {
			return this.toString().substring(t, e);
		}),
	(Array_c = sc_newClass("Array", Array)),
	(Array_c.hashCode = jv_Object_c.hashCode),
	(Array_c.equals = jv_Object_c.equals),
	(Array_c.getClass = jv_Object_c.getClass),
	(Array_c.clone = function () {
		for (var t = this.length, e = new Array(t), n = (e.length, 0); n < t; n++) e[n] = this[n];
		return e;
	}),
	(jv_Array_c = sc_newClass("jv_Array", jv_Array, Array, null)),
	(jv_Array_c.newInstance = function () {
		for (var t = null, e = 1; e < arguments.length; e++) {
			var n = new Array(arguments[e]);
			t = null == t ? n : t[n];
		}
		return t;
	}),
	(jv_Array_c.hashCode = jv_Object_c.hashCode),
	(jv_Array_c.equals = jv_Object_c.equals),
	(jv_Exception_c = sc_newClass("java.lang.Exception", jv_Exception, jv_Object, null)),
	(jv_Exception_c.printStackTrace = function () {
		console.log(this.stack);
	}),
	(jv_Exception_c.toString = function () {
		return this.message ? this.message : this.getClass().getName();
	});
var jv_enableAsserts = !0;
function jv_assert(t) {
	!t && jv_enableAsserts && console.log("Assertion failed" + (arguments.length > 1 ? ": " + arguments[1] : ""));
}
function jv_Character() {}
function jv_Math() {}
(jv_Character_c = sc_newClass("java.lang.Character", jv_Character)),
	(jv_Character_c.hashCode = jv_Object_c.hashCode),
	(jv_Character_c.equals = jv_Object_c.equals),
	(jv_Character_c.isLowerCase = function (t) {
		return /[a-z]/.test(t);
	}),
	(jv_Character_c.isUpperCase = function (t) {
		return /[A-Z]/.test(t);
	}),
	(jv_Character_c.toLowerCase = function (t) {
		return t.toLowerCase();
	}),
	(jv_Character_c.toUpperCase = function (t) {
		return t.toUpperCase();
	}),
	(jv_Character_c.isLetter = function (t) {
		var e = t.charCodeAt(0);
		return (e >= 65 && e < 91) || (e >= 97 && e < 123);
	}),
	(jv_Character_c.isDigit = function (t) {
		var e = t.charCodeAt(0);
		return e >= 48 && e <= 57;
	}),
	(jv_Character_c.isLetterOrDigit = function (t) {
		return jv_Character_c.isDigit(t) || jv_Character_c.isLetter(t);
	}),
	(jv_Character_c.isWhitespace = function (t) {
		return -1 != " \n\t\r\f\v".indexOf(t);
	}),
	(jv_Character_c.isJavaIdentifierStart = function (t) {
		return (t >= "A" && t <= "z") || "_" == t;
	}),
	(jv_Character_c.isJavaIdentifierPart = function (t) {
		return (t >= "A" && t <= "z") || (t >= "0" && t <= "9") || "_" == t;
	}),
	(jv_Math_c = sc_newClass("java.lang.Math", jv_Math)),
	(jv_Math_c.max = function (t, e) {
		return Math.max(t, e);
	}),
	(jv_Math_c.min = function (t, e) {
		return Math.min(t, e);
	}),
	(jv_Math_c.abs = function (t) {
		return Math.abs(t);
	}),
	(jv_Math_c.floor = function (t) {
		return Math.floor(t);
	}),
	(jv_Math_c.round = function (t) {
		return Math.round(t);
	}),
	(jv_Class_c = {}),
	(jv_Class_c.equals = jv_Object_c.equals),
	(jv_Class_c.hashCode = jv_Object_c.hashCode),
	(Number_c.getName = jv_Class_c.getName =
		function () {
			return this.$protoName;
		}),
	(jv_Class_c.toString = function () {
		return this.$protoName;
	}),
	(jv_Collections_c = {}),
	(jv_Collections_c.sort = function (t) {
		var e = t.toArray();
		if (1 == arguments.length)
			e.sort(function (t, e) {
				return t.compareTo(e);
			});
		else {
			var n = arguments[1];
			e.sort(function (t, e) {
				return n.compare(t, e);
			});
		}
		for (var r = e.length, a = 0; a < r; a++) t.set(a, e[a]);
	}),
	(jv_Collections_c.emptyList = function () {
		return new jv_ArrayList();
	}),
	(jv_Collections_c.singletonList = function (t) {
		var e = new jv_ArrayList();
		return e.add(t), e;
	}),
	(jv_Date = Date),
	(jv_Date_c = sc_newClass("java.util.Date", Date, jv_Object, null)),
	(Date.prototype.hashCode = jv_Object_c.hashCode),
	(Date.prototype.equals = jv_Object_c.equals),
	(Date.prototype.getClass = jv_Object_c.getClass);
var scaleFactor;
let captured,
	context,
	video,
	src,
	cap,
	checkBlur = !1;
function FrameProcessor() {
	if (
		(FrameProcessor_c._clInit(),
		(this.cardWidthRatio = 0),
		(this.cardHeightRatio = 0),
		(this.minFocusScore = 0),
		(this.marginRatio = 0),
		(this.angleErrorRatio = 0),
		(this.lineErrorRatio = 0),
		2 == arguments.length)
	) {
		var e = arguments[0],
			t = arguments[1];
		jv_Object.call(this), this._FrameProcessorInit(), (this.cardWidthRatio = e), (this.cardHeightRatio = t);
	} else if (3 == arguments.length) {
		(e = arguments[0]), (t = arguments[1]);
		var c = arguments[2];
		jv_Object.call(this),
			this._FrameProcessorInit(),
			(this.cardWidthRatio = e),
			(this.cardHeightRatio = t),
			(this.minFocusScore = c);
	} else if (6 == arguments.length) {
		(e = arguments[0]), (t = arguments[1]), (c = arguments[2]);
		var o = arguments[3],
			i = arguments[4],
			n = arguments[5];
		jv_Object.call(this),
			this._FrameProcessorInit(),
			(this.cardWidthRatio = e),
			(this.cardHeightRatio = t),
			(this.minFocusScore = c),
			(this.marginRatio = o),
			(this.angleErrorRatio = i),
			(this.lineErrorRatio = n),
			(this.canvas_overlay = document.getElementById("canvas_overlay")),
			(this.canvas_captured = document.getElementById("captured")),
			null === this.canvas_overlay && (this.canvas_overlay = document.getElementById("canvas")),
			(this.src = new cv.Mat(this.canvas_overlay.height, this.canvas_overlay.width, cv.CV_8UC4)),
			(this.ctx_overlay = this.canvas_overlay.getContext("2d")),
			(this.focusScore = 1),
			(captured = document.getElementById("captured")),
			(context = captured.getContext("2d")),
			(this.ctx_overlay.strokeStyle = "#f00"),
			(this.ctx_overlay.lineWidth = 5),
			(this.ctx_overlay.fillStyle = "rgba(224,224,226,0.30)");
	}
}
var FrameProcessor_c = sc_newClass("FrameProcessor", FrameProcessor, jv_Object, null);
function ProcessedFrameModel(e, t, c) {
	(this.card = null),
		(this.rectangleLines = null),
		(this.focusScore = 0),
		jv_Object.call(this),
		this._ProcessedFrameModelInit(),
		(this.card = e),
		(this.rectangleLines = t),
		(this.focusScore = c);
}
(FrameProcessor_c.process = function (e) {
	try {
		if (void 0 !== (e = cv.imread("captured"))) {
			if (((scaleFactor = e.size().width / FrameProcessor_c.SAMPLE_WIDTH), void 0 !== this.scaleBy))
				var t = this.scaleBy(e, scaleFactor);
			if (((FrameProcessor_c.focusScore = lastFocusScore(e)), void 0 !== this.findLines))
				this.findLines(t).scaleBy(scaleFactor);
			e.delete();
		}
	} catch (e) {
		return window.location.reload(), void console.log(e);
	}
}),
	(FrameProcessor_c._lastP1 = []),
	(FrameProcessor_c._lastP2 = []),
	(FrameProcessor_c.fourPointTransform = function () {
		if (sc_paramType(arguments[0], Mat) && sc_paramType(arguments[1], MatOfPoint2f)) {
			var e = arguments[0],
				t = arguments[1],
				c = (f = t.toList()).get(0),
				o = f.get(1),
				i = f.get(2),
				n = f.get(3),
				r = jv_Math_c.sqrt(jv_Math_c.pow(i.x - n.x, 2) + jv_Math_c.pow(i.y - n.y, 2)),
				s = jv_Math_c.sqrt(jv_Math_c.pow(o.x - c.x, 2) + jv_Math_c.pow(o.y - c.y, 2)),
				a = jv_Math_c.max(r, s),
				l = Number_c.valueOf(a).intValue(),
				_ = jv_Math_c.sqrt(jv_Math_c.pow(o.x - i.x, 2) + jv_Math_c.pow(o.y - i.y, 2)),
				g = jv_Math_c.sqrt(jv_Math_c.pow(c.x - n.x, 2) + jv_Math_c.pow(c.y - n.y, 2)),
				h = jv_Math_c.max(_, g),
				u = Number_c.valueOf(h).intValue(),
				d = new cv.Mat(u, l, cv.CV_8UC4),
				P = new MatOfPoint2f();
			P.fromList(f);
			var v = new MatOfPoint2f(),
				m = new ArrayList();
			m.add(new Point(0, 0)),
				m.add(new Point(a, 0)),
				m.add(new Point(a, h)),
				m.add(new Point(0, h)),
				v.fromList(m);
			var y = cv.imgproc.getPerspectiveTransform(P, v);
			return cv.imgproc.warpPerspective(e, d, y, d.size()), d;
		}
		if (sc_paramType(arguments[0], Mat) && sc_paramType(arguments[1], RectangleLines)) {
			e = arguments[0];
			var f,
				p = arguments[1],
				T = new RectanglePoints(p),
				L = new MatOfPoint2f();
			return (
				(f = new ArrayList()).add(new Point(T.getLeftTop().getX(), T.getLeftTop().getY())),
				f.add(new Point(T.getRightTop().getX(), T.getRightTop().getY())),
				f.add(new Point(T.getRightBottom().getX(), T.getRightBottom().getY())),
				f.add(new Point(T.getLeftBottom().getX(), T.getLeftBottom().getY())),
				L.fromList(f),
				this.fourPointTransform(e, L)
			);
		}
	}),
	(FrameProcessor_c.scaleBy = function (e, t) {
		var c = Number_c.valueOf(e.size().height / t).intValue(),
			o = Number_c.valueOf(e.size().width / t).intValue(),
			i = new cv.Size(o, c),
			n = new cv.Mat(i, cv.CV_8UC4);
		return cv.resize(e, n, i), n;
	}),
	(FrameProcessor_c.findLines = function (e) {
		var t = null,
			c = null,
			o = null,
			i = null;
		if (window.cardDetection && !0 === window.cardDetection.continueToShot) {
			var n = Math.floor(this.marginRatio * FrameProcessor_c.SAMPLE_WIDTH),
				r = Math.floor(e.cols * ((1 - this.cardWidthRatio) / 2)),
				s = Math.floor(e.cols * ((1 + this.cardWidthRatio) / 2)),
				a = Math.floor(e.rows * ((1 - this.cardHeightRatio) / 2)),
				l = Math.floor(e.rows * ((1 + this.cardHeightRatio) / 2)),
				_ = this.cropRegions(e, r, a, s, a, n),
				g = this.cropRegions(e, r, a, r, l, n),
				h = this.cropRegions(e, s, a, s, l, n),
				u = this.cropRegions(e, r, l, s, l, n),
				d = this;
			null !== (t = this.findLine(_, sc_clInit(LineRegionType_c).TOP)) &&
				(setTimeout(function () {
					d.ctx_overlay.beginPath(),
						(d.ctx_overlay.lineWidth = 5),
						(d.ctx_overlay.strokeStyle = "#26ff00"),
						d.ctx_overlay.moveTo(
							FrameProcessor_c._lastP1[sc_clInit(LineRegionType_c).TOP].getX(),
							FrameProcessor_c._lastP1[sc_clInit(LineRegionType_c).TOP].getY()
						),
						d.ctx_overlay.lineTo(
							FrameProcessor_c._lastP2[sc_clInit(LineRegionType_c).TOP].getX(),
							FrameProcessor_c._lastP2[sc_clInit(LineRegionType_c).TOP].getY()
						),
						d.ctx_overlay.stroke();
				}, 0),
				t.shiftBy(r - n, a - n),
				_.delete()),
				null !== (c = this.findLine(g, sc_clInit(LineRegionType_c).LEFT)) &&
					(setTimeout(function () {
						d.ctx_overlay.beginPath(),
							(d.ctx_overlay.lineWidth = 5),
							(d.ctx_overlay.strokeStyle = "#26ff00"),
							d.ctx_overlay.moveTo(
								FrameProcessor_c._lastP1[sc_clInit(LineRegionType_c).LEFT].getX(),
								FrameProcessor_c._lastP1[sc_clInit(LineRegionType_c).LEFT].getY()
							),
							d.ctx_overlay.lineTo(
								FrameProcessor_c._lastP2[sc_clInit(LineRegionType_c).LEFT].getX(),
								FrameProcessor_c._lastP2[sc_clInit(LineRegionType_c).LEFT].getY()
							),
							d.ctx_overlay.stroke();
					}, 0),
					c.shiftBy(r - n, a - n),
					g.delete()),
				null !== (o = this.findLine(h, sc_clInit(LineRegionType_c).RIGHT)) &&
					(setTimeout(function () {
						d.ctx_overlay.beginPath(),
							(d.ctx_overlay.lineWidth = 5),
							(d.ctx_overlay.strokeStyle = "#26ff00"),
							d.ctx_overlay.moveTo(
								FrameProcessor_c._lastP1[sc_clInit(LineRegionType_c).RIGHT].getX(),
								FrameProcessor_c._lastP1[sc_clInit(LineRegionType_c).RIGHT].getY()
							),
							d.ctx_overlay.lineTo(
								FrameProcessor_c._lastP2[sc_clInit(LineRegionType_c).RIGHT].getX(),
								FrameProcessor_c._lastP2[sc_clInit(LineRegionType_c).RIGHT].getY()
							),
							d.ctx_overlay.stroke();
					}, 0),
					o.shiftBy(s - n, a - n),
					h.delete()),
				null !== (i = this.findLine(u, sc_clInit(LineRegionType_c).BOTTOM)) &&
					(setTimeout(function () {
						d.ctx_overlay.beginPath(),
							(d.ctx_overlay.lineWidth = 5),
							(d.ctx_overlay.strokeStyle = "#26ff00"),
							d.ctx_overlay.moveTo(
								FrameProcessor_c._lastP1[sc_clInit(LineRegionType_c).BOTTOM].getX(),
								FrameProcessor_c._lastP1[sc_clInit(LineRegionType_c).BOTTOM].getY()
							),
							d.ctx_overlay.lineTo(
								FrameProcessor_c._lastP2[sc_clInit(LineRegionType_c).BOTTOM].getX(),
								FrameProcessor_c._lastP2[sc_clInit(LineRegionType_c).BOTTOM].getY()
							),
							d.ctx_overlay.stroke();
					}, 0),
					i.shiftBy(r - n, l - n),
					u.delete());
		}
		return new RectangleLines(t, i, c, o);
	}),
	(FrameProcessor_c.findLine = function (e, t) {
		let c = new cv.MatVector();
		cv.split(e, c);
		let o = c.get(0),
			i = c.get(1),
			n = c.get(2);
		c.delete();
		var r = this.findLineByChannel(o, t);
		return (
			null === r && (r = this.findLineByChannel(i, t)),
			null === r && (r = this.findLineByChannel(n, t)),
			null !== r && ((FrameProcessor_c._lastP1[t] = r.getP1()), (FrameProcessor_c._lastP2[t] = r.getP2())),
			r
		);
	}),
	(FrameProcessor_c.findLineByChannel = function (e, t) {
		var c,
			o,
			i = Math.floor(e.cols > e.rows ? e.cols : e.rows),
			n = (Math.floor(e.cols > e.rows ? e.rows : e.cols), e.clone()),
			r = t === sc_clInit(LineRegionType_c).LEFT || t === sc_clInit(LineRegionType_c).RIGHT,
			s = new cv.Mat(),
			a = new cv.Mat();
		cv.Sobel(n, s, cv.CV_16S, 1, 0), cv.Sobel(n, a, cv.CV_16S, 0, 1);
		var l = new cv.Mat(),
			_ = new cv.Mat();
		cv.absdiff(s, new cv.Mat(s.rows, s.cols, s.type(), new cv.Scalar(0)), l),
			cv.absdiff(a, new cv.Mat(a.rows, a.cols, a.type(), new cv.Scalar(0)), _),
			(c = Math.floor((this.sumElems(l) + this.sumElems(_)) / (e.cols * e.rows))),
			cv.Canny(n, n, c, 3 * c),
			(o = i / 3);
		var g = new cv.Mat();
		cv.HoughLines(
			n,
			g,
			1,
			(this.angleErrorRatio * Math.PI) / 180,
			Math.floor(o * this.lineErrorRatio),
			0,
			0,
			0,
			Math.PI
		);
		var h = null;
		for (let t = 0; t < g.rows; ++t) {
			let c = g.data32F[2 * t],
				o = g.data32F[2 * t + 1],
				i = Math.cos(o),
				n = Math.sin(o),
				s = i * c,
				a = n * c;
			var u, d;
			r
				? ((u = Util_c.computeIntersect(
						jv_Math_c.round(s + FrameProcessor_c.SAMPLE_WIDTH * -n),
						jv_Math_c.round(a + FrameProcessor_c.SAMPLE_WIDTH * i),
						jv_Math_c.round(s - FrameProcessor_c.SAMPLE_WIDTH * -n),
						jv_Math_c.round(a - FrameProcessor_c.SAMPLE_WIDTH * i),
						0,
						0,
						e.size().width,
						0
				  )),
				  (d = Util_c.computeIntersect(
						jv_Math_c.round(s + FrameProcessor_c.SAMPLE_WIDTH * -n),
						jv_Math_c.round(a + FrameProcessor_c.SAMPLE_WIDTH * i),
						jv_Math_c.round(s - FrameProcessor_c.SAMPLE_WIDTH * -n),
						jv_Math_c.round(a - FrameProcessor_c.SAMPLE_WIDTH * i),
						0,
						e.size().height,
						e.size().width,
						e.size().height
				  )))
				: ((u = Util_c.computeIntersect(
						jv_Math_c.round(s + FrameProcessor_c.SAMPLE_WIDTH * -n),
						jv_Math_c.round(a + FrameProcessor_c.SAMPLE_WIDTH * i),
						jv_Math_c.round(s - FrameProcessor_c.SAMPLE_WIDTH * -n),
						jv_Math_c.round(a - FrameProcessor_c.SAMPLE_WIDTH * i),
						0,
						0,
						0,
						e.size().height
				  )),
				  (d = Util_c.computeIntersect(
						jv_Math_c.round(s + FrameProcessor_c.SAMPLE_WIDTH * -n),
						jv_Math_c.round(a + FrameProcessor_c.SAMPLE_WIDTH * i),
						jv_Math_c.round(s - FrameProcessor_c.SAMPLE_WIDTH * -n),
						jv_Math_c.round(a - FrameProcessor_c.SAMPLE_WIDTH * i),
						e.size().width,
						0,
						e.size().width,
						e.size().height
				  )));
			var P = new Line(u, d),
				v = u.getX() - d.getX(),
				m = u.getY() - d.getY(),
				y = Math.PI / 2;
			0 !== v && (y = Math.atan(jv_Math_c.abs(m / v)));
			if (r && y > (Math.PI / 180) * 88 && y < (Math.PI / 180) * 92) {
				h = P;
				break;
			}
			if (!r && (y < (Math.PI / 180) * 2 || y > (Math.PI / 180) * 178)) {
				h = P;
				break;
			}
		}
		return s.delete(), a.delete(), l.delete(), _.delete(), g.delete(), h;
	}),
	(FrameProcessor_c.cropRegions = function (e, t, c, o, i, n) {
		return e.roi(new cv.Rect(t - n, c - n, o - t + 2 * n, i - c + 2 * n));
	}),
	(FrameProcessor_c.sumElems = function (e) {
		return numeric.sum(this.getMatData(e));
	}),
	(FrameProcessor_c.getMatData = function (e) {
		switch (e.type()) {
			case cv.CV_8UC1:
			case cv.CV_8UC2:
			case cv.CV_8UC3:
			case cv.CV_8UC4:
				return e.data;
			case cv.CV_8SC1:
			case cv.CV_8SC2:
			case cv.CV_8SC3:
			case cv.CV_8SC4:
				return e.data8S;
			case cv.CV_16UC1:
			case cv.CV_16UC2:
			case cv.CV_16UC3:
			case cv.CV_16UC4:
				return e.data16U;
			case cv.CV_16SC1:
			case cv.CV_16SC2:
			case cv.CV_16SC3:
			case cv.CV_16SC4:
				return e.data16S;
			case cv.CV_32SC1:
			case cv.CV_32SC2:
			case cv.CV_32SC3:
			case cv.CV_32SC4:
				return e.data32S;
			case cv.CV_32FC1:
			case cv.CV_32FC2:
			case cv.CV_32FC3:
			case cv.CV_32FC4:
				return e.data32F;
			case cv.CV_64FC1:
			case cv.CV_64FC2:
			case cv.CV_64FC3:
			case cv.CV_64FC4:
				return e.data64F;
		}
	}),
	(FrameProcessor_c._FrameProcessorInit = function () {
		(this.minFocusScore = 6), (this.marginRatio = 0.014), (this.angleErrorRatio = 1), (this.lineErrorRatio = 1);
	}),
	(FrameProcessor_c._clInit = function () {
		FrameProcessor_c.hasOwnProperty("_clInited") ||
			((FrameProcessor_c._clInited = !0), (FrameProcessor_c.SAMPLE_WIDTH = 350));
	});
var ProcessedFrameModel_c = sc_newClass("ProcessedFrameModel", ProcessedFrameModel, jv_Object, null);
(ProcessedFrameModel_c.getCard = function () {
	return this.card;
}),
	(ProcessedFrameModel_c.getRectangleLines = function () {
		return this.rectangleLines;
	}),
	(ProcessedFrameModel_c.getRectanglePoints = function () {
		return new RectanglePoints(this.rectangleLines);
	}),
	(ProcessedFrameModel_c.getFocusScore = function () {
		return this.focusScore;
	}),
	(ProcessedFrameModel_c.setFocusScore = function (e) {
		this.focusScore = e;
	}),
	(ProcessedFrameModel_c._ProcessedFrameModelInit = function () {});
var lastFocusScore = function (e) {
	let t = new cv.Mat(),
		c = new cv.Mat();
	cv.cvtColor(e, t, cv.COLOR_RGBA2GRAY), cv.Laplacian(t, c, cv.CV_64F, 1, 1, 0, cv.BORDER_DEFAULT);
	let o = new cv.Mat(1, 4, cv.CV_64F),
		i = new cv.Mat(1, 4, cv.CV_64F);
	cv.meanStdDev(c, o, i);
	let n = i.doubleAt(0, 0);
	return t.delete(), c.delete(), o.delete(), i.delete(), n * n;
};
function RectangleLines(e, t, c, o) {
	if (
		((this.top = null),
		(this.bottom = null),
		(this.left = null),
		(this.right = null),
		null !== e &&
			null !== t &&
			null !== c &&
			null !== o &&
			((!0 === checkBlur && FrameProcessor_c.focusScore > 100) ||
				(!1 === checkBlur && window.cardDetection && !0 === window.cardDetection.continueToShot)))
	) {
		var i = {},
			n = {},
			r = {},
			s = {};
		(i.x = e.getP1().getX()),
			(i.y = e.getP1().getY()),
			(n.x = e.getP2().getX()),
			(n.y = e.getP2().getY()),
			(r.x = c.getP1().getX()),
			(r.y = c.getP1().getY()),
			(s.x = c.getP2().getX()),
			(s.y = c.getP2().getY());
		var a = this.calculateIntersection(i, n, r, s);
		(i.x = o.getP1().getX()),
			(i.y = o.getP1().getY()),
			(n.x = o.getP2().getX()),
			(n.y = o.getP2().getY()),
			(r.x = t.getP1().getX()),
			(r.y = t.getP1().getY()),
			(s.x = t.getP2().getX()),
			(s.y = t.getP2().getY());
		var l = this.calculateIntersection(i, n, r, s);
		const _ = document.getElementById("shot"),
			g = document.getElementById("captured"),
			h = document.getElementById("cropped"),
			u = document.getElementById("cropped_last");
		if (
			((h.width = g.width),
			(h.height = g.height),
			"ImageCapture" in window && !0 === cardDetection.useImageCapture)
		)
			window.cardDetection.imageCapture
				.takePhoto()
				.then((e) => createImageBitmap(e))
				.then((e) => {
					try {
						(u.width = e.width), (u.height = e.height);
						var t = e.width / $("#video").width(),
							c = e.height / $("#video").height();
						(h.width = (l.x - a.x) * scaleFactor * t),
							(h.height = (l.y - a.y) * scaleFactor * c),
							h
								.getContext("2d")
								.drawImage(
									e,
									a.x * scaleFactor * t,
									a.y * scaleFactor * c,
									(l.x - a.x) * scaleFactor * t,
									(l.y - a.y) * scaleFactor * c,
									0,
									0,
									(l.x - a.x) * scaleFactor * t,
									(l.y - a.y) * scaleFactor * c
								);
						var o = h.width,
							i = h.height,
							n = 2;
						!1 === cardDetection.isMobileOrNot() && (n = 1),
							(u.width = o / n),
							(u.height = i / n),
							u.getContext("2d").drawImage(h, 0, 0, o / n, i / n),
							(cardDetection.lastRecordedBase64 = u.toDataURL()),
							(_.src = u.toDataURL()),
							(_.width = 300);
					} catch (e) {
						alert(e);
					}
				})
				.catch((e) => console.error("grabFrame() error:", e));
		else {
			(h.width = (l.x - a.x) * scaleFactor),
				(h.height = (l.y - a.y) * scaleFactor),
				(function (e, t, c, o) {
					for (
						var i,
							n,
							r,
							s,
							g,
							d,
							P,
							v,
							m,
							y,
							f,
							p,
							T,
							L = e.getContext("2d"),
							R = [0, -1, 0, -1, 5, -1, 0, -1, 0],
							F = Math.round(Math.sqrt(R.length)),
							M = (0.5 * F) | 0,
							w = L.createImageData(t, c),
							I = w.data,
							C = L.getImageData(0, 0, t, c).data,
							x = c;
						x--;

					)
						for (i = t; i--; ) {
							for (r = x, n = i, P = 4 * (x * t + i), s = 0, g = 0, d = 0, 0, f = 0; f < F; f++)
								for (y = 0; y < F; y++)
									(T = n + y - M),
										(p = r + f - M) >= 0 &&
											p < c &&
											T >= 0 &&
											T < t &&
											((m = R[f * F + y]),
											(s += C[(v = 4 * (p * t + T))] * m),
											(g += C[v + 1] * m),
											(d += C[v + 2] * m),
											C[v + 3] * m);
							(I[P] = s * o + C[P] * (1 - o)),
								(I[P + 1] = g * o + C[P + 1] * (1 - o)),
								(I[P + 2] = d * o + C[P + 2] * (1 - o)),
								(I[P + 3] = C[P + 3]);
						}
					L.putImageData(w, 0, 0),
						h
							.getContext("2d")
							.drawImage(
								e,
								a.x * scaleFactor,
								a.y * scaleFactor,
								(l.x - a.x) * scaleFactor,
								(l.y - a.y) * scaleFactor,
								0,
								0,
								(l.x - a.x) * scaleFactor,
								(l.y - a.y) * scaleFactor
							);
					var B = h.width,
						j = h.height;
					(u.width = 3 * B),
						(u.height = 3 * j),
						u.getContext("2d").drawImage(h, 0, 0, 3 * B, 3 * j),
						(cardDetection.lastRecordedBase64 = u.toDataURL()),
						(_.src = u.toDataURL()),
						(_.width = 300);
				})(g, g.width, g.height, 0.5);
		}
		$(".spinner").show(),
			clearInterval(cardDetection.intervalCV),
			(_.onload = function () {
				!0 === cardDetection.continueToShot &&
					(cardDetection.onCapturedSuccess(
						cardDetection.lastRecordedBase64,
						cardDetection.b64toBlob(cardDetection.lastRecordedBase64),
						_
					),
					setTimeout(function () {
						document.getElementById("video").play(),
							setTimeout(function () {
								(cardDetection.capture = !0), cardDetection.getInterValVideoCVCapture();
							}, 2500);
					}, 5e3));
			});
	}
	jv_Object.call(this),
		this._RectangleLinesInit(),
		(this.top = e),
		(this.bottom = t),
		(this.left = c),
		(this.right = o);
}
var RectangleLines_c = sc_newClass("RectangleLines", RectangleLines, jv_Object, null);
function RectanglePoints(e) {
	(this.leftTop = null),
		(this.rightTop = null),
		(this.leftBottom = null),
		(this.rightBottom = null),
		jv_Object.call(this),
		this._RectanglePointsInit(),
		this.calculateByLines(e);
}
(RectangleLines_c.calculateIntersection = function (e, t, c, o) {
	var i = (e.x - t.x) * (c.y - o.y) - (e.y - t.y) * (c.x - o.x);
	if (0 == i) throw new Error("Number of intersection points is zero or infinity.");
	var n = e.x * t.y - e.y * t.x,
		r = c.x * o.y - c.y * o.x;
	return { x: (n * (c.x - o.x) - (e.x - t.x) * r) / i, y: (n * (c.y - o.y) - (e.y - t.y) * r) / i };
}),
	(RectangleLines_c.getTop = function () {
		return this.top;
	}),
	(RectangleLines_c.getBottom = function () {
		return this.bottom;
	}),
	(RectangleLines_c.getLeft = function () {
		return this.left;
	}),
	(RectangleLines_c.getRight = function () {
		return this.right;
	}),
	(RectangleLines_c.isCompleted = function () {
		return null !== this.top && null !== this.bottom && null !== this.left && null !== this.right;
	}),
	(RectangleLines_c.scaleBy = function (e) {
		null !== this.top && this.top.scaleBy(e),
			null !== this.bottom && this.bottom.scaleBy(e),
			null !== this.left && this.left.scaleBy(e),
			null !== this.right && this.right.scaleBy(e);
	}),
	(RectangleLines_c._RectangleLinesInit = function () {});
var RectanglePoints_c = sc_newClass("RectanglePoints", RectanglePoints, jv_Object, null);
function Point(e, t) {
	(this.x = 0), (this.y = 0), jv_Object.call(this), this._PointInit(), (this.x = e), (this.y = t);
}
(RectanglePoints_c.getLeftTop = function () {
	return this.leftTop;
}),
	(RectanglePoints_c.getRightTop = function () {
		return this.rightTop;
	}),
	(RectanglePoints_c.getLeftBottom = function () {
		return this.leftBottom;
	}),
	(RectanglePoints_c.getRightBottom = function () {
		return this.rightBottom;
	}),
	(RectanglePoints_c.calculateByLines = function (e) {
		null !== e.getTop() &&
			null !== e.getLeft() &&
			(this.leftTop = computeIntersect(
				e.getTop().getP1().getX(),
				e.getTop().getP1().getY(),
				e.getTop().getP2().getX(),
				e.getTop().getP2().getY(),
				e.getLeft().getP1().getX(),
				e.getLeft().getP1().getY(),
				e.getLeft().getP2().getX(),
				e.getLeft().getP2().getY()
			)),
			null !== e.getTop() &&
				null !== e.getRight() &&
				(this.rightTop = computeIntersect(
					e.getTop().getP1().getX(),
					e.getTop().getP1().getY(),
					e.getTop().getP2().getX(),
					e.getTop().getP2().getY(),
					e.getRight().getP1().getX(),
					e.getRight().getP1().getY(),
					e.getRight().getP2().getX(),
					e.getRight().getP2().getY()
				)),
			null !== e.getBottom() &&
				null !== e.getLeft() &&
				(this.leftBottom = computeIntersect(
					e.getBottom().getP1().getX(),
					e.getBottom().getP1().getY(),
					e.getBottom().getP2().getX(),
					e.getBottom().getP2().getY(),
					e.getLeft().getP1().getX(),
					e.getLeft().getP1().getY(),
					e.getLeft().getP2().getX(),
					e.getLeft().getP2().getY()
				)),
			null !== e.getBottom() &&
				null !== e.getRight() &&
				(this.rightBottom = computeIntersect(
					e.getBottom().getP1().getX(),
					e.getBottom().getP1().getY(),
					e.getBottom().getP2().getX(),
					e.getBottom().getP2().getY(),
					e.getRight().getP1().getX(),
					e.getRight().getP1().getY(),
					e.getRight().getP2().getX(),
					e.getRight().getP2().getY()
				));
	}),
	(RectanglePoints_c._RectanglePointsInit = function () {});
var Point_c = sc_newClass("Point", Point, jv_Object, null);
function Line(e, t) {
	(this.p1 = null), (this.p2 = null), jv_Object.call(this), this._LineInit(), (this.p1 = e), (this.p2 = t);
}
(Point_c.getX = function () {
	return this.x;
}),
	(Point_c.getY = function () {
		return this.y;
	}),
	(Point_c.shiftBy = function (e, t) {
		(this.x = this.x + e), (this.y = this.y + t);
	}),
	(Point_c.scaleBy = function (e) {
		(this.x = Math.floor(e * this.x)), (this.y = Math.floor(e * this.y));
	}),
	(Point_c._PointInit = function () {});
var Line_c = sc_newClass("Line", Line, jv_Object, null);
function LineRegionType(e, t) {
	LineRegionType_c._clInit(), jv_Enum.call(this, e, t);
}
(Line_c.getP1 = function () {
	return this.p1;
}),
	(Line_c.getP2 = function () {
		return this.p2;
	}),
	(Line_c.shiftBy = function (e, t) {
		null !== this.p1 && this.p1.shiftBy(e, t), null !== this.p2 && this.p2.shiftBy(e, t);
	}),
	(Line_c.scaleBy = function (e) {
		null !== this.p1 && this.p1.scaleBy(e), null !== this.p2 && this.p2.scaleBy(e);
	}),
	(Line_c._LineInit = function () {});
var LineRegionType_c = sc_newClass("LineRegionType", LineRegionType, jv_Enum, null);
function Util() {
	jv_Object.call(this);
}
LineRegionType_c._clInit = function () {
	LineRegionType_c.hasOwnProperty("_clInited") ||
		((LineRegionType_c._clInited = !0),
		(LineRegionType_c.TOP = new LineRegionType("TOP", 0)),
		(LineRegionType_c.BOTTOM = new LineRegionType("BOTTOM", 1)),
		(LineRegionType_c.LEFT = new LineRegionType("LEFT", 2)),
		(LineRegionType_c.RIGHT = new LineRegionType("RIGHT", 3)),
		(LineRegionType_c._values = sc_initArray(jv_Object_c, 1, [
			LineRegionType_c.TOP,
			LineRegionType_c.BOTTOM,
			LineRegionType_c.LEFT,
			LineRegionType_c.RIGHT,
		])));
};
var Util_c = sc_newClass("Util", Util, jv_Object, null);
Util_c.computeIntersect = function (e, t, c, o, i, n, r, s) {
	var a = (e - c) * (n - s) - (t - o) * (i - r);
	if (0 === a) return null;
	var l = ((e * o - t * c) * (i - r) - (e - c) * (i * s - n * r)) / a,
		_ = ((e * o - t * c) * (n - s) - (t - o) * (i * s - n * r)) / a;
	return new Point(Math.floor(l), Math.floor(_));
};
!(function (t) {
	if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
	else if ("function" == typeof define && define.amd) define([], t);
	else {
		("undefined" != typeof window
			? window
			: "undefined" != typeof global
			? global
			: "undefined" != typeof self
			? self
			: this
		).measureBlur = t();
	}
})(function () {
	return (function t(a, e, r) {
		function i(o, l) {
			if (!e[o]) {
				if (!a[o]) {
					var h = "function" == typeof require && require;
					if (!l && h) return h(o, !0);
					if (n) return n(o, !0);
					var s = new Error("Cannot find module '" + o + "'");
					throw ((s.code = "MODULE_NOT_FOUND"), s);
				}
				var d = (e[o] = { exports: {} });
				a[o][0].call(
					d.exports,
					function (t) {
						var e = a[o][1][t];
						return i(e || t);
					},
					d,
					d.exports,
					t,
					a,
					e,
					r
				);
			}
			return e[o].exports;
		}
		for (var n = "function" == typeof require && require, o = 0; o < r.length; o++) i(r[o]);
		return i;
	})(
		{
			1: [
				function (t, a, e) {
					var r,
						i = t("canvasfilters").Filters;
					function n(t) {
						return (function (t) {
							var a,
								e,
								r,
								i,
								n,
								o,
								l,
								h = t[0].length,
								s = t.length,
								d = 0,
								u = 0;
							for (e = 0; e < s; e += 1)
								for (n = -1, a = 0; a < h; a += 1)
									(r = t[e][a]),
										n >= 0 &&
											a > n &&
											r < (i = t[e][a - 1]) &&
											(i >= 20 && ((d += 1), (u += a - n - 1)), (n = -1)),
										0 == r && (n = a);
							return (
								0 === d ? ((o = 0), (l = 0)) : (l = ((o = u / d) / h) * 100),
								{ width: h, height: s, num_edges: d, avg_edge_width: o, avg_edge_width_perc: l }
							);
						})(
							(function (t) {
								var a,
									e,
									r,
									i,
									n = t.data,
									o = 4 * t.width,
									l = [];
								for (r = 0; r < n.length; r += o) {
									for (i = new Uint8ClampedArray(t.width), e = 0, a = r; a < r + o; a += 4)
										(i[e] = n[a]), (e += 1);
									l.push(i);
								}
								return l;
							})(
								(function (t) {
									var a, e;
									return (
										(a = t.width >= 360 ? i.luminance(i.gaussianBlur(t, 5)) : i.luminance(t)),
										(e = i.getFloat32Array([1, 0, -1, 2, 0, -2, 1, 0, -1])),
										i.convolve(a, e, !0)
									);
								})(t)
							)
						);
					}
					var o = 0,
						l = {},
						h = { workerURL: "measure_blur_worker.js" };
					(n.async = function (t) {
						return (
							r ||
								((r = new Worker(h.workerURL)).onmessage = function (t) {
									l[t.data.id](t.data.score), delete l[t.data.id];
								}),
							new Promise(function (a) {
								var e = ++o;
								r.postMessage({ id: e, imageData: t }), (l[e] = a);
							})
						);
					}),
						(n.setup = function (t) {
							Object.assign(h, t);
						}),
						(a.exports = n);
				},
				{ canvasfilters: 2 },
			],
			2: [
				function (t, a, e) {
					(Filters = {}),
						"undefined" == typeof Float32Array
							? (Filters.getFloat32Array = Filters.getUint8Array =
									function (t) {
										return t.length ? t.slice(0) : new Array(t);
									})
							: ((Filters.getFloat32Array = function (t) {
									return new Float32Array(t);
							  }),
							  (Filters.getUint8Array = function (t) {
									return new Uint8Array(t);
							  })),
						"undefined" != typeof document
							? ((Filters.tmpCanvas = document.createElement("canvas")),
							  (Filters.tmpCtx = Filters.tmpCanvas.getContext("2d")),
							  (Filters.getPixels = function (t) {
									var a, e;
									if (t.getContext) {
										a = t;
										try {
											e = a.getContext("2d");
										} catch (t) {}
									}
									return (
										e ||
											(e = (a = this.getCanvas(t.width, t.height)).getContext("2d")).drawImage(
												t,
												0,
												0
											),
										e.getImageData(0, 0, a.width, a.height)
									);
							  }),
							  (Filters.createImageData = function (t, a) {
									return this.tmpCtx.createImageData(t, a);
							  }),
							  (Filters.getCanvas = function (t, a) {
									var e = document.createElement("canvas");
									return (e.width = t), (e.height = a), e;
							  }),
							  (Filters.filterImage = function (t, a, e) {
									for (var r = [this.getPixels(a)], i = 2; i < arguments.length; i++)
										r.push(arguments[i]);
									return t.apply(this, r);
							  }),
							  (Filters.toCanvas = function (t) {
									var a = this.getCanvas(t.width, t.height);
									return a.getContext("2d").putImageData(t, 0, 0), a;
							  }),
							  (Filters.toImageData = function (t) {
									return this.identity(t);
							  }))
							: ((onmessage = function (t) {
									var a = t.data;
									a.length || (a = [a]), postMessage(Filters.runPipeline(a));
							  }),
							  (Filters.createImageData = function (t, a) {
									return { width: t, height: a, data: this.getFloat32Array(t * a * 4) };
							  })),
						(Filters.runPipeline = function (t) {
							var a = null;
							a = this[t[0].name].apply(this, t[0].args);
							for (var e = 1; e < t.length; e++) {
								var r = t[e],
									i = r.args.slice(0);
								i.unshift(a), (a = this[r.name].apply(this, i));
							}
							return a;
						}),
						(Filters.createImageDataFloat32 = function (t, a) {
							return { width: t, height: a, data: this.getFloat32Array(t * a * 4) };
						}),
						(Filters.identity = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height), r = e.data, i = t.data, n = 0;
								n < i.length;
								n++
							)
								r[n] = i[n];
							return e;
						}),
						(Filters.horizontalFlip = function (t) {
							for (
								var a = Filters.createImageData(t.width, t.height),
									e = t.width,
									r = t.height,
									i = a.data,
									n = t.data,
									o = 0;
								o < r;
								o++
							)
								for (var l = 0; l < e; l++) {
									var h = 4 * (o * e + l),
										s = 4 * (o * e + (e - l - 1));
									(i[s] = n[h]), (i[s + 1] = n[h + 1]), (i[s + 2] = n[h + 2]), (i[s + 3] = n[h + 3]);
								}
							return a;
						}),
						(Filters.verticalFlip = function (t) {
							for (
								var a = Filters.createImageData(t.width, t.height),
									e = t.width,
									r = t.height,
									i = a.data,
									n = t.data,
									o = 0;
								o < r;
								o++
							)
								for (var l = 0; l < e; l++) {
									var h = 4 * (o * e + l),
										s = 4 * ((r - o - 1) * e + l);
									(i[s] = n[h]), (i[s + 1] = n[h + 1]), (i[s + 2] = n[h + 2]), (i[s + 3] = n[h + 3]);
								}
							return a;
						}),
						(Filters.luminance = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height), r = e.data, i = t.data, n = 0;
								n < i.length;
								n += 4
							) {
								var o = 0.2126 * i[n] + 0.7152 * i[n + 1] + 0.0722 * i[n + 2];
								(r[n] = r[n + 1] = r[n + 2] = o), (r[n + 3] = i[n + 3]);
							}
							return e;
						}),
						(Filters.grayscale = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height), r = e.data, i = t.data, n = 0;
								n < i.length;
								n += 4
							) {
								var o = 0.3 * i[n] + 0.59 * i[n + 1] + 0.11 * i[n + 2];
								(r[n] = r[n + 1] = r[n + 2] = o), (r[n + 3] = i[n + 3]);
							}
							return e;
						}),
						(Filters.grayscaleAvg = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height), r = e.data, i = t.data, n = 0;
								n < i.length;
								n += 4
							) {
								var o = 0.3333333333333333 * (i[n] + i[n + 1] + i[n + 2]);
								(r[n] = r[n + 1] = r[n + 2] = o), (r[n + 3] = i[n + 3]);
							}
							return e;
						}),
						(Filters.threshold = function (t, a, e, r) {
							var i = Filters.createImageData(t.width, t.height);
							null == e && (e = 255), null == r && (r = 0);
							for (var n = t.data, o = i.data, l = 0; l < n.length; l += 4) {
								var h = 0.3 * n[l] + 0.59 * n[l + 1] + 0.11 * n[l + 2] >= a ? e : r;
								(o[l] = o[l + 1] = o[l + 2] = h), (o[l + 3] = n[l + 3]);
							}
							return i;
						}),
						(Filters.invert = function (t) {
							for (
								var a = Filters.createImageData(t.width, t.height), e = t.data, r = a.data, i = 0;
								i < e.length;
								i += 4
							)
								(r[i] = 255 - e[i]),
									(r[i + 1] = 255 - e[i + 1]),
									(r[i + 2] = 255 - e[i + 2]),
									(r[i + 3] = e[i + 3]);
							return a;
						}),
						(Filters.brightnessContrast = function (t, a, e) {
							var r = this.brightnessContrastLUT(a, e);
							return this.applyLUT(t, { r: r, g: r, b: r, a: this.identityLUT() });
						}),
						(Filters.applyLUT = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height),
									r = t.data,
									i = e.data,
									n = a.r,
									o = a.g,
									l = a.b,
									h = a.a,
									s = 0;
								s < r.length;
								s += 4
							)
								(i[s] = n[r[s]]),
									(i[s + 1] = o[r[s + 1]]),
									(i[s + 2] = l[r[s + 2]]),
									(i[s + 3] = h[r[s + 3]]);
							return e;
						}),
						(Filters.createLUTFromCurve = function (t) {
							for (var a = this.getUint8Array(256), e = [0, 0], r = 0, i = 0; r < a.length; r++) {
								for (; i < t.length && t[i][0] < r; ) (e = t[i]), i++;
								a[r] = e[1];
							}
							return a;
						}),
						(Filters.identityLUT = function () {
							for (var t = this.getUint8Array(256), a = 0; a < t.length; a++) t[a] = a;
							return t;
						}),
						(Filters.invertLUT = function () {
							for (var t = this.getUint8Array(256), a = 0; a < t.length; a++) t[a] = 255 - a;
							return t;
						}),
						(Filters.brightnessContrastLUT = function (t, a) {
							for (
								var e = this.getUint8Array(256), r = -128 * a + 128 + 255 * t, i = 0;
								i < e.length;
								i++
							) {
								var n = i * a + r;
								e[i] = n < 0 ? 0 : n > 255 ? 255 : n;
							}
							return e;
						}),
						(Filters.convolve = function (t, a, e) {
							for (
								var r = Math.round(Math.sqrt(a.length)),
									i = Math.floor(r / 2),
									n = t.data,
									o = t.width,
									l = t.height,
									h = o,
									s = l,
									d = Filters.createImageData(h, s),
									u = d.data,
									f = e ? 1 : 0,
									g = 0;
								g < s;
								g++
							)
								for (var c = 0; c < h; c++) {
									for (
										var v = g, F = c, m = 4 * (g * h + c), w = 0, p = 0, M = 0, y = 0, b = 0;
										b < r;
										b++
									)
										for (var I = 0; I < r; I++) {
											var D =
													4 *
													(Math.min(l - 1, Math.max(0, v + b - i)) * o +
														Math.min(o - 1, Math.max(0, F + I - i))),
												C = a[b * r + I];
											(w += n[D] * C),
												(p += n[D + 1] * C),
												(M += n[D + 2] * C),
												(y += n[D + 3] * C);
										}
									(u[m] = w), (u[m + 1] = p), (u[m + 2] = M), (u[m + 3] = y + f * (255 - y));
								}
							return d;
						}),
						(Filters.verticalConvolve = function (t, a, e) {
							for (
								var r = a.length,
									i = Math.floor(r / 2),
									n = t.data,
									o = t.width,
									l = t.height,
									h = o,
									s = l,
									d = Filters.createImageData(h, s),
									u = d.data,
									f = e ? 1 : 0,
									g = 0;
								g < s;
								g++
							)
								for (var c = 0; c < h; c++) {
									for (
										var v = g, F = c, m = 4 * (g * h + c), w = 0, p = 0, M = 0, y = 0, b = 0;
										b < r;
										b++
									) {
										var I = 4 * (Math.min(l - 1, Math.max(0, v + b - i)) * o + F),
											D = a[b];
										(w += n[I] * D), (p += n[I + 1] * D), (M += n[I + 2] * D), (y += n[I + 3] * D);
									}
									(u[m] = w), (u[m + 1] = p), (u[m + 2] = M), (u[m + 3] = y + f * (255 - y));
								}
							return d;
						}),
						(Filters.horizontalConvolve = function (t, a, e) {
							for (
								var r = a.length,
									i = Math.floor(r / 2),
									n = t.data,
									o = t.width,
									l = o,
									h = t.height,
									s = Filters.createImageData(l, h),
									d = s.data,
									u = e ? 1 : 0,
									f = 0;
								f < h;
								f++
							)
								for (var g = 0; g < l; g++) {
									for (
										var c = f, v = g, F = 4 * (f * l + g), m = 0, w = 0, p = 0, M = 0, y = 0;
										y < r;
										y++
									) {
										var b = 4 * (c * o + Math.min(o - 1, Math.max(0, v + y - i))),
											I = a[y];
										(m += n[b] * I), (w += n[b + 1] * I), (p += n[b + 2] * I), (M += n[b + 3] * I);
									}
									(d[F] = m), (d[F + 1] = w), (d[F + 2] = p), (d[F + 3] = M + u * (255 - M));
								}
							return s;
						}),
						(Filters.separableConvolve = function (t, a, e, r) {
							return this.horizontalConvolve(this.verticalConvolveFloat32(t, e, r), a, r);
						}),
						(Filters.convolveFloat32 = function (t, a, e) {
							for (
								var r = Math.round(Math.sqrt(a.length)),
									i = Math.floor(r / 2),
									n = t.data,
									o = t.width,
									l = t.height,
									h = o,
									s = l,
									d = Filters.createImageDataFloat32(h, s),
									u = d.data,
									f = e ? 1 : 0,
									g = 0;
								g < s;
								g++
							)
								for (var c = 0; c < h; c++) {
									for (
										var v = g, F = c, m = 4 * (g * h + c), w = 0, p = 0, M = 0, y = 0, b = 0;
										b < r;
										b++
									)
										for (var I = 0; I < r; I++) {
											var D =
													4 *
													(Math.min(l - 1, Math.max(0, v + b - i)) * o +
														Math.min(o - 1, Math.max(0, F + I - i))),
												C = a[b * r + I];
											(w += n[D] * C),
												(p += n[D + 1] * C),
												(M += n[D + 2] * C),
												(y += n[D + 3] * C);
										}
									(u[m] = w), (u[m + 1] = p), (u[m + 2] = M), (u[m + 3] = y + f * (255 - y));
								}
							return d;
						}),
						(Filters.verticalConvolveFloat32 = function (t, a, e) {
							for (
								var r = a.length,
									i = Math.floor(r / 2),
									n = t.data,
									o = t.width,
									l = t.height,
									h = o,
									s = l,
									d = Filters.createImageDataFloat32(h, s),
									u = d.data,
									f = e ? 1 : 0,
									g = 0;
								g < s;
								g++
							)
								for (var c = 0; c < h; c++) {
									for (
										var v = g, F = c, m = 4 * (g * h + c), w = 0, p = 0, M = 0, y = 0, b = 0;
										b < r;
										b++
									) {
										var I = 4 * (Math.min(l - 1, Math.max(0, v + b - i)) * o + F),
											D = a[b];
										(w += n[I] * D), (p += n[I + 1] * D), (M += n[I + 2] * D), (y += n[I + 3] * D);
									}
									(u[m] = w), (u[m + 1] = p), (u[m + 2] = M), (u[m + 3] = y + f * (255 - y));
								}
							return d;
						}),
						(Filters.horizontalConvolveFloat32 = function (t, a, e) {
							for (
								var r = a.length,
									i = Math.floor(r / 2),
									n = t.data,
									o = t.width,
									l = o,
									h = t.height,
									s = Filters.createImageDataFloat32(l, h),
									d = s.data,
									u = e ? 1 : 0,
									f = 0;
								f < h;
								f++
							)
								for (var g = 0; g < l; g++) {
									for (
										var c = f, v = g, F = 4 * (f * l + g), m = 0, w = 0, p = 0, M = 0, y = 0;
										y < r;
										y++
									) {
										var b = 4 * (c * o + Math.min(o - 1, Math.max(0, v + y - i))),
											I = a[y];
										(m += n[b] * I), (w += n[b + 1] * I), (p += n[b + 2] * I), (M += n[b + 3] * I);
									}
									(d[F] = m), (d[F + 1] = w), (d[F + 2] = p), (d[F + 3] = M + u * (255 - M));
								}
							return s;
						}),
						(Filters.separableConvolveFloat32 = function (t, a, e, r) {
							return this.horizontalConvolveFloat32(this.verticalConvolveFloat32(t, e, r), a, r);
						}),
						(Filters.gaussianBlur = function (t, a) {
							if ((a = Math.abs(a)) <= 1) return Filters.identity(t);
							for (
								var e = a / 2,
									r = Math.ceil(a) + (1 - (Math.ceil(a) % 2)),
									i = this.getFloat32Array(r),
									n = (e + 0.5) / 3,
									o = n * n,
									l = 1 / Math.sqrt(2 * Math.PI * o),
									h = -1 / (2 * n * n),
									s = 0,
									d = Math.floor(r / 2),
									u = 0;
								u < r;
								u++
							) {
								var f = u - d,
									g = l * Math.exp(f * f * h);
								(i[u] = g), (s += g);
							}
							for (u = 0; u < i.length; u++) i[u] /= s;
							return Filters.separableConvolve(t, i, i, !1);
						}),
						(Filters.laplaceKernel = Filters.getFloat32Array([-1, -1, -1, -1, 8, -1, -1, -1, -1])),
						(Filters.laplace = function (t) {
							return Filters.convolve(t, this.laplaceKernel, !0);
						}),
						(Filters.sobelSignVector = Filters.getFloat32Array([-1, 0, 1])),
						(Filters.sobelScaleVector = Filters.getFloat32Array([1, 2, 1])),
						(Filters.sobelVerticalGradient = function (t) {
							return this.separableConvolveFloat32(t, this.sobelSignVector, this.sobelScaleVector);
						}),
						(Filters.sobelHorizontalGradient = function (t) {
							return this.separableConvolveFloat32(t, this.sobelScaleVector, this.sobelSignVector);
						}),
						(Filters.sobelVectors = function (t) {
							for (
								var a = this.sobelVerticalGradient(t),
									e = this.sobelHorizontalGradient(t),
									r = {
										width: a.width,
										height: a.height,
										data: this.getFloat32Array(a.width * a.height * 8),
									},
									i = a.data,
									n = e.data,
									o = r.data,
									l = 0,
									h = 0;
								l < o.length;
								l += 2, h++
							)
								(o[l] = n[h]), (o[l + 1] = i[h]);
							return r;
						}),
						(Filters.sobel = function (t) {
							t = this.grayscale(t);
							for (
								var a = this.sobelVerticalGradient(t),
									e = this.sobelHorizontalGradient(t),
									r = this.createImageData(a.width, a.height),
									i = 0;
								i < r.data.length;
								i += 4
							) {
								var n = Math.abs(a.data[i]);
								r.data[i] = n;
								var o = Math.abs(e.data[i]);
								(r.data[i + 1] = o), (r.data[i + 2] = (n + o) / 4), (r.data[i + 3] = 255);
							}
							return r;
						}),
						(Filters.bilinearSample = function (t, a, e, r) {
							var i = Math.floor(a),
								n = Math.ceil(a),
								o = Math.floor(e),
								l = Math.ceil(e),
								h = 4 * (i + t.width * o),
								s = 4 * (n + t.width * o),
								d = 4 * (i + t.width * l),
								u = 4 * (n + t.width * l),
								f = a - i + (e - o),
								g = n - a + (e - o),
								c = a - i + (l - e),
								v = n - a + (l - e),
								F = 1 / (v + c + g + f);
							(v *= F), (c *= F), (g *= F), (f *= F);
							var m = t.data;
							return (
								(r[0] = m[h] * v + m[s] * c + m[d] * g + m[u] * f),
								(r[1] = m[h + 1] * v + m[s + 1] * c + m[d + 1] * g + m[u + 1] * f),
								(r[2] = m[h + 2] * v + m[s + 2] * c + m[d + 2] * g + m[u + 2] * f),
								(r[3] = m[h + 3] * v + m[s + 3] * c + m[d + 3] * g + m[u + 3] * f),
								r
							);
						}),
						(Filters.distortSine = function (t, a, e) {
							null == a && (a = 0.5), null == e && (e = a);
							for (
								var r = this.createImageData(t.width, t.height),
									i = r.data,
									n = (t.data, this.createImageData(1, 1).data),
									o = 0;
								o < r.height;
								o++
							) {
								var l = o + (-Math.sin((o / (r.height - 1)) * Math.PI * 2) * e * r.height) / 4;
								l = Math.max(Math.min(l, r.height - 1), 0);
								for (var h = 0; h < r.width; h++) {
									var s = h + (-Math.sin((h / (r.width - 1)) * Math.PI * 2) * a * r.width) / 4;
									s = Math.max(Math.min(s, r.width - 1), 0);
									var d = this.bilinearSample(t, s, l, n),
										u = 4 * (o * r.width + h);
									(i[u] = d[0]), (i[u + 1] = d[1]), (i[u + 2] = d[2]), (i[u + 3] = d[3]);
								}
							}
							return r;
						}),
						(Filters.darkenBlend = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height),
									r = t.data,
									i = a.data,
									n = e.data,
									o = 0;
								o < r.length;
								o += 4
							)
								(n[o] = r[o] < i[o] ? r[o] : i[o]),
									(n[o + 1] = r[o + 1] < i[o + 1] ? r[o + 1] : i[o + 1]),
									(n[o + 2] = r[o + 2] < i[o + 2] ? r[o + 2] : i[o + 2]),
									(n[o + 3] = r[o + 3] + (255 - r[o + 3]) * i[o + 3] * 0.00392156862745098);
							return e;
						}),
						(Filters.lightenBlend = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height),
									r = t.data,
									i = a.data,
									n = e.data,
									o = 0;
								o < r.length;
								o += 4
							)
								(n[o] = r[o] > i[o] ? r[o] : i[o]),
									(n[o + 1] = r[o + 1] > i[o + 1] ? r[o + 1] : i[o + 1]),
									(n[o + 2] = r[o + 2] > i[o + 2] ? r[o + 2] : i[o + 2]),
									(n[o + 3] = r[o + 3] + (255 - r[o + 3]) * i[o + 3] * 0.00392156862745098);
							return e;
						}),
						(Filters.multiplyBlend = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height),
									r = t.data,
									i = a.data,
									n = e.data,
									o = 1 / 255,
									l = 0;
								l < r.length;
								l += 4
							)
								(n[l] = r[l] * i[l] * o),
									(n[l + 1] = r[l + 1] * i[l + 1] * o),
									(n[l + 2] = r[l + 2] * i[l + 2] * o),
									(n[l + 3] = r[l + 3] + (255 - r[l + 3]) * i[l + 3] * o);
							return e;
						}),
						(Filters.screenBlend = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height),
									r = t.data,
									i = a.data,
									n = e.data,
									o = 1 / 255,
									l = 0;
								l < r.length;
								l += 4
							)
								(n[l] = r[l] + i[l] - r[l] * i[l] * o),
									(n[l + 1] = r[l + 1] + i[l + 1] - r[l + 1] * i[l + 1] * o),
									(n[l + 2] = r[l + 2] + i[l + 2] - r[l + 2] * i[l + 2] * o),
									(n[l + 3] = r[l + 3] + (255 - r[l + 3]) * i[l + 3] * o);
							return e;
						}),
						(Filters.addBlend = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height),
									r = t.data,
									i = a.data,
									n = e.data,
									o = 0;
								o < r.length;
								o += 4
							)
								(n[o] = r[o] + i[o]),
									(n[o + 1] = r[o + 1] + i[o + 1]),
									(n[o + 2] = r[o + 2] + i[o + 2]),
									(n[o + 3] = r[o + 3] + (255 - r[o + 3]) * i[o + 3] * 0.00392156862745098);
							return e;
						}),
						(Filters.subBlend = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height),
									r = t.data,
									i = a.data,
									n = e.data,
									o = 0;
								o < r.length;
								o += 4
							)
								(n[o] = r[o] + i[o] - 255),
									(n[o + 1] = r[o + 1] + i[o + 1] - 255),
									(n[o + 2] = r[o + 2] + i[o + 2] - 255),
									(n[o + 3] = r[o + 3] + (255 - r[o + 3]) * i[o + 3] * 0.00392156862745098);
							return e;
						}),
						(Filters.differenceBlend = function (t, a) {
							for (
								var e = Filters.createImageData(t.width, t.height),
									r = t.data,
									i = a.data,
									n = e.data,
									o = 0;
								o < r.length;
								o += 4
							)
								(n[o] = Math.abs(r[o] - i[o])),
									(n[o + 1] = Math.abs(r[o + 1] - i[o + 1])),
									(n[o + 2] = Math.abs(r[o + 2] - i[o + 2])),
									(n[o + 3] = r[o + 3] + (255 - r[o + 3]) * i[o + 3] * 0.00392156862745098);
							return e;
						}),
						(Filters.erode = function (t) {
							for (
								var a = t.data,
									e = t.width,
									r = e,
									i = t.height,
									n = Filters.createImageData(r, i),
									o = n.data,
									l = 0;
								l < i;
								l++
							)
								for (var h = 0; h < r; h++) {
									var s = l,
										d = h,
										u = 4 * (l * r + h),
										f = 0;
									0 == a[4 * (s * e + d)]
										? 0 == a[4 * (s * e + Math.max(0, d - 1))] &&
										  0 == a[4 * (Math.max(0, s - 1) * e + d)] &&
										  (f = 255)
										: (f = 255),
										(o[u] = f),
										(o[u + 1] = f),
										(o[u + 2] = f),
										(o[u + 3] = 255);
								}
							return n;
						}),
						void 0 !== t && (e.Filters = Filters);
				},
				{},
			],
		},
		{},
		[1]
	)(1);
});
if ("undefined" == typeof mediaRecorder) {
}
class CardDetectorModel {
	constructor(t) {
		if (new.target === CardDetectorModel) throw new Error("Abstract Class cannot be instantiated.");
		this.modelUrl = t;
	}
	getModelUrl() {
		return this.modelUrl;
	}
}
class CardCatchModel extends CardDetectorModel {
	constructor(t) {
		super(t), this.catchModelLoadPromise;
	}
	async loadModel() {
		this.catchModelLoadPromise = await tf.loadGraphModel(this.getModelUrl());
	}
}
class CardBlurModel extends CardDetectorModel {
	constructor(t) {
		super(t), this.blurModelLoadPromise;
	}
	async loadBlurModel() {
		this.blurModelLoadPromise = await tf.loadGraphModel(this.getModelUrl());
	}
}
class CardLocationLines {
	constructor(t, e, a, i) {
		(this.top = t), (this.bottom = e), (this.left = a), (this.right = i);
	}
	getTop() {
		return this.top;
	}
	getBottom() {
		return this.bottom;
	}
	getLeft() {
		return this.left;
	}
	getRight() {
		return this.right;
	}
	isCompleted() {
		return null != this.top && null != this.bottom && null != this.left && null != this.right;
	}
	scaleBy(t) {
		null != this.top && this.top.scaleBy(t),
			null != this.bottom && this.bottom.scaleBy(t),
			null != this.left && this.left.scaleBy(t),
			null != this.right && this.right.scaleBy(t);
	}
}
class CardLocationPoints {
	constructor(t) {
		this.calculateByLines(t);
	}
	getLeftTop() {
		return this.leftTop;
	}
	getRightTop() {
		return this.rightTop;
	}
	getLeftBottom() {
		return this.leftBottom;
	}
	getRightBottom() {
		return this.rightBottom;
	}
	computeIntersect(t, e, a, i, o, r, n, s) {
		let c = (t - a) * (r - s) - (e - i) * (o - n);
		if (0 == c) return null;
		return new Point(
			((t * i - e * a) * (o - n) - (t - a) * (o * s - r * n)) / c,
			((t * i - e * a) * (r - s) - (e - i) * (o * s - r * n)) / c
		);
	}
	calculateByLines(t) {
		null != t.getTop() &&
			null != t.getLeft() &&
			(this.leftTop = this.computeIntersect(
				t.getTop().getP1().getX(),
				t.getTop().getP1().getY(),
				t.getTop().getP2().getX(),
				t.getTop().getP2().getY(),
				t.getLeft().getP1().getX(),
				t.getLeft().getP1().getY(),
				t.getLeft().getP2().getX(),
				t.getLeft().getP2().getY()
			)),
			null != t.getTop() &&
				null != t.getRight() &&
				(this.rightTop = this.computeIntersect(
					t.getTop().getP1().getX(),
					t.getTop().getP1().getY(),
					t.getTop().getP2().getX(),
					t.getTop().getP2().getY(),
					t.getRight().getP1().getX(),
					t.getRight().getP1().getY(),
					t.getRight().getP2().getX(),
					t.getRight().getP2().getY()
				)),
			null != t.getBottom() &&
				null != t.getLeft() &&
				(this.leftBottom = this.computeIntersect(
					t.getBottom().getP1().getX(),
					t.getBottom().getP1().getY(),
					t.getBottom().getP2().getX(),
					t.getBottom().getP2().getY(),
					t.getLeft().getP1().getX(),
					t.getLeft().getP1().getY(),
					t.getLeft().getP2().getX(),
					t.getLeft().getP2().getY()
				)),
			null != t.getBottom() &&
				null != t.getRight() &&
				(this.rightBottom = this.computeIntersect(
					t.getBottom().getP1().getX(),
					t.getBottom().getP1().getY(),
					t.getBottom().getP2().getX(),
					t.getBottom().getP2().getY(),
					t.getRight().getP1().getX(),
					t.getRight().getP1().getY(),
					t.getRight().getP2().getX(),
					t.getRight().getP2().getY()
				));
	}
	clone() {
		return new CardLocationPoints(leftTop.clone(), rightTop.clone(), leftBottom.clone(), rightBottom.clone());
	}
}
class detectCard {
	constructor(t = {}) {
		if ("undefined" == typeof CONFIG) throw new Error("Please include config.json file first");
		(navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia),
			this.canvasRef,
			this.videoRef,
			this.cropper,
			(this.selectedCamera = ""),
			(this.currentCardTypeForDetection = null),
			(this.useImageCapture = !0),
			(this.availableLanguages = ["tr", "en"]),
			(this.resultContainer = document.querySelector(".result")),
			(this.capture = !1),
			(this.isFirst = !0),
			(this.continueToShot = !0),
			(this.domain = CONFIG.domain),
			(this.url = this.domain + "/id/check/old-id"),
			(this.urlOCR = this.domain + "/id/ocr-with-parse"),
			(this.urlOCRForeign = this.domain + "/id/check/template-id-card"),
			(this.urlOCRForeignSecondary = this.domain + "/id/add-secondary-template"),
			(this.urlHolohram = this.domain + "/id/hologram"),
			(this.urlStart = this.domain + "/id/start"),
			(this.transactionId = ""),
			(this.token = CONFIG.token),
			(this.focusRate = CONFIG.focusRate),
			(this.validationMode = CONFIG.validationMode || "cloud"),
			this.lastRecordedBase64,
			this.calculationTime,
			this.timeout,
			(this.currentCardType = ""),
			(this.isMobile = !1),
			(this.isBackCamera = !0),
			(this.debug = CONFIG.debug),
			(this.gestureType = ""),
			(this.fps = 0),
			(this.lang = "tr"),
			(this.stream_width = ""),
			(this.stream_height = ""),
			(this.boundingBoxMargin = 0),
			(this.shotType = "grab"),
			(this.realTimeCrop = !1),
			(this.method = "OD"),
			(this.conitinueToRecord = !0),
			(this.countFrom = CONFIG.countFrom),
			(this.countWhileReacording = CONFIG.countWhileReacording),
			(this.timeInterval = 1200 * this.countWhileReacording),
			(this.version = "1.0.0"),
			(this.cardNotFound = !1),
			(this.MODEL_INPUT_SIZE_WIDTH = 384),
			(this.MODEL_INPUT_SIZE_HEIGHT = 384),
			(this.checkForStability = !0),
			(this.lastStabilityCheckTime = null),
			(this.lastRightBottom = null),
			(this.lastLeftTop = null),
			(this.isCardStable = !1),
			(this.blurThreshold = 0.8),
			(this.checkBlur = !0),
			(this.askForSecondary = !0),
			(this.cameraIsOK = !1),
			(this.minimumCameraWidth = 1920),
			(this.showStepper = !0),
			(this.showResultsImmediately = !1),
			(this.currentCountry = null),
			(this.currentCountryBack = null),
			(this.isBack = !1),
			(this.frameCount = 0),
			(this.frameRatioMod = 6),
			(this.theme = ""),
			(this.blurCorrectionThresholdTimes = 5),
			(this.blurTry = 0),
			(this.cardCatchModel = new CardCatchModel("./assets/model/model.json")),
			(this.cardBlurModel = new CardBlurModel("./assets/model/blur/model.json")),
			(this.CARDCONFIG = {
				OLDIDCARD: {
					minRatio: 0.6,
					maxRatio: 0.9,
					openCVRatio: 1.35,
					marginRatio: 0.035,
					angleErrorRatio: 1,
					lineErrorRatio: 1,
				},
				IDCARD: {
					minRatio: 1.46,
					maxRatio: 1.76,
					openCVRatio: 0.63,
					marginRatio: 0.014,
					angleErrorRatio: 2,
					lineErrorRatio: 1,
				},
				PASSPORT: {
					minRatio: 1.29,
					maxRatio: 1.57,
					openCVRatio: 0.69,
					marginRatio: 0.014,
					angleErrorRatio: 2,
					lineErrorRatio: 0.66,
				},
				DRIVERCARD: {
					minRatio: 1.46,
					maxRatio: 1.76,
					openCVRatio: 0.63,
					marginRatio: 0.014,
					angleErrorRatio: 2,
					lineErrorRatio: 1,
				},
				FOREIGNID: {
					minRatio: 1.46,
					maxRatio: 1.76,
					openCVRatio: 0.63,
					marginRatio: 0.014,
					angleErrorRatio: 2,
					lineErrorRatio: 1,
				},
				FOREIGNIDBACK: {
					minRatio: 1.46,
					maxRatio: 1.76,
					openCVRatio: 0.63,
					marginRatio: 0.014,
					angleErrorRatio: 2,
					lineErrorRatio: 1,
				},
				IDBACKDRIVER: {
					minRatio: 1.46,
					maxRatio: 1.76,
					openCVRatio: 0.63,
					marginRatio: 0.014,
					angleErrorRatio: 2,
					lineErrorRatio: 1,
				},
				IDBACKID: {
					minRatio: 1.46,
					maxRatio: 1.76,
					openCVRatio: 0.63,
					marginRatio: 0.014,
					angleErrorRatio: 2,
					lineErrorRatio: 1,
				},
				TYPEFREE: {
					minRatio: 1.46,
					maxRatio: 1.76,
					openCVRatio: 0.63,
					marginRatio: 0.014,
					angleErrorRatio: 2,
					lineErrorRatio: 1,
				},
			});
		const e = window.location.search,
			a = new URLSearchParams(e);
		a.get("token") && "" !== a.get("token") && (this.token = decodeURIComponent(a.get("token"))),
			a.get("theme") && "" !== a.get("theme") && (this.theme = decodeURIComponent(a.get("theme"))),
			a.get("transactionId") &&
				"" !== a.get("transactionId") &&
				null != a.get("transactionId") &&
				(this.transactionId = decodeURIComponent(a.get("transactionId"))),
			a.get("selectedCamera") &&
				"" !== a.get("selectedCamera") &&
				null != a.get("selectedCamera") &&
				(this.selectedCamera = decodeURIComponent(a.get("selectedCamera"))),
			a.get("isBackCamera") &&
				"" !== a.get("isBackCamera") &&
				null != a.get("isBackCamera") &&
				(this.isBackCamera = decodeURIComponent(a.get("isBackCamera"))),
			(this.canRecord = !0),
			(this.ratioOverlay = 0.4),
			!0 === this.isMobileOrNot() &&
				((this.ratioOverlay = 0.9), (this.ratioOverlay = 0.9), (this.blurThreshold = 0.8)),
			void 0 !== t.lang && this.availableLanguages.includes(t.lang) && (this.lang = t.lang),
			console.log(1, a),
			console.log(2, a.get("lg")),
			console.log(3, this.availableLanguages.includes(a.get("lg"))),
			console.log(4, this.lang),
			a.get("lg") && this.availableLanguages.includes(a.get("lg")) && (this.lang = a.get("lg")),
			console.log(5, this.lang),
			a.get("country") && "" !== a.get("country") && (this.currentCountry = decodeURIComponent(a.get("country"))),
			a.get("countryBack") &&
				"" !== a.get("countryBack") &&
				(this.currentCountryBack = decodeURIComponent(a.get("countryBack"))),
			a.get("isBack") && "" !== a.get("isBack") && "true" == a.get("isBack") && (this.isBack = !0),
			console.log(6, this.lang);
		try {
			$("body").html(
				'<section class="modal-portrait"><div><img src="./assets/images/rotate.svg" style="width: 40%;max-width: 200px;"/></br>' +
					CONFIG.staticText[this.lang].please_keep_potrait +
					'</div></section><div class="fullscreen-modal"><div><img src="./assets/images/detection.png"/><div>' +
					CONFIG.staticText[this.lang].loading_model +
					'</div></div></div><div class="logo" style="display: none"><img src="./assets/images/proveid.svg" ><select id="select" style="float: right;display: none;\n    margin: 10px;">\n  <option></option>\n</select></div><div class="stepper"> <div class="wrapper-progressBar"> <ul class="progressBar">\n        <li class="active">' +
					CONFIG.staticText[this.lang].read_card +
					'</li>\n        <li id="back-stepper" style="display: none">' +
					CONFIG.staticText[this.lang].read_card_back +
					'</li>\n        <li class="">' +
					CONFIG.staticText[this.lang].introduce_face +
					"</li>\n        <li>" +
					CONFIG.staticText[this.lang].results +
					'</li>\n      </ul></div></div>\n<div id="ratio"></div><div class="result"><img id="shot" style="visibility: none"/></div>\n\n<div class="result-ocr">\n</div>\n\n<div style="position:absolute;right:7px;top: 25px">\n    <p id="blur_score"></p>\n    <p id="calculation_time"></p>\n</div><div id="result-modal" class="modal">\n\n  \x3c!-- Modal content --\x3e\n  <div class="modal-content">\n    \x3c!--<span class="close" onclick="$(\'#result-modal\').hide();">&times;</span>--\x3e\n    <p class="inner-result"></p>\n  </div>\n\n</div>\n<div id="video-container" style="position:relative;margin:0 auto;"><div class="overlay"></div>\n    <div id="cameras"></div>\n    <img class="spinner" src="./assets/images/spinner.png"/>\n    <video\n             poster="" id="video"\n            autoPlay\n            playsinline\n            muted\n    ></video>\n<canvas id="counter" style="z-index: 9999999;position: absolute;left:0;top:0"></canvas>\n    <canvas id="canvas" style="z-index: 9999999;position: absolute;left:0;top:0"></canvas>\n \n    <canvas id="captured" style="display:none;"><canvas id="cropped_last" style="display:none;"></canvas><canvas id="cropped" style="display:none;"></canvas>\n</div>\n    <div id="buttons">\n       <button id="take-snapshot" onClick="detectCardNow.captureImage()" lang="en" style="display: none;">Capture Card</button>\n    </div>\n<div id="ratio-result"></div>\n<div id="transaction"></div><div class="notify warning"></div>'
			),
				!0 === this.isMobileOrNot() && $(".notify").width(window.innerWidth - 30),
				$("body").height(window.innerHeight),
				$("body").width(window.innerWidth),
				"cloud" === this.validationMode
					? $(".logo").show()
					: ($(".notify").addClass("standalone-notify"), $(".logo").remove()),
				!1 === this.debug && $(".result img").hide(),
				this.method;
		} catch (t) {
			alert(t);
		}
		t.idType && (this.currentCardType = t.idType),
			void 0 !== t.debug && (this.debug = t.debug),
			a.get("cardType") && (this.currentCardType = a.get("cardType")),
			"OLDIDCARD" === this.currentCardType && (this.ratioOverlay = 0.32),
			(this.counter = document.getElementById("counter")),
			this.initCardDetection(),
			(window.cardDetection = this),
			this.cardCatchModel.loadModel();
	}
	showAlert(t, e = null, a = !1) {
		$(".notify").html(t),
			$(".notify").removeClass("danger").removeClass("info").removeClass("warning"),
			null !== e ? $(".notify").addClass(e) : $(".notify").addClass("warning"),
			$(".notify").is(":visible") ? clearTimeout(this.timeout) : $(".notify").toggle(),
			a
				? clearTimeout(this.timeout)
				: (this.timeout = setTimeout(function () {
						$(".notify").fadeOut();
				  }, 6e4));
	}
	onGetResult(t) {
		console.log(t);
	}
	goToFaceDetection(t = !1) {
		var e = this;
		!0 === this.askForSecondary &&
		!1 === t &&
		("IDCARD" === this.currentCardType ||
			("FOREIGNID" === this.currentCardType && null !== this.currentCountryBack))
			? ("IDCARD" === this.currentCardType
					? (this.currentCardType = "IDBACKID")
					: (this.currentCardType = null !== this.currentCountryBack) &&
					  (this.currentCardType = "FOREIGNIDBACK"),
			  $("#back-stepper").addClass("active"),
			  $("#demo").hide(),
			  $("#canvas").show(),
			  this.showAlert(CONFIG.staticText[this.lang].show_secondary, "warning"),
			  $("#result-modal").hide(),
			  setTimeout(function () {
					e.continueAgain();
			  }, 3e3))
			: !0 !== CONFIG.requestHologram ||
			  !1 !== t ||
			  ("DRIVERCARD" !== this.currentCardType && "IDCARD" !== this.currentCardType)
			? "cloud" === e.validationMode
				? !1 === CONFIG.isCombined
					? (window.location =
							window.location.origin +
							CONFIG.redirectToFaceUrl +
							"?transactionId=" +
							this.transactionId +
							"&gestureType=" +
							this.gestureType +
							"&token=" +
							encodeURIComponent(this.token) +
							"&lg=" +
							this.lang +
							"&cardType=" +
							this.currentCardType +
							"&theme=" +
							this.theme)
					: new detectFace({
							debug: !1,
							gestureType: e.gestureType,
							transactionId: e.transactionId,
							token: e.token,
							scannedBack: "IDBACKID" === e.currentCardType,
							lang: "tr",
					  })
				: e.onGetResult(sessionStorage)
			: (this.getHologramVideo(), $("#result-modal").hide());
	}
	getTimeLength(t) {
		var e = new Date(t);
		return this.countWhileReacording + 1 - e.getUTCSeconds();
	}
	getMobileOperatingSystem() {
		var t = navigator.userAgent || navigator.vendor || window.opera;
		return /windows phone/i.test(t)
			? "Windows Phone"
			: /android/i.test(t)
			? "Android"
			: /iPad|iPhone|iPod/.test(t) && !window.MSStream
			? "iOS"
			: "unknown";
	}
	onRecordSuccess(t, e) {
		document.createElement("a");
		this.sendHologram(e);
	}
	startAgain(t = !1) {
		window.location.reload();
	}
	continue() {
		return "TYPEFREE" === this.currentCardType ? detectCardNow.continueAgain() : detectCardNow.startAgain();
	}
	sendToOCR(t) {
		var e = this;
		e.showAlert("Waiting for OCR results...");
		let a = {};
		null === e.currentCountry &&
			(a = {
				rawImage: t.replace("data:image/png;base64,", ""),
				cardWidthRatio: 0,
				cardHeightRatio: 0,
				returnCroppedCard: !0,
			}),
			"TYPEFREE" !== e.currentCardType ? (a.idType = e.currentCardType) : (a.transactionId = e.transactionId),
			$.ajax({
				contentType: "application/json",
				type: "POST",
				url: e.urlOCR,
				beforeSend: function (t, a) {
					//t.setRequestHeader("Authorization", "Bearer " + e.token);
				},
				data: JSON.stringify(a),
				success: function (t) {
					if (($(".spinner").hide(), $(".notify").fadeOut(), !0 === e.debug))
						alert(JSON.stringify(t)),
							$("#shot").show(),
							$(".result").prepend(
								"<button onclick=\"window.location = '" +
									CONFIG.redirectToFaceUrl +
									"?transactionId=" +
									e.transactionId +
									"&gestureType=" +
									e.gestureType +
									"'\">Face Detection</button>"
							);
					else
						try {
							if (null !== e.currentCountry) {
								var a = $("#shot").clone();
								"IDBACKID" !== e.currentCardType
									? (sessionStorage.setItem("card_result_front", JSON.stringify(t)),
									  sessionStorage.setItem("card_result_front_image", JSON.stringify(a[0].src)))
									: (sessionStorage.setItem("card_result_back", JSON.stringify(t)),
									  sessionStorage.setItem("card_result_back_image", JSON.stringify(a[0].src))),
									e.goToFaceDetection();
							} else {
								e.gestureType = t.parsedData.gestureType;
								var i =
									'<table><tr><td colspan="2" id="img-container"></td></tr><tr><td class="title">' +
									CONFIG.staticText[e.lang].identity_no +
									": </td><td>" +
									t.parsedData.capturedData.id +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[e.lang].name +
									": </td><td>" +
									t.parsedData.capturedData.name +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[e.lang].surname +
									": </td><td>" +
									t.parsedData.capturedData.sname +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[e.lang].birthdate +
									": </td><td>" +
									t.parsedData.capturedData.bdat +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[e.lang].document_no +
									": </td><td>" +
									t.parsedData.capturedData.sno +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[e.lang].valid_until +
									": </td><td>" +
									t.parsedData.capturedData.edat +
									"</td></tr>";
								"" !== t.parsedData.capturedData.nat &&
									(i +=
										'<tr><td class="title">' +
										CONFIG.staticText[e.lang].nationality +
										": </td><td>" +
										t.parsedData.capturedData.nat +
										"</td></tr>"),
									(i +=
										'<tr><td colspan="2" class="title" style="text-align: center;padding: 10px; font-weight: bold">' +
										CONFIG.staticText[e.lang].controls +
										"</td></tr>");
								var o = "";
								t.parsedData.controlResults.map(function (t, a) {
									o +=
										'<tr><td class="title">' +
										CONFIG.staticText[e.lang][t.entryType] +
										": </td><td>" +
										parseFloat(t.entryScore).toFixed(2) +
										"</td></tr>";
								});
								var r =
									'<tr><td colspan="2" class="title" style="text-align: center;padding: 10px"><hr/></td></tr>';
								(r +=
									'<tr><td class="title" width="50%"><button onclick="detectCardNow.continueAgain()" class="buttons" style="color:#F59428;background-color: #fff">' +
									CONFIG.staticText[e.lang].repeat +
									'</button></td><td><button width="50%"  style="background-color: #F59428" onclick="detectCardNow.continue()" class="buttons">' +
									("TYPEFREE" === e.currentCardType
										? CONFIG.staticText[e.lang].continue_back
										: CONFIG.staticText[e.lang].continue) +
									"</button></td></tr>"),
									"TYPEFREE" === e.currentCardType &&
										(r +=
											'<tr><td class="title" style="transform: translateX(50%);"><button onclick="detectCardNow.startAgain(true)" class="buttons" style="color:#F59428;background-color: #fff;border: none;text-decoration: underline;">' +
											CONFIG.staticText[e.lang].try +
											"</button></td></tr>"),
									$(".inner-result").html(i + o + r);
								a = `<img src="data:image/png;base64,${t.cropResult.croppedImage}"></img>`;
								$("#img-container").append(a), (e.cardNotFound = !1), $("#result-modal").show();
							}
						} catch (t) {
							e.cardNotFound = !0;
						}
				},
				error: function (t) {
					!0 === e.debug && alert(JSON.stringify(t)),
						(e.continueToShot = !0),
						void 0 !== t.responseJSON.message &&
							"cloud" === e.validationMode &&
							e.showAlert(t.responseJSON.message, "danger"),
						(e.cardNotFound = !0),
						e.continueAgain();
				},
			});
	}
	async sendHologram(t) {
		var e = this;
		$(".spinner").show(), $(".backdrop").show();
		try {
			e.mediaStreamTrack.applyConstraints({ advanced: [{ torch: !1 }] });
		} catch (t) {
			console.log(t);
		}
		"cloud" === e.validationMode &&
			e.showAlert(CONFIG.staticText[e.lang].processing_video, "success", "processing_video"),
			$.ajax({
				contentType: "application/json",
				type: "POST",
				url: e.urlHolohram,
				beforeSend: function (t, a) {
					//t.setRequestHeader("Authorization", "Bearer " + e.token);
				},
				data: JSON.stringify({
					transactionId: e.transactionId,
					cardType:
						"DRIVERCARD" === e.currentCardType
							? "NEW-DRIVER"
							: "IDCARD" === e.currentCardType
							? "NEW-ID"
							: "",
					video: t.replace("data:video/mp4;base64,", "").replace("data:video/webm;base64,", ""),
					rotate: "iOS" === e.getMobileOperatingSystem() ? 90 : 0,
				}),
				success: function (t) {
					$(".notify").hide();
					try {
						if (!0 === e.debug)
							$("#videos-container").append(JSON.stringify(t)), (e.conitinueToRecord = !0);
						else {
							var a = "<table>";
							t.controlResults.map(function (t, i) {
								a +=
									'<tr><td class="title">' +
									CONFIG.staticText[e.lang][t.entryType] +
									": </td><td>" +
									t.entryScore +
									"</td></tr>";
							});
							var i =
								'<tr><td colspan="2" class="title" style="text-align: center;padding: 10px"><hr/></td></tr>';
							(i +=
								'<tr><td class="title" width="50%"><button onclick="cardDetection.goToFaceDetection()" class="buttons" style="color:#F59428;background-color: #fff">' +
								CONFIG.staticText[e.lang].repeat +
								'</button></td><td width="50%"><button style="background-color: #F59428" onclick="cardDetection.goToFaceDetection(true)" class="buttons">' +
								CONFIG.staticText[e.lang].continue +
								"</button></td></tr></table>"),
								$(".inner-result").html(a + "" + i),
								$("#result-modal").show();
						}
						(e.canRecord = !0),
							$(".spinner").hide(),
							$(".backdrop").hide(),
							setTimeout(function () {
								$(".notify").hide();
							}, 1e4);
					} catch (t) {
						$(".notify").hide();
					}
				},
				error: function (t) {
					(e.conitinueToRecord = !0),
						$(".notify").hide(),
						$(".spinner").hide(),
						$(".backdrop").hide(),
						(e.canRecord = !0),
						!0 === e.debug ? alert(JSON.stringify(t)) : alert(CONFIG.staticText[e.lang].liveness_error),
						void 0 !== t.responseJSON.message &&
							!0 === e.debug &&
							($("#videos-container").append(t.responseJSON.message), alert(t.responseJSON.message)),
						setTimeout(function () {
							$(".notify").hide();
						}, 1e4);
				},
			});
	}
	_arrayBufferToBase64(t) {
		for (var e = "", a = new Uint8Array(t), i = a.byteLength, o = 0; o < i; o++) e += String.fromCharCode(a[o]);
		return window.btoa(e);
	}
	getHologramVideo() {
		(context = this),
			(mediaRecorder = new MediaStreamRecorder(stream)),
			(mediaRecorder.stream = stream),
			(mediaRecorder.videoWidth = 240),
			(mediaRecorder.videoHeight = 180),
			(mediaRecorder.onstop = async (t) => {
				var e,
					a = this;
				if (!0 === a.sendVideoNow)
					if ("iOS" === a.getMobileOperatingSystem()) {
						var i = new FileReader();
						(i.onload = function (t) {
							e = t.target.result;
							ffmpeg_run({
								arguments: "-t 5 -nostdin -i video.webm -c:v copy output.mp4".split(" "),
								files: [{ data: new Uint8Array(e), name: "video.webm" }],
							}).forEach(async function (t) {
								var e = await a._arrayBufferToBase64(t.data);
								a.onRecordSuccess(a.lastRecordedBlob, e);
							});
						}),
							i.readAsArrayBuffer(a.lastRecordedBlob);
					} else {
						var o = await a.blobToBase64(a.lastRecordedBlob);
						a.onRecordSuccess(a.lastRecordedBlob, o);
					}
			}),
			(mediaRecorder.ondataavailable = async function (t) {
				!0 === context.recording
					? ($(".backdrop").show(),
					  (context.lastRecordedBlob = t),
					  (context.conitinueToRecord = !1),
					  (context.sendVideoNow = !0),
					  context.stopRecording(),
					  (context.lastRecordedBlobUrl = window.URL.createObjectURL(context.lastRecordedBlob)))
					: (context.sendVideoNow = !1);
			}),
			$(".spinner").hide(),
			$(".backdrop").hide(),
			(context.lastTime = +new Date()),
			(this.recording = !0);
		try {
			mediaRecorder.clearOldRecordedFrames();
		} catch (t) {
			console.log(t);
		}
		(context.canvasRef = document.getElementById("canvas")),
			(context.counter.width = context.canvasRef.width),
			(context.counter.height = context.canvasRef.height),
			context.countToZero(context);
	}
	countToZero(t) {
		try {
			t.mediaStreamTrack.applyConstraints({ advanced: [{ torch: !0 }] });
			var e = t.counter.getContext("2d");
			e.clearRect(0, 0, t.counter.width, t.counter.height),
				(t.lastTime = +new Date()),
				(t.waitForShot = setInterval(function () {
					"cloud" === t.validationMode &&
						t.showAlert(CONFIG.staticText[t.lang].show_card_hologram, "warning", "keep_face"),
						e.clearRect(0, 0, t.counter.width, t.counter.height),
						(e.font = "96px Arial"),
						(e.fillStyle = CONFIG.elipseColor),
						(e.textAlign = "center"),
						e.fillText(
							t.countFrom + 1 - ~~((+new Date() - t.lastTime) / 1e3),
							t.counter.width / 2,
							t.counter.height / 2
						),
						(e.font = "32px Arial"),
						e.fillText(CONFIG.staticText[t.lang].starting, t.counter.width / 2, t.counter.height / 2 + 60),
						t.countFrom - ~~((+new Date() - t.lastTime) / 1e3) < 0 &&
							!0 === t.canRecord &&
							(e.clearRect(0, 0, t.counter.width, t.counter.height),
							clearTimeout(t.waitForShot),
							(t.canRecord = !1),
							t.startRecording(t));
				}, 1e3));
		} catch (t) {
			console.log(t);
		}
	}
	startRecording(t) {
		(t.lastTime = +new Date()), mediaRecorder.start(t.timeInterval);
		var e = t.counter.getContext("2d");
		t.videoLengthInt = setInterval(function () {
			t.getTimeLength(+new Date() - t.lastTime);
			e.clearRect(0, 0, t.counter.width, t.counter.height),
				(e.font = "96px Arial"),
				(e.fillStyle = CONFIG.recordingTextColor),
				(e.textAlign = "center"),
				t.countWhileReacording - ~~((+new Date() - t.lastTime) / 1e3) > 0 &&
					((e.font = "32px Arial"),
					e.fillText(CONFIG.staticText[t.lang].recording, t.counter.width / 2, t.counter.height / 2 + 60),
					(e.font = "96px Arial"),
					e.fillText(
						t.countWhileReacording - ~~((+new Date() - t.lastTime) / 1e3),
						t.counter.width / 2,
						t.counter.height / 2
					));
		}, 1e3);
	}
	stopRecording() {
		(this.recording = !1),
			this.counter.getContext("2d").clearRect(0, 0, this.counter.width, this.counter.height),
			clearInterval(this.videoLengthInt),
			mediaRecorder.stop();
	}
	resetCounting(t) {
		(this.counting = !1),
			!0 === this.recording && this.stopRecording(),
			clearTimeout(this.waitForShot),
			(this.waitForShot = null),
			counter.getContext("2d").clearRect(0, 0, t.counter.width, t.counter.height);
	}
	continueAgain() {
		document.getElementById("video").play(),
			(this.continueToShot = !0),
			(this.capture = !0),
			$("#result-modal").hide(),
			"TYPEFREE" === this.currentCardType
				? this.startVideoCam()
				: this.detectFromVideoFrame(this.cardCatchModel.catchModelLoadPromise, this.videoRef);
	}
	async sendImage() {
		var t = this,
			e = t.lastRecordedBase64;
		t.token;
		switch (this.currentCardType) {
			case "OLDIDCARD":
				t.url = t.domain + "/id/check/old-id";
				break;
			case "IDCARD":
				t.url = t.domain + "/id/check/new-id";
				break;
			case "PASSPORT":
				t.url = t.domain + "/id/check/passport";
				break;
			case "DRIVERCARD":
				t.url = t.domain + "/id/check/new-driver";
				break;
			case "IDBACKDRIVER":
			case "IDBACKID":
				t.url = t.domain + "/id/add-secondary";
				break;
			case "FOREIGNID":
				t.url = t.urlOCRForeign;
				break;
			case "FOREIGNIDBACK":
				t.url = t.urlOCRForeignSecondary;
		}
		let a = { transactionId: t.transactionId, img: e.replace("data:image/png;base64,", "") };
		"IDBACKDRIVER" === this.currentCardType && (a.idType = "DRIVERCARD"),
			"IDBACKID" === this.currentCardType &&
				(a = { transactionID: t.transactionId, image: e.replace("data:image/png;base64,", "") }),
			"FOREIGNID" === this.currentCardType && "" !== this.currentCountry && "null" != this.currentCountry
				? (a.templateName = t.currentCountry)
				: "FOREIGNIDBACK" === this.currentCardType &&
				  "" !== this.currentCountryBack &&
				  "null" != this.currentCountryBack &&
				  ((a.template = t.currentCountryBack),
				  (a.image = e.replace("data:image/png;base64,", "")),
				  delete a.img),
			(a.imageCorrectionRotationOnly = !1),
			$(".spinner").show(),
			t.ctx_overlay.clearRect(0, 0, this.canvas_overlay.width, this.canvas_overlay.height),
			$.ajax({
				contentType: "application/json",
				type: "POST",
				url: t.url,
				beforeSend: function (e, a) {
					//e.setRequestHeader("Authorization", "Bearer " + t.token);
				},
				data: JSON.stringify(a),
				success: function (e) {
					$(".result-ocr").html("");
					var a = $("#shot").clone();
					if (
						("IDBACKID" !== t.currentCardType && "FOREIGNIDBACK" !== t.currentCardType
							? (sessionStorage.setItem("card_result_front", JSON.stringify(e)),
							  sessionStorage.setItem("card_result_front_image", JSON.stringify(a[0].src)))
							: (sessionStorage.setItem("card_result_back", JSON.stringify(e)),
							  sessionStorage.setItem("card_result_back_image", JSON.stringify(a[0].src))),
						e.gestureType && (t.gestureType = e.gestureType),
						$(".spinner").hide(),
						!0 === t.debug)
					)
						alert(JSON.stringify(e)),
							$("#shot").show(),
							$(".result").prepend(
								"<button onclick=\"window.location = '" +
									CONFIG.redirectToFaceUrl +
									"?transactionId=" +
									t.transactionId +
									"&gestureType=" +
									t.gestureType +
									"'\">Face Detection</button>"
							);
					else
						try {
							if (!0 === t.showResultsImmediately) {
								var i =
									'<table><tr><td colspan="2" id="img-container"></td></tr><tr><td class="title">' +
									CONFIG.staticText[t.lang].identity_no +
									": </td><td>" +
									e.capturedData.id +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[t.lang].name +
									": </td><td>" +
									e.capturedData.name +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[t.lang].surname +
									": </td><td>" +
									e.capturedData.sname +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[t.lang].birthdate +
									": </td><td>" +
									e.capturedData.bdat +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[t.lang].document_no +
									": </td><td>" +
									e.capturedData.sno +
									'</td></tr><tr><td class="title">' +
									CONFIG.staticText[t.lang].valid_until +
									": </td><td>" +
									e.capturedData.edat +
									"</td></tr>";
								"" !== e.capturedData.nat &&
									(i +=
										'<tr><td class="title">' +
										CONFIG.staticText[t.lang].nationality +
										": </td><td>" +
										e.capturedData.nat +
										"</td></tr>"),
									(i +=
										'<tr><td colspan="2" class="title" style="text-align: center;padding: 10px; font-weight: bold">' +
										CONFIG.staticText[t.lang].controls +
										"</td></tr>");
								var o = "";
								e.controlResults.map(function (e, a) {
									o +=
										'<tr><td class="title">' +
										CONFIG.staticText[t.lang][e.entryType] +
										": </td><td>" +
										parseFloat(e.entryScore).toFixed(2) +
										"</td></tr>";
								});
								var r =
									'<tr><td colspan="2" class="title" style="text-align: center;padding: 10px"><hr/></td></tr>';
								(r +=
									'<tr><td class="title" width="50%"><button onclick="cardDetection.continueAgain()" class="buttons" style="color:#F59428;background-color: #fff">' +
									CONFIG.staticText[t.lang].repeat +
									'</button></td><td><button width="50%"  style="background-color: #F59428" onclick="cardDetection.goToFaceDetection()" class="buttons">' +
									CONFIG.staticText[t.lang].continue +
									"</button></td></tr>"),
									$(".inner-result").html(i + o + r),
									$("#img-container").append(a),
									$("#result-modal").show();
							} else t.goToFaceDetection();
						} catch (t) {
							alert(t);
						}
				},
				error: function (e) {
					$(".spinner").hide(),
						!0 === t.debug && alert(JSON.stringify(e)),
						(t.continueToShot = !0),
						void 0 !== e.responseJSON.message &&
							"cloud" === t.validationMode &&
							t.showAlert(e.responseJSON.message, "danger"),
						setTimeout(function () {
							t.detectFromVideoFrame(t.cardCatchModel.catchModelLoadPromise, t.videoRef);
						}, 5e3);
				},
			});
	}
	showScore(t) {
		return t.avg_edge_width_perc.toFixed(2);
	}
	fromValue(t) {
		switch (t) {
			case 0:
			default:
				(t = "NO_CARD"), (this.currentCardTypeForDetectionConfirm = null);
				break;
			case 1:
				(t = "UNKNOWN"), (this.currentCardTypeForDetectionConfirm = "FOREIGNID");
				break;
			case 2:
				(t = "PASSPORT"), (this.currentCardTypeForDetectionConfirm = "PASSPORT");
				break;
			case 3:
				(t = "PAPER"), (this.currentCardTypeForDetectionConfirm = "PAPER");
				break;
			case 4:
				(t = "TURKISH_ID_FRONT"), (this.currentCardTypeForDetectionConfirm = "IDCARD");
				break;
			case 5:
				(t = "TURKISH_ID_BACK"), (this.currentCardTypeForDetectionConfirm = "IDBACKID");
				break;
			case 6:
				(t = "TURKISH_DRIVER_LICENSE_FRONT"), (this.currentCardTypeForDetectionConfirm = "DRIVERCARD");
				break;
			case 7:
				(t = "TURKISH_DRIVER_LICENSE_BACK"), (this.currentCardTypeForDetectionConfirm = "IDBACKDRIVER");
				break;
			case 8:
				(t = "TURKISH_OLD_ID_FRONT"), (this.currentCardTypeForDetectionConfirm = "OLDIDCARD");
				break;
			case 9:
				(t = "TURKISH_OLD_ID_BACK"), (this.currentCardTypeForDetectionConfirm = "IDBACKOLDID");
		}
		return t;
	}
	calculateAngle(t, e) {
		Math.atan2(e.y - t.y, e.x - t.x);
		return (180 * Math.atan2(e.y - t.y, e.x - t.x)) / Math.PI;
	}
	argmax(t) {
		let e = Number.MIN_VALUE,
			a = -1;
		for (let i = 0; i < t.length; i++) t[i] > e && ((e = t[i]), (a = i));
		return a;
	}
	secondsAgo(t) {
		return Math.round(new Date().getTime() / 1e3) - new Date(t).getTime() / 1e3;
	}
	async checkForCardStability(t, e) {
		const a = this;
		new Promise((i, o) => {
			null === a.lastRightBottom &&
				null === a.lastLeftTop &&
				((a.lastStabilityCheckTime = +new Date()),
				(a.lastRightBottom = t),
				(a.lastLeftTop = e),
				(a.isCardStable = !1),
				i()),
				!1 === a.checkForStability
					? ((a.isCardStable = !0), i())
					: null !== a.lastRightBottom &&
					  null !== a.lastLeftTop &&
					  a.secondsAgo(this.lastStabilityCheckTime) >= 1.5 &&
					  ((a.lastStabilityCheckTime = +new Date()),
					  Math.abs(t.x - a.lastRightBottom.x) <= 30 &&
					  Math.abs(t.y - a.lastRightBottom.y) <= 30 &&
					  Math.abs(e.x - a.lastLeftTop.x <= 30) &&
					  Math.abs(e.y - a.lastLeftTop.y) <= 30
							? ((a.isCardStable = !0), i())
							: ((a.lastRightBottom = t), (a.lastLeftTop = e), (a.isCardStable = !1), i()));
		});
	}
	async detectFromVideoFrame(t, e, a) {
		var i = this;
		if ((this.frameCount++, this.frameCount % this.frameRatioMod == 0 && e)) {
			let a = tf.browser.fromPixels(e),
				o = tf.image.resizeNearestNeighbor(a, [384, 384]),
				r = tf.cast(o, "float32"),
				n = tf.expandDims(r, 0);
			n.shape[1], n.shape[2];
			let s = tf.image.resizeNearestNeighbor(a, [160, 160]),
				c = (tf.cast(s, "float32"), await t.execute(n));
			c.forEach((t) => t.print);
			let d = [];
			for (let t = 0; t < c.length; t++) d.push(c[t].dataSync());
			n.dispose(),
				o.dispose(),
				r.dispose(),
				a.dispose(),
				($(".spinner").is(":visible") || $(".fullscreen-modal").is(":visible")) &&
					($(".spinner").hide(), $(".fullscreen-modal").hide()),
				i.showAlert(
					'<img class="notify-image" src="./assets/images/scan.png"  />' +
						CONFIG.staticText[i.lang].zoom_in_card,
					"success"
				);
			for (let t = 0; t < 16; t++)
				d[0][t] =
					t % 2 == 0
						? (d[0][t] / i.MODEL_INPUT_SIZE_WIDTH) * e.videoWidth
						: (d[0][t] / i.MODEL_INPUT_SIZE_HEIGHT) * e.videoHeight;
			let l = new Line(new Point(d[0][0], d[0][1]), new Point(d[0][2], d[0][3])),
				h = new Line(new Point(d[0][4], d[0][5]), new Point(d[0][6], d[0][7])),
				g = new Line(new Point(d[0][8], d[0][9]), new Point(d[0][10], d[0][11])),
				u = new Line(new Point(d[0][12], d[0][13]), new Point(d[0][14], d[0][15]));
			(this.canvas_overlay = document.getElementById("canvas")),
				(this.ctx_overlay = this.canvas_overlay.getContext("2d"));
			let m = new CardLocationPoints(new CardLocationLines(l, g, u, h));
			this.ctx_overlay.clearRect(0, 0, this.canvas_overlay.width, this.canvas_overlay.height);
			let p = i.argmax(d[1]),
				C = d[1][p],
				y = i.fromValue(p);
			if (
				((i.scale = $("#video").width() / document.getElementsByTagName("video").video.videoWidth),
				(this.canvas_overlay.width = document.getElementsByTagName("video").video.videoWidth * i.scale),
				(this.canvas_overlay.height = document.getElementsByTagName("video").video.videoHeight * i.scale),
				null !== l && null !== h && null !== g && null !== u && "NO_CARD" !== y)
			) {
				let t = 1;
				this.ctx_overlay.beginPath(),
					(this.ctx_overlay.lineWidth = 1),
					(this.ctx_overlay.strokeStyle = "#26ff00"),
					(this.ctx_overlay.fillStyle = "#26ff00"),
					(t = $("#video").width() / e.videoWidth);
				const a = this.calculateAngle(m.leftTop, m.rightTop),
					o = this.calculateAngle(m.leftBottom, m.leftTop);
				this.ctx_overlay.moveTo(m.leftTop.x * t, m.leftTop.y * t),
					this.ctx_overlay.lineTo(m.rightTop.x * t, m.rightTop.y * t),
					this.ctx_overlay.moveTo(m.leftBottom.x * t, m.leftBottom.y * t),
					this.ctx_overlay.lineTo(m.rightBottom.x * t, m.rightBottom.y * t),
					this.ctx_overlay.moveTo(m.leftTop.x * t, m.leftTop.y * t),
					this.ctx_overlay.lineTo(m.leftBottom.x * t, m.leftBottom.y * t),
					this.ctx_overlay.moveTo(m.rightTop.x * t, m.rightTop.y * t),
					this.ctx_overlay.lineTo(m.rightBottom.x * t, m.rightBottom.y * t),
					this.ctx_overlay.stroke();
				const r = m.rightTop.x - m.leftTop.x,
					n = m.rightBottom.y - m.rightTop.y,
					s = r / n;
				await this.checkForCardStability(m.leftBottom, m.leftTop),
					console.log(i.currentCardType),
					console.log(i.currentCardTypeForDetectionConfirm),
					console.log(i.CARDCONFIG[i.currentCardType].maxRatio),
					console.log(s),
					s >= i.CARDCONFIG[i.currentCardType].maxRatio || s <= i.CARDCONFIG[i.currentCardType].minRatio
						? "TYPEFREE" !== i.currentCardType &&
						  "FOREIGNID" !== i.currentCardType &&
						  "FOREIGNIDBACK" !== i.currentCardType &&
						  null !== i.currentCardTypeForDetectionConfirm &&
						  i.currentCardTypeForDetectionConfirm !== i.currentCardType
							? i.showAlert(CONFIG.staticText[i.lang].wrong_card_type, "danger")
							: i.showAlert(CONFIG.staticText[i.lang].be_sure_full_visible, "danger")
						: ("TYPEFREE" !== i.currentCardType &&
								"FOREIGNID" !== i.currentCardType &&
								"FOREIGNIDBACK" !== i.currentCardType &&
								null === i.currentCardTypeForDetectionConfirm) ||
						  ("TYPEFREE" !== i.currentCardType &&
								"FOREIGNID" !== i.currentCardType &&
								"FOREIGNIDBACK" !== i.currentCardType &&
								null !== i.currentCardTypeForDetectionConfirm &&
								i.currentCardTypeForDetectionConfirm !== i.currentCardType)
						? i.showAlert(CONFIG.staticText[i.lang].not_clear_come_closer, "danger")
						: null !== i.currentCardTypeForDetectionConfirm &&
						  C > 0.5 &&
						  ((a > 0 && a < 15) || (a < 0 && a > -15)) &&
						  ((o > -90 && o < -75) || (o < -90 && o > -105)) &&
						  this.checkForShotAvailability(r, n, m.leftTop.x, m.leftTop.y, e, i.isCardStable);
			}
		}
		await tf.nextFrame(), !0 === i.continueToShot && i.detectFromVideoFrame(t, e, a);
	}
	async checkForShotAvailability(t = null, e = null, a = null, i = null, o = null, r) {
		var n = this;
		n.calculationTime = Date.now();
		let s = 62;
		const c = (t / $("#video").width()) * 100;
		if (
			(!1 === n.isMobileOrNot() && (s = 50),
			"OLDIDCARD" === this.currentCardType && (s = 25),
			"PASSPORT" === this.currentCardType && !1 === n.isMobileOrNot() && (s = 40),
			(!0 === n.isCardStable && c >= s && !1 === n.isMobileOrNot()) ||
				(!0 === n.isCardStable && c >= 105 && !0 === n.isMobileOrNot() && !0 === n.isBackCamera) ||
				(!0 === n.isCardStable && c >= 105 && !0 === n.isMobileOrNot() && !1 === n.isBackCamera))
		)
			return (n.capture = !1), n.shotImage(t, e, a, i, o);
		(c < s && !1 === n.isMobileOrNot()) ||
		(c < 105 && !0 === n.isMobileOrNot() && !0 === n.isBackCamera) ||
		(c < 105 && !0 === n.isMobileOrNot() && !1 === n.isBackCamera)
			? "cloud" === n.validationMode && n.showAlert(CONFIG.staticText[n.lang].zoom_card, "warning")
			: (c >= s + 25 && !1 === n.isMobileOrNot()) ||
			  (c > 220 && !0 === n.isMobileOrNot() && !0 === n.isBackCamera) ||
			  (c > 105 && !0 === n.isMobileOrNot() && !1 === n.isBackCamera)
			? "cloud" === n.validationMode && n.showAlert(CONFIG.staticText[n.lang].zoom_out, "warning")
			: !1 === n.isCardStable
			? n.showAlert(CONFIG.staticText[n.lang].keep_align, "warning")
			: n.showAlert(CONFIG.staticText[n.lang].analyzing, "success");
	}
	blobToBase64(t) {
		return new Promise((e, a) => {
			const i = new FileReader();
			(i.onloadend = () => e(i.result)), i.readAsDataURL(t);
		});
	}
	calculateMaxScores(t, e, a) {
		const i = [],
			o = [];
		for (let r = 0; r < e; r++) {
			let e = Number.MIN_VALUE,
				n = -1;
			for (let i = 0; i < a; i++) t[r * a + i] > e && ((e = t[r * a + i]), (n = i));
			(i[r] = e), (o[r] = n);
		}
		return [i, o];
	}
	onCapturedSuccess(t, e, a) {
		var i = this;
		$(".result").html(a),
			(i.continueToShot = !1),
			i.showAlert(CONFIG.staticText[i.lang].captured_success, "success"),
			i.sendImage();
	}
	b64toBlob(t) {
		for (
			var e = atob(t.split(",")[1]), a = new ArrayBuffer(e.length), i = new Uint8Array(a), o = 0;
			o < e.length;
			o++
		)
			i[o] = e.charCodeAt(o);
		return new Blob([a], { type: "image/png" });
	}
	shotImage(t = null, e = null, a = null, i = null, o = null) {
		!1 === this.isMobileOrNot && $("#video").hide(), this.captureImage(t, e, a, i, o);
	}
	isIpadOS() {
		return navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);
	}
	isMobileOrNot() {
		var t,
			e = !1;
		return (
			(t = navigator.userAgent || navigator.vendor || window.opera),
			(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
				t
			) ||
				/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
					t.substr(0, 4)
				)) &&
				(e = !0),
			!1 === e && (e = this.isIpadOS() > 0),
			!1 === e && (e = /Macintosh/.test(navigator.userAgent) && "ontouchend" in document),
			(this.isMobile = e),
			e
		);
	}
	async captureImage(t = null, e = null, a = null, i = null, o = null) {
		var r = this;
		"TYPEFREE" === r.currentCardType && $("#take-snapshot").hide();
		const n = document.getElementById("shot"),
			s = document.getElementById("captured"),
			c = document.getElementById("cropped"),
			d = document.getElementById("video");
		if (((r.capture = !1), null !== o))
			if (
				((s.width = o.videoWidth),
				(s.height = o.videoHeight),
				s.getContext("2d").drawImage(o, 0, 0),
				"TYPEFREE" !== r.currentCardType)
			)
				r.afterShot(s, c, n, t, e, a, i);
			else {
				let t = s.toDataURL("image/png");
				this.mediaStreamTrack.stop(), $(".spinner").show(), this.sendToOCR(t);
			}
		else if ("ImageCapture" in window) {
			if ("grab" === r.shotType)
				this.imageCapture
					.grabFrame()
					.then((o) => {
						try {
							if (
								((s.width = o.width),
								(s.height = o.height),
								s.getContext("2d").drawImage(o, 0, 0),
								"TYPEFREE" !== r.currentCardType)
							)
								r.afterShot(s, c, n, t, e, a, i);
							else {
								let t = s.toDataURL("image/png");
								$("#video").hide(),
									this.mediaStreamTrack.stop(),
									$(".spinner").show(),
									this.sendToOCR(t);
							}
						} catch (t) {
							alert(t);
						}
					})
					.catch((t) => console.error("grabFrame() error:", t));
			else if ("shot" === r.shotType)
				try {
					this.imageCapture
						.takePhoto({ imageWidth: $("#video").width(), imageHeight: $("#video").height() })
						.then((t) => createImageBitmap(t))
						.then((o) => {
							if (
								((s.width = o.width),
								(s.height = o.width),
								s.getContext("2d").drawImage(o, 0, 0),
								"TYPEFREE" !== r.currentCardType)
							)
								r.afterShot(s, c, n, t, e, a, i);
							else {
								let t = s.toDataURL("image/png");
								$("#video").hide(),
									this.mediaStreamTrack.stop(),
									$(".spinner").show(),
									this.sendToOCR(t);
							}
						})
						.catch((t) => console.error("takePhoto() error:", t));
				} catch (t) {
					alert(t);
				}
		} else
			try {
				if (
					((s.width = r.videoRef.videoWidth),
					(s.height = r.videoRef.videoHeight),
					s.getContext("2d").drawImage(d, 0, 0),
					"TYPEFREE" !== r.currentCardType)
				)
					r.afterShot(s, c, n, t, e, a, i);
				else {
					let t = s.toDataURL("image/png");
					$("#video").hide(), this.mediaStreamTrack.stop(), $(".spinner").show(), this.sendToOCR(t);
				}
			} catch (t) {
				alert(t);
			}
	}
	getMobileOperatingSystem() {
		var t = navigator.userAgent || navigator.vendor || window.opera;
		return /windows phone/i.test(t)
			? "Windows Phone"
			: /android/i.test(t)
			? "Android"
			: /iPad|iPhone|iPod/.test(t) && !window.MSStream
			? "iOS"
			: "unknown";
	}
	async afterShot(t, e, a, i = null, o = null, r = null, n = null) {
		var s = this;
		let c = 0;
		e.getContext("2d");
		(e.width = i), (e.height = o);
		e.getContext("2d").drawImage(t, 1 * r, 1 * n, 1 * i, 1 * o, 0, 0, 1 * i, 1 * o);
		let d = tf.browser.fromPixels(e),
			l = tf.image.resizeNearestNeighbor(d, [160, 160]),
			h = tf.cast(l, "float32"),
			g = tf.expandDims(h, 0);
		this.cardBlurModel.loadBlurModel();
		let u = await this.cardBlurModel.blurModelLoadPromise.execute(g),
			m = [];
		m.push(u.dataSync()),
			g.dispose(),
			l.dispose(),
			h.dispose(),
			d.dispose(),
			(c = m[0][0]),
			(s.videoIsPlaying = !1),
			"Android" === s.getMobileOperatingSystem() && (s.blurThreshold = 0.6),
			c >= s.blurThreshold && c < 1 && s.blurTry < s.blurCorrectionThresholdTimes
				? (s.blurTry++,
				  s.showAlert(CONFIG.staticText[s.lang].blurry_image_low, "warning"),
				  $(".spinner").hide())
				: c < s.blurThreshold
				? (s.showAlert(CONFIG.staticText[s.lang].blurry_image + " " + c, "danger"), $(".spinner").hide())
				: c >= s.blurThreshold && 1 == s.continueToShot
				? !0 === s.continueToShot &&
				  ((s.continueToShot = !1),
				  document.getElementById("video").pause(),
				  (s.lastRecordedBase64 = e.toDataURL()),
				  s.ctx_overlay.clearRect(0, 0, this.canvas_overlay.width, this.canvas_overlay.height),
				  s.onCapturedSuccess(s.lastRecordedBase64, s.b64toBlob(s.lastRecordedBase64), a),
				  s.showAlert(CONFIG.staticText[s.lang].captured_success, "success"),
				  (a.src = e.toDataURL()),
				  (a.width = 300),
				  setTimeout(function () {
						"standalone" === s.validationMode && s.goToFaceDetection();
				  }, 2500),
				  setTimeout(function () {
						document.getElementById("video").play();
				  }, 1e3))
				: s.showAlert(CONFIG.staticText[s.lang].analyzing, "success");
	}
	getInterValVideoCVCapture() {
		var t = this,
			e = document.getElementById("canvas").getContext("2d"),
			a = document.getElementById("captured"),
			i = a.getContext("2d");
		document.getElementById("cropped");
		$(".overlay").show(),
			setTimeout(function () {
				(captured.width = parseFloat($("#video").width())),
					(captured.height = parseFloat($("#video").height())),
					(a.width = parseFloat($("#video").width())),
					(a.height = parseFloat($("#video").height()));
			}, 250),
			"cloud" === t.validationMode && t.showAlert(CONFIG.staticText[t.lang].center_card, "warning"),
			(t.intervalCV = setInterval(function () {
				t.continueToShot,
					requestAnimationFrame(t.frameProcessor.process),
					"ImageCapture" in window
						? t.imageCapture
								.grabFrame()
								.then((o) => {
									i.drawImage(
										o,
										0,
										0,
										t.videoRef.videoWidth,
										t.videoRef.videoHeight,
										0,
										0,
										$("#video").width(),
										$("#video").height()
									),
										setTimeout(function () {
											e.clearRect(0, 0, a.width, a.height), t.frameProcessor.process(a);
										}, 100);
								})
								.catch((t) => console.error("grabFrame() error:", t))
						: (i.drawImage(
								t.videoRef,
								0,
								0,
								t.videoRef.videoWidth,
								t.videoRef.videoHeight,
								0,
								0,
								$("#video").width(),
								$("#video").height()
						  ),
						  setTimeout(function () {
								e.clearRect(0, 0, a.width, a.height), t.frameProcessor.process(a);
						  }, 100));
			}, 250));
	}
	onReadyCapture() {}
	waitingForCamera() {}
	async gotDevices(t) {
		const e = await navigator.mediaDevices.enumerateDevices();
		let a = 1;
		e.forEach((t) => {
			if ("videoinput" === t.kind) {
				const e = document.createElement("option");
				e.value = t.deviceId;
				const i = t.label || "Camera " + a++,
					o = document.createTextNode(i);
				e.setAttribute(
					"type",
					!0 === t.label.includes("front") ? "front" : !0 === t.label.includes("back") ? "back" : "user"
				),
					e.appendChild(o);
			}
		});
	}
	async getVideo(t, e = !1) {
		if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
			throw new Error("Browser API navigator.mediaDevices.getUserMedia not available");
		var a = this;
		!0 === this.isMobileOrNot() && !0 === this.switchCameras && (a.isBackCamera = !a.isBackCamera),
			!1 === a.isBackCamera ? $("video").addClass("mirrored") : $("video").removeClass("mirrored"),
			a.waitingForCamera(),
			"cloud" === a.validationMode && a.showAlert(CONFIG.staticText[a.lang].please_wait);
		var i = { deviceId: "" !== a.selectedCamera ? { exact: a.selectedCamera } : void 0 },
			o = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
		if (navigator.mediaDevices.getUserMedia || navigator.mediaDevices.webkitGetUserMedia) {
			if (
				(!0 === this.isMobileOrNot()
					? ("" !== a.selectedCamera && a.selectedCamera,
					  !0 === a.isBackCamera
							? ((i.facingMode = { exact: "environment" }),
							  (i.width = { min: 1920 }),
							  (i.height = { min: 1080 }))
							: (i.facingMode = "user"))
					: ((i.width = { ideal: 1920 }), (i.height = { ideal: 1080 })),
				window.stream)
			)
				try {
					window.stream.getTracks().forEach(function (t) {
						t.stop();
					});
				} catch (t) {
					alert(t);
				}
			navigator.mediaDevices
				.getUserMedia({ video: i, audio: !1 })
				.then(
					async (t) => {
						try {
							const [e] = t.getVideoTracks(),
								i = e.getCapabilities();
							let r = t.getVideoTracks()[0].getSettings();
							a.stream_settings = r;
							let n = null;
							if (
								((a.mediaStreamTrack = t.getVideoTracks()[0]),
								i.focusDistance &&
									(await e.applyConstraints({ focusMode: "manual", focusDistance: 10 })),
								i.width.max > 1920 && (a.ratioOverlay = 0.75),
								"ImageCapture" in window &&
									((a.imageCapture = new ImageCapture(a.mediaStreamTrack)),
									(n = await a.imageCapture.getPhotoCapabilities())),
								(a.stream_width = r.width),
								(a.stream_height = r.height),
								!1 === a.isMobileOrNot()
									? ($("#video").addClass("mirrored"), $("#canvas").addClass("mirrored"))
									: ($("#video").removeClass("mirrored"), $("#canvas").removeClass("mirrored")),
								o &&
									setTimeout(function () {
										document.getElementById("video").load();
									}, 100),
								(a.videoRef = document.getElementById("video")),
								(window.stream = t),
								(a.videoRef.srcObject = t),
								!1 === a.isMobileOrNot() && i.max < a.minimumCameraWidth)
							)
								return (
									a.mediaStreamTrack.stop(),
									a.showAlert(
										"Low quality camera detected. please proceed with a better quality camera",
										"danger",
										!0
									),
									void $("#cameras").hide()
								);
							(a.cameraIsOK = !0),
								(a.videoRef.onloadedmetadata = async (t) => {
									if (
										("OD" === a.method
											? ($(".spinner").hide(),
											  a.showAlert(CONFIG.staticText[a.lang].loading_model, "warning"),
											  Promise.all([a.cardCatchModel.catchModelLoadPromise])
													.then(async (t) => {
														if (!0 === a.continueToShot) {
															if (
																((a.frameCount = 0),
																(a.lastRightBottom = null),
																(a.lastLeftTop = null),
																(a.lastStabilityCheckTime = null),
																void 0 === a.cardCatchModel.catchModelLoadPromise)
															)
																return void (a.tryInt = setInterval(function () {
																	a.detectFromVideoFrame(
																		a.cardCatchModel.catchModelLoadPromise,
																		a.videoRef,
																		a.options
																	),
																		void 0 !==
																			a.cardCatchModel.catchModelLoadPromise &&
																			clearInterval(a.tryInt);
																}, 200));
															if (!0 === a.cameraIsOK)
																a.onReadyCapture(),
																	!0 === a.isMobileOrNot() && $(".spinner").hide(),
																	a.detectFromVideoFrame(
																		a.cardCatchModel.catchModelLoadPromise,
																		a.videoRef,
																		a.options
																	);
															else {
																let t = setInterval(function () {
																	!0 === a.cameraIsOK &&
																		(a.onReadyCapture(),
																		clearInterval(t),
																		a.detectFromVideoFrame(
																			a.cardCatchModel.catchModelLoadPromise,
																			a.videoRef,
																			a.options
																		));
																}, 1e3);
															}
															!0 === a.showStepper && $(".stepper").show();
														}
													})
													.catch((t) => {
														console.error(t);
													}))
											: $(".spinner").hide(),
										"CV" === a.method && "TYPEFREE" !== a.currentCardType)
									)
										$("#video").width(),
											a.ratioOverlay,
											a.CARDCONFIG[a.currentCardType].openCVRatio;
									try {
										document.getElementsByTagName("video").video.videoWidth !== $("#video").width()
											? ((a.scale =
													$("#video").width() /
													document.getElementsByTagName("video").video.videoWidth),
											  $("#canvas").attr(
													"width",
													document.getElementsByTagName("video").video.videoWidth * a.scale
											  ),
											  $("#canvas").attr(
													"height",
													document.getElementsByTagName("video").video.videoHeight * a.scale
											  ))
											: ($("#canvas").attr(
													"width",
													document.getElementsByTagName("video").video.videoWidth
											  ),
											  $("#canvas").attr(
													"height",
													document.getElementsByTagName("video").video.videoHeight
											  ),
											  (a.scale = 1)),
											!0 === a.isBackCamera && $("#video").css({ width: "100%" }),
											"TYPEFREE" === a.currentCardType &&
												($("#video").show(),
												a.cardNotFound
													? a.showAlert(
															"Something didn't workout. Please reposition the card and capture it again.",
															"danger",
															!0
													  )
													: a.showAlert("Take Picture"),
												$("#take-snapshot").show());
									} catch (t) {
										alert(t);
									}
								});
						} catch (t) {
							alert(t);
						}
					},
					(t) => {
						console.log("Couldn't start the webcam"), console.error(t);
					}
				)
				.then(a.gotDevices(a));
		}
	}
	async startVideoCam() {
		var t = this;
		sessionStorage.setItem("card_result_front", ""),
			sessionStorage.setItem("card_result_front_image", ""),
			sessionStorage.setItem("card_result_back", ""),
			sessionStorage.setItem("card_result_back_image", ""),
			sessionStorage.setItem("card_result_face", ""),
			$(".spinner").hide(),
			"IDCARD" === t.currentCardType ||
			("FOREIGNID" === t.currentCardType && "" != t.currentCountryBack && null !== t.currentCountryBack)
				? $("#back-stepper").show()
				: $("#back-stepper").hide();
		try {
			navigator.mediaDevices
				.enumerateDevices()
				.then(function (e) {
					0 === $("#cameras").children().length &&
						e.forEach(function (e) {
							if ("videoinput" === e.kind) {
								var a = e.label;
								"" === e.label && (a = "Camera"),
									!1 === t.isMobileOrNot() &&
										"cloud" === t.validationMode &&
										$("#cameras").append(
											'<button type="button" onclick="cardDetection.getVideo(\'' +
												e.deviceId +
												"')\">" +
												a +
												"</button>"
										);
							}
						}),
						$(".fullscreen-modal").show(),
						t.getVideo();
				})
				.catch(function (t) {
					console.log(t.name + ": " + t.message);
				});
		} catch (t) {
			alert(t);
		}
		t.isMobileOrNot();
	}
	selectType(t) {
		(this.currentCardType = t),
			$("#demo").hide(),
			"OLDIDCARD" === this.currentCardType && !1 === this.isMobileOrNot() && (this.ratioOverlay = 0.32),
			"TYPEFREE" === this.currentCardType || $("#canvas").show(),
			this.askForInfo();
	}
	askForInfo(t) {
		t = this;
		if ("" === this.transactionId || "null" == this.transactionId) {
			$(".spinner").show();
			const e = {
				optionalData: {
					device: navigator.userAgentData,
					versionName: t.version,
					language: t.lang,
					browser: navigator.appVersion,
				},
			};
			"TYPEFREE" !== t.currentCardType && (e.optionalData.idType = t.currentCardType),
				$.ajax({
					contentType: "application/json",
					type: "POST",
					url: this.urlStart,
					beforeSend: function (e, a) {
						// e.setRequestHeader("Authorization", "Bearer " + t.token);
					},
					data: JSON.stringify(e),
					success: function (e) {
						(t.gestureType = e.gestureType),
							(t.transactionId = e.transactionId),
							!0 === t.debug && $("#transaction").html(t.transactionId),
							t.startVideoCam();
					},
					error: function (e) {
						$(".spinner").hide(),
							void 0 !== e.responseJSON && void 0 !== e.responseJSON.message
								? t.showAlert(e.responseJSON.message, "danger")
								: t.showAlert("Token error", "danger");
					},
				});
		} else !0 === t.debug && $("#transaction").html(t.transactionId), t.startVideoCam();
	}
	showHidePortraitModal(t = !1) {
		!0 === t
			? ($(".stepper").hide(), $("video").hide(), $(".modal-portrait").addClass("active"))
			: ($("body.active .stepper").show(), $("video").show(), $(".modal-portrait").removeClass("active")),
			$("body").addClass("active"),
			setTimeout(function () {
				$("body").height(window.innerHeight), $("body").width(window.innerWidth);
			}, 250);
	}
	async initCardDetection(t) {
		context = this;
		const e = document.getElementById("select");
		null !== e &&
			e.addEventListener("change", (t) => {
				const e = document.getElementById("select");
				context.selectedCamera = e.value;
				t.target.selectedOptions[0].getAttribute("type");
				const a = new URLSearchParams(window.location.search);
				a.set("selectedCamera", context.selectedCamera),
					a.set("isBackCamera", "back" === e.type),
					(window.location.search = a);
			}),
			$(window).resize(function () {
				context.showHidePortraitModal(
					window.matchMedia("(orientation: landscape)").matches && context.isMobileOrNot()
				);
			}),
			window.matchMedia("(orientation: landscape)").matches &&
				context.showHidePortraitModal(
					window.matchMedia("(orientation: landscape)").matches && context.isMobileOrNot()
				),
			!0 === CONFIG.isDemo && "" === context.currentCardType
				? $("body").append(
						'<div id="demo" class="row"><div class="col-12"><h4 style="text-align: center;padding: 20px">' +
							CONFIG.staticText[context.lang].select_please +
							'</h4></div><div class="col-sm-6 col-xs-6 col-lg-2"  onclick="detectCardNow.selectType(\'IDCARD\')"><div class="circle"><img  onclick="detectCardNow.selectType(\'IDCARD\')" src="./assets/images/NationalID.svg"/></div><div class="card-type-text">New ID Card</div></div><div class="col-sm-6 col-xs-6 col-lg-3"  onclick="detectCardNow.selectType(\'OLDIDCARD\')"><div class="circle"><img onclick="detectCardNow.selectType(\'OLDIDCARD\')" src="./assets/images/National-ID-V.svg"/></div><div class="card-type-text">Old ID Card</div></div><div class="col-sm-6 col-xs-6 col-lg-2"  onclick="detectCardNow.selectType(\'DRIVERCARD\')"><div class="circle"><img onclick="detectCardNow.selectType(\'DRIVERCARD\')" src="./assets/images/Driver-License.svg"/></div><div class="card-type-text">Driving Licence</div></div><div class="col-sm-6 col-xs-6 col-lg-3"  onclick="detectCardNow.selectType(\'PASSPORT\')"><div class="circle"><img onclick="detectCardNow.selectType(\'PASSPORT\')" src="./assets/images/Passport.svg"/></div><div class="card-type-text">Passport</div></div><div class="col-sm-6 col-xs-6 col-lg-2"  onclick="detectCardNow.selectType(\'FOREIGNID\')"><div class="circle"><img onclick="detectCardNow.selectType(\'FOREIGNID\')" src="./assets/images/Residence-Permit.svg"/></div><div class="card-type-text">Foreign ID Card</div></div></div>'
				  )
				: context.askForInfo();
	}
}
